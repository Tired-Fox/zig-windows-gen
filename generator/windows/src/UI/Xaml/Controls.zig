pub const AnchorRequestedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getAnchor(self: *@This()) core.HResult!*UIElement {
        const this: *IAnchorRequestedEventArgs = @ptrCast(self);
        return try this.getAnchor();
    }
    pub fn putAnchor(self: *@This(), value: *UIElement) core.HResult!void {
        const this: *IAnchorRequestedEventArgs = @ptrCast(self);
        return try this.putAnchor(value);
    }
    pub fn getAnchorCandidates(self: *@This()) core.HResult!*IVector(UIElement) {
        const this: *IAnchorRequestedEventArgs = @ptrCast(self);
        return try this.getAnchorCandidates();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.AnchorRequestedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IAnchorRequestedEventArgs.GUID;
    pub const IID: Guid = IAnchorRequestedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IAnchorRequestedEventArgs.SIGNATURE);
};
pub const Control = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getFontSize(self: *@This()) core.HResult!f64 {
        const this: *IControl = @ptrCast(self);
        return try this.getFontSize();
    }
    pub fn putFontSize(self: *@This(), value: f64) core.HResult!void {
        const this: *IControl = @ptrCast(self);
        return try this.putFontSize(value);
    }
    pub fn getFontFamily(self: *@This()) core.HResult!*FontFamily {
        const this: *IControl = @ptrCast(self);
        return try this.getFontFamily();
    }
    pub fn putFontFamily(self: *@This(), value: *FontFamily) core.HResult!void {
        const this: *IControl = @ptrCast(self);
        return try this.putFontFamily(value);
    }
    pub fn getFontWeight(self: *@This()) core.HResult!FontWeight {
        const this: *IControl = @ptrCast(self);
        return try this.getFontWeight();
    }
    pub fn putFontWeight(self: *@This(), value: FontWeight) core.HResult!void {
        const this: *IControl = @ptrCast(self);
        return try this.putFontWeight(value);
    }
    pub fn getFontStyle(self: *@This()) core.HResult!FontStyle {
        const this: *IControl = @ptrCast(self);
        return try this.getFontStyle();
    }
    pub fn putFontStyle(self: *@This(), value: FontStyle) core.HResult!void {
        const this: *IControl = @ptrCast(self);
        return try this.putFontStyle(value);
    }
    pub fn getFontStretch(self: *@This()) core.HResult!FontStretch {
        const this: *IControl = @ptrCast(self);
        return try this.getFontStretch();
    }
    pub fn putFontStretch(self: *@This(), value: FontStretch) core.HResult!void {
        const this: *IControl = @ptrCast(self);
        return try this.putFontStretch(value);
    }
    pub fn getCharacterSpacing(self: *@This()) core.HResult!i32 {
        const this: *IControl = @ptrCast(self);
        return try this.getCharacterSpacing();
    }
    pub fn putCharacterSpacing(self: *@This(), value: i32) core.HResult!void {
        const this: *IControl = @ptrCast(self);
        return try this.putCharacterSpacing(value);
    }
    pub fn getForeground(self: *@This()) core.HResult!*Brush {
        const this: *IControl = @ptrCast(self);
        return try this.getForeground();
    }
    pub fn putForeground(self: *@This(), value: *Brush) core.HResult!void {
        const this: *IControl = @ptrCast(self);
        return try this.putForeground(value);
    }
    pub fn getIsTabStop(self: *@This()) core.HResult!bool {
        const this: *IControl = @ptrCast(self);
        return try this.getIsTabStop();
    }
    pub fn putIsTabStop(self: *@This(), value: bool) core.HResult!void {
        const this: *IControl = @ptrCast(self);
        return try this.putIsTabStop(value);
    }
    pub fn getIsEnabled(self: *@This()) core.HResult!bool {
        const this: *IControl = @ptrCast(self);
        return try this.getIsEnabled();
    }
    pub fn putIsEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IControl = @ptrCast(self);
        return try this.putIsEnabled(value);
    }
    pub fn getTabIndex(self: *@This()) core.HResult!i32 {
        const this: *IControl = @ptrCast(self);
        return try this.getTabIndex();
    }
    pub fn putTabIndex(self: *@This(), value: i32) core.HResult!void {
        const this: *IControl = @ptrCast(self);
        return try this.putTabIndex(value);
    }
    pub fn getTabNavigation(self: *@This()) core.HResult!KeyboardNavigationMode {
        const this: *IControl = @ptrCast(self);
        return try this.getTabNavigation();
    }
    pub fn putTabNavigation(self: *@This(), value: KeyboardNavigationMode) core.HResult!void {
        const this: *IControl = @ptrCast(self);
        return try this.putTabNavigation(value);
    }
    pub fn getTemplate(self: *@This()) core.HResult!*ControlTemplate {
        const this: *IControl = @ptrCast(self);
        return try this.getTemplate();
    }
    pub fn putTemplate(self: *@This(), value: *ControlTemplate) core.HResult!void {
        const this: *IControl = @ptrCast(self);
        return try this.putTemplate(value);
    }
    pub fn getPadding(self: *@This()) core.HResult!Thickness {
        const this: *IControl = @ptrCast(self);
        return try this.getPadding();
    }
    pub fn putPadding(self: *@This(), value: Thickness) core.HResult!void {
        const this: *IControl = @ptrCast(self);
        return try this.putPadding(value);
    }
    pub fn getHorizontalContentAlignment(self: *@This()) core.HResult!HorizontalAlignment {
        const this: *IControl = @ptrCast(self);
        return try this.getHorizontalContentAlignment();
    }
    pub fn putHorizontalContentAlignment(self: *@This(), value: HorizontalAlignment) core.HResult!void {
        const this: *IControl = @ptrCast(self);
        return try this.putHorizontalContentAlignment(value);
    }
    pub fn getVerticalContentAlignment(self: *@This()) core.HResult!VerticalAlignment {
        const this: *IControl = @ptrCast(self);
        return try this.getVerticalContentAlignment();
    }
    pub fn putVerticalContentAlignment(self: *@This(), value: VerticalAlignment) core.HResult!void {
        const this: *IControl = @ptrCast(self);
        return try this.putVerticalContentAlignment(value);
    }
    pub fn getBackground(self: *@This()) core.HResult!*Brush {
        const this: *IControl = @ptrCast(self);
        return try this.getBackground();
    }
    pub fn putBackground(self: *@This(), value: *Brush) core.HResult!void {
        const this: *IControl = @ptrCast(self);
        return try this.putBackground(value);
    }
    pub fn getBorderThickness(self: *@This()) core.HResult!Thickness {
        const this: *IControl = @ptrCast(self);
        return try this.getBorderThickness();
    }
    pub fn putBorderThickness(self: *@This(), value: Thickness) core.HResult!void {
        const this: *IControl = @ptrCast(self);
        return try this.putBorderThickness(value);
    }
    pub fn getBorderBrush(self: *@This()) core.HResult!*Brush {
        const this: *IControl = @ptrCast(self);
        return try this.getBorderBrush();
    }
    pub fn putBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const this: *IControl = @ptrCast(self);
        return try this.putBorderBrush(value);
    }
    pub fn getFocusState(self: *@This()) core.HResult!FocusState {
        const this: *IControl = @ptrCast(self);
        return try this.getFocusState();
    }
    pub fn addIsEnabledChanged(self: *@This(), handler: *DependencyPropertyChangedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IControl = @ptrCast(self);
        return try this.addIsEnabledChanged(handler);
    }
    pub fn removeIsEnabledChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IControl = @ptrCast(self);
        return try this.removeIsEnabledChanged(token);
    }
    pub fn ApplyTemplate(self: *@This()) core.HResult!bool {
        const this: *IControl = @ptrCast(self);
        return try this.ApplyTemplate();
    }
    pub fn Focus(self: *@This(), value: FocusState) core.HResult!bool {
        const this: *IControl = @ptrCast(self);
        return try this.Focus(value);
    }
    pub fn getIsTextScaleFactorEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IControl2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsTextScaleFactorEnabled();
    }
    pub fn putIsTextScaleFactorEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IControl2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsTextScaleFactorEnabled(value);
    }
    pub fn getUseSystemFocusVisuals(self: *@This()) core.HResult!bool {
        var this: ?*IControl3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getUseSystemFocusVisuals();
    }
    pub fn putUseSystemFocusVisuals(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IControl3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putUseSystemFocusVisuals(value);
    }
    pub fn getIsFocusEngagementEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IControl4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsFocusEngagementEnabled();
    }
    pub fn putIsFocusEngagementEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IControl4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsFocusEngagementEnabled(value);
    }
    pub fn getIsFocusEngaged(self: *@This()) core.HResult!bool {
        var this: ?*IControl4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsFocusEngaged();
    }
    pub fn putIsFocusEngaged(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IControl4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsFocusEngaged(value);
    }
    pub fn getRequiresPointer(self: *@This()) core.HResult!RequiresPointer {
        var this: ?*IControl4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getRequiresPointer();
    }
    pub fn putRequiresPointer(self: *@This(), value: RequiresPointer) core.HResult!void {
        var this: ?*IControl4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putRequiresPointer(value);
    }
    pub fn getXYFocusLeft(self: *@This()) core.HResult!*DependencyObject {
        var this: ?*IControl4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getXYFocusLeft();
    }
    pub fn putXYFocusLeft(self: *@This(), value: *DependencyObject) core.HResult!void {
        var this: ?*IControl4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putXYFocusLeft(value);
    }
    pub fn getXYFocusRight(self: *@This()) core.HResult!*DependencyObject {
        var this: ?*IControl4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getXYFocusRight();
    }
    pub fn putXYFocusRight(self: *@This(), value: *DependencyObject) core.HResult!void {
        var this: ?*IControl4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putXYFocusRight(value);
    }
    pub fn getXYFocusUp(self: *@This()) core.HResult!*DependencyObject {
        var this: ?*IControl4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getXYFocusUp();
    }
    pub fn putXYFocusUp(self: *@This(), value: *DependencyObject) core.HResult!void {
        var this: ?*IControl4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putXYFocusUp(value);
    }
    pub fn getXYFocusDown(self: *@This()) core.HResult!*DependencyObject {
        var this: ?*IControl4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getXYFocusDown();
    }
    pub fn putXYFocusDown(self: *@This(), value: *DependencyObject) core.HResult!void {
        var this: ?*IControl4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putXYFocusDown(value);
    }
    pub fn getElementSoundMode(self: *@This()) core.HResult!ElementSoundMode {
        var this: ?*IControl4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getElementSoundMode();
    }
    pub fn putElementSoundMode(self: *@This(), value: ElementSoundMode) core.HResult!void {
        var this: ?*IControl4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putElementSoundMode(value);
    }
    pub fn addFocusEngaged(self: *@This(), handler: *TypedEventHandler(Control,FocusEngagedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IControl4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addFocusEngaged(handler);
    }
    pub fn removeFocusEngaged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IControl4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeFocusEngaged(token);
    }
    pub fn addFocusDisengaged(self: *@This(), handler: *TypedEventHandler(Control,FocusDisengagedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IControl4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addFocusDisengaged(handler);
    }
    pub fn removeFocusDisengaged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IControl4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeFocusDisengaged(token);
    }
    pub fn RemoveFocusEngagement(self: *@This()) core.HResult!void {
        var this: ?*IControl4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.RemoveFocusEngagement();
    }
    pub fn getDefaultStyleResourceUri(self: *@This()) core.HResult!*Uri {
        var this: ?*IControl5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDefaultStyleResourceUri();
    }
    pub fn putDefaultStyleResourceUri(self: *@This(), value: *Uri) core.HResult!void {
        var this: ?*IControl5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putDefaultStyleResourceUri(value);
    }
    pub fn getBackgroundSizing(self: *@This()) core.HResult!BackgroundSizing {
        var this: ?*IControl7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getBackgroundSizing();
    }
    pub fn putBackgroundSizing(self: *@This(), value: BackgroundSizing) core.HResult!void {
        var this: ?*IControl7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putBackgroundSizing(value);
    }
    pub fn getCornerRadius(self: *@This()) core.HResult!CornerRadius {
        var this: ?*IControl7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCornerRadius();
    }
    pub fn putCornerRadius(self: *@This(), value: CornerRadius) core.HResult!void {
        var this: ?*IControl7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControl7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putCornerRadius(value);
    }
    pub fn getDefaultStyleKey(self: *@This()) core.HResult!*IInspectable {
        var this: ?*IControlProtected = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlProtected.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDefaultStyleKey();
    }
    pub fn putDefaultStyleKey(self: *@This(), value: *IInspectable) core.HResult!void {
        var this: ?*IControlProtected = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlProtected.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putDefaultStyleKey(value);
    }
    pub fn GetTemplateChild(self: *@This(), childName: HSTRING) core.HResult!*DependencyObject {
        var this: ?*IControlProtected = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlProtected.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GetTemplateChild(childName);
    }
    pub fn OnPointerEntered(self: *@This(), e: *PointerRoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnPointerEntered(e);
    }
    pub fn OnPointerPressed(self: *@This(), e: *PointerRoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnPointerPressed(e);
    }
    pub fn OnPointerMoved(self: *@This(), e: *PointerRoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnPointerMoved(e);
    }
    pub fn OnPointerReleased(self: *@This(), e: *PointerRoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnPointerReleased(e);
    }
    pub fn OnPointerExited(self: *@This(), e: *PointerRoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnPointerExited(e);
    }
    pub fn OnPointerCaptureLost(self: *@This(), e: *PointerRoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnPointerCaptureLost(e);
    }
    pub fn OnPointerCanceled(self: *@This(), e: *PointerRoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnPointerCanceled(e);
    }
    pub fn OnPointerWheelChanged(self: *@This(), e: *PointerRoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnPointerWheelChanged(e);
    }
    pub fn OnTapped(self: *@This(), e: *TappedRoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnTapped(e);
    }
    pub fn OnDoubleTapped(self: *@This(), e: *DoubleTappedRoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnDoubleTapped(e);
    }
    pub fn OnHolding(self: *@This(), e: *HoldingRoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnHolding(e);
    }
    pub fn OnRightTapped(self: *@This(), e: *RightTappedRoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnRightTapped(e);
    }
    pub fn OnManipulationStarting(self: *@This(), e: *ManipulationStartingRoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnManipulationStarting(e);
    }
    pub fn OnManipulationInertiaStarting(self: *@This(), e: *ManipulationInertiaStartingRoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnManipulationInertiaStarting(e);
    }
    pub fn OnManipulationStarted(self: *@This(), e: *ManipulationStartedRoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnManipulationStarted(e);
    }
    pub fn OnManipulationDelta(self: *@This(), e: *ManipulationDeltaRoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnManipulationDelta(e);
    }
    pub fn OnManipulationCompleted(self: *@This(), e: *ManipulationCompletedRoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnManipulationCompleted(e);
    }
    pub fn OnKeyUp(self: *@This(), e: *KeyRoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnKeyUp(e);
    }
    pub fn OnKeyDown(self: *@This(), e: *KeyRoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnKeyDown(e);
    }
    pub fn OnGotFocus(self: *@This(), e: *RoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnGotFocus(e);
    }
    pub fn OnLostFocus(self: *@This(), e: *RoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnLostFocus(e);
    }
    pub fn OnDragEnter(self: *@This(), e: *DragEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnDragEnter(e);
    }
    pub fn OnDragLeave(self: *@This(), e: *DragEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnDragLeave(e);
    }
    pub fn OnDragOver(self: *@This(), e: *DragEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnDragOver(e);
    }
    pub fn OnDrop(self: *@This(), e: *DragEventArgs) core.HResult!void {
        var this: ?*IControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnDrop(e);
    }
    pub fn OnPreviewKeyDown(self: *@This(), e: *KeyRoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnPreviewKeyDown(e);
    }
    pub fn OnPreviewKeyUp(self: *@This(), e: *KeyRoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnPreviewKeyUp(e);
    }
    pub fn OnCharacterReceived(self: *@This(), e: *CharacterReceivedRoutedEventArgs) core.HResult!void {
        var this: ?*IControlOverrides6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IControlOverrides6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnCharacterReceived(e);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getUseSystemFocusVisualsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStatics3Cache.get();
        return try _f.getUseSystemFocusVisualsProperty();
    }
    pub fn getIsTemplateFocusTargetProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStatics3Cache.get();
        return try _f.getIsTemplateFocusTargetProperty();
    }
    pub fn GetIsTemplateFocusTarget(element: *FrameworkElement) core.HResult!bool {
        const _f = @This().IControlStatics3Cache.get();
        return try _f.GetIsTemplateFocusTarget(element);
    }
    pub fn SetIsTemplateFocusTarget(element: *FrameworkElement, value: bool) core.HResult!void {
        const _f = @This().IControlStatics3Cache.get();
        return try _f.SetIsTemplateFocusTarget(element, value);
    }
    pub fn getIsTextScaleFactorEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStatics2Cache.get();
        return try _f.getIsTextScaleFactorEnabledProperty();
    }
    pub fn getBackgroundSizingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStatics7Cache.get();
        return try _f.getBackgroundSizingProperty();
    }
    pub fn getCornerRadiusProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStatics7Cache.get();
        return try _f.getCornerRadiusProperty();
    }
    pub fn getFontSizeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStaticsCache.get();
        return try _f.getFontSizeProperty();
    }
    pub fn getFontFamilyProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStaticsCache.get();
        return try _f.getFontFamilyProperty();
    }
    pub fn getFontWeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStaticsCache.get();
        return try _f.getFontWeightProperty();
    }
    pub fn getFontStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStaticsCache.get();
        return try _f.getFontStyleProperty();
    }
    pub fn getFontStretchProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStaticsCache.get();
        return try _f.getFontStretchProperty();
    }
    pub fn getCharacterSpacingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStaticsCache.get();
        return try _f.getCharacterSpacingProperty();
    }
    pub fn getForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStaticsCache.get();
        return try _f.getForegroundProperty();
    }
    pub fn getIsTabStopProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStaticsCache.get();
        return try _f.getIsTabStopProperty();
    }
    pub fn getIsEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStaticsCache.get();
        return try _f.getIsEnabledProperty();
    }
    pub fn getTabIndexProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStaticsCache.get();
        return try _f.getTabIndexProperty();
    }
    pub fn getTabNavigationProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStaticsCache.get();
        return try _f.getTabNavigationProperty();
    }
    pub fn getTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStaticsCache.get();
        return try _f.getTemplateProperty();
    }
    pub fn getPaddingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStaticsCache.get();
        return try _f.getPaddingProperty();
    }
    pub fn getHorizontalContentAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStaticsCache.get();
        return try _f.getHorizontalContentAlignmentProperty();
    }
    pub fn getVerticalContentAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStaticsCache.get();
        return try _f.getVerticalContentAlignmentProperty();
    }
    pub fn getBackgroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStaticsCache.get();
        return try _f.getBackgroundProperty();
    }
    pub fn getBorderThicknessProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStaticsCache.get();
        return try _f.getBorderThicknessProperty();
    }
    pub fn getBorderBrushProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStaticsCache.get();
        return try _f.getBorderBrushProperty();
    }
    pub fn getDefaultStyleKeyProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStaticsCache.get();
        return try _f.getDefaultStyleKeyProperty();
    }
    pub fn getFocusStateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStaticsCache.get();
        return try _f.getFocusStateProperty();
    }
    pub fn getDefaultStyleResourceUriProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStatics5Cache.get();
        return try _f.getDefaultStyleResourceUriProperty();
    }
    pub fn getIsTemplateKeyTipTargetProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStatics5Cache.get();
        return try _f.getIsTemplateKeyTipTargetProperty();
    }
    pub fn GetIsTemplateKeyTipTarget(element: *DependencyObject) core.HResult!bool {
        const _f = @This().IControlStatics5Cache.get();
        return try _f.GetIsTemplateKeyTipTarget(element);
    }
    pub fn SetIsTemplateKeyTipTarget(element: *DependencyObject, value: bool) core.HResult!void {
        const _f = @This().IControlStatics5Cache.get();
        return try _f.SetIsTemplateKeyTipTarget(element, value);
    }
    pub fn getIsFocusEngagementEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStatics4Cache.get();
        return try _f.getIsFocusEngagementEnabledProperty();
    }
    pub fn getIsFocusEngagedProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStatics4Cache.get();
        return try _f.getIsFocusEngagedProperty();
    }
    pub fn getRequiresPointerProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStatics4Cache.get();
        return try _f.getRequiresPointerProperty();
    }
    pub fn getXYFocusLeftProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStatics4Cache.get();
        return try _f.getXYFocusLeftProperty();
    }
    pub fn getXYFocusRightProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStatics4Cache.get();
        return try _f.getXYFocusRightProperty();
    }
    pub fn getXYFocusUpProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStatics4Cache.get();
        return try _f.getXYFocusUpProperty();
    }
    pub fn getXYFocusDownProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStatics4Cache.get();
        return try _f.getXYFocusDownProperty();
    }
    pub fn getElementSoundModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IControlStatics4Cache.get();
        return try _f.getElementSoundModeProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*Control {
        const _f = @This().IControlFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.Control";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IControl.GUID;
    pub const IID: Guid = IControl.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IControl.SIGNATURE);
    var _IControlStatics3Cache: FactoryCache(IControlStatics3, RUNTIME_NAME) = .{};
    var _IControlStatics2Cache: FactoryCache(IControlStatics2, RUNTIME_NAME) = .{};
    var _IControlStatics7Cache: FactoryCache(IControlStatics7, RUNTIME_NAME) = .{};
    var _IControlStaticsCache: FactoryCache(IControlStatics, RUNTIME_NAME) = .{};
    var _IControlStatics5Cache: FactoryCache(IControlStatics5, RUNTIME_NAME) = .{};
    var _IControlStatics4Cache: FactoryCache(IControlStatics4, RUNTIME_NAME) = .{};
    var _IControlFactoryCache: FactoryCache(IControlFactory, RUNTIME_NAME) = .{};
};
pub const ContentControl = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getContent(self: *@This()) core.HResult!*IInspectable {
        const this: *IContentControl = @ptrCast(self);
        return try this.getContent();
    }
    pub fn putContent(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IContentControl = @ptrCast(self);
        return try this.putContent(value);
    }
    pub fn getContentTemplate(self: *@This()) core.HResult!*DataTemplate {
        const this: *IContentControl = @ptrCast(self);
        return try this.getContentTemplate();
    }
    pub fn putContentTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const this: *IContentControl = @ptrCast(self);
        return try this.putContentTemplate(value);
    }
    pub fn getContentTemplateSelector(self: *@This()) core.HResult!*DataTemplateSelector {
        const this: *IContentControl = @ptrCast(self);
        return try this.getContentTemplateSelector();
    }
    pub fn putContentTemplateSelector(self: *@This(), value: *DataTemplateSelector) core.HResult!void {
        const this: *IContentControl = @ptrCast(self);
        return try this.putContentTemplateSelector(value);
    }
    pub fn getContentTransitions(self: *@This()) core.HResult!*TransitionCollection {
        const this: *IContentControl = @ptrCast(self);
        return try this.getContentTransitions();
    }
    pub fn putContentTransitions(self: *@This(), value: *TransitionCollection) core.HResult!void {
        const this: *IContentControl = @ptrCast(self);
        return try this.putContentTransitions(value);
    }
    pub fn getContentTemplateRoot(self: *@This()) core.HResult!*UIElement {
        var this: ?*IContentControl2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentControl2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getContentTemplateRoot();
    }
    pub fn OnContentChanged(self: *@This(), oldContent: *IInspectable, newContent: *IInspectable) core.HResult!void {
        var this: ?*IContentControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnContentChanged(oldContent, newContent);
    }
    pub fn OnContentTemplateChanged(self: *@This(), oldContentTemplate: *DataTemplate, newContentTemplate: *DataTemplate) core.HResult!void {
        var this: ?*IContentControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnContentTemplateChanged(oldContentTemplate, newContentTemplate);
    }
    pub fn OnContentTemplateSelectorChanged(self: *@This(), oldContentTemplateSelector: *DataTemplateSelector, newContentTemplateSelector: *DataTemplateSelector) core.HResult!void {
        var this: ?*IContentControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnContentTemplateSelectorChanged(oldContentTemplateSelector, newContentTemplateSelector);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getContentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentControlStaticsCache.get();
        return try _f.getContentProperty();
    }
    pub fn getContentTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentControlStaticsCache.get();
        return try _f.getContentTemplateProperty();
    }
    pub fn getContentTemplateSelectorProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentControlStaticsCache.get();
        return try _f.getContentTemplateSelectorProperty();
    }
    pub fn getContentTransitionsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentControlStaticsCache.get();
        return try _f.getContentTransitionsProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ContentControl {
        const _f = @This().IContentControlFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ContentControl";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IContentControl.GUID;
    pub const IID: Guid = IContentControl.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IContentControl.SIGNATURE);
    var _IContentControlStaticsCache: FactoryCache(IContentControlStatics, RUNTIME_NAME) = .{};
    var _IContentControlFactoryCache: FactoryCache(IContentControlFactory, RUNTIME_NAME) = .{};
};
pub const AppBar = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsOpen(self: *@This()) core.HResult!bool {
        const this: *IAppBar = @ptrCast(self);
        return try this.getIsOpen();
    }
    pub fn putIsOpen(self: *@This(), value: bool) core.HResult!void {
        const this: *IAppBar = @ptrCast(self);
        return try this.putIsOpen(value);
    }
    pub fn getIsSticky(self: *@This()) core.HResult!bool {
        const this: *IAppBar = @ptrCast(self);
        return try this.getIsSticky();
    }
    pub fn putIsSticky(self: *@This(), value: bool) core.HResult!void {
        const this: *IAppBar = @ptrCast(self);
        return try this.putIsSticky(value);
    }
    pub fn addOpened(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        const this: *IAppBar = @ptrCast(self);
        return try this.addOpened(handler);
    }
    pub fn removeOpened(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IAppBar = @ptrCast(self);
        return try this.removeOpened(token);
    }
    pub fn addClosed(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        const this: *IAppBar = @ptrCast(self);
        return try this.addClosed(handler);
    }
    pub fn removeClosed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IAppBar = @ptrCast(self);
        return try this.removeClosed(token);
    }
    pub fn getClosedDisplayMode(self: *@This()) core.HResult!AppBarClosedDisplayMode {
        var this: ?*IAppBar2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBar2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getClosedDisplayMode();
    }
    pub fn putClosedDisplayMode(self: *@This(), value: AppBarClosedDisplayMode) core.HResult!void {
        var this: ?*IAppBar2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBar2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putClosedDisplayMode(value);
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*AppBarTemplateSettings {
        var this: ?*IAppBar3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBar3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTemplateSettings();
    }
    pub fn addOpening(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        var this: ?*IAppBar3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBar3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addOpening(handler);
    }
    pub fn removeOpening(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IAppBar3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBar3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeOpening(token);
    }
    pub fn addClosing(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        var this: ?*IAppBar3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBar3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addClosing(handler);
    }
    pub fn removeClosing(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IAppBar3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBar3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeClosing(token);
    }
    pub fn getLightDismissOverlayMode(self: *@This()) core.HResult!LightDismissOverlayMode {
        var this: ?*IAppBar4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBar4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getLightDismissOverlayMode();
    }
    pub fn putLightDismissOverlayMode(self: *@This(), value: LightDismissOverlayMode) core.HResult!void {
        var this: ?*IAppBar4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBar4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putLightDismissOverlayMode(value);
    }
    pub fn OnClosed(self: *@This(), e: *IInspectable) core.HResult!void {
        var this: ?*IAppBarOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBarOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnClosed(e);
    }
    pub fn OnOpened(self: *@This(), e: *IInspectable) core.HResult!void {
        var this: ?*IAppBarOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBarOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnOpened(e);
    }
    pub fn OnClosing(self: *@This(), e: *IInspectable) core.HResult!void {
        var this: ?*IAppBarOverrides3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBarOverrides3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnClosing(e);
    }
    pub fn OnOpening(self: *@This(), e: *IInspectable) core.HResult!void {
        var this: ?*IAppBarOverrides3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBarOverrides3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnOpening(e);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getLightDismissOverlayModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarStatics4Cache.get();
        return try _f.getLightDismissOverlayModeProperty();
    }
    pub fn getClosedDisplayModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarStatics2Cache.get();
        return try _f.getClosedDisplayModeProperty();
    }
    pub fn getIsOpenProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarStaticsCache.get();
        return try _f.getIsOpenProperty();
    }
    pub fn getIsStickyProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarStaticsCache.get();
        return try _f.getIsStickyProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*AppBar {
        const _f = @This().IAppBarFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.AppBar";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IAppBar.GUID;
    pub const IID: Guid = IAppBar.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IAppBar.SIGNATURE);
    var _IAppBarStatics4Cache: FactoryCache(IAppBarStatics4, RUNTIME_NAME) = .{};
    var _IAppBarStatics2Cache: FactoryCache(IAppBarStatics2, RUNTIME_NAME) = .{};
    var _IAppBarStaticsCache: FactoryCache(IAppBarStatics, RUNTIME_NAME) = .{};
    var _IAppBarFactoryCache: FactoryCache(IAppBarFactory, RUNTIME_NAME) = .{};
};
pub const Button = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getFlyout(self: *@This()) core.HResult!*FlyoutBase {
        var this: ?*IButtonWithFlyout = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IButtonWithFlyout.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getFlyout();
    }
    pub fn putFlyout(self: *@This(), value: *FlyoutBase) core.HResult!void {
        var this: ?*IButtonWithFlyout = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IButtonWithFlyout.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putFlyout(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getFlyoutProperty() core.HResult!*DependencyProperty {
        const _f = @This().IButtonStaticsWithFlyoutCache.get();
        return try _f.getFlyoutProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*Button {
        const _f = @This().IButtonFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.Button";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IButton.GUID;
    pub const IID: Guid = IButton.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IButton.SIGNATURE);
    var _IButtonStaticsWithFlyoutCache: FactoryCache(IButtonStaticsWithFlyout, RUNTIME_NAME) = .{};
    var _IButtonFactoryCache: FactoryCache(IButtonFactory, RUNTIME_NAME) = .{};
};
pub const AppBarButton = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getLabel(self: *@This()) core.HResult!HSTRING {
        const this: *IAppBarButton = @ptrCast(self);
        return try this.getLabel();
    }
    pub fn putLabel(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IAppBarButton = @ptrCast(self);
        return try this.putLabel(value);
    }
    pub fn getIcon(self: *@This()) core.HResult!*IconElement {
        const this: *IAppBarButton = @ptrCast(self);
        return try this.getIcon();
    }
    pub fn putIcon(self: *@This(), value: *IconElement) core.HResult!void {
        const this: *IAppBarButton = @ptrCast(self);
        return try this.putIcon(value);
    }
    pub fn getLabelPosition(self: *@This()) core.HResult!CommandBarLabelPosition {
        var this: ?*IAppBarButton3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBarButton3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getLabelPosition();
    }
    pub fn putLabelPosition(self: *@This(), value: CommandBarLabelPosition) core.HResult!void {
        var this: ?*IAppBarButton3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBarButton3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putLabelPosition(value);
    }
    pub fn getKeyboardAcceleratorTextOverride(self: *@This()) core.HResult!HSTRING {
        var this: ?*IAppBarButton4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBarButton4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getKeyboardAcceleratorTextOverride();
    }
    pub fn putKeyboardAcceleratorTextOverride(self: *@This(), value: HSTRING) core.HResult!void {
        var this: ?*IAppBarButton4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBarButton4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putKeyboardAcceleratorTextOverride(value);
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*AppBarButtonTemplateSettings {
        var this: ?*IAppBarButton5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBarButton5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTemplateSettings();
    }
    pub fn getIsCompact(self: *@This()) core.HResult!bool {
        var this: ?*ICommandBarElement = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBarElement.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsCompact();
    }
    pub fn putIsCompact(self: *@This(), value: bool) core.HResult!void {
        var this: ?*ICommandBarElement = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBarElement.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsCompact(value);
    }
    pub fn getIsInOverflow(self: *@This()) core.HResult!bool {
        var this: ?*ICommandBarElement2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBarElement2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsInOverflow();
    }
    pub fn getDynamicOverflowOrder(self: *@This()) core.HResult!i32 {
        var this: ?*ICommandBarElement2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBarElement2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDynamicOverflowOrder();
    }
    pub fn putDynamicOverflowOrder(self: *@This(), value: i32) core.HResult!void {
        var this: ?*ICommandBarElement2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBarElement2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putDynamicOverflowOrder(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getLabelProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarButtonStaticsCache.get();
        return try _f.getLabelProperty();
    }
    pub fn getIconProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarButtonStaticsCache.get();
        return try _f.getIconProperty();
    }
    pub fn getIsCompactProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarButtonStaticsCache.get();
        return try _f.getIsCompactProperty();
    }
    pub fn getKeyboardAcceleratorTextOverrideProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarButtonStatics4Cache.get();
        return try _f.getKeyboardAcceleratorTextOverrideProperty();
    }
    pub fn getLabelPositionProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarButtonStatics3Cache.get();
        return try _f.getLabelPositionProperty();
    }
    pub fn getIsInOverflowProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarButtonStatics3Cache.get();
        return try _f.getIsInOverflowProperty();
    }
    pub fn getDynamicOverflowOrderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarButtonStatics3Cache.get();
        return try _f.getDynamicOverflowOrderProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*AppBarButton {
        const _f = @This().IAppBarButtonFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.AppBarButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IAppBarButton.GUID;
    pub const IID: Guid = IAppBarButton.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IAppBarButton.SIGNATURE);
    var _IAppBarButtonStaticsCache: FactoryCache(IAppBarButtonStatics, RUNTIME_NAME) = .{};
    var _IAppBarButtonStatics4Cache: FactoryCache(IAppBarButtonStatics4, RUNTIME_NAME) = .{};
    var _IAppBarButtonStatics3Cache: FactoryCache(IAppBarButtonStatics3, RUNTIME_NAME) = .{};
    var _IAppBarButtonFactoryCache: FactoryCache(IAppBarButtonFactory, RUNTIME_NAME) = .{};
};
pub const AppBarClosedDisplayMode = enum(i32) {
    Compact = 0,
    Minimal = 1,
    Hidden = 2,
};
pub const AppBarElementContainer = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsCompact(self: *@This()) core.HResult!bool {
        var this: ?*ICommandBarElement = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBarElement.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsCompact();
    }
    pub fn putIsCompact(self: *@This(), value: bool) core.HResult!void {
        var this: ?*ICommandBarElement = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBarElement.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsCompact(value);
    }
    pub fn getIsInOverflow(self: *@This()) core.HResult!bool {
        var this: ?*ICommandBarElement2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBarElement2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsInOverflow();
    }
    pub fn getDynamicOverflowOrder(self: *@This()) core.HResult!i32 {
        var this: ?*ICommandBarElement2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBarElement2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDynamicOverflowOrder();
    }
    pub fn putDynamicOverflowOrder(self: *@This(), value: i32) core.HResult!void {
        var this: ?*ICommandBarElement2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBarElement2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putDynamicOverflowOrder(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getIsCompactProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarElementContainerStaticsCache.get();
        return try _f.getIsCompactProperty();
    }
    pub fn getIsInOverflowProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarElementContainerStaticsCache.get();
        return try _f.getIsInOverflowProperty();
    }
    pub fn getDynamicOverflowOrderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarElementContainerStaticsCache.get();
        return try _f.getDynamicOverflowOrderProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*AppBarElementContainer {
        const _f = @This().IAppBarElementContainerFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.AppBarElementContainer";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IAppBarElementContainer.GUID;
    pub const IID: Guid = IAppBarElementContainer.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IAppBarElementContainer.SIGNATURE);
    var _IAppBarElementContainerStaticsCache: FactoryCache(IAppBarElementContainerStatics, RUNTIME_NAME) = .{};
    var _IAppBarElementContainerFactoryCache: FactoryCache(IAppBarElementContainerFactory, RUNTIME_NAME) = .{};
};
pub const AppBarSeparator = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsCompact(self: *@This()) core.HResult!bool {
        var this: ?*ICommandBarElement = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBarElement.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsCompact();
    }
    pub fn putIsCompact(self: *@This(), value: bool) core.HResult!void {
        var this: ?*ICommandBarElement = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBarElement.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsCompact(value);
    }
    pub fn getIsInOverflow(self: *@This()) core.HResult!bool {
        var this: ?*ICommandBarElement2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBarElement2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsInOverflow();
    }
    pub fn getDynamicOverflowOrder(self: *@This()) core.HResult!i32 {
        var this: ?*ICommandBarElement2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBarElement2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDynamicOverflowOrder();
    }
    pub fn putDynamicOverflowOrder(self: *@This(), value: i32) core.HResult!void {
        var this: ?*ICommandBarElement2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBarElement2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putDynamicOverflowOrder(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getIsInOverflowProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarSeparatorStatics3Cache.get();
        return try _f.getIsInOverflowProperty();
    }
    pub fn getDynamicOverflowOrderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarSeparatorStatics3Cache.get();
        return try _f.getDynamicOverflowOrderProperty();
    }
    pub fn getIsCompactProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarSeparatorStaticsCache.get();
        return try _f.getIsCompactProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*AppBarSeparator {
        const _f = @This().IAppBarSeparatorFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.AppBarSeparator";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IAppBarSeparator.GUID;
    pub const IID: Guid = IAppBarSeparator.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IAppBarSeparator.SIGNATURE);
    var _IAppBarSeparatorStatics3Cache: FactoryCache(IAppBarSeparatorStatics3, RUNTIME_NAME) = .{};
    var _IAppBarSeparatorStaticsCache: FactoryCache(IAppBarSeparatorStatics, RUNTIME_NAME) = .{};
    var _IAppBarSeparatorFactoryCache: FactoryCache(IAppBarSeparatorFactory, RUNTIME_NAME) = .{};
};
pub const AppBarToggleButton = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getLabel(self: *@This()) core.HResult!HSTRING {
        const this: *IAppBarToggleButton = @ptrCast(self);
        return try this.getLabel();
    }
    pub fn putLabel(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IAppBarToggleButton = @ptrCast(self);
        return try this.putLabel(value);
    }
    pub fn getIcon(self: *@This()) core.HResult!*IconElement {
        const this: *IAppBarToggleButton = @ptrCast(self);
        return try this.getIcon();
    }
    pub fn putIcon(self: *@This(), value: *IconElement) core.HResult!void {
        const this: *IAppBarToggleButton = @ptrCast(self);
        return try this.putIcon(value);
    }
    pub fn getLabelPosition(self: *@This()) core.HResult!CommandBarLabelPosition {
        var this: ?*IAppBarToggleButton3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBarToggleButton3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getLabelPosition();
    }
    pub fn putLabelPosition(self: *@This(), value: CommandBarLabelPosition) core.HResult!void {
        var this: ?*IAppBarToggleButton3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBarToggleButton3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putLabelPosition(value);
    }
    pub fn getKeyboardAcceleratorTextOverride(self: *@This()) core.HResult!HSTRING {
        var this: ?*IAppBarToggleButton4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBarToggleButton4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getKeyboardAcceleratorTextOverride();
    }
    pub fn putKeyboardAcceleratorTextOverride(self: *@This(), value: HSTRING) core.HResult!void {
        var this: ?*IAppBarToggleButton4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBarToggleButton4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putKeyboardAcceleratorTextOverride(value);
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*AppBarToggleButtonTemplateSettings {
        var this: ?*IAppBarToggleButton5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAppBarToggleButton5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTemplateSettings();
    }
    pub fn getIsCompact(self: *@This()) core.HResult!bool {
        var this: ?*ICommandBarElement = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBarElement.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsCompact();
    }
    pub fn putIsCompact(self: *@This(), value: bool) core.HResult!void {
        var this: ?*ICommandBarElement = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBarElement.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsCompact(value);
    }
    pub fn getIsInOverflow(self: *@This()) core.HResult!bool {
        var this: ?*ICommandBarElement2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBarElement2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsInOverflow();
    }
    pub fn getDynamicOverflowOrder(self: *@This()) core.HResult!i32 {
        var this: ?*ICommandBarElement2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBarElement2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDynamicOverflowOrder();
    }
    pub fn putDynamicOverflowOrder(self: *@This(), value: i32) core.HResult!void {
        var this: ?*ICommandBarElement2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBarElement2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putDynamicOverflowOrder(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getLabelPositionProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarToggleButtonStatics3Cache.get();
        return try _f.getLabelPositionProperty();
    }
    pub fn getIsInOverflowProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarToggleButtonStatics3Cache.get();
        return try _f.getIsInOverflowProperty();
    }
    pub fn getDynamicOverflowOrderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarToggleButtonStatics3Cache.get();
        return try _f.getDynamicOverflowOrderProperty();
    }
    pub fn getLabelProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarToggleButtonStaticsCache.get();
        return try _f.getLabelProperty();
    }
    pub fn getIconProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarToggleButtonStaticsCache.get();
        return try _f.getIconProperty();
    }
    pub fn getIsCompactProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarToggleButtonStaticsCache.get();
        return try _f.getIsCompactProperty();
    }
    pub fn getKeyboardAcceleratorTextOverrideProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAppBarToggleButtonStatics4Cache.get();
        return try _f.getKeyboardAcceleratorTextOverrideProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*AppBarToggleButton {
        const _f = @This().IAppBarToggleButtonFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.AppBarToggleButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IAppBarToggleButton.GUID;
    pub const IID: Guid = IAppBarToggleButton.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IAppBarToggleButton.SIGNATURE);
    var _IAppBarToggleButtonStatics3Cache: FactoryCache(IAppBarToggleButtonStatics3, RUNTIME_NAME) = .{};
    var _IAppBarToggleButtonStaticsCache: FactoryCache(IAppBarToggleButtonStatics, RUNTIME_NAME) = .{};
    var _IAppBarToggleButtonStatics4Cache: FactoryCache(IAppBarToggleButtonStatics4, RUNTIME_NAME) = .{};
    var _IAppBarToggleButtonFactoryCache: FactoryCache(IAppBarToggleButtonFactory, RUNTIME_NAME) = .{};
};
pub const ItemsControl = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getItemsSource(self: *@This()) core.HResult!*IInspectable {
        const this: *IItemsControl = @ptrCast(self);
        return try this.getItemsSource();
    }
    pub fn putItemsSource(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IItemsControl = @ptrCast(self);
        return try this.putItemsSource(value);
    }
    pub fn getItems(self: *@This()) core.HResult!*ItemCollection {
        const this: *IItemsControl = @ptrCast(self);
        return try this.getItems();
    }
    pub fn getItemTemplate(self: *@This()) core.HResult!*DataTemplate {
        const this: *IItemsControl = @ptrCast(self);
        return try this.getItemTemplate();
    }
    pub fn putItemTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const this: *IItemsControl = @ptrCast(self);
        return try this.putItemTemplate(value);
    }
    pub fn getItemTemplateSelector(self: *@This()) core.HResult!*DataTemplateSelector {
        const this: *IItemsControl = @ptrCast(self);
        return try this.getItemTemplateSelector();
    }
    pub fn putItemTemplateSelector(self: *@This(), value: *DataTemplateSelector) core.HResult!void {
        const this: *IItemsControl = @ptrCast(self);
        return try this.putItemTemplateSelector(value);
    }
    pub fn getItemsPanel(self: *@This()) core.HResult!*ItemsPanelTemplate {
        const this: *IItemsControl = @ptrCast(self);
        return try this.getItemsPanel();
    }
    pub fn putItemsPanel(self: *@This(), value: *ItemsPanelTemplate) core.HResult!void {
        const this: *IItemsControl = @ptrCast(self);
        return try this.putItemsPanel(value);
    }
    pub fn getDisplayMemberPath(self: *@This()) core.HResult!HSTRING {
        const this: *IItemsControl = @ptrCast(self);
        return try this.getDisplayMemberPath();
    }
    pub fn putDisplayMemberPath(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IItemsControl = @ptrCast(self);
        return try this.putDisplayMemberPath(value);
    }
    pub fn getItemContainerStyle(self: *@This()) core.HResult!*Style {
        const this: *IItemsControl = @ptrCast(self);
        return try this.getItemContainerStyle();
    }
    pub fn putItemContainerStyle(self: *@This(), value: *Style) core.HResult!void {
        const this: *IItemsControl = @ptrCast(self);
        return try this.putItemContainerStyle(value);
    }
    pub fn getItemContainerStyleSelector(self: *@This()) core.HResult!*StyleSelector {
        const this: *IItemsControl = @ptrCast(self);
        return try this.getItemContainerStyleSelector();
    }
    pub fn putItemContainerStyleSelector(self: *@This(), value: *StyleSelector) core.HResult!void {
        const this: *IItemsControl = @ptrCast(self);
        return try this.putItemContainerStyleSelector(value);
    }
    pub fn getItemContainerGenerator(self: *@This()) core.HResult!*ItemContainerGenerator {
        const this: *IItemsControl = @ptrCast(self);
        return try this.getItemContainerGenerator();
    }
    pub fn getItemContainerTransitions(self: *@This()) core.HResult!*TransitionCollection {
        const this: *IItemsControl = @ptrCast(self);
        return try this.getItemContainerTransitions();
    }
    pub fn putItemContainerTransitions(self: *@This(), value: *TransitionCollection) core.HResult!void {
        const this: *IItemsControl = @ptrCast(self);
        return try this.putItemContainerTransitions(value);
    }
    pub fn getGroupStyle(self: *@This()) core.HResult!*IObservableVector(GroupStyle) {
        const this: *IItemsControl = @ptrCast(self);
        return try this.getGroupStyle();
    }
    pub fn getGroupStyleSelector(self: *@This()) core.HResult!*GroupStyleSelector {
        const this: *IItemsControl = @ptrCast(self);
        return try this.getGroupStyleSelector();
    }
    pub fn putGroupStyleSelector(self: *@This(), value: *GroupStyleSelector) core.HResult!void {
        const this: *IItemsControl = @ptrCast(self);
        return try this.putGroupStyleSelector(value);
    }
    pub fn getIsGrouping(self: *@This()) core.HResult!bool {
        const this: *IItemsControl = @ptrCast(self);
        return try this.getIsGrouping();
    }
    pub fn getItemsPanelRoot(self: *@This()) core.HResult!*Panel {
        var this: ?*IItemsControl2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemsControl2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getItemsPanelRoot();
    }
    pub fn GroupHeaderContainerFromItemContainer(self: *@This(), itemContainer: *DependencyObject) core.HResult!*DependencyObject {
        var this: ?*IItemsControl3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemsControl3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GroupHeaderContainerFromItemContainer(itemContainer);
    }
    pub fn IsItemItsOwnContainerOverride(self: *@This(), item: *IInspectable) core.HResult!bool {
        var this: ?*IItemsControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemsControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.IsItemItsOwnContainerOverride(item);
    }
    pub fn GetContainerForItemOverride(self: *@This()) core.HResult!*DependencyObject {
        var this: ?*IItemsControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemsControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GetContainerForItemOverride();
    }
    pub fn ClearContainerForItemOverride(self: *@This(), element: *DependencyObject, item: *IInspectable) core.HResult!void {
        var this: ?*IItemsControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemsControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.ClearContainerForItemOverride(element, item);
    }
    pub fn PrepareContainerForItemOverride(self: *@This(), element: *DependencyObject, item: *IInspectable) core.HResult!void {
        var this: ?*IItemsControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemsControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.PrepareContainerForItemOverride(element, item);
    }
    pub fn OnItemsChanged(self: *@This(), e: *IInspectable) core.HResult!void {
        var this: ?*IItemsControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemsControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnItemsChanged(e);
    }
    pub fn OnItemContainerStyleChanged(self: *@This(), oldItemContainerStyle: *Style, newItemContainerStyle: *Style) core.HResult!void {
        var this: ?*IItemsControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemsControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnItemContainerStyleChanged(oldItemContainerStyle, newItemContainerStyle);
    }
    pub fn OnItemContainerStyleSelectorChanged(self: *@This(), oldItemContainerStyleSelector: *StyleSelector, newItemContainerStyleSelector: *StyleSelector) core.HResult!void {
        var this: ?*IItemsControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemsControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnItemContainerStyleSelectorChanged(oldItemContainerStyleSelector, newItemContainerStyleSelector);
    }
    pub fn OnItemTemplateChanged(self: *@This(), oldItemTemplate: *DataTemplate, newItemTemplate: *DataTemplate) core.HResult!void {
        var this: ?*IItemsControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemsControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnItemTemplateChanged(oldItemTemplate, newItemTemplate);
    }
    pub fn OnItemTemplateSelectorChanged(self: *@This(), oldItemTemplateSelector: *DataTemplateSelector, newItemTemplateSelector: *DataTemplateSelector) core.HResult!void {
        var this: ?*IItemsControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemsControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnItemTemplateSelectorChanged(oldItemTemplateSelector, newItemTemplateSelector);
    }
    pub fn OnGroupStyleSelectorChanged(self: *@This(), oldGroupStyleSelector: *GroupStyleSelector, newGroupStyleSelector: *GroupStyleSelector) core.HResult!void {
        var this: ?*IItemsControlOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemsControlOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnGroupStyleSelectorChanged(oldGroupStyleSelector, newGroupStyleSelector);
    }
    pub fn ItemFromContainer(self: *@This(), container: *DependencyObject) core.HResult!*IInspectable {
        var this: ?*IItemContainerMapping = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemContainerMapping.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.ItemFromContainer(container);
    }
    pub fn ContainerFromItem(self: *@This(), item: *IInspectable) core.HResult!*DependencyObject {
        var this: ?*IItemContainerMapping = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemContainerMapping.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.ContainerFromItem(item);
    }
    pub fn IndexFromContainer(self: *@This(), container: *DependencyObject) core.HResult!i32 {
        var this: ?*IItemContainerMapping = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemContainerMapping.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.IndexFromContainer(container);
    }
    pub fn ContainerFromIndex(self: *@This(), index: i32) core.HResult!*DependencyObject {
        var this: ?*IItemContainerMapping = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemContainerMapping.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.ContainerFromIndex(index);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getItemsSourceProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsControlStaticsCache.get();
        return try _f.getItemsSourceProperty();
    }
    pub fn getItemTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsControlStaticsCache.get();
        return try _f.getItemTemplateProperty();
    }
    pub fn getItemTemplateSelectorProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsControlStaticsCache.get();
        return try _f.getItemTemplateSelectorProperty();
    }
    pub fn getItemsPanelProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsControlStaticsCache.get();
        return try _f.getItemsPanelProperty();
    }
    pub fn getDisplayMemberPathProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsControlStaticsCache.get();
        return try _f.getDisplayMemberPathProperty();
    }
    pub fn getItemContainerStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsControlStaticsCache.get();
        return try _f.getItemContainerStyleProperty();
    }
    pub fn getItemContainerStyleSelectorProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsControlStaticsCache.get();
        return try _f.getItemContainerStyleSelectorProperty();
    }
    pub fn getItemContainerTransitionsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsControlStaticsCache.get();
        return try _f.getItemContainerTransitionsProperty();
    }
    pub fn getGroupStyleSelectorProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsControlStaticsCache.get();
        return try _f.getGroupStyleSelectorProperty();
    }
    pub fn getIsGroupingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsControlStaticsCache.get();
        return try _f.getIsGroupingProperty();
    }
    pub fn GetItemsOwner(element: *DependencyObject) core.HResult!*ItemsControl {
        const _f = @This().IItemsControlStaticsCache.get();
        return try _f.GetItemsOwner(element);
    }
    pub fn ItemsControlFromItemContainer(container: *DependencyObject) core.HResult!*ItemsControl {
        const _f = @This().IItemsControlStaticsCache.get();
        return try _f.ItemsControlFromItemContainer(container);
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ItemsControl {
        const _f = @This().IItemsControlFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ItemsControl";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IItemsControl.GUID;
    pub const IID: Guid = IItemsControl.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IItemsControl.SIGNATURE);
    var _IItemsControlStaticsCache: FactoryCache(IItemsControlStatics, RUNTIME_NAME) = .{};
    var _IItemsControlFactoryCache: FactoryCache(IItemsControlFactory, RUNTIME_NAME) = .{};
};
pub const AutoSuggestBox = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getMaxSuggestionListHeight(self: *@This()) core.HResult!f64 {
        const this: *IAutoSuggestBox = @ptrCast(self);
        return try this.getMaxSuggestionListHeight();
    }
    pub fn putMaxSuggestionListHeight(self: *@This(), value: f64) core.HResult!void {
        const this: *IAutoSuggestBox = @ptrCast(self);
        return try this.putMaxSuggestionListHeight(value);
    }
    pub fn getIsSuggestionListOpen(self: *@This()) core.HResult!bool {
        const this: *IAutoSuggestBox = @ptrCast(self);
        return try this.getIsSuggestionListOpen();
    }
    pub fn putIsSuggestionListOpen(self: *@This(), value: bool) core.HResult!void {
        const this: *IAutoSuggestBox = @ptrCast(self);
        return try this.putIsSuggestionListOpen(value);
    }
    pub fn getTextMemberPath(self: *@This()) core.HResult!HSTRING {
        const this: *IAutoSuggestBox = @ptrCast(self);
        return try this.getTextMemberPath();
    }
    pub fn putTextMemberPath(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IAutoSuggestBox = @ptrCast(self);
        return try this.putTextMemberPath(value);
    }
    pub fn getText(self: *@This()) core.HResult!HSTRING {
        const this: *IAutoSuggestBox = @ptrCast(self);
        return try this.getText();
    }
    pub fn putText(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IAutoSuggestBox = @ptrCast(self);
        return try this.putText(value);
    }
    pub fn getUpdateTextOnSelect(self: *@This()) core.HResult!bool {
        const this: *IAutoSuggestBox = @ptrCast(self);
        return try this.getUpdateTextOnSelect();
    }
    pub fn putUpdateTextOnSelect(self: *@This(), value: bool) core.HResult!void {
        const this: *IAutoSuggestBox = @ptrCast(self);
        return try this.putUpdateTextOnSelect(value);
    }
    pub fn getPlaceholderText(self: *@This()) core.HResult!HSTRING {
        const this: *IAutoSuggestBox = @ptrCast(self);
        return try this.getPlaceholderText();
    }
    pub fn putPlaceholderText(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IAutoSuggestBox = @ptrCast(self);
        return try this.putPlaceholderText(value);
    }
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        const this: *IAutoSuggestBox = @ptrCast(self);
        return try this.getHeader();
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IAutoSuggestBox = @ptrCast(self);
        return try this.putHeader(value);
    }
    pub fn getAutoMaximizeSuggestionArea(self: *@This()) core.HResult!bool {
        const this: *IAutoSuggestBox = @ptrCast(self);
        return try this.getAutoMaximizeSuggestionArea();
    }
    pub fn putAutoMaximizeSuggestionArea(self: *@This(), value: bool) core.HResult!void {
        const this: *IAutoSuggestBox = @ptrCast(self);
        return try this.putAutoMaximizeSuggestionArea(value);
    }
    pub fn getTextBoxStyle(self: *@This()) core.HResult!*Style {
        const this: *IAutoSuggestBox = @ptrCast(self);
        return try this.getTextBoxStyle();
    }
    pub fn putTextBoxStyle(self: *@This(), value: *Style) core.HResult!void {
        const this: *IAutoSuggestBox = @ptrCast(self);
        return try this.putTextBoxStyle(value);
    }
    pub fn addSuggestionChosen(self: *@This(), handler: *TypedEventHandler(AutoSuggestBox,AutoSuggestBoxSuggestionChosenEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IAutoSuggestBox = @ptrCast(self);
        return try this.addSuggestionChosen(handler);
    }
    pub fn removeSuggestionChosen(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IAutoSuggestBox = @ptrCast(self);
        return try this.removeSuggestionChosen(token);
    }
    pub fn addTextChanged(self: *@This(), handler: *TypedEventHandler(AutoSuggestBox,AutoSuggestBoxTextChangedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IAutoSuggestBox = @ptrCast(self);
        return try this.addTextChanged(handler);
    }
    pub fn removeTextChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IAutoSuggestBox = @ptrCast(self);
        return try this.removeTextChanged(token);
    }
    pub fn getQueryIcon(self: *@This()) core.HResult!*IconElement {
        var this: ?*IAutoSuggestBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAutoSuggestBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getQueryIcon();
    }
    pub fn putQueryIcon(self: *@This(), value: *IconElement) core.HResult!void {
        var this: ?*IAutoSuggestBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAutoSuggestBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putQueryIcon(value);
    }
    pub fn addQuerySubmitted(self: *@This(), handler: *TypedEventHandler(AutoSuggestBox,AutoSuggestBoxQuerySubmittedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IAutoSuggestBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAutoSuggestBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addQuerySubmitted(handler);
    }
    pub fn removeQuerySubmitted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IAutoSuggestBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAutoSuggestBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeQuerySubmitted(token);
    }
    pub fn getLightDismissOverlayMode(self: *@This()) core.HResult!LightDismissOverlayMode {
        var this: ?*IAutoSuggestBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAutoSuggestBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getLightDismissOverlayMode();
    }
    pub fn putLightDismissOverlayMode(self: *@This(), value: LightDismissOverlayMode) core.HResult!void {
        var this: ?*IAutoSuggestBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAutoSuggestBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putLightDismissOverlayMode(value);
    }
    pub fn getDescription(self: *@This()) core.HResult!*IInspectable {
        var this: ?*IAutoSuggestBox4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAutoSuggestBox4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDescription();
    }
    pub fn putDescription(self: *@This(), value: *IInspectable) core.HResult!void {
        var this: ?*IAutoSuggestBox4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IAutoSuggestBox4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putDescription(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IAutoSuggestBox.IID)));
    }
    pub fn getMaxSuggestionListHeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAutoSuggestBoxStaticsCache.get();
        return try _f.getMaxSuggestionListHeightProperty();
    }
    pub fn getIsSuggestionListOpenProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAutoSuggestBoxStaticsCache.get();
        return try _f.getIsSuggestionListOpenProperty();
    }
    pub fn getTextMemberPathProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAutoSuggestBoxStaticsCache.get();
        return try _f.getTextMemberPathProperty();
    }
    pub fn getTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAutoSuggestBoxStaticsCache.get();
        return try _f.getTextProperty();
    }
    pub fn getUpdateTextOnSelectProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAutoSuggestBoxStaticsCache.get();
        return try _f.getUpdateTextOnSelectProperty();
    }
    pub fn getPlaceholderTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAutoSuggestBoxStaticsCache.get();
        return try _f.getPlaceholderTextProperty();
    }
    pub fn getHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAutoSuggestBoxStaticsCache.get();
        return try _f.getHeaderProperty();
    }
    pub fn getAutoMaximizeSuggestionAreaProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAutoSuggestBoxStaticsCache.get();
        return try _f.getAutoMaximizeSuggestionAreaProperty();
    }
    pub fn getTextBoxStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAutoSuggestBoxStaticsCache.get();
        return try _f.getTextBoxStyleProperty();
    }
    pub fn getLightDismissOverlayModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAutoSuggestBoxStatics3Cache.get();
        return try _f.getLightDismissOverlayModeProperty();
    }
    pub fn getDescriptionProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAutoSuggestBoxStatics4Cache.get();
        return try _f.getDescriptionProperty();
    }
    pub fn getQueryIconProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAutoSuggestBoxStatics2Cache.get();
        return try _f.getQueryIconProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.AutoSuggestBox";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IAutoSuggestBox.GUID;
    pub const IID: Guid = IAutoSuggestBox.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IAutoSuggestBox.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IAutoSuggestBoxStaticsCache: FactoryCache(IAutoSuggestBoxStatics, RUNTIME_NAME) = .{};
    var _IAutoSuggestBoxStatics3Cache: FactoryCache(IAutoSuggestBoxStatics3, RUNTIME_NAME) = .{};
    var _IAutoSuggestBoxStatics4Cache: FactoryCache(IAutoSuggestBoxStatics4, RUNTIME_NAME) = .{};
    var _IAutoSuggestBoxStatics2Cache: FactoryCache(IAutoSuggestBoxStatics2, RUNTIME_NAME) = .{};
};
pub const AutoSuggestBoxQuerySubmittedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getQueryText(self: *@This()) core.HResult!HSTRING {
        const this: *IAutoSuggestBoxQuerySubmittedEventArgs = @ptrCast(self);
        return try this.getQueryText();
    }
    pub fn getChosenSuggestion(self: *@This()) core.HResult!*IInspectable {
        const this: *IAutoSuggestBoxQuerySubmittedEventArgs = @ptrCast(self);
        return try this.getChosenSuggestion();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IAutoSuggestBoxQuerySubmittedEventArgs.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.AutoSuggestBoxQuerySubmittedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IAutoSuggestBoxQuerySubmittedEventArgs.GUID;
    pub const IID: Guid = IAutoSuggestBoxQuerySubmittedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IAutoSuggestBoxQuerySubmittedEventArgs.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const AutoSuggestBoxSuggestionChosenEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getSelectedItem(self: *@This()) core.HResult!*IInspectable {
        const this: *IAutoSuggestBoxSuggestionChosenEventArgs = @ptrCast(self);
        return try this.getSelectedItem();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IAutoSuggestBoxSuggestionChosenEventArgs.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.AutoSuggestBoxSuggestionChosenEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IAutoSuggestBoxSuggestionChosenEventArgs.GUID;
    pub const IID: Guid = IAutoSuggestBoxSuggestionChosenEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IAutoSuggestBoxSuggestionChosenEventArgs.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const AutoSuggestBoxTextChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getReason(self: *@This()) core.HResult!AutoSuggestionBoxTextChangeReason {
        const this: *IAutoSuggestBoxTextChangedEventArgs = @ptrCast(self);
        return try this.getReason();
    }
    pub fn putReason(self: *@This(), value: AutoSuggestionBoxTextChangeReason) core.HResult!void {
        const this: *IAutoSuggestBoxTextChangedEventArgs = @ptrCast(self);
        return try this.putReason(value);
    }
    pub fn CheckCurrent(self: *@This()) core.HResult!bool {
        const this: *IAutoSuggestBoxTextChangedEventArgs = @ptrCast(self);
        return try this.CheckCurrent();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IAutoSuggestBoxTextChangedEventArgs.IID)));
    }
    pub fn getReasonProperty() core.HResult!*DependencyProperty {
        const _f = @This().IAutoSuggestBoxTextChangedEventArgsStaticsCache.get();
        return try _f.getReasonProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.AutoSuggestBoxTextChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IAutoSuggestBoxTextChangedEventArgs.GUID;
    pub const IID: Guid = IAutoSuggestBoxTextChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IAutoSuggestBoxTextChangedEventArgs.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IAutoSuggestBoxTextChangedEventArgsStaticsCache: FactoryCache(IAutoSuggestBoxTextChangedEventArgsStatics, RUNTIME_NAME) = .{};
};
pub const AutoSuggestionBoxTextChangeReason = enum(i32) {
    UserInput = 0,
    ProgrammaticChange = 1,
    SuggestionChosen = 2,
};
pub const BackClickEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getHandled(self: *@This()) core.HResult!bool {
        const this: *IBackClickEventArgs = @ptrCast(self);
        return try this.getHandled();
    }
    pub fn putHandled(self: *@This(), value: bool) core.HResult!void {
        const this: *IBackClickEventArgs = @ptrCast(self);
        return try this.putHandled(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IBackClickEventArgs.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.BackClickEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IBackClickEventArgs.GUID;
    pub const IID: Guid = IBackClickEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IBackClickEventArgs.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const BackClickEventHandler = extern struct {
    vtable: *const VTable,
    _refs: @import("std").atomic.Value(u32),
    _cb: *const fn (context: ?*anyopaque) callconv(.winapi) void,
    _context: ?*anyopaque = null,
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn init(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *BackClickEventArgs) callconv(.winapi) void,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
        };
        return _r;
    }
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn initWithState(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *BackClickEventArgs) callconv(.winapi) void,
        context: anytype,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
            ._context = @ptrCast(context),
        };
        return _r;
    }
    /// This calls Release and voids the returned ref count. If ref count is 0 the memory is released,
    /// Otherwise the memory stays until all references are released, including all references Windows holds.
    ///
    /// The caller *MUST* always call deinit/Release at least once for every AddRef and init called.
    pub fn deinit(self: *@This()) void {
        _ = Release(@ptrCast(self));
    }
    fn QueryInterface(self: *anyopaque, riid: *const Guid, out: *?*anyopaque) callconv(.c) HRESULT {
        const me: *@This() = @ptrCast(@alignCast(self));
        // TODO: Handle IMarshal
        if (core.wiredGuidEql(riid, &IID) or
            core.wiredGuidEql(riid, &IUnknown.IID) or
            core.wiredGuidEql(riid, &IAgileObject.IID))
        {
            out.* = @as(?*anyopaque, @ptrCast(me));
            _ = AddRef(self);
            return 0;
        }
        out.* = null;
        return -2147467262; // E_NOINTERFACE
    }
    fn AddRef(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        return this._refs.fetchAdd(1, .monotonic) + 1;
    }
    fn Release(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        const left = this._refs.fetchSub(1, .acq_rel) - 1;
        if (left == 0) @import("std").heap.c_allocator.destroy(this);
        return left;
    }
    pub fn Invoke(self: *anyopaque, sender: *IInspectable, e: *BackClickEventArgs) callconv(.winapi) HRESULT {
        const this: *@This() = @ptrCast(@alignCast(self));
        this._cb(this._context, sender, e);
        return 0;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.BackClickEventHandler";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "fa9bc21f-9892-482e-abf6-eb2d607d32de";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.pinterface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        Invoke: *const fn(self: *anyopaque, sender: *IInspectable, e: *BackClickEventArgs) callconv(.winapi) HRESULT
    };
    pub const VTABLE = VTable {
        .QueryInterface = QueryInterface,
        .AddRef = AddRef,
        .Release = Release,
        .Invoke = Invoke,
    };
};
pub const BackgroundSizing = enum(i32) {
    InnerBorderEdge = 0,
    OuterBorderEdge = 1,
};
pub const IconElement = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getForeground(self: *@This()) core.HResult!*Brush {
        const this: *IIconElement = @ptrCast(self);
        return try this.getForeground();
    }
    pub fn putForeground(self: *@This(), value: *Brush) core.HResult!void {
        const this: *IIconElement = @ptrCast(self);
        return try this.putForeground(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().IIconElementStaticsCache.get();
        return try _f.getForegroundProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IconElement";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IIconElement.GUID;
    pub const IID: Guid = IIconElement.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IIconElement.SIGNATURE);
    var _IIconElementStaticsCache: FactoryCache(IIconElementStatics, RUNTIME_NAME) = .{};
    var _IIconElementFactoryCache: FactoryCache(IIconElementFactory, RUNTIME_NAME) = .{};
};
pub const BitmapIcon = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getUriSource(self: *@This()) core.HResult!*Uri {
        const this: *IBitmapIcon = @ptrCast(self);
        return try this.getUriSource();
    }
    pub fn putUriSource(self: *@This(), value: *Uri) core.HResult!void {
        const this: *IBitmapIcon = @ptrCast(self);
        return try this.putUriSource(value);
    }
    pub fn getShowAsMonochrome(self: *@This()) core.HResult!bool {
        var this: ?*IBitmapIcon2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IBitmapIcon2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getShowAsMonochrome();
    }
    pub fn putShowAsMonochrome(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IBitmapIcon2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IBitmapIcon2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putShowAsMonochrome(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getShowAsMonochromeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IBitmapIconStatics2Cache.get();
        return try _f.getShowAsMonochromeProperty();
    }
    pub fn getUriSourceProperty() core.HResult!*DependencyProperty {
        const _f = @This().IBitmapIconStaticsCache.get();
        return try _f.getUriSourceProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*BitmapIcon {
        const _f = @This().IBitmapIconFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.BitmapIcon";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IBitmapIcon.GUID;
    pub const IID: Guid = IBitmapIcon.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IBitmapIcon.SIGNATURE);
    var _IBitmapIconStatics2Cache: FactoryCache(IBitmapIconStatics2, RUNTIME_NAME) = .{};
    var _IBitmapIconStaticsCache: FactoryCache(IBitmapIconStatics, RUNTIME_NAME) = .{};
    var _IBitmapIconFactoryCache: FactoryCache(IBitmapIconFactory, RUNTIME_NAME) = .{};
};
pub const IconSource = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getForeground(self: *@This()) core.HResult!*Brush {
        const this: *IIconSource = @ptrCast(self);
        return try this.getForeground();
    }
    pub fn putForeground(self: *@This(), value: *Brush) core.HResult!void {
        const this: *IIconSource = @ptrCast(self);
        return try this.putForeground(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().IIconSourceStaticsCache.get();
        return try _f.getForegroundProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IconSource";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IIconSource.GUID;
    pub const IID: Guid = IIconSource.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IIconSource.SIGNATURE);
    var _IIconSourceStaticsCache: FactoryCache(IIconSourceStatics, RUNTIME_NAME) = .{};
    var _IIconSourceFactoryCache: FactoryCache(IIconSourceFactory, RUNTIME_NAME) = .{};
};
pub const BitmapIconSource = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getUriSource(self: *@This()) core.HResult!*Uri {
        const this: *IBitmapIconSource = @ptrCast(self);
        return try this.getUriSource();
    }
    pub fn putUriSource(self: *@This(), value: *Uri) core.HResult!void {
        const this: *IBitmapIconSource = @ptrCast(self);
        return try this.putUriSource(value);
    }
    pub fn getShowAsMonochrome(self: *@This()) core.HResult!bool {
        const this: *IBitmapIconSource = @ptrCast(self);
        return try this.getShowAsMonochrome();
    }
    pub fn putShowAsMonochrome(self: *@This(), value: bool) core.HResult!void {
        const this: *IBitmapIconSource = @ptrCast(self);
        return try this.putShowAsMonochrome(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getUriSourceProperty() core.HResult!*DependencyProperty {
        const _f = @This().IBitmapIconSourceStaticsCache.get();
        return try _f.getUriSourceProperty();
    }
    pub fn getShowAsMonochromeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IBitmapIconSourceStaticsCache.get();
        return try _f.getShowAsMonochromeProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*BitmapIconSource {
        const _f = @This().IBitmapIconSourceFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.BitmapIconSource";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IBitmapIconSource.GUID;
    pub const IID: Guid = IBitmapIconSource.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IBitmapIconSource.SIGNATURE);
    var _IBitmapIconSourceStaticsCache: FactoryCache(IBitmapIconSourceStatics, RUNTIME_NAME) = .{};
    var _IBitmapIconSourceFactoryCache: FactoryCache(IBitmapIconSourceFactory, RUNTIME_NAME) = .{};
};
pub const Border = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getBorderBrush(self: *@This()) core.HResult!*Brush {
        const this: *IBorder = @ptrCast(self);
        return try this.getBorderBrush();
    }
    pub fn putBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const this: *IBorder = @ptrCast(self);
        return try this.putBorderBrush(value);
    }
    pub fn getBorderThickness(self: *@This()) core.HResult!Thickness {
        const this: *IBorder = @ptrCast(self);
        return try this.getBorderThickness();
    }
    pub fn putBorderThickness(self: *@This(), value: Thickness) core.HResult!void {
        const this: *IBorder = @ptrCast(self);
        return try this.putBorderThickness(value);
    }
    pub fn getBackground(self: *@This()) core.HResult!*Brush {
        const this: *IBorder = @ptrCast(self);
        return try this.getBackground();
    }
    pub fn putBackground(self: *@This(), value: *Brush) core.HResult!void {
        const this: *IBorder = @ptrCast(self);
        return try this.putBackground(value);
    }
    pub fn getCornerRadius(self: *@This()) core.HResult!CornerRadius {
        const this: *IBorder = @ptrCast(self);
        return try this.getCornerRadius();
    }
    pub fn putCornerRadius(self: *@This(), value: CornerRadius) core.HResult!void {
        const this: *IBorder = @ptrCast(self);
        return try this.putCornerRadius(value);
    }
    pub fn getPadding(self: *@This()) core.HResult!Thickness {
        const this: *IBorder = @ptrCast(self);
        return try this.getPadding();
    }
    pub fn putPadding(self: *@This(), value: Thickness) core.HResult!void {
        const this: *IBorder = @ptrCast(self);
        return try this.putPadding(value);
    }
    pub fn getChild(self: *@This()) core.HResult!*UIElement {
        const this: *IBorder = @ptrCast(self);
        return try this.getChild();
    }
    pub fn putChild(self: *@This(), value: *UIElement) core.HResult!void {
        const this: *IBorder = @ptrCast(self);
        return try this.putChild(value);
    }
    pub fn getChildTransitions(self: *@This()) core.HResult!*TransitionCollection {
        const this: *IBorder = @ptrCast(self);
        return try this.getChildTransitions();
    }
    pub fn putChildTransitions(self: *@This(), value: *TransitionCollection) core.HResult!void {
        const this: *IBorder = @ptrCast(self);
        return try this.putChildTransitions(value);
    }
    pub fn getBackgroundSizing(self: *@This()) core.HResult!BackgroundSizing {
        var this: ?*IBorder2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IBorder2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getBackgroundSizing();
    }
    pub fn putBackgroundSizing(self: *@This(), value: BackgroundSizing) core.HResult!void {
        var this: ?*IBorder2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IBorder2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putBackgroundSizing(value);
    }
    pub fn getBackgroundTransition(self: *@This()) core.HResult!*BrushTransition {
        var this: ?*IBorder2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IBorder2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getBackgroundTransition();
    }
    pub fn putBackgroundTransition(self: *@This(), value: *BrushTransition) core.HResult!void {
        var this: ?*IBorder2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IBorder2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putBackgroundTransition(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IBorder.IID)));
    }
    pub fn getBackgroundSizingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IBorderStatics2Cache.get();
        return try _f.getBackgroundSizingProperty();
    }
    pub fn getBorderBrushProperty() core.HResult!*DependencyProperty {
        const _f = @This().IBorderStaticsCache.get();
        return try _f.getBorderBrushProperty();
    }
    pub fn getBorderThicknessProperty() core.HResult!*DependencyProperty {
        const _f = @This().IBorderStaticsCache.get();
        return try _f.getBorderThicknessProperty();
    }
    pub fn getBackgroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().IBorderStaticsCache.get();
        return try _f.getBackgroundProperty();
    }
    pub fn getCornerRadiusProperty() core.HResult!*DependencyProperty {
        const _f = @This().IBorderStaticsCache.get();
        return try _f.getCornerRadiusProperty();
    }
    pub fn getPaddingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IBorderStaticsCache.get();
        return try _f.getPaddingProperty();
    }
    pub fn getChildTransitionsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IBorderStaticsCache.get();
        return try _f.getChildTransitionsProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.Border";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IBorder.GUID;
    pub const IID: Guid = IBorder.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IBorder.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IBorderStatics2Cache: FactoryCache(IBorderStatics2, RUNTIME_NAME) = .{};
    var _IBorderStaticsCache: FactoryCache(IBorderStatics, RUNTIME_NAME) = .{};
};
pub const CalendarDatePicker = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getDate(self: *@This()) core.HResult!*IReference(DateTime) {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.getDate();
    }
    pub fn putDate(self: *@This(), value: *IReference(DateTime)) core.HResult!void {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.putDate(value);
    }
    pub fn getIsCalendarOpen(self: *@This()) core.HResult!bool {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.getIsCalendarOpen();
    }
    pub fn putIsCalendarOpen(self: *@This(), value: bool) core.HResult!void {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.putIsCalendarOpen(value);
    }
    pub fn getDateFormat(self: *@This()) core.HResult!HSTRING {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.getDateFormat();
    }
    pub fn putDateFormat(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.putDateFormat(value);
    }
    pub fn getPlaceholderText(self: *@This()) core.HResult!HSTRING {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.getPlaceholderText();
    }
    pub fn putPlaceholderText(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.putPlaceholderText(value);
    }
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.getHeader();
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.putHeader(value);
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.getHeaderTemplate();
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.putHeaderTemplate(value);
    }
    pub fn getCalendarViewStyle(self: *@This()) core.HResult!*Style {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.getCalendarViewStyle();
    }
    pub fn putCalendarViewStyle(self: *@This(), value: *Style) core.HResult!void {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.putCalendarViewStyle(value);
    }
    pub fn getMinDate(self: *@This()) core.HResult!DateTime {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.getMinDate();
    }
    pub fn putMinDate(self: *@This(), value: DateTime) core.HResult!void {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.putMinDate(value);
    }
    pub fn getMaxDate(self: *@This()) core.HResult!DateTime {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.getMaxDate();
    }
    pub fn putMaxDate(self: *@This(), value: DateTime) core.HResult!void {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.putMaxDate(value);
    }
    pub fn getIsTodayHighlighted(self: *@This()) core.HResult!bool {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.getIsTodayHighlighted();
    }
    pub fn putIsTodayHighlighted(self: *@This(), value: bool) core.HResult!void {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.putIsTodayHighlighted(value);
    }
    pub fn getDisplayMode(self: *@This()) core.HResult!CalendarViewDisplayMode {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.getDisplayMode();
    }
    pub fn putDisplayMode(self: *@This(), value: CalendarViewDisplayMode) core.HResult!void {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.putDisplayMode(value);
    }
    pub fn getFirstDayOfWeek(self: *@This()) core.HResult!DayOfWeek {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.getFirstDayOfWeek();
    }
    pub fn putFirstDayOfWeek(self: *@This(), value: DayOfWeek) core.HResult!void {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.putFirstDayOfWeek(value);
    }
    pub fn getDayOfWeekFormat(self: *@This()) core.HResult!HSTRING {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.getDayOfWeekFormat();
    }
    pub fn putDayOfWeekFormat(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.putDayOfWeekFormat(value);
    }
    pub fn getCalendarIdentifier(self: *@This()) core.HResult!HSTRING {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.getCalendarIdentifier();
    }
    pub fn putCalendarIdentifier(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.putCalendarIdentifier(value);
    }
    pub fn getIsOutOfScopeEnabled(self: *@This()) core.HResult!bool {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.getIsOutOfScopeEnabled();
    }
    pub fn putIsOutOfScopeEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.putIsOutOfScopeEnabled(value);
    }
    pub fn getIsGroupLabelVisible(self: *@This()) core.HResult!bool {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.getIsGroupLabelVisible();
    }
    pub fn putIsGroupLabelVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.putIsGroupLabelVisible(value);
    }
    pub fn addCalendarViewDayItemChanging(self: *@This(), handler: *CalendarViewDayItemChangingEventHandler) core.HResult!EventRegistrationToken {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.addCalendarViewDayItemChanging(handler);
    }
    pub fn removeCalendarViewDayItemChanging(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.removeCalendarViewDayItemChanging(token);
    }
    pub fn addDateChanged(self: *@This(), handler: *TypedEventHandler(CalendarDatePicker,CalendarDatePickerDateChangedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.addDateChanged(handler);
    }
    pub fn removeDateChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.removeDateChanged(token);
    }
    pub fn addOpened(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.addOpened(handler);
    }
    pub fn removeOpened(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.removeOpened(token);
    }
    pub fn addClosed(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.addClosed(handler);
    }
    pub fn removeClosed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.removeClosed(token);
    }
    pub fn SetDisplayDate(self: *@This(), date: DateTime) core.HResult!void {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.SetDisplayDate(date);
    }
    pub fn SetYearDecadeDisplayDimensions(self: *@This(), columns: i32, rows: i32) core.HResult!void {
        const this: *ICalendarDatePicker = @ptrCast(self);
        return try this.SetYearDecadeDisplayDimensions(columns, rows);
    }
    pub fn getLightDismissOverlayMode(self: *@This()) core.HResult!LightDismissOverlayMode {
        var this: ?*ICalendarDatePicker2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarDatePicker2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getLightDismissOverlayMode();
    }
    pub fn putLightDismissOverlayMode(self: *@This(), value: LightDismissOverlayMode) core.HResult!void {
        var this: ?*ICalendarDatePicker2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarDatePicker2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putLightDismissOverlayMode(value);
    }
    pub fn getDescription(self: *@This()) core.HResult!*IInspectable {
        var this: ?*ICalendarDatePicker3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarDatePicker3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDescription();
    }
    pub fn putDescription(self: *@This(), value: *IInspectable) core.HResult!void {
        var this: ?*ICalendarDatePicker3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarDatePicker3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putDescription(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getDateProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarDatePickerStaticsCache.get();
        return try _f.getDateProperty();
    }
    pub fn getIsCalendarOpenProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarDatePickerStaticsCache.get();
        return try _f.getIsCalendarOpenProperty();
    }
    pub fn getDateFormatProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarDatePickerStaticsCache.get();
        return try _f.getDateFormatProperty();
    }
    pub fn getPlaceholderTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarDatePickerStaticsCache.get();
        return try _f.getPlaceholderTextProperty();
    }
    pub fn getHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarDatePickerStaticsCache.get();
        return try _f.getHeaderProperty();
    }
    pub fn getHeaderTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarDatePickerStaticsCache.get();
        return try _f.getHeaderTemplateProperty();
    }
    pub fn getCalendarViewStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarDatePickerStaticsCache.get();
        return try _f.getCalendarViewStyleProperty();
    }
    pub fn getMinDateProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarDatePickerStaticsCache.get();
        return try _f.getMinDateProperty();
    }
    pub fn getMaxDateProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarDatePickerStaticsCache.get();
        return try _f.getMaxDateProperty();
    }
    pub fn getIsTodayHighlightedProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarDatePickerStaticsCache.get();
        return try _f.getIsTodayHighlightedProperty();
    }
    pub fn getDisplayModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarDatePickerStaticsCache.get();
        return try _f.getDisplayModeProperty();
    }
    pub fn getFirstDayOfWeekProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarDatePickerStaticsCache.get();
        return try _f.getFirstDayOfWeekProperty();
    }
    pub fn getDayOfWeekFormatProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarDatePickerStaticsCache.get();
        return try _f.getDayOfWeekFormatProperty();
    }
    pub fn getCalendarIdentifierProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarDatePickerStaticsCache.get();
        return try _f.getCalendarIdentifierProperty();
    }
    pub fn getIsOutOfScopeEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarDatePickerStaticsCache.get();
        return try _f.getIsOutOfScopeEnabledProperty();
    }
    pub fn getIsGroupLabelVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarDatePickerStaticsCache.get();
        return try _f.getIsGroupLabelVisibleProperty();
    }
    pub fn getDescriptionProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarDatePickerStatics3Cache.get();
        return try _f.getDescriptionProperty();
    }
    pub fn getLightDismissOverlayModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarDatePickerStatics2Cache.get();
        return try _f.getLightDismissOverlayModeProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*CalendarDatePicker {
        const _f = @This().ICalendarDatePickerFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.CalendarDatePicker";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ICalendarDatePicker.GUID;
    pub const IID: Guid = ICalendarDatePicker.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ICalendarDatePicker.SIGNATURE);
    var _ICalendarDatePickerStaticsCache: FactoryCache(ICalendarDatePickerStatics, RUNTIME_NAME) = .{};
    var _ICalendarDatePickerStatics3Cache: FactoryCache(ICalendarDatePickerStatics3, RUNTIME_NAME) = .{};
    var _ICalendarDatePickerStatics2Cache: FactoryCache(ICalendarDatePickerStatics2, RUNTIME_NAME) = .{};
    var _ICalendarDatePickerFactoryCache: FactoryCache(ICalendarDatePickerFactory, RUNTIME_NAME) = .{};
};
pub const CalendarDatePickerDateChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getNewDate(self: *@This()) core.HResult!*IReference(DateTime) {
        const this: *ICalendarDatePickerDateChangedEventArgs = @ptrCast(self);
        return try this.getNewDate();
    }
    pub fn getOldDate(self: *@This()) core.HResult!*IReference(DateTime) {
        const this: *ICalendarDatePickerDateChangedEventArgs = @ptrCast(self);
        return try this.getOldDate();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.CalendarDatePickerDateChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ICalendarDatePickerDateChangedEventArgs.GUID;
    pub const IID: Guid = ICalendarDatePickerDateChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ICalendarDatePickerDateChangedEventArgs.SIGNATURE);
};
pub const CalendarView = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getCalendarIdentifier(self: *@This()) core.HResult!HSTRING {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getCalendarIdentifier();
    }
    pub fn putCalendarIdentifier(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putCalendarIdentifier(value);
    }
    pub fn getDayOfWeekFormat(self: *@This()) core.HResult!HSTRING {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getDayOfWeekFormat();
    }
    pub fn putDayOfWeekFormat(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putDayOfWeekFormat(value);
    }
    pub fn getIsGroupLabelVisible(self: *@This()) core.HResult!bool {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getIsGroupLabelVisible();
    }
    pub fn putIsGroupLabelVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putIsGroupLabelVisible(value);
    }
    pub fn getDisplayMode(self: *@This()) core.HResult!CalendarViewDisplayMode {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getDisplayMode();
    }
    pub fn putDisplayMode(self: *@This(), value: CalendarViewDisplayMode) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putDisplayMode(value);
    }
    pub fn getFirstDayOfWeek(self: *@This()) core.HResult!DayOfWeek {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getFirstDayOfWeek();
    }
    pub fn putFirstDayOfWeek(self: *@This(), value: DayOfWeek) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putFirstDayOfWeek(value);
    }
    pub fn getIsOutOfScopeEnabled(self: *@This()) core.HResult!bool {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getIsOutOfScopeEnabled();
    }
    pub fn putIsOutOfScopeEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putIsOutOfScopeEnabled(value);
    }
    pub fn getIsTodayHighlighted(self: *@This()) core.HResult!bool {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getIsTodayHighlighted();
    }
    pub fn putIsTodayHighlighted(self: *@This(), value: bool) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putIsTodayHighlighted(value);
    }
    pub fn getMaxDate(self: *@This()) core.HResult!DateTime {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getMaxDate();
    }
    pub fn putMaxDate(self: *@This(), value: DateTime) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putMaxDate(value);
    }
    pub fn getMinDate(self: *@This()) core.HResult!DateTime {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getMinDate();
    }
    pub fn putMinDate(self: *@This(), value: DateTime) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putMinDate(value);
    }
    pub fn getNumberOfWeeksInView(self: *@This()) core.HResult!i32 {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getNumberOfWeeksInView();
    }
    pub fn putNumberOfWeeksInView(self: *@This(), value: i32) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putNumberOfWeeksInView(value);
    }
    pub fn getSelectedDates(self: *@This()) core.HResult!*IVector(DateTime) {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getSelectedDates();
    }
    pub fn getSelectionMode(self: *@This()) core.HResult!CalendarViewSelectionMode {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getSelectionMode();
    }
    pub fn putSelectionMode(self: *@This(), value: CalendarViewSelectionMode) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putSelectionMode(value);
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*CalendarViewTemplateSettings {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getTemplateSettings();
    }
    pub fn getFocusBorderBrush(self: *@This()) core.HResult!*Brush {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getFocusBorderBrush();
    }
    pub fn putFocusBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putFocusBorderBrush(value);
    }
    pub fn getSelectedHoverBorderBrush(self: *@This()) core.HResult!*Brush {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getSelectedHoverBorderBrush();
    }
    pub fn putSelectedHoverBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putSelectedHoverBorderBrush(value);
    }
    pub fn getSelectedPressedBorderBrush(self: *@This()) core.HResult!*Brush {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getSelectedPressedBorderBrush();
    }
    pub fn putSelectedPressedBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putSelectedPressedBorderBrush(value);
    }
    pub fn getSelectedBorderBrush(self: *@This()) core.HResult!*Brush {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getSelectedBorderBrush();
    }
    pub fn putSelectedBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putSelectedBorderBrush(value);
    }
    pub fn getHoverBorderBrush(self: *@This()) core.HResult!*Brush {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getHoverBorderBrush();
    }
    pub fn putHoverBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putHoverBorderBrush(value);
    }
    pub fn getPressedBorderBrush(self: *@This()) core.HResult!*Brush {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getPressedBorderBrush();
    }
    pub fn putPressedBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putPressedBorderBrush(value);
    }
    pub fn getCalendarItemBorderBrush(self: *@This()) core.HResult!*Brush {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getCalendarItemBorderBrush();
    }
    pub fn putCalendarItemBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putCalendarItemBorderBrush(value);
    }
    pub fn getOutOfScopeBackground(self: *@This()) core.HResult!*Brush {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getOutOfScopeBackground();
    }
    pub fn putOutOfScopeBackground(self: *@This(), value: *Brush) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putOutOfScopeBackground(value);
    }
    pub fn getCalendarItemBackground(self: *@This()) core.HResult!*Brush {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getCalendarItemBackground();
    }
    pub fn putCalendarItemBackground(self: *@This(), value: *Brush) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putCalendarItemBackground(value);
    }
    pub fn getPressedForeground(self: *@This()) core.HResult!*Brush {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getPressedForeground();
    }
    pub fn putPressedForeground(self: *@This(), value: *Brush) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putPressedForeground(value);
    }
    pub fn getTodayForeground(self: *@This()) core.HResult!*Brush {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getTodayForeground();
    }
    pub fn putTodayForeground(self: *@This(), value: *Brush) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putTodayForeground(value);
    }
    pub fn getBlackoutForeground(self: *@This()) core.HResult!*Brush {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getBlackoutForeground();
    }
    pub fn putBlackoutForeground(self: *@This(), value: *Brush) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putBlackoutForeground(value);
    }
    pub fn getSelectedForeground(self: *@This()) core.HResult!*Brush {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getSelectedForeground();
    }
    pub fn putSelectedForeground(self: *@This(), value: *Brush) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putSelectedForeground(value);
    }
    pub fn getOutOfScopeForeground(self: *@This()) core.HResult!*Brush {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getOutOfScopeForeground();
    }
    pub fn putOutOfScopeForeground(self: *@This(), value: *Brush) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putOutOfScopeForeground(value);
    }
    pub fn getCalendarItemForeground(self: *@This()) core.HResult!*Brush {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getCalendarItemForeground();
    }
    pub fn putCalendarItemForeground(self: *@This(), value: *Brush) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putCalendarItemForeground(value);
    }
    pub fn getDayItemFontFamily(self: *@This()) core.HResult!*FontFamily {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getDayItemFontFamily();
    }
    pub fn putDayItemFontFamily(self: *@This(), value: *FontFamily) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putDayItemFontFamily(value);
    }
    pub fn getDayItemFontSize(self: *@This()) core.HResult!f64 {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getDayItemFontSize();
    }
    pub fn putDayItemFontSize(self: *@This(), value: f64) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putDayItemFontSize(value);
    }
    pub fn getDayItemFontStyle(self: *@This()) core.HResult!FontStyle {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getDayItemFontStyle();
    }
    pub fn putDayItemFontStyle(self: *@This(), value: FontStyle) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putDayItemFontStyle(value);
    }
    pub fn getDayItemFontWeight(self: *@This()) core.HResult!FontWeight {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getDayItemFontWeight();
    }
    pub fn putDayItemFontWeight(self: *@This(), value: FontWeight) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putDayItemFontWeight(value);
    }
    pub fn getTodayFontWeight(self: *@This()) core.HResult!FontWeight {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getTodayFontWeight();
    }
    pub fn putTodayFontWeight(self: *@This(), value: FontWeight) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putTodayFontWeight(value);
    }
    pub fn getFirstOfMonthLabelFontFamily(self: *@This()) core.HResult!*FontFamily {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getFirstOfMonthLabelFontFamily();
    }
    pub fn putFirstOfMonthLabelFontFamily(self: *@This(), value: *FontFamily) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putFirstOfMonthLabelFontFamily(value);
    }
    pub fn getFirstOfMonthLabelFontSize(self: *@This()) core.HResult!f64 {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getFirstOfMonthLabelFontSize();
    }
    pub fn putFirstOfMonthLabelFontSize(self: *@This(), value: f64) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putFirstOfMonthLabelFontSize(value);
    }
    pub fn getFirstOfMonthLabelFontStyle(self: *@This()) core.HResult!FontStyle {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getFirstOfMonthLabelFontStyle();
    }
    pub fn putFirstOfMonthLabelFontStyle(self: *@This(), value: FontStyle) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putFirstOfMonthLabelFontStyle(value);
    }
    pub fn getFirstOfMonthLabelFontWeight(self: *@This()) core.HResult!FontWeight {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getFirstOfMonthLabelFontWeight();
    }
    pub fn putFirstOfMonthLabelFontWeight(self: *@This(), value: FontWeight) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putFirstOfMonthLabelFontWeight(value);
    }
    pub fn getMonthYearItemFontFamily(self: *@This()) core.HResult!*FontFamily {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getMonthYearItemFontFamily();
    }
    pub fn putMonthYearItemFontFamily(self: *@This(), value: *FontFamily) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putMonthYearItemFontFamily(value);
    }
    pub fn getMonthYearItemFontSize(self: *@This()) core.HResult!f64 {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getMonthYearItemFontSize();
    }
    pub fn putMonthYearItemFontSize(self: *@This(), value: f64) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putMonthYearItemFontSize(value);
    }
    pub fn getMonthYearItemFontStyle(self: *@This()) core.HResult!FontStyle {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getMonthYearItemFontStyle();
    }
    pub fn putMonthYearItemFontStyle(self: *@This(), value: FontStyle) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putMonthYearItemFontStyle(value);
    }
    pub fn getMonthYearItemFontWeight(self: *@This()) core.HResult!FontWeight {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getMonthYearItemFontWeight();
    }
    pub fn putMonthYearItemFontWeight(self: *@This(), value: FontWeight) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putMonthYearItemFontWeight(value);
    }
    pub fn getFirstOfYearDecadeLabelFontFamily(self: *@This()) core.HResult!*FontFamily {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getFirstOfYearDecadeLabelFontFamily();
    }
    pub fn putFirstOfYearDecadeLabelFontFamily(self: *@This(), value: *FontFamily) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putFirstOfYearDecadeLabelFontFamily(value);
    }
    pub fn getFirstOfYearDecadeLabelFontSize(self: *@This()) core.HResult!f64 {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getFirstOfYearDecadeLabelFontSize();
    }
    pub fn putFirstOfYearDecadeLabelFontSize(self: *@This(), value: f64) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putFirstOfYearDecadeLabelFontSize(value);
    }
    pub fn getFirstOfYearDecadeLabelFontStyle(self: *@This()) core.HResult!FontStyle {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getFirstOfYearDecadeLabelFontStyle();
    }
    pub fn putFirstOfYearDecadeLabelFontStyle(self: *@This(), value: FontStyle) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putFirstOfYearDecadeLabelFontStyle(value);
    }
    pub fn getFirstOfYearDecadeLabelFontWeight(self: *@This()) core.HResult!FontWeight {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getFirstOfYearDecadeLabelFontWeight();
    }
    pub fn putFirstOfYearDecadeLabelFontWeight(self: *@This(), value: FontWeight) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putFirstOfYearDecadeLabelFontWeight(value);
    }
    pub fn getHorizontalDayItemAlignment(self: *@This()) core.HResult!HorizontalAlignment {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getHorizontalDayItemAlignment();
    }
    pub fn putHorizontalDayItemAlignment(self: *@This(), value: HorizontalAlignment) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putHorizontalDayItemAlignment(value);
    }
    pub fn getVerticalDayItemAlignment(self: *@This()) core.HResult!VerticalAlignment {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getVerticalDayItemAlignment();
    }
    pub fn putVerticalDayItemAlignment(self: *@This(), value: VerticalAlignment) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putVerticalDayItemAlignment(value);
    }
    pub fn getHorizontalFirstOfMonthLabelAlignment(self: *@This()) core.HResult!HorizontalAlignment {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getHorizontalFirstOfMonthLabelAlignment();
    }
    pub fn putHorizontalFirstOfMonthLabelAlignment(self: *@This(), value: HorizontalAlignment) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putHorizontalFirstOfMonthLabelAlignment(value);
    }
    pub fn getVerticalFirstOfMonthLabelAlignment(self: *@This()) core.HResult!VerticalAlignment {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getVerticalFirstOfMonthLabelAlignment();
    }
    pub fn putVerticalFirstOfMonthLabelAlignment(self: *@This(), value: VerticalAlignment) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putVerticalFirstOfMonthLabelAlignment(value);
    }
    pub fn getCalendarItemBorderThickness(self: *@This()) core.HResult!Thickness {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getCalendarItemBorderThickness();
    }
    pub fn putCalendarItemBorderThickness(self: *@This(), value: Thickness) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putCalendarItemBorderThickness(value);
    }
    pub fn getCalendarViewDayItemStyle(self: *@This()) core.HResult!*Style {
        const this: *ICalendarView = @ptrCast(self);
        return try this.getCalendarViewDayItemStyle();
    }
    pub fn putCalendarViewDayItemStyle(self: *@This(), value: *Style) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.putCalendarViewDayItemStyle(value);
    }
    pub fn addCalendarViewDayItemChanging(self: *@This(), handler: *TypedEventHandler(CalendarView,CalendarViewDayItemChangingEventArgs)) core.HResult!EventRegistrationToken {
        const this: *ICalendarView = @ptrCast(self);
        return try this.addCalendarViewDayItemChanging(handler);
    }
    pub fn removeCalendarViewDayItemChanging(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.removeCalendarViewDayItemChanging(token);
    }
    pub fn addSelectedDatesChanged(self: *@This(), handler: *TypedEventHandler(CalendarView,CalendarViewSelectedDatesChangedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *ICalendarView = @ptrCast(self);
        return try this.addSelectedDatesChanged(handler);
    }
    pub fn removeSelectedDatesChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.removeSelectedDatesChanged(token);
    }
    pub fn SetDisplayDate(self: *@This(), date: DateTime) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.SetDisplayDate(date);
    }
    pub fn SetYearDecadeDisplayDimensions(self: *@This(), columns: i32, rows: i32) core.HResult!void {
        const this: *ICalendarView = @ptrCast(self);
        return try this.SetYearDecadeDisplayDimensions(columns, rows);
    }
    pub fn getSelectedDisabledBorderBrush(self: *@This()) core.HResult!*Brush {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectedDisabledBorderBrush();
    }
    pub fn putSelectedDisabledBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSelectedDisabledBorderBrush(value);
    }
    pub fn getTodaySelectedInnerBorderBrush(self: *@This()) core.HResult!*Brush {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTodaySelectedInnerBorderBrush();
    }
    pub fn putTodaySelectedInnerBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTodaySelectedInnerBorderBrush(value);
    }
    pub fn getBlackoutStrikethroughBrush(self: *@This()) core.HResult!*Brush {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getBlackoutStrikethroughBrush();
    }
    pub fn putBlackoutStrikethroughBrush(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putBlackoutStrikethroughBrush(value);
    }
    pub fn getBlackoutBackground(self: *@This()) core.HResult!*Brush {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getBlackoutBackground();
    }
    pub fn putBlackoutBackground(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putBlackoutBackground(value);
    }
    pub fn getCalendarItemHoverBackground(self: *@This()) core.HResult!*Brush {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCalendarItemHoverBackground();
    }
    pub fn putCalendarItemHoverBackground(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putCalendarItemHoverBackground(value);
    }
    pub fn getCalendarItemPressedBackground(self: *@This()) core.HResult!*Brush {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCalendarItemPressedBackground();
    }
    pub fn putCalendarItemPressedBackground(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putCalendarItemPressedBackground(value);
    }
    pub fn getCalendarItemDisabledBackground(self: *@This()) core.HResult!*Brush {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCalendarItemDisabledBackground();
    }
    pub fn putCalendarItemDisabledBackground(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putCalendarItemDisabledBackground(value);
    }
    pub fn getTodayBackground(self: *@This()) core.HResult!*Brush {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTodayBackground();
    }
    pub fn putTodayBackground(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTodayBackground(value);
    }
    pub fn getTodayBlackoutBackground(self: *@This()) core.HResult!*Brush {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTodayBlackoutBackground();
    }
    pub fn putTodayBlackoutBackground(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTodayBlackoutBackground(value);
    }
    pub fn getTodayHoverBackground(self: *@This()) core.HResult!*Brush {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTodayHoverBackground();
    }
    pub fn putTodayHoverBackground(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTodayHoverBackground(value);
    }
    pub fn getTodayPressedBackground(self: *@This()) core.HResult!*Brush {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTodayPressedBackground();
    }
    pub fn putTodayPressedBackground(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTodayPressedBackground(value);
    }
    pub fn getTodayDisabledBackground(self: *@This()) core.HResult!*Brush {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTodayDisabledBackground();
    }
    pub fn putTodayDisabledBackground(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTodayDisabledBackground(value);
    }
    pub fn getTodayBlackoutForeground(self: *@This()) core.HResult!*Brush {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTodayBlackoutForeground();
    }
    pub fn putTodayBlackoutForeground(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTodayBlackoutForeground(value);
    }
    pub fn getSelectedHoverForeground(self: *@This()) core.HResult!*Brush {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectedHoverForeground();
    }
    pub fn putSelectedHoverForeground(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSelectedHoverForeground(value);
    }
    pub fn getSelectedPressedForeground(self: *@This()) core.HResult!*Brush {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectedPressedForeground();
    }
    pub fn putSelectedPressedForeground(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSelectedPressedForeground(value);
    }
    pub fn getSelectedDisabledForeground(self: *@This()) core.HResult!*Brush {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectedDisabledForeground();
    }
    pub fn putSelectedDisabledForeground(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSelectedDisabledForeground(value);
    }
    pub fn getOutOfScopeHoverForeground(self: *@This()) core.HResult!*Brush {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getOutOfScopeHoverForeground();
    }
    pub fn putOutOfScopeHoverForeground(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putOutOfScopeHoverForeground(value);
    }
    pub fn getOutOfScopePressedForeground(self: *@This()) core.HResult!*Brush {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getOutOfScopePressedForeground();
    }
    pub fn putOutOfScopePressedForeground(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putOutOfScopePressedForeground(value);
    }
    pub fn getDisabledForeground(self: *@This()) core.HResult!*Brush {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDisabledForeground();
    }
    pub fn putDisabledForeground(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putDisabledForeground(value);
    }
    pub fn getDayItemMargin(self: *@This()) core.HResult!Thickness {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDayItemMargin();
    }
    pub fn putDayItemMargin(self: *@This(), value: Thickness) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putDayItemMargin(value);
    }
    pub fn getMonthYearItemMargin(self: *@This()) core.HResult!Thickness {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getMonthYearItemMargin();
    }
    pub fn putMonthYearItemMargin(self: *@This(), value: Thickness) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putMonthYearItemMargin(value);
    }
    pub fn getFirstOfMonthLabelMargin(self: *@This()) core.HResult!Thickness {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getFirstOfMonthLabelMargin();
    }
    pub fn putFirstOfMonthLabelMargin(self: *@This(), value: Thickness) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putFirstOfMonthLabelMargin(value);
    }
    pub fn getFirstOfYearDecadeLabelMargin(self: *@This()) core.HResult!Thickness {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getFirstOfYearDecadeLabelMargin();
    }
    pub fn putFirstOfYearDecadeLabelMargin(self: *@This(), value: Thickness) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putFirstOfYearDecadeLabelMargin(value);
    }
    pub fn getCalendarItemCornerRadius(self: *@This()) core.HResult!CornerRadius {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCalendarItemCornerRadius();
    }
    pub fn putCalendarItemCornerRadius(self: *@This(), value: CornerRadius) core.HResult!void {
        var this: ?*ICalendarView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICalendarView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putCalendarItemCornerRadius(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getSelectedDisabledBorderBrushProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getSelectedDisabledBorderBrushProperty();
    }
    pub fn getTodaySelectedInnerBorderBrushProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getTodaySelectedInnerBorderBrushProperty();
    }
    pub fn getBlackoutStrikethroughBrushProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getBlackoutStrikethroughBrushProperty();
    }
    pub fn getBlackoutBackgroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getBlackoutBackgroundProperty();
    }
    pub fn getCalendarItemHoverBackgroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getCalendarItemHoverBackgroundProperty();
    }
    pub fn getCalendarItemPressedBackgroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getCalendarItemPressedBackgroundProperty();
    }
    pub fn getCalendarItemDisabledBackgroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getCalendarItemDisabledBackgroundProperty();
    }
    pub fn getTodayBackgroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getTodayBackgroundProperty();
    }
    pub fn getTodayBlackoutBackgroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getTodayBlackoutBackgroundProperty();
    }
    pub fn getTodayHoverBackgroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getTodayHoverBackgroundProperty();
    }
    pub fn getTodayPressedBackgroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getTodayPressedBackgroundProperty();
    }
    pub fn getTodayDisabledBackgroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getTodayDisabledBackgroundProperty();
    }
    pub fn getTodayBlackoutForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getTodayBlackoutForegroundProperty();
    }
    pub fn getSelectedHoverForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getSelectedHoverForegroundProperty();
    }
    pub fn getSelectedPressedForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getSelectedPressedForegroundProperty();
    }
    pub fn getSelectedDisabledForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getSelectedDisabledForegroundProperty();
    }
    pub fn getOutOfScopeHoverForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getOutOfScopeHoverForegroundProperty();
    }
    pub fn getOutOfScopePressedForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getOutOfScopePressedForegroundProperty();
    }
    pub fn getDisabledForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getDisabledForegroundProperty();
    }
    pub fn getDayItemMarginProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getDayItemMarginProperty();
    }
    pub fn getMonthYearItemMarginProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getMonthYearItemMarginProperty();
    }
    pub fn getFirstOfMonthLabelMarginProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getFirstOfMonthLabelMarginProperty();
    }
    pub fn getFirstOfYearDecadeLabelMarginProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getFirstOfYearDecadeLabelMarginProperty();
    }
    pub fn getCalendarItemCornerRadiusProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStatics2Cache.get();
        return try _f.getCalendarItemCornerRadiusProperty();
    }
    pub fn getCalendarIdentifierProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getCalendarIdentifierProperty();
    }
    pub fn getDayOfWeekFormatProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getDayOfWeekFormatProperty();
    }
    pub fn getIsGroupLabelVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getIsGroupLabelVisibleProperty();
    }
    pub fn getDisplayModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getDisplayModeProperty();
    }
    pub fn getFirstDayOfWeekProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getFirstDayOfWeekProperty();
    }
    pub fn getIsOutOfScopeEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getIsOutOfScopeEnabledProperty();
    }
    pub fn getIsTodayHighlightedProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getIsTodayHighlightedProperty();
    }
    pub fn getMaxDateProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getMaxDateProperty();
    }
    pub fn getMinDateProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getMinDateProperty();
    }
    pub fn getNumberOfWeeksInViewProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getNumberOfWeeksInViewProperty();
    }
    pub fn getSelectedDatesProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getSelectedDatesProperty();
    }
    pub fn getSelectionModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getSelectionModeProperty();
    }
    pub fn getTemplateSettingsProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getTemplateSettingsProperty();
    }
    pub fn getFocusBorderBrushProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getFocusBorderBrushProperty();
    }
    pub fn getSelectedHoverBorderBrushProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getSelectedHoverBorderBrushProperty();
    }
    pub fn getSelectedPressedBorderBrushProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getSelectedPressedBorderBrushProperty();
    }
    pub fn getSelectedBorderBrushProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getSelectedBorderBrushProperty();
    }
    pub fn getHoverBorderBrushProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getHoverBorderBrushProperty();
    }
    pub fn getPressedBorderBrushProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getPressedBorderBrushProperty();
    }
    pub fn getCalendarItemBorderBrushProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getCalendarItemBorderBrushProperty();
    }
    pub fn getOutOfScopeBackgroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getOutOfScopeBackgroundProperty();
    }
    pub fn getCalendarItemBackgroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getCalendarItemBackgroundProperty();
    }
    pub fn getPressedForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getPressedForegroundProperty();
    }
    pub fn getTodayForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getTodayForegroundProperty();
    }
    pub fn getBlackoutForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getBlackoutForegroundProperty();
    }
    pub fn getSelectedForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getSelectedForegroundProperty();
    }
    pub fn getOutOfScopeForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getOutOfScopeForegroundProperty();
    }
    pub fn getCalendarItemForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getCalendarItemForegroundProperty();
    }
    pub fn getDayItemFontFamilyProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getDayItemFontFamilyProperty();
    }
    pub fn getDayItemFontSizeProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getDayItemFontSizeProperty();
    }
    pub fn getDayItemFontStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getDayItemFontStyleProperty();
    }
    pub fn getDayItemFontWeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getDayItemFontWeightProperty();
    }
    pub fn getTodayFontWeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getTodayFontWeightProperty();
    }
    pub fn getFirstOfMonthLabelFontFamilyProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getFirstOfMonthLabelFontFamilyProperty();
    }
    pub fn getFirstOfMonthLabelFontSizeProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getFirstOfMonthLabelFontSizeProperty();
    }
    pub fn getFirstOfMonthLabelFontStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getFirstOfMonthLabelFontStyleProperty();
    }
    pub fn getFirstOfMonthLabelFontWeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getFirstOfMonthLabelFontWeightProperty();
    }
    pub fn getMonthYearItemFontFamilyProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getMonthYearItemFontFamilyProperty();
    }
    pub fn getMonthYearItemFontSizeProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getMonthYearItemFontSizeProperty();
    }
    pub fn getMonthYearItemFontStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getMonthYearItemFontStyleProperty();
    }
    pub fn getMonthYearItemFontWeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getMonthYearItemFontWeightProperty();
    }
    pub fn getFirstOfYearDecadeLabelFontFamilyProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getFirstOfYearDecadeLabelFontFamilyProperty();
    }
    pub fn getFirstOfYearDecadeLabelFontSizeProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getFirstOfYearDecadeLabelFontSizeProperty();
    }
    pub fn getFirstOfYearDecadeLabelFontStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getFirstOfYearDecadeLabelFontStyleProperty();
    }
    pub fn getFirstOfYearDecadeLabelFontWeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getFirstOfYearDecadeLabelFontWeightProperty();
    }
    pub fn getHorizontalDayItemAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getHorizontalDayItemAlignmentProperty();
    }
    pub fn getVerticalDayItemAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getVerticalDayItemAlignmentProperty();
    }
    pub fn getHorizontalFirstOfMonthLabelAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getHorizontalFirstOfMonthLabelAlignmentProperty();
    }
    pub fn getVerticalFirstOfMonthLabelAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getVerticalFirstOfMonthLabelAlignmentProperty();
    }
    pub fn getCalendarItemBorderThicknessProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getCalendarItemBorderThicknessProperty();
    }
    pub fn getCalendarViewDayItemStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewStaticsCache.get();
        return try _f.getCalendarViewDayItemStyleProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*CalendarView {
        const _f = @This().ICalendarViewFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.CalendarView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ICalendarView.GUID;
    pub const IID: Guid = ICalendarView.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ICalendarView.SIGNATURE);
    var _ICalendarViewStatics2Cache: FactoryCache(ICalendarViewStatics2, RUNTIME_NAME) = .{};
    var _ICalendarViewStaticsCache: FactoryCache(ICalendarViewStatics, RUNTIME_NAME) = .{};
    var _ICalendarViewFactoryCache: FactoryCache(ICalendarViewFactory, RUNTIME_NAME) = .{};
};
pub const CalendarViewDayItem = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsBlackout(self: *@This()) core.HResult!bool {
        const this: *ICalendarViewDayItem = @ptrCast(self);
        return try this.getIsBlackout();
    }
    pub fn putIsBlackout(self: *@This(), value: bool) core.HResult!void {
        const this: *ICalendarViewDayItem = @ptrCast(self);
        return try this.putIsBlackout(value);
    }
    pub fn getDate(self: *@This()) core.HResult!DateTime {
        const this: *ICalendarViewDayItem = @ptrCast(self);
        return try this.getDate();
    }
    pub fn SetDensityColors(self: *@This(), colors: *IIterable(Color)) core.HResult!void {
        const this: *ICalendarViewDayItem = @ptrCast(self);
        return try this.SetDensityColors(colors);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getIsBlackoutProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewDayItemStaticsCache.get();
        return try _f.getIsBlackoutProperty();
    }
    pub fn getDateProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICalendarViewDayItemStaticsCache.get();
        return try _f.getDateProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*CalendarViewDayItem {
        const _f = @This().ICalendarViewDayItemFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.CalendarViewDayItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ICalendarViewDayItem.GUID;
    pub const IID: Guid = ICalendarViewDayItem.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ICalendarViewDayItem.SIGNATURE);
    var _ICalendarViewDayItemStaticsCache: FactoryCache(ICalendarViewDayItemStatics, RUNTIME_NAME) = .{};
    var _ICalendarViewDayItemFactoryCache: FactoryCache(ICalendarViewDayItemFactory, RUNTIME_NAME) = .{};
};
pub const CalendarViewDayItemChangingEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getInRecycleQueue(self: *@This()) core.HResult!bool {
        const this: *ICalendarViewDayItemChangingEventArgs = @ptrCast(self);
        return try this.getInRecycleQueue();
    }
    pub fn getItem(self: *@This()) core.HResult!*CalendarViewDayItem {
        const this: *ICalendarViewDayItemChangingEventArgs = @ptrCast(self);
        return try this.getItem();
    }
    pub fn getPhase(self: *@This()) core.HResult!u32 {
        const this: *ICalendarViewDayItemChangingEventArgs = @ptrCast(self);
        return try this.getPhase();
    }
    pub fn RegisterUpdateCallback(self: *@This(), callback: *TypedEventHandler(CalendarView,CalendarViewDayItemChangingEventArgs)) core.HResult!void {
        const this: *ICalendarViewDayItemChangingEventArgs = @ptrCast(self);
        return try this.RegisterUpdateCallback(callback);
    }
    pub fn RegisterUpdateCallbackWithCallbackPhaseAndCallback(self: *@This(), callbackPhase: u32, callback: *TypedEventHandler(CalendarView,CalendarViewDayItemChangingEventArgs)) core.HResult!void {
        const this: *ICalendarViewDayItemChangingEventArgs = @ptrCast(self);
        return try this.RegisterUpdateCallbackWithCallbackPhaseAndCallback(callbackPhase, callback);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.CalendarViewDayItemChangingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ICalendarViewDayItemChangingEventArgs.GUID;
    pub const IID: Guid = ICalendarViewDayItemChangingEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ICalendarViewDayItemChangingEventArgs.SIGNATURE);
};
pub const CalendarViewDayItemChangingEventHandler = extern struct {
    vtable: *const VTable,
    _refs: @import("std").atomic.Value(u32),
    _cb: *const fn (context: ?*anyopaque) callconv(.winapi) void,
    _context: ?*anyopaque = null,
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn init(
        cb: *const fn(?*anyopaque, sender: *CalendarView, e: *CalendarViewDayItemChangingEventArgs) callconv(.winapi) void,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
        };
        return _r;
    }
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn initWithState(
        cb: *const fn(?*anyopaque, sender: *CalendarView, e: *CalendarViewDayItemChangingEventArgs) callconv(.winapi) void,
        context: anytype,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
            ._context = @ptrCast(context),
        };
        return _r;
    }
    /// This calls Release and voids the returned ref count. If ref count is 0 the memory is released,
    /// Otherwise the memory stays until all references are released, including all references Windows holds.
    ///
    /// The caller *MUST* always call deinit/Release at least once for every AddRef and init called.
    pub fn deinit(self: *@This()) void {
        _ = Release(@ptrCast(self));
    }
    fn QueryInterface(self: *anyopaque, riid: *const Guid, out: *?*anyopaque) callconv(.c) HRESULT {
        const me: *@This() = @ptrCast(@alignCast(self));
        // TODO: Handle IMarshal
        if (core.wiredGuidEql(riid, &IID) or
            core.wiredGuidEql(riid, &IUnknown.IID) or
            core.wiredGuidEql(riid, &IAgileObject.IID))
        {
            out.* = @as(?*anyopaque, @ptrCast(me));
            _ = AddRef(self);
            return 0;
        }
        out.* = null;
        return -2147467262; // E_NOINTERFACE
    }
    fn AddRef(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        return this._refs.fetchAdd(1, .monotonic) + 1;
    }
    fn Release(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        const left = this._refs.fetchSub(1, .acq_rel) - 1;
        if (left == 0) @import("std").heap.c_allocator.destroy(this);
        return left;
    }
    pub fn Invoke(self: *anyopaque, sender: *CalendarView, e: *CalendarViewDayItemChangingEventArgs) callconv(.winapi) HRESULT {
        const this: *@This() = @ptrCast(@alignCast(self));
        this._cb(this._context, sender, e);
        return 0;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.CalendarViewDayItemChangingEventHandler";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8d745891-4de3-49cb-974b-083871a3afe6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.pinterface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        Invoke: *const fn(self: *anyopaque, sender: *CalendarView, e: *CalendarViewDayItemChangingEventArgs) callconv(.winapi) HRESULT
    };
    pub const VTABLE = VTable {
        .QueryInterface = QueryInterface,
        .AddRef = AddRef,
        .Release = Release,
        .Invoke = Invoke,
    };
};
pub const CalendarViewDisplayMode = enum(i32) {
    Month = 0,
    Year = 1,
    Decade = 2,
};
pub const CalendarViewSelectedDatesChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getAddedDates(self: *@This()) core.HResult!*IVectorView(DateTime) {
        const this: *ICalendarViewSelectedDatesChangedEventArgs = @ptrCast(self);
        return try this.getAddedDates();
    }
    pub fn getRemovedDates(self: *@This()) core.HResult!*IVectorView(DateTime) {
        const this: *ICalendarViewSelectedDatesChangedEventArgs = @ptrCast(self);
        return try this.getRemovedDates();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.CalendarViewSelectedDatesChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ICalendarViewSelectedDatesChangedEventArgs.GUID;
    pub const IID: Guid = ICalendarViewSelectedDatesChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ICalendarViewSelectedDatesChangedEventArgs.SIGNATURE);
};
pub const CalendarViewSelectionMode = enum(i32) {
    None = 0,
    Single = 1,
    Multiple = 2,
};
pub const CandidateWindowAlignment = enum(i32) {
    Default = 0,
    BottomEdge = 1,
};
pub const CandidateWindowBoundsChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getBounds(self: *@This()) core.HResult!Rect {
        const this: *ICandidateWindowBoundsChangedEventArgs = @ptrCast(self);
        return try this.getBounds();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.CandidateWindowBoundsChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ICandidateWindowBoundsChangedEventArgs.GUID;
    pub const IID: Guid = ICandidateWindowBoundsChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ICandidateWindowBoundsChangedEventArgs.SIGNATURE);
};
pub const Panel = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getChildren(self: *@This()) core.HResult!*UIElementCollection {
        const this: *IPanel = @ptrCast(self);
        return try this.getChildren();
    }
    pub fn getBackground(self: *@This()) core.HResult!*Brush {
        const this: *IPanel = @ptrCast(self);
        return try this.getBackground();
    }
    pub fn putBackground(self: *@This(), value: *Brush) core.HResult!void {
        const this: *IPanel = @ptrCast(self);
        return try this.putBackground(value);
    }
    pub fn getIsItemsHost(self: *@This()) core.HResult!bool {
        const this: *IPanel = @ptrCast(self);
        return try this.getIsItemsHost();
    }
    pub fn getChildrenTransitions(self: *@This()) core.HResult!*TransitionCollection {
        const this: *IPanel = @ptrCast(self);
        return try this.getChildrenTransitions();
    }
    pub fn putChildrenTransitions(self: *@This(), value: *TransitionCollection) core.HResult!void {
        const this: *IPanel = @ptrCast(self);
        return try this.putChildrenTransitions(value);
    }
    pub fn getBackgroundTransition(self: *@This()) core.HResult!*BrushTransition {
        var this: ?*IPanel2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPanel2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getBackgroundTransition();
    }
    pub fn putBackgroundTransition(self: *@This(), value: *BrushTransition) core.HResult!void {
        var this: ?*IPanel2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPanel2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putBackgroundTransition(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getBackgroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPanelStaticsCache.get();
        return try _f.getBackgroundProperty();
    }
    pub fn getIsItemsHostProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPanelStaticsCache.get();
        return try _f.getIsItemsHostProperty();
    }
    pub fn getChildrenTransitionsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPanelStaticsCache.get();
        return try _f.getChildrenTransitionsProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*Panel {
        const _f = @This().IPanelFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.Panel";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IPanel.GUID;
    pub const IID: Guid = IPanel.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IPanel.SIGNATURE);
    var _IPanelStaticsCache: FactoryCache(IPanelStatics, RUNTIME_NAME) = .{};
    var _IPanelFactoryCache: FactoryCache(IPanelFactory, RUNTIME_NAME) = .{};
};
pub const Canvas = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getLeftProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICanvasStaticsCache.get();
        return try _f.getLeftProperty();
    }
    pub fn GetLeft(element: *UIElement) core.HResult!f64 {
        const _f = @This().ICanvasStaticsCache.get();
        return try _f.GetLeft(element);
    }
    pub fn SetLeft(element: *UIElement, length: f64) core.HResult!void {
        const _f = @This().ICanvasStaticsCache.get();
        return try _f.SetLeft(element, length);
    }
    pub fn getTopProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICanvasStaticsCache.get();
        return try _f.getTopProperty();
    }
    pub fn GetTop(element: *UIElement) core.HResult!f64 {
        const _f = @This().ICanvasStaticsCache.get();
        return try _f.GetTop(element);
    }
    pub fn SetTop(element: *UIElement, length: f64) core.HResult!void {
        const _f = @This().ICanvasStaticsCache.get();
        return try _f.SetTop(element, length);
    }
    pub fn getZIndexProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICanvasStaticsCache.get();
        return try _f.getZIndexProperty();
    }
    pub fn GetZIndex(element: *UIElement) core.HResult!i32 {
        const _f = @This().ICanvasStaticsCache.get();
        return try _f.GetZIndex(element);
    }
    pub fn SetZIndex(element: *UIElement, value: i32) core.HResult!void {
        const _f = @This().ICanvasStaticsCache.get();
        return try _f.SetZIndex(element, value);
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*Canvas {
        const _f = @This().ICanvasFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.Canvas";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ICanvas.GUID;
    pub const IID: Guid = ICanvas.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ICanvas.SIGNATURE);
    var _ICanvasStaticsCache: FactoryCache(ICanvasStatics, RUNTIME_NAME) = .{};
    var _ICanvasFactoryCache: FactoryCache(ICanvasFactory, RUNTIME_NAME) = .{};
};
pub const CaptureElement = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getSource(self: *@This()) core.HResult!*MediaCapture {
        const this: *ICaptureElement = @ptrCast(self);
        return try this.getSource();
    }
    pub fn putSource(self: *@This(), value: *MediaCapture) core.HResult!void {
        const this: *ICaptureElement = @ptrCast(self);
        return try this.putSource(value);
    }
    pub fn getStretch(self: *@This()) core.HResult!Stretch {
        const this: *ICaptureElement = @ptrCast(self);
        return try this.getStretch();
    }
    pub fn putStretch(self: *@This(), value: Stretch) core.HResult!void {
        const this: *ICaptureElement = @ptrCast(self);
        return try this.putStretch(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&ICaptureElement.IID)));
    }
    pub fn getSourceProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICaptureElementStaticsCache.get();
        return try _f.getSourceProperty();
    }
    pub fn getStretchProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICaptureElementStaticsCache.get();
        return try _f.getStretchProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.CaptureElement";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ICaptureElement.GUID;
    pub const IID: Guid = ICaptureElement.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ICaptureElement.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _ICaptureElementStaticsCache: FactoryCache(ICaptureElementStatics, RUNTIME_NAME) = .{};
};
pub const CharacterCasing = enum(i32) {
    Normal = 0,
    Lower = 1,
    Upper = 2,
};
pub const CheckBox = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*CheckBox {
        const _f = @This().ICheckBoxFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.CheckBox";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ICheckBox.GUID;
    pub const IID: Guid = ICheckBox.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ICheckBox.SIGNATURE);
    var _ICheckBoxFactoryCache: FactoryCache(ICheckBoxFactory, RUNTIME_NAME) = .{};
};
pub const ChoosingGroupHeaderContainerEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getGroupHeaderContainer(self: *@This()) core.HResult!*ListViewBaseHeaderItem {
        const this: *IChoosingGroupHeaderContainerEventArgs = @ptrCast(self);
        return try this.getGroupHeaderContainer();
    }
    pub fn putGroupHeaderContainer(self: *@This(), value: *ListViewBaseHeaderItem) core.HResult!void {
        const this: *IChoosingGroupHeaderContainerEventArgs = @ptrCast(self);
        return try this.putGroupHeaderContainer(value);
    }
    pub fn getGroupIndex(self: *@This()) core.HResult!i32 {
        const this: *IChoosingGroupHeaderContainerEventArgs = @ptrCast(self);
        return try this.getGroupIndex();
    }
    pub fn getGroup(self: *@This()) core.HResult!*IInspectable {
        const this: *IChoosingGroupHeaderContainerEventArgs = @ptrCast(self);
        return try this.getGroup();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IChoosingGroupHeaderContainerEventArgs.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ChoosingGroupHeaderContainerEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IChoosingGroupHeaderContainerEventArgs.GUID;
    pub const IID: Guid = IChoosingGroupHeaderContainerEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IChoosingGroupHeaderContainerEventArgs.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const ChoosingItemContainerEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getItemIndex(self: *@This()) core.HResult!i32 {
        const this: *IChoosingItemContainerEventArgs = @ptrCast(self);
        return try this.getItemIndex();
    }
    pub fn getItem(self: *@This()) core.HResult!*IInspectable {
        const this: *IChoosingItemContainerEventArgs = @ptrCast(self);
        return try this.getItem();
    }
    pub fn getItemContainer(self: *@This()) core.HResult!*SelectorItem {
        const this: *IChoosingItemContainerEventArgs = @ptrCast(self);
        return try this.getItemContainer();
    }
    pub fn putItemContainer(self: *@This(), value: *SelectorItem) core.HResult!void {
        const this: *IChoosingItemContainerEventArgs = @ptrCast(self);
        return try this.putItemContainer(value);
    }
    pub fn getIsContainerPrepared(self: *@This()) core.HResult!bool {
        const this: *IChoosingItemContainerEventArgs = @ptrCast(self);
        return try this.getIsContainerPrepared();
    }
    pub fn putIsContainerPrepared(self: *@This(), value: bool) core.HResult!void {
        const this: *IChoosingItemContainerEventArgs = @ptrCast(self);
        return try this.putIsContainerPrepared(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IChoosingItemContainerEventArgs.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ChoosingItemContainerEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IChoosingItemContainerEventArgs.GUID;
    pub const IID: Guid = IChoosingItemContainerEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IChoosingItemContainerEventArgs.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const CleanUpVirtualizedItemEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getValue(self: *@This()) core.HResult!*IInspectable {
        const this: *ICleanUpVirtualizedItemEventArgs = @ptrCast(self);
        return try this.getValue();
    }
    pub fn getUIElement(self: *@This()) core.HResult!*UIElement {
        const this: *ICleanUpVirtualizedItemEventArgs = @ptrCast(self);
        return try this.getUIElement();
    }
    pub fn getCancel(self: *@This()) core.HResult!bool {
        const this: *ICleanUpVirtualizedItemEventArgs = @ptrCast(self);
        return try this.getCancel();
    }
    pub fn putCancel(self: *@This(), value: bool) core.HResult!void {
        const this: *ICleanUpVirtualizedItemEventArgs = @ptrCast(self);
        return try this.putCancel(value);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.CleanUpVirtualizedItemEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ICleanUpVirtualizedItemEventArgs.GUID;
    pub const IID: Guid = ICleanUpVirtualizedItemEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ICleanUpVirtualizedItemEventArgs.SIGNATURE);
};
pub const CleanUpVirtualizedItemEventHandler = extern struct {
    vtable: *const VTable,
    _refs: @import("std").atomic.Value(u32),
    _cb: *const fn (context: ?*anyopaque) callconv(.winapi) void,
    _context: ?*anyopaque = null,
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn init(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *CleanUpVirtualizedItemEventArgs) callconv(.winapi) void,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
        };
        return _r;
    }
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn initWithState(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *CleanUpVirtualizedItemEventArgs) callconv(.winapi) void,
        context: anytype,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
            ._context = @ptrCast(context),
        };
        return _r;
    }
    /// This calls Release and voids the returned ref count. If ref count is 0 the memory is released,
    /// Otherwise the memory stays until all references are released, including all references Windows holds.
    ///
    /// The caller *MUST* always call deinit/Release at least once for every AddRef and init called.
    pub fn deinit(self: *@This()) void {
        _ = Release(@ptrCast(self));
    }
    fn QueryInterface(self: *anyopaque, riid: *const Guid, out: *?*anyopaque) callconv(.c) HRESULT {
        const me: *@This() = @ptrCast(@alignCast(self));
        // TODO: Handle IMarshal
        if (core.wiredGuidEql(riid, &IID) or
            core.wiredGuidEql(riid, &IUnknown.IID) or
            core.wiredGuidEql(riid, &IAgileObject.IID))
        {
            out.* = @as(?*anyopaque, @ptrCast(me));
            _ = AddRef(self);
            return 0;
        }
        out.* = null;
        return -2147467262; // E_NOINTERFACE
    }
    fn AddRef(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        return this._refs.fetchAdd(1, .monotonic) + 1;
    }
    fn Release(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        const left = this._refs.fetchSub(1, .acq_rel) - 1;
        if (left == 0) @import("std").heap.c_allocator.destroy(this);
        return left;
    }
    pub fn Invoke(self: *anyopaque, sender: *IInspectable, e: *CleanUpVirtualizedItemEventArgs) callconv(.winapi) HRESULT {
        const this: *@This() = @ptrCast(@alignCast(self));
        this._cb(this._context, sender, e);
        return 0;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.CleanUpVirtualizedItemEventHandler";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "cacad0d6-0f0d-4870-884d-f2dedf674288";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.pinterface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        Invoke: *const fn(self: *anyopaque, sender: *IInspectable, e: *CleanUpVirtualizedItemEventArgs) callconv(.winapi) HRESULT
    };
    pub const VTABLE = VTable {
        .QueryInterface = QueryInterface,
        .AddRef = AddRef,
        .Release = Release,
        .Invoke = Invoke,
    };
};
pub const ClickMode = enum(i32) {
    Release = 0,
    Press = 1,
    Hover = 2,
};
pub const ColorChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getOldColor(self: *@This()) core.HResult!Color {
        const this: *IColorChangedEventArgs = @ptrCast(self);
        return try this.getOldColor();
    }
    pub fn getNewColor(self: *@This()) core.HResult!Color {
        const this: *IColorChangedEventArgs = @ptrCast(self);
        return try this.getNewColor();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ColorChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IColorChangedEventArgs.GUID;
    pub const IID: Guid = IColorChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IColorChangedEventArgs.SIGNATURE);
};
pub const ColorPicker = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getColor(self: *@This()) core.HResult!Color {
        const this: *IColorPicker = @ptrCast(self);
        return try this.getColor();
    }
    pub fn putColor(self: *@This(), value: Color) core.HResult!void {
        const this: *IColorPicker = @ptrCast(self);
        return try this.putColor(value);
    }
    pub fn getPreviousColor(self: *@This()) core.HResult!*IReference(Color) {
        const this: *IColorPicker = @ptrCast(self);
        return try this.getPreviousColor();
    }
    pub fn putPreviousColor(self: *@This(), value: *IReference(Color)) core.HResult!void {
        const this: *IColorPicker = @ptrCast(self);
        return try this.putPreviousColor(value);
    }
    pub fn getIsAlphaEnabled(self: *@This()) core.HResult!bool {
        const this: *IColorPicker = @ptrCast(self);
        return try this.getIsAlphaEnabled();
    }
    pub fn putIsAlphaEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IColorPicker = @ptrCast(self);
        return try this.putIsAlphaEnabled(value);
    }
    pub fn getIsColorSpectrumVisible(self: *@This()) core.HResult!bool {
        const this: *IColorPicker = @ptrCast(self);
        return try this.getIsColorSpectrumVisible();
    }
    pub fn putIsColorSpectrumVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IColorPicker = @ptrCast(self);
        return try this.putIsColorSpectrumVisible(value);
    }
    pub fn getIsColorPreviewVisible(self: *@This()) core.HResult!bool {
        const this: *IColorPicker = @ptrCast(self);
        return try this.getIsColorPreviewVisible();
    }
    pub fn putIsColorPreviewVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IColorPicker = @ptrCast(self);
        return try this.putIsColorPreviewVisible(value);
    }
    pub fn getIsColorSliderVisible(self: *@This()) core.HResult!bool {
        const this: *IColorPicker = @ptrCast(self);
        return try this.getIsColorSliderVisible();
    }
    pub fn putIsColorSliderVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IColorPicker = @ptrCast(self);
        return try this.putIsColorSliderVisible(value);
    }
    pub fn getIsAlphaSliderVisible(self: *@This()) core.HResult!bool {
        const this: *IColorPicker = @ptrCast(self);
        return try this.getIsAlphaSliderVisible();
    }
    pub fn putIsAlphaSliderVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IColorPicker = @ptrCast(self);
        return try this.putIsAlphaSliderVisible(value);
    }
    pub fn getIsMoreButtonVisible(self: *@This()) core.HResult!bool {
        const this: *IColorPicker = @ptrCast(self);
        return try this.getIsMoreButtonVisible();
    }
    pub fn putIsMoreButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IColorPicker = @ptrCast(self);
        return try this.putIsMoreButtonVisible(value);
    }
    pub fn getIsColorChannelTextInputVisible(self: *@This()) core.HResult!bool {
        const this: *IColorPicker = @ptrCast(self);
        return try this.getIsColorChannelTextInputVisible();
    }
    pub fn putIsColorChannelTextInputVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IColorPicker = @ptrCast(self);
        return try this.putIsColorChannelTextInputVisible(value);
    }
    pub fn getIsAlphaTextInputVisible(self: *@This()) core.HResult!bool {
        const this: *IColorPicker = @ptrCast(self);
        return try this.getIsAlphaTextInputVisible();
    }
    pub fn putIsAlphaTextInputVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IColorPicker = @ptrCast(self);
        return try this.putIsAlphaTextInputVisible(value);
    }
    pub fn getIsHexInputVisible(self: *@This()) core.HResult!bool {
        const this: *IColorPicker = @ptrCast(self);
        return try this.getIsHexInputVisible();
    }
    pub fn putIsHexInputVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IColorPicker = @ptrCast(self);
        return try this.putIsHexInputVisible(value);
    }
    pub fn getMinHue(self: *@This()) core.HResult!i32 {
        const this: *IColorPicker = @ptrCast(self);
        return try this.getMinHue();
    }
    pub fn putMinHue(self: *@This(), value: i32) core.HResult!void {
        const this: *IColorPicker = @ptrCast(self);
        return try this.putMinHue(value);
    }
    pub fn getMaxHue(self: *@This()) core.HResult!i32 {
        const this: *IColorPicker = @ptrCast(self);
        return try this.getMaxHue();
    }
    pub fn putMaxHue(self: *@This(), value: i32) core.HResult!void {
        const this: *IColorPicker = @ptrCast(self);
        return try this.putMaxHue(value);
    }
    pub fn getMinSaturation(self: *@This()) core.HResult!i32 {
        const this: *IColorPicker = @ptrCast(self);
        return try this.getMinSaturation();
    }
    pub fn putMinSaturation(self: *@This(), value: i32) core.HResult!void {
        const this: *IColorPicker = @ptrCast(self);
        return try this.putMinSaturation(value);
    }
    pub fn getMaxSaturation(self: *@This()) core.HResult!i32 {
        const this: *IColorPicker = @ptrCast(self);
        return try this.getMaxSaturation();
    }
    pub fn putMaxSaturation(self: *@This(), value: i32) core.HResult!void {
        const this: *IColorPicker = @ptrCast(self);
        return try this.putMaxSaturation(value);
    }
    pub fn getMinValue(self: *@This()) core.HResult!i32 {
        const this: *IColorPicker = @ptrCast(self);
        return try this.getMinValue();
    }
    pub fn putMinValue(self: *@This(), value: i32) core.HResult!void {
        const this: *IColorPicker = @ptrCast(self);
        return try this.putMinValue(value);
    }
    pub fn getMaxValue(self: *@This()) core.HResult!i32 {
        const this: *IColorPicker = @ptrCast(self);
        return try this.getMaxValue();
    }
    pub fn putMaxValue(self: *@This(), value: i32) core.HResult!void {
        const this: *IColorPicker = @ptrCast(self);
        return try this.putMaxValue(value);
    }
    pub fn getColorSpectrumShape(self: *@This()) core.HResult!ColorSpectrumShape {
        const this: *IColorPicker = @ptrCast(self);
        return try this.getColorSpectrumShape();
    }
    pub fn putColorSpectrumShape(self: *@This(), value: ColorSpectrumShape) core.HResult!void {
        const this: *IColorPicker = @ptrCast(self);
        return try this.putColorSpectrumShape(value);
    }
    pub fn getColorSpectrumComponents(self: *@This()) core.HResult!ColorSpectrumComponents {
        const this: *IColorPicker = @ptrCast(self);
        return try this.getColorSpectrumComponents();
    }
    pub fn putColorSpectrumComponents(self: *@This(), value: ColorSpectrumComponents) core.HResult!void {
        const this: *IColorPicker = @ptrCast(self);
        return try this.putColorSpectrumComponents(value);
    }
    pub fn addColorChanged(self: *@This(), handler: *TypedEventHandler(ColorPicker,ColorChangedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IColorPicker = @ptrCast(self);
        return try this.addColorChanged(handler);
    }
    pub fn removeColorChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IColorPicker = @ptrCast(self);
        return try this.removeColorChanged(token);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getColorProperty() core.HResult!*DependencyProperty {
        const _f = @This().IColorPickerStaticsCache.get();
        return try _f.getColorProperty();
    }
    pub fn getPreviousColorProperty() core.HResult!*DependencyProperty {
        const _f = @This().IColorPickerStaticsCache.get();
        return try _f.getPreviousColorProperty();
    }
    pub fn getIsAlphaEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IColorPickerStaticsCache.get();
        return try _f.getIsAlphaEnabledProperty();
    }
    pub fn getIsColorSpectrumVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IColorPickerStaticsCache.get();
        return try _f.getIsColorSpectrumVisibleProperty();
    }
    pub fn getIsColorPreviewVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IColorPickerStaticsCache.get();
        return try _f.getIsColorPreviewVisibleProperty();
    }
    pub fn getIsColorSliderVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IColorPickerStaticsCache.get();
        return try _f.getIsColorSliderVisibleProperty();
    }
    pub fn getIsAlphaSliderVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IColorPickerStaticsCache.get();
        return try _f.getIsAlphaSliderVisibleProperty();
    }
    pub fn getIsMoreButtonVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IColorPickerStaticsCache.get();
        return try _f.getIsMoreButtonVisibleProperty();
    }
    pub fn getIsColorChannelTextInputVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IColorPickerStaticsCache.get();
        return try _f.getIsColorChannelTextInputVisibleProperty();
    }
    pub fn getIsAlphaTextInputVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IColorPickerStaticsCache.get();
        return try _f.getIsAlphaTextInputVisibleProperty();
    }
    pub fn getIsHexInputVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IColorPickerStaticsCache.get();
        return try _f.getIsHexInputVisibleProperty();
    }
    pub fn getMinHueProperty() core.HResult!*DependencyProperty {
        const _f = @This().IColorPickerStaticsCache.get();
        return try _f.getMinHueProperty();
    }
    pub fn getMaxHueProperty() core.HResult!*DependencyProperty {
        const _f = @This().IColorPickerStaticsCache.get();
        return try _f.getMaxHueProperty();
    }
    pub fn getMinSaturationProperty() core.HResult!*DependencyProperty {
        const _f = @This().IColorPickerStaticsCache.get();
        return try _f.getMinSaturationProperty();
    }
    pub fn getMaxSaturationProperty() core.HResult!*DependencyProperty {
        const _f = @This().IColorPickerStaticsCache.get();
        return try _f.getMaxSaturationProperty();
    }
    pub fn getMinValueProperty() core.HResult!*DependencyProperty {
        const _f = @This().IColorPickerStaticsCache.get();
        return try _f.getMinValueProperty();
    }
    pub fn getMaxValueProperty() core.HResult!*DependencyProperty {
        const _f = @This().IColorPickerStaticsCache.get();
        return try _f.getMaxValueProperty();
    }
    pub fn getColorSpectrumShapeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IColorPickerStaticsCache.get();
        return try _f.getColorSpectrumShapeProperty();
    }
    pub fn getColorSpectrumComponentsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IColorPickerStaticsCache.get();
        return try _f.getColorSpectrumComponentsProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ColorPicker {
        const _f = @This().IColorPickerFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ColorPicker";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IColorPicker.GUID;
    pub const IID: Guid = IColorPicker.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IColorPicker.SIGNATURE);
    var _IColorPickerStaticsCache: FactoryCache(IColorPickerStatics, RUNTIME_NAME) = .{};
    var _IColorPickerFactoryCache: FactoryCache(IColorPickerFactory, RUNTIME_NAME) = .{};
};
pub const ColorPickerHsvChannel = enum(i32) {
    Hue = 0,
    Saturation = 1,
    Value = 2,
    Alpha = 3,
};
pub const ColorSpectrumComponents = enum(i32) {
    HueValue = 0,
    ValueHue = 1,
    HueSaturation = 2,
    SaturationHue = 3,
    SaturationValue = 4,
    ValueSaturation = 5,
};
pub const ColorSpectrumShape = enum(i32) {
    Box = 0,
    Ring = 1,
};
pub const ColumnDefinition = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getWidth(self: *@This()) core.HResult!GridLength {
        const this: *IColumnDefinition = @ptrCast(self);
        return try this.getWidth();
    }
    pub fn putWidth(self: *@This(), value: GridLength) core.HResult!void {
        const this: *IColumnDefinition = @ptrCast(self);
        return try this.putWidth(value);
    }
    pub fn getMaxWidth(self: *@This()) core.HResult!f64 {
        const this: *IColumnDefinition = @ptrCast(self);
        return try this.getMaxWidth();
    }
    pub fn putMaxWidth(self: *@This(), value: f64) core.HResult!void {
        const this: *IColumnDefinition = @ptrCast(self);
        return try this.putMaxWidth(value);
    }
    pub fn getMinWidth(self: *@This()) core.HResult!f64 {
        const this: *IColumnDefinition = @ptrCast(self);
        return try this.getMinWidth();
    }
    pub fn putMinWidth(self: *@This(), value: f64) core.HResult!void {
        const this: *IColumnDefinition = @ptrCast(self);
        return try this.putMinWidth(value);
    }
    pub fn getActualWidth(self: *@This()) core.HResult!f64 {
        const this: *IColumnDefinition = @ptrCast(self);
        return try this.getActualWidth();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IColumnDefinition.IID)));
    }
    pub fn getWidthProperty() core.HResult!*DependencyProperty {
        const _f = @This().IColumnDefinitionStaticsCache.get();
        return try _f.getWidthProperty();
    }
    pub fn getMaxWidthProperty() core.HResult!*DependencyProperty {
        const _f = @This().IColumnDefinitionStaticsCache.get();
        return try _f.getMaxWidthProperty();
    }
    pub fn getMinWidthProperty() core.HResult!*DependencyProperty {
        const _f = @This().IColumnDefinitionStaticsCache.get();
        return try _f.getMinWidthProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ColumnDefinition";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IColumnDefinition.GUID;
    pub const IID: Guid = IColumnDefinition.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IColumnDefinition.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IColumnDefinitionStaticsCache: FactoryCache(IColumnDefinitionStatics, RUNTIME_NAME) = .{};
};
pub const ColumnDefinitionCollection = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getSize(self: *@This()) core.HResult!u32 {
        const this: *IVector(ColumnDefinition) = @ptrCast(self);
        return try this.getSize();
    }
    pub fn GetView(self: *@This()) core.HResult!*IVectorView(ColumnDefinition) {
        const this: *IVector(ColumnDefinition) = @ptrCast(self);
        return try this.GetView();
    }
    pub fn RemoveAt(self: *@This(), index: u32) core.HResult!void {
        const this: *IVector(ColumnDefinition) = @ptrCast(self);
        return try this.RemoveAt(index);
    }
    pub fn RemoveAtEnd(self: *@This()) core.HResult!void {
        const this: *IVector(ColumnDefinition) = @ptrCast(self);
        return try this.RemoveAtEnd();
    }
    pub fn Clear(self: *@This()) core.HResult!void {
        const this: *IVector(ColumnDefinition) = @ptrCast(self);
        return try this.Clear();
    }
    pub fn First(self: *@This()) core.HResult!*IIterator(ColumnDefinition) {
        var this: ?*IIterable(ColumnDefinition) = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IIterable.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.First();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ColumnDefinitionCollection";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IVector.GUID;
    pub const IID: Guid = IVector.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IVector.SIGNATURE);
};
pub const ComboBox = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsDropDownOpen(self: *@This()) core.HResult!bool {
        const this: *IComboBox = @ptrCast(self);
        return try this.getIsDropDownOpen();
    }
    pub fn putIsDropDownOpen(self: *@This(), value: bool) core.HResult!void {
        const this: *IComboBox = @ptrCast(self);
        return try this.putIsDropDownOpen(value);
    }
    pub fn getIsEditable(self: *@This()) core.HResult!bool {
        const this: *IComboBox = @ptrCast(self);
        return try this.getIsEditable();
    }
    pub fn getIsSelectionBoxHighlighted(self: *@This()) core.HResult!bool {
        const this: *IComboBox = @ptrCast(self);
        return try this.getIsSelectionBoxHighlighted();
    }
    pub fn getMaxDropDownHeight(self: *@This()) core.HResult!f64 {
        const this: *IComboBox = @ptrCast(self);
        return try this.getMaxDropDownHeight();
    }
    pub fn putMaxDropDownHeight(self: *@This(), value: f64) core.HResult!void {
        const this: *IComboBox = @ptrCast(self);
        return try this.putMaxDropDownHeight(value);
    }
    pub fn getSelectionBoxItem(self: *@This()) core.HResult!*IInspectable {
        const this: *IComboBox = @ptrCast(self);
        return try this.getSelectionBoxItem();
    }
    pub fn getSelectionBoxItemTemplate(self: *@This()) core.HResult!*DataTemplate {
        const this: *IComboBox = @ptrCast(self);
        return try this.getSelectionBoxItemTemplate();
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*ComboBoxTemplateSettings {
        const this: *IComboBox = @ptrCast(self);
        return try this.getTemplateSettings();
    }
    pub fn addDropDownClosed(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        const this: *IComboBox = @ptrCast(self);
        return try this.addDropDownClosed(handler);
    }
    pub fn removeDropDownClosed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IComboBox = @ptrCast(self);
        return try this.removeDropDownClosed(token);
    }
    pub fn addDropDownOpened(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        const this: *IComboBox = @ptrCast(self);
        return try this.addDropDownOpened(handler);
    }
    pub fn removeDropDownOpened(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IComboBox = @ptrCast(self);
        return try this.removeDropDownOpened(token);
    }
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        var this: ?*IComboBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getHeader();
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        var this: ?*IComboBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putHeader(value);
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var this: ?*IComboBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getHeaderTemplate();
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        var this: ?*IComboBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putHeaderTemplate(value);
    }
    pub fn getPlaceholderText(self: *@This()) core.HResult!HSTRING {
        var this: ?*IComboBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getPlaceholderText();
    }
    pub fn putPlaceholderText(self: *@This(), value: HSTRING) core.HResult!void {
        var this: ?*IComboBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putPlaceholderText(value);
    }
    pub fn getLightDismissOverlayMode(self: *@This()) core.HResult!LightDismissOverlayMode {
        var this: ?*IComboBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getLightDismissOverlayMode();
    }
    pub fn putLightDismissOverlayMode(self: *@This(), value: LightDismissOverlayMode) core.HResult!void {
        var this: ?*IComboBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putLightDismissOverlayMode(value);
    }
    pub fn getIsTextSearchEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IComboBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsTextSearchEnabled();
    }
    pub fn putIsTextSearchEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IComboBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsTextSearchEnabled(value);
    }
    pub fn getSelectionChangedTrigger(self: *@This()) core.HResult!ComboBoxSelectionChangedTrigger {
        var this: ?*IComboBox4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectionChangedTrigger();
    }
    pub fn putSelectionChangedTrigger(self: *@This(), value: ComboBoxSelectionChangedTrigger) core.HResult!void {
        var this: ?*IComboBox4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSelectionChangedTrigger(value);
    }
    pub fn getPlaceholderForeground(self: *@This()) core.HResult!*Brush {
        var this: ?*IComboBox5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getPlaceholderForeground();
    }
    pub fn putPlaceholderForeground(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*IComboBox5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putPlaceholderForeground(value);
    }
    pub fn putIsEditable(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IComboBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsEditable(value);
    }
    pub fn getText(self: *@This()) core.HResult!HSTRING {
        var this: ?*IComboBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getText();
    }
    pub fn putText(self: *@This(), value: HSTRING) core.HResult!void {
        var this: ?*IComboBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putText(value);
    }
    pub fn getTextBoxStyle(self: *@This()) core.HResult!*Style {
        var this: ?*IComboBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTextBoxStyle();
    }
    pub fn putTextBoxStyle(self: *@This(), value: *Style) core.HResult!void {
        var this: ?*IComboBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTextBoxStyle(value);
    }
    pub fn getDescription(self: *@This()) core.HResult!*IInspectable {
        var this: ?*IComboBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDescription();
    }
    pub fn putDescription(self: *@This(), value: *IInspectable) core.HResult!void {
        var this: ?*IComboBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putDescription(value);
    }
    pub fn addTextSubmitted(self: *@This(), handler: *TypedEventHandler(ComboBox,ComboBoxTextSubmittedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IComboBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addTextSubmitted(handler);
    }
    pub fn removeTextSubmitted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IComboBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeTextSubmitted(token);
    }
    pub fn OnDropDownClosed(self: *@This(), e: *IInspectable) core.HResult!void {
        var this: ?*IComboBoxOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBoxOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnDropDownClosed(e);
    }
    pub fn OnDropDownOpened(self: *@This(), e: *IInspectable) core.HResult!void {
        var this: ?*IComboBoxOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IComboBoxOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnDropDownOpened(e);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getIsDropDownOpenProperty() core.HResult!*DependencyProperty {
        const _f = @This().IComboBoxStaticsCache.get();
        return try _f.getIsDropDownOpenProperty();
    }
    pub fn getMaxDropDownHeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().IComboBoxStaticsCache.get();
        return try _f.getMaxDropDownHeightProperty();
    }
    pub fn getIsEditableProperty() core.HResult!*DependencyProperty {
        const _f = @This().IComboBoxStatics6Cache.get();
        return try _f.getIsEditableProperty();
    }
    pub fn getTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().IComboBoxStatics6Cache.get();
        return try _f.getTextProperty();
    }
    pub fn getTextBoxStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IComboBoxStatics6Cache.get();
        return try _f.getTextBoxStyleProperty();
    }
    pub fn getDescriptionProperty() core.HResult!*DependencyProperty {
        const _f = @This().IComboBoxStatics6Cache.get();
        return try _f.getDescriptionProperty();
    }
    pub fn getPlaceholderForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().IComboBoxStatics5Cache.get();
        return try _f.getPlaceholderForegroundProperty();
    }
    pub fn getSelectionChangedTriggerProperty() core.HResult!*DependencyProperty {
        const _f = @This().IComboBoxStatics4Cache.get();
        return try _f.getSelectionChangedTriggerProperty();
    }
    pub fn getLightDismissOverlayModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IComboBoxStatics3Cache.get();
        return try _f.getLightDismissOverlayModeProperty();
    }
    pub fn getIsTextSearchEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IComboBoxStatics3Cache.get();
        return try _f.getIsTextSearchEnabledProperty();
    }
    pub fn getHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IComboBoxStatics2Cache.get();
        return try _f.getHeaderProperty();
    }
    pub fn getHeaderTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IComboBoxStatics2Cache.get();
        return try _f.getHeaderTemplateProperty();
    }
    pub fn getPlaceholderTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().IComboBoxStatics2Cache.get();
        return try _f.getPlaceholderTextProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ComboBox {
        const _f = @This().IComboBoxFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ComboBox";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IComboBox.GUID;
    pub const IID: Guid = IComboBox.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IComboBox.SIGNATURE);
    var _IComboBoxStaticsCache: FactoryCache(IComboBoxStatics, RUNTIME_NAME) = .{};
    var _IComboBoxStatics6Cache: FactoryCache(IComboBoxStatics6, RUNTIME_NAME) = .{};
    var _IComboBoxStatics5Cache: FactoryCache(IComboBoxStatics5, RUNTIME_NAME) = .{};
    var _IComboBoxStatics4Cache: FactoryCache(IComboBoxStatics4, RUNTIME_NAME) = .{};
    var _IComboBoxStatics3Cache: FactoryCache(IComboBoxStatics3, RUNTIME_NAME) = .{};
    var _IComboBoxStatics2Cache: FactoryCache(IComboBoxStatics2, RUNTIME_NAME) = .{};
    var _IComboBoxFactoryCache: FactoryCache(IComboBoxFactory, RUNTIME_NAME) = .{};
};
pub const ComboBoxItem = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ComboBoxItem {
        const _f = @This().IComboBoxItemFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ComboBoxItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IComboBoxItem.GUID;
    pub const IID: Guid = IComboBoxItem.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IComboBoxItem.SIGNATURE);
    var _IComboBoxItemFactoryCache: FactoryCache(IComboBoxItemFactory, RUNTIME_NAME) = .{};
};
pub const ComboBoxSelectionChangedTrigger = enum(i32) {
    Committed = 0,
    Always = 1,
};
pub const ComboBoxTextSubmittedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getText(self: *@This()) core.HResult!HSTRING {
        const this: *IComboBoxTextSubmittedEventArgs = @ptrCast(self);
        return try this.getText();
    }
    pub fn getHandled(self: *@This()) core.HResult!bool {
        const this: *IComboBoxTextSubmittedEventArgs = @ptrCast(self);
        return try this.getHandled();
    }
    pub fn putHandled(self: *@This(), value: bool) core.HResult!void {
        const this: *IComboBoxTextSubmittedEventArgs = @ptrCast(self);
        return try this.putHandled(value);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ComboBoxTextSubmittedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IComboBoxTextSubmittedEventArgs.GUID;
    pub const IID: Guid = IComboBoxTextSubmittedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IComboBoxTextSubmittedEventArgs.SIGNATURE);
};
pub const CommandBar = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getPrimaryCommands(self: *@This()) core.HResult!*IObservableVector(ICommandBarElement) {
        const this: *ICommandBar = @ptrCast(self);
        return try this.getPrimaryCommands();
    }
    pub fn getSecondaryCommands(self: *@This()) core.HResult!*IObservableVector(ICommandBarElement) {
        const this: *ICommandBar = @ptrCast(self);
        return try this.getSecondaryCommands();
    }
    pub fn getCommandBarOverflowPresenterStyle(self: *@This()) core.HResult!*Style {
        var this: ?*ICommandBar2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBar2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCommandBarOverflowPresenterStyle();
    }
    pub fn putCommandBarOverflowPresenterStyle(self: *@This(), value: *Style) core.HResult!void {
        var this: ?*ICommandBar2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBar2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putCommandBarOverflowPresenterStyle(value);
    }
    pub fn getCommandBarTemplateSettings(self: *@This()) core.HResult!*CommandBarTemplateSettings {
        var this: ?*ICommandBar2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBar2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCommandBarTemplateSettings();
    }
    pub fn getDefaultLabelPosition(self: *@This()) core.HResult!CommandBarDefaultLabelPosition {
        var this: ?*ICommandBar3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBar3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDefaultLabelPosition();
    }
    pub fn putDefaultLabelPosition(self: *@This(), value: CommandBarDefaultLabelPosition) core.HResult!void {
        var this: ?*ICommandBar3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBar3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putDefaultLabelPosition(value);
    }
    pub fn getOverflowButtonVisibility(self: *@This()) core.HResult!CommandBarOverflowButtonVisibility {
        var this: ?*ICommandBar3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBar3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getOverflowButtonVisibility();
    }
    pub fn putOverflowButtonVisibility(self: *@This(), value: CommandBarOverflowButtonVisibility) core.HResult!void {
        var this: ?*ICommandBar3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBar3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putOverflowButtonVisibility(value);
    }
    pub fn getIsDynamicOverflowEnabled(self: *@This()) core.HResult!bool {
        var this: ?*ICommandBar3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBar3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsDynamicOverflowEnabled();
    }
    pub fn putIsDynamicOverflowEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*ICommandBar3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBar3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsDynamicOverflowEnabled(value);
    }
    pub fn addDynamicOverflowItemsChanging(self: *@This(), handler: *TypedEventHandler(CommandBar,DynamicOverflowItemsChangingEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*ICommandBar3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBar3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addDynamicOverflowItemsChanging(handler);
    }
    pub fn removeDynamicOverflowItemsChanging(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*ICommandBar3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICommandBar3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeDynamicOverflowItemsChanging(token);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getCommandBarOverflowPresenterStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICommandBarStatics2Cache.get();
        return try _f.getCommandBarOverflowPresenterStyleProperty();
    }
    pub fn getPrimaryCommandsProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICommandBarStaticsCache.get();
        return try _f.getPrimaryCommandsProperty();
    }
    pub fn getSecondaryCommandsProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICommandBarStaticsCache.get();
        return try _f.getSecondaryCommandsProperty();
    }
    pub fn getDefaultLabelPositionProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICommandBarStatics3Cache.get();
        return try _f.getDefaultLabelPositionProperty();
    }
    pub fn getOverflowButtonVisibilityProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICommandBarStatics3Cache.get();
        return try _f.getOverflowButtonVisibilityProperty();
    }
    pub fn getIsDynamicOverflowEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().ICommandBarStatics3Cache.get();
        return try _f.getIsDynamicOverflowEnabledProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*CommandBar {
        const _f = @This().ICommandBarFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.CommandBar";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ICommandBar.GUID;
    pub const IID: Guid = ICommandBar.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ICommandBar.SIGNATURE);
    var _ICommandBarStatics2Cache: FactoryCache(ICommandBarStatics2, RUNTIME_NAME) = .{};
    var _ICommandBarStaticsCache: FactoryCache(ICommandBarStatics, RUNTIME_NAME) = .{};
    var _ICommandBarStatics3Cache: FactoryCache(ICommandBarStatics3, RUNTIME_NAME) = .{};
    var _ICommandBarFactoryCache: FactoryCache(ICommandBarFactory, RUNTIME_NAME) = .{};
};
pub const CommandBarDefaultLabelPosition = enum(i32) {
    Bottom = 0,
    Right = 1,
    Collapsed = 2,
};
pub const CommandBarDynamicOverflowAction = enum(i32) {
    AddingToOverflow = 0,
    RemovingFromOverflow = 1,
};
pub const CommandBarFlyout = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getPrimaryCommands(self: *@This()) core.HResult!*IObservableVector(ICommandBarElement) {
        const this: *ICommandBarFlyout = @ptrCast(self);
        return try this.getPrimaryCommands();
    }
    pub fn getSecondaryCommands(self: *@This()) core.HResult!*IObservableVector(ICommandBarElement) {
        const this: *ICommandBarFlyout = @ptrCast(self);
        return try this.getSecondaryCommands();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*CommandBarFlyout {
        const _f = @This().ICommandBarFlyoutFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.CommandBarFlyout";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ICommandBarFlyout.GUID;
    pub const IID: Guid = ICommandBarFlyout.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ICommandBarFlyout.SIGNATURE);
    var _ICommandBarFlyoutFactoryCache: FactoryCache(ICommandBarFlyoutFactory, RUNTIME_NAME) = .{};
};
pub const CommandBarLabelPosition = enum(i32) {
    Default = 0,
    Collapsed = 1,
};
pub const CommandBarOverflowButtonVisibility = enum(i32) {
    Auto = 0,
    Visible = 1,
    Collapsed = 2,
};
pub const CommandBarOverflowPresenter = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*CommandBarOverflowPresenter {
        const _f = @This().ICommandBarOverflowPresenterFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.CommandBarOverflowPresenter";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ICommandBarOverflowPresenter.GUID;
    pub const IID: Guid = ICommandBarOverflowPresenter.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ICommandBarOverflowPresenter.SIGNATURE);
    var _ICommandBarOverflowPresenterFactoryCache: FactoryCache(ICommandBarOverflowPresenterFactory, RUNTIME_NAME) = .{};
};
pub const ContainerContentChangingEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getItemContainer(self: *@This()) core.HResult!*SelectorItem {
        const this: *IContainerContentChangingEventArgs = @ptrCast(self);
        return try this.getItemContainer();
    }
    pub fn getInRecycleQueue(self: *@This()) core.HResult!bool {
        const this: *IContainerContentChangingEventArgs = @ptrCast(self);
        return try this.getInRecycleQueue();
    }
    pub fn getItemIndex(self: *@This()) core.HResult!i32 {
        const this: *IContainerContentChangingEventArgs = @ptrCast(self);
        return try this.getItemIndex();
    }
    pub fn getItem(self: *@This()) core.HResult!*IInspectable {
        const this: *IContainerContentChangingEventArgs = @ptrCast(self);
        return try this.getItem();
    }
    pub fn getPhase(self: *@This()) core.HResult!u32 {
        const this: *IContainerContentChangingEventArgs = @ptrCast(self);
        return try this.getPhase();
    }
    pub fn getHandled(self: *@This()) core.HResult!bool {
        const this: *IContainerContentChangingEventArgs = @ptrCast(self);
        return try this.getHandled();
    }
    pub fn putHandled(self: *@This(), value: bool) core.HResult!void {
        const this: *IContainerContentChangingEventArgs = @ptrCast(self);
        return try this.putHandled(value);
    }
    pub fn RegisterUpdateCallback(self: *@This(), callback: *TypedEventHandler(ListViewBase,ContainerContentChangingEventArgs)) core.HResult!void {
        const this: *IContainerContentChangingEventArgs = @ptrCast(self);
        return try this.RegisterUpdateCallback(callback);
    }
    pub fn RegisterUpdateCallbackWithCallbackPhaseAndCallback(self: *@This(), callbackPhase: u32, callback: *TypedEventHandler(ListViewBase,ContainerContentChangingEventArgs)) core.HResult!void {
        const this: *IContainerContentChangingEventArgs = @ptrCast(self);
        return try this.RegisterUpdateCallbackWithCallbackPhaseAndCallback(callbackPhase, callback);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IContainerContentChangingEventArgs.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ContainerContentChangingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IContainerContentChangingEventArgs.GUID;
    pub const IID: Guid = IContainerContentChangingEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IContainerContentChangingEventArgs.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const ContentDialog = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getTitle(self: *@This()) core.HResult!*IInspectable {
        const this: *IContentDialog = @ptrCast(self);
        return try this.getTitle();
    }
    pub fn putTitle(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IContentDialog = @ptrCast(self);
        return try this.putTitle(value);
    }
    pub fn getTitleTemplate(self: *@This()) core.HResult!*DataTemplate {
        const this: *IContentDialog = @ptrCast(self);
        return try this.getTitleTemplate();
    }
    pub fn putTitleTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const this: *IContentDialog = @ptrCast(self);
        return try this.putTitleTemplate(value);
    }
    pub fn getFullSizeDesired(self: *@This()) core.HResult!bool {
        const this: *IContentDialog = @ptrCast(self);
        return try this.getFullSizeDesired();
    }
    pub fn putFullSizeDesired(self: *@This(), value: bool) core.HResult!void {
        const this: *IContentDialog = @ptrCast(self);
        return try this.putFullSizeDesired(value);
    }
    pub fn getPrimaryButtonText(self: *@This()) core.HResult!HSTRING {
        const this: *IContentDialog = @ptrCast(self);
        return try this.getPrimaryButtonText();
    }
    pub fn putPrimaryButtonText(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IContentDialog = @ptrCast(self);
        return try this.putPrimaryButtonText(value);
    }
    pub fn getSecondaryButtonText(self: *@This()) core.HResult!HSTRING {
        const this: *IContentDialog = @ptrCast(self);
        return try this.getSecondaryButtonText();
    }
    pub fn putSecondaryButtonText(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IContentDialog = @ptrCast(self);
        return try this.putSecondaryButtonText(value);
    }
    pub fn getPrimaryButtonCommand(self: *@This()) core.HResult!*ICommand {
        const this: *IContentDialog = @ptrCast(self);
        return try this.getPrimaryButtonCommand();
    }
    pub fn putPrimaryButtonCommand(self: *@This(), value: *ICommand) core.HResult!void {
        const this: *IContentDialog = @ptrCast(self);
        return try this.putPrimaryButtonCommand(value);
    }
    pub fn getSecondaryButtonCommand(self: *@This()) core.HResult!*ICommand {
        const this: *IContentDialog = @ptrCast(self);
        return try this.getSecondaryButtonCommand();
    }
    pub fn putSecondaryButtonCommand(self: *@This(), value: *ICommand) core.HResult!void {
        const this: *IContentDialog = @ptrCast(self);
        return try this.putSecondaryButtonCommand(value);
    }
    pub fn getPrimaryButtonCommandParameter(self: *@This()) core.HResult!*IInspectable {
        const this: *IContentDialog = @ptrCast(self);
        return try this.getPrimaryButtonCommandParameter();
    }
    pub fn putPrimaryButtonCommandParameter(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IContentDialog = @ptrCast(self);
        return try this.putPrimaryButtonCommandParameter(value);
    }
    pub fn getSecondaryButtonCommandParameter(self: *@This()) core.HResult!*IInspectable {
        const this: *IContentDialog = @ptrCast(self);
        return try this.getSecondaryButtonCommandParameter();
    }
    pub fn putSecondaryButtonCommandParameter(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IContentDialog = @ptrCast(self);
        return try this.putSecondaryButtonCommandParameter(value);
    }
    pub fn getIsPrimaryButtonEnabled(self: *@This()) core.HResult!bool {
        const this: *IContentDialog = @ptrCast(self);
        return try this.getIsPrimaryButtonEnabled();
    }
    pub fn putIsPrimaryButtonEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IContentDialog = @ptrCast(self);
        return try this.putIsPrimaryButtonEnabled(value);
    }
    pub fn getIsSecondaryButtonEnabled(self: *@This()) core.HResult!bool {
        const this: *IContentDialog = @ptrCast(self);
        return try this.getIsSecondaryButtonEnabled();
    }
    pub fn putIsSecondaryButtonEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IContentDialog = @ptrCast(self);
        return try this.putIsSecondaryButtonEnabled(value);
    }
    pub fn addClosing(self: *@This(), handler: *TypedEventHandler(ContentDialog,ContentDialogClosingEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IContentDialog = @ptrCast(self);
        return try this.addClosing(handler);
    }
    pub fn removeClosing(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IContentDialog = @ptrCast(self);
        return try this.removeClosing(token);
    }
    pub fn addClosed(self: *@This(), handler: *TypedEventHandler(ContentDialog,ContentDialogClosedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IContentDialog = @ptrCast(self);
        return try this.addClosed(handler);
    }
    pub fn removeClosed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IContentDialog = @ptrCast(self);
        return try this.removeClosed(token);
    }
    pub fn addOpened(self: *@This(), handler: *TypedEventHandler(ContentDialog,ContentDialogOpenedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IContentDialog = @ptrCast(self);
        return try this.addOpened(handler);
    }
    pub fn removeOpened(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IContentDialog = @ptrCast(self);
        return try this.removeOpened(token);
    }
    pub fn addPrimaryButtonClick(self: *@This(), handler: *TypedEventHandler(ContentDialog,ContentDialogButtonClickEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IContentDialog = @ptrCast(self);
        return try this.addPrimaryButtonClick(handler);
    }
    pub fn removePrimaryButtonClick(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IContentDialog = @ptrCast(self);
        return try this.removePrimaryButtonClick(token);
    }
    pub fn addSecondaryButtonClick(self: *@This(), handler: *TypedEventHandler(ContentDialog,ContentDialogButtonClickEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IContentDialog = @ptrCast(self);
        return try this.addSecondaryButtonClick(handler);
    }
    pub fn removeSecondaryButtonClick(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IContentDialog = @ptrCast(self);
        return try this.removeSecondaryButtonClick(token);
    }
    pub fn Hide(self: *@This()) core.HResult!void {
        const this: *IContentDialog = @ptrCast(self);
        return try this.Hide();
    }
    pub fn ShowAsync(self: *@This()) core.HResult!*IAsyncOperation(ContentDialogResult) {
        const this: *IContentDialog = @ptrCast(self);
        return try this.ShowAsync();
    }
    pub fn getCloseButtonText(self: *@This()) core.HResult!HSTRING {
        var this: ?*IContentDialog2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentDialog2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCloseButtonText();
    }
    pub fn putCloseButtonText(self: *@This(), value: HSTRING) core.HResult!void {
        var this: ?*IContentDialog2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentDialog2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putCloseButtonText(value);
    }
    pub fn getCloseButtonCommand(self: *@This()) core.HResult!*ICommand {
        var this: ?*IContentDialog2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentDialog2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCloseButtonCommand();
    }
    pub fn putCloseButtonCommand(self: *@This(), value: *ICommand) core.HResult!void {
        var this: ?*IContentDialog2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentDialog2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putCloseButtonCommand(value);
    }
    pub fn getCloseButtonCommandParameter(self: *@This()) core.HResult!*IInspectable {
        var this: ?*IContentDialog2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentDialog2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCloseButtonCommandParameter();
    }
    pub fn putCloseButtonCommandParameter(self: *@This(), value: *IInspectable) core.HResult!void {
        var this: ?*IContentDialog2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentDialog2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putCloseButtonCommandParameter(value);
    }
    pub fn getPrimaryButtonStyle(self: *@This()) core.HResult!*Style {
        var this: ?*IContentDialog2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentDialog2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getPrimaryButtonStyle();
    }
    pub fn putPrimaryButtonStyle(self: *@This(), value: *Style) core.HResult!void {
        var this: ?*IContentDialog2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentDialog2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putPrimaryButtonStyle(value);
    }
    pub fn getSecondaryButtonStyle(self: *@This()) core.HResult!*Style {
        var this: ?*IContentDialog2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentDialog2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSecondaryButtonStyle();
    }
    pub fn putSecondaryButtonStyle(self: *@This(), value: *Style) core.HResult!void {
        var this: ?*IContentDialog2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentDialog2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSecondaryButtonStyle(value);
    }
    pub fn getCloseButtonStyle(self: *@This()) core.HResult!*Style {
        var this: ?*IContentDialog2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentDialog2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCloseButtonStyle();
    }
    pub fn putCloseButtonStyle(self: *@This(), value: *Style) core.HResult!void {
        var this: ?*IContentDialog2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentDialog2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putCloseButtonStyle(value);
    }
    pub fn getDefaultButton(self: *@This()) core.HResult!ContentDialogButton {
        var this: ?*IContentDialog2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentDialog2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDefaultButton();
    }
    pub fn putDefaultButton(self: *@This(), value: ContentDialogButton) core.HResult!void {
        var this: ?*IContentDialog2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentDialog2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putDefaultButton(value);
    }
    pub fn addCloseButtonClick(self: *@This(), handler: *TypedEventHandler(ContentDialog,ContentDialogButtonClickEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IContentDialog2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentDialog2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addCloseButtonClick(handler);
    }
    pub fn removeCloseButtonClick(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IContentDialog2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentDialog2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeCloseButtonClick(token);
    }
    pub fn ShowAsyncWithPlacement(self: *@This(), placement: ContentDialogPlacement) core.HResult!*IAsyncOperation(ContentDialogResult) {
        var this: ?*IContentDialog3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentDialog3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.ShowAsyncWithPlacement(placement);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getTitleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentDialogStaticsCache.get();
        return try _f.getTitleProperty();
    }
    pub fn getTitleTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentDialogStaticsCache.get();
        return try _f.getTitleTemplateProperty();
    }
    pub fn getFullSizeDesiredProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentDialogStaticsCache.get();
        return try _f.getFullSizeDesiredProperty();
    }
    pub fn getPrimaryButtonTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentDialogStaticsCache.get();
        return try _f.getPrimaryButtonTextProperty();
    }
    pub fn getSecondaryButtonTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentDialogStaticsCache.get();
        return try _f.getSecondaryButtonTextProperty();
    }
    pub fn getPrimaryButtonCommandProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentDialogStaticsCache.get();
        return try _f.getPrimaryButtonCommandProperty();
    }
    pub fn getSecondaryButtonCommandProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentDialogStaticsCache.get();
        return try _f.getSecondaryButtonCommandProperty();
    }
    pub fn getPrimaryButtonCommandParameterProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentDialogStaticsCache.get();
        return try _f.getPrimaryButtonCommandParameterProperty();
    }
    pub fn getSecondaryButtonCommandParameterProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentDialogStaticsCache.get();
        return try _f.getSecondaryButtonCommandParameterProperty();
    }
    pub fn getIsPrimaryButtonEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentDialogStaticsCache.get();
        return try _f.getIsPrimaryButtonEnabledProperty();
    }
    pub fn getIsSecondaryButtonEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentDialogStaticsCache.get();
        return try _f.getIsSecondaryButtonEnabledProperty();
    }
    pub fn getCloseButtonTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentDialogStatics2Cache.get();
        return try _f.getCloseButtonTextProperty();
    }
    pub fn getCloseButtonCommandProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentDialogStatics2Cache.get();
        return try _f.getCloseButtonCommandProperty();
    }
    pub fn getCloseButtonCommandParameterProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentDialogStatics2Cache.get();
        return try _f.getCloseButtonCommandParameterProperty();
    }
    pub fn getPrimaryButtonStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentDialogStatics2Cache.get();
        return try _f.getPrimaryButtonStyleProperty();
    }
    pub fn getSecondaryButtonStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentDialogStatics2Cache.get();
        return try _f.getSecondaryButtonStyleProperty();
    }
    pub fn getCloseButtonStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentDialogStatics2Cache.get();
        return try _f.getCloseButtonStyleProperty();
    }
    pub fn getDefaultButtonProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentDialogStatics2Cache.get();
        return try _f.getDefaultButtonProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ContentDialog {
        const _f = @This().IContentDialogFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ContentDialog";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IContentDialog.GUID;
    pub const IID: Guid = IContentDialog.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IContentDialog.SIGNATURE);
    var _IContentDialogStaticsCache: FactoryCache(IContentDialogStatics, RUNTIME_NAME) = .{};
    var _IContentDialogStatics2Cache: FactoryCache(IContentDialogStatics2, RUNTIME_NAME) = .{};
    var _IContentDialogFactoryCache: FactoryCache(IContentDialogFactory, RUNTIME_NAME) = .{};
};
pub const ContentDialogButton = enum(i32) {
    None = 0,
    Primary = 1,
    Secondary = 2,
    Close = 3,
};
pub const ContentDialogButtonClickDeferral = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn Complete(self: *@This()) core.HResult!void {
        const this: *IContentDialogButtonClickDeferral = @ptrCast(self);
        return try this.Complete();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ContentDialogButtonClickDeferral";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IContentDialogButtonClickDeferral.GUID;
    pub const IID: Guid = IContentDialogButtonClickDeferral.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IContentDialogButtonClickDeferral.SIGNATURE);
};
pub const ContentDialogButtonClickEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getCancel(self: *@This()) core.HResult!bool {
        const this: *IContentDialogButtonClickEventArgs = @ptrCast(self);
        return try this.getCancel();
    }
    pub fn putCancel(self: *@This(), value: bool) core.HResult!void {
        const this: *IContentDialogButtonClickEventArgs = @ptrCast(self);
        return try this.putCancel(value);
    }
    pub fn GetDeferral(self: *@This()) core.HResult!*ContentDialogButtonClickDeferral {
        const this: *IContentDialogButtonClickEventArgs = @ptrCast(self);
        return try this.GetDeferral();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ContentDialogButtonClickEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IContentDialogButtonClickEventArgs.GUID;
    pub const IID: Guid = IContentDialogButtonClickEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IContentDialogButtonClickEventArgs.SIGNATURE);
};
pub const ContentDialogClosedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getResult(self: *@This()) core.HResult!ContentDialogResult {
        const this: *IContentDialogClosedEventArgs = @ptrCast(self);
        return try this.getResult();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ContentDialogClosedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IContentDialogClosedEventArgs.GUID;
    pub const IID: Guid = IContentDialogClosedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IContentDialogClosedEventArgs.SIGNATURE);
};
pub const ContentDialogClosingDeferral = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn Complete(self: *@This()) core.HResult!void {
        const this: *IContentDialogClosingDeferral = @ptrCast(self);
        return try this.Complete();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ContentDialogClosingDeferral";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IContentDialogClosingDeferral.GUID;
    pub const IID: Guid = IContentDialogClosingDeferral.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IContentDialogClosingDeferral.SIGNATURE);
};
pub const ContentDialogClosingEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getResult(self: *@This()) core.HResult!ContentDialogResult {
        const this: *IContentDialogClosingEventArgs = @ptrCast(self);
        return try this.getResult();
    }
    pub fn getCancel(self: *@This()) core.HResult!bool {
        const this: *IContentDialogClosingEventArgs = @ptrCast(self);
        return try this.getCancel();
    }
    pub fn putCancel(self: *@This(), value: bool) core.HResult!void {
        const this: *IContentDialogClosingEventArgs = @ptrCast(self);
        return try this.putCancel(value);
    }
    pub fn GetDeferral(self: *@This()) core.HResult!*ContentDialogClosingDeferral {
        const this: *IContentDialogClosingEventArgs = @ptrCast(self);
        return try this.GetDeferral();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ContentDialogClosingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IContentDialogClosingEventArgs.GUID;
    pub const IID: Guid = IContentDialogClosingEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IContentDialogClosingEventArgs.SIGNATURE);
};
pub const ContentDialogOpenedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ContentDialogOpenedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IContentDialogOpenedEventArgs.GUID;
    pub const IID: Guid = IContentDialogOpenedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IContentDialogOpenedEventArgs.SIGNATURE);
};
pub const ContentDialogPlacement = enum(i32) {
    Popup = 0,
    InPlace = 1,
};
pub const ContentDialogResult = enum(i32) {
    None = 0,
    Primary = 1,
    Secondary = 2,
};
pub const ContentLinkChangeKind = enum(i32) {
    Inserted = 0,
    Removed = 1,
    Edited = 2,
};
pub const ContentLinkChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getChangeKind(self: *@This()) core.HResult!ContentLinkChangeKind {
        const this: *IContentLinkChangedEventArgs = @ptrCast(self);
        return try this.getChangeKind();
    }
    pub fn getContentLinkInfo(self: *@This()) core.HResult!*ContentLinkInfo {
        const this: *IContentLinkChangedEventArgs = @ptrCast(self);
        return try this.getContentLinkInfo();
    }
    pub fn getTextRange(self: *@This()) core.HResult!TextRange {
        const this: *IContentLinkChangedEventArgs = @ptrCast(self);
        return try this.getTextRange();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ContentLinkChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IContentLinkChangedEventArgs.GUID;
    pub const IID: Guid = IContentLinkChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IContentLinkChangedEventArgs.SIGNATURE);
};
pub const ContentPresenter = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getContent(self: *@This()) core.HResult!*IInspectable {
        const this: *IContentPresenter = @ptrCast(self);
        return try this.getContent();
    }
    pub fn putContent(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IContentPresenter = @ptrCast(self);
        return try this.putContent(value);
    }
    pub fn getContentTemplate(self: *@This()) core.HResult!*DataTemplate {
        const this: *IContentPresenter = @ptrCast(self);
        return try this.getContentTemplate();
    }
    pub fn putContentTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const this: *IContentPresenter = @ptrCast(self);
        return try this.putContentTemplate(value);
    }
    pub fn getContentTemplateSelector(self: *@This()) core.HResult!*DataTemplateSelector {
        const this: *IContentPresenter = @ptrCast(self);
        return try this.getContentTemplateSelector();
    }
    pub fn putContentTemplateSelector(self: *@This(), value: *DataTemplateSelector) core.HResult!void {
        const this: *IContentPresenter = @ptrCast(self);
        return try this.putContentTemplateSelector(value);
    }
    pub fn getContentTransitions(self: *@This()) core.HResult!*TransitionCollection {
        const this: *IContentPresenter = @ptrCast(self);
        return try this.getContentTransitions();
    }
    pub fn putContentTransitions(self: *@This(), value: *TransitionCollection) core.HResult!void {
        const this: *IContentPresenter = @ptrCast(self);
        return try this.putContentTransitions(value);
    }
    pub fn getFontSize(self: *@This()) core.HResult!f64 {
        const this: *IContentPresenter = @ptrCast(self);
        return try this.getFontSize();
    }
    pub fn putFontSize(self: *@This(), value: f64) core.HResult!void {
        const this: *IContentPresenter = @ptrCast(self);
        return try this.putFontSize(value);
    }
    pub fn getFontFamily(self: *@This()) core.HResult!*FontFamily {
        const this: *IContentPresenter = @ptrCast(self);
        return try this.getFontFamily();
    }
    pub fn putFontFamily(self: *@This(), value: *FontFamily) core.HResult!void {
        const this: *IContentPresenter = @ptrCast(self);
        return try this.putFontFamily(value);
    }
    pub fn getFontWeight(self: *@This()) core.HResult!FontWeight {
        const this: *IContentPresenter = @ptrCast(self);
        return try this.getFontWeight();
    }
    pub fn putFontWeight(self: *@This(), value: FontWeight) core.HResult!void {
        const this: *IContentPresenter = @ptrCast(self);
        return try this.putFontWeight(value);
    }
    pub fn getFontStyle(self: *@This()) core.HResult!FontStyle {
        const this: *IContentPresenter = @ptrCast(self);
        return try this.getFontStyle();
    }
    pub fn putFontStyle(self: *@This(), value: FontStyle) core.HResult!void {
        const this: *IContentPresenter = @ptrCast(self);
        return try this.putFontStyle(value);
    }
    pub fn getFontStretch(self: *@This()) core.HResult!FontStretch {
        const this: *IContentPresenter = @ptrCast(self);
        return try this.getFontStretch();
    }
    pub fn putFontStretch(self: *@This(), value: FontStretch) core.HResult!void {
        const this: *IContentPresenter = @ptrCast(self);
        return try this.putFontStretch(value);
    }
    pub fn getCharacterSpacing(self: *@This()) core.HResult!i32 {
        const this: *IContentPresenter = @ptrCast(self);
        return try this.getCharacterSpacing();
    }
    pub fn putCharacterSpacing(self: *@This(), value: i32) core.HResult!void {
        const this: *IContentPresenter = @ptrCast(self);
        return try this.putCharacterSpacing(value);
    }
    pub fn getForeground(self: *@This()) core.HResult!*Brush {
        const this: *IContentPresenter = @ptrCast(self);
        return try this.getForeground();
    }
    pub fn putForeground(self: *@This(), value: *Brush) core.HResult!void {
        const this: *IContentPresenter = @ptrCast(self);
        return try this.putForeground(value);
    }
    pub fn getOpticalMarginAlignment(self: *@This()) core.HResult!OpticalMarginAlignment {
        var this: ?*IContentPresenter2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getOpticalMarginAlignment();
    }
    pub fn putOpticalMarginAlignment(self: *@This(), value: OpticalMarginAlignment) core.HResult!void {
        var this: ?*IContentPresenter2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putOpticalMarginAlignment(value);
    }
    pub fn getTextLineBounds(self: *@This()) core.HResult!TextLineBounds {
        var this: ?*IContentPresenter2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTextLineBounds();
    }
    pub fn putTextLineBounds(self: *@This(), value: TextLineBounds) core.HResult!void {
        var this: ?*IContentPresenter2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTextLineBounds(value);
    }
    pub fn getIsTextScaleFactorEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IContentPresenter3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsTextScaleFactorEnabled();
    }
    pub fn putIsTextScaleFactorEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IContentPresenter3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsTextScaleFactorEnabled(value);
    }
    pub fn getTextWrapping(self: *@This()) core.HResult!TextWrapping {
        var this: ?*IContentPresenter4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTextWrapping();
    }
    pub fn putTextWrapping(self: *@This(), value: TextWrapping) core.HResult!void {
        var this: ?*IContentPresenter4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTextWrapping(value);
    }
    pub fn getMaxLines(self: *@This()) core.HResult!i32 {
        var this: ?*IContentPresenter4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getMaxLines();
    }
    pub fn putMaxLines(self: *@This(), value: i32) core.HResult!void {
        var this: ?*IContentPresenter4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putMaxLines(value);
    }
    pub fn getLineStackingStrategy(self: *@This()) core.HResult!LineStackingStrategy {
        var this: ?*IContentPresenter4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getLineStackingStrategy();
    }
    pub fn putLineStackingStrategy(self: *@This(), value: LineStackingStrategy) core.HResult!void {
        var this: ?*IContentPresenter4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putLineStackingStrategy(value);
    }
    pub fn getLineHeight(self: *@This()) core.HResult!f64 {
        var this: ?*IContentPresenter4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getLineHeight();
    }
    pub fn putLineHeight(self: *@This(), value: f64) core.HResult!void {
        var this: ?*IContentPresenter4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putLineHeight(value);
    }
    pub fn getBorderBrush(self: *@This()) core.HResult!*Brush {
        var this: ?*IContentPresenter4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getBorderBrush();
    }
    pub fn putBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*IContentPresenter4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putBorderBrush(value);
    }
    pub fn getBorderThickness(self: *@This()) core.HResult!Thickness {
        var this: ?*IContentPresenter4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getBorderThickness();
    }
    pub fn putBorderThickness(self: *@This(), value: Thickness) core.HResult!void {
        var this: ?*IContentPresenter4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putBorderThickness(value);
    }
    pub fn getCornerRadius(self: *@This()) core.HResult!CornerRadius {
        var this: ?*IContentPresenter4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCornerRadius();
    }
    pub fn putCornerRadius(self: *@This(), value: CornerRadius) core.HResult!void {
        var this: ?*IContentPresenter4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putCornerRadius(value);
    }
    pub fn getPadding(self: *@This()) core.HResult!Thickness {
        var this: ?*IContentPresenter4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getPadding();
    }
    pub fn putPadding(self: *@This(), value: Thickness) core.HResult!void {
        var this: ?*IContentPresenter4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putPadding(value);
    }
    pub fn getBackground(self: *@This()) core.HResult!*Brush {
        var this: ?*IContentPresenter4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getBackground();
    }
    pub fn putBackground(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*IContentPresenter4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putBackground(value);
    }
    pub fn getHorizontalContentAlignment(self: *@This()) core.HResult!HorizontalAlignment {
        var this: ?*IContentPresenter4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getHorizontalContentAlignment();
    }
    pub fn putHorizontalContentAlignment(self: *@This(), value: HorizontalAlignment) core.HResult!void {
        var this: ?*IContentPresenter4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putHorizontalContentAlignment(value);
    }
    pub fn getVerticalContentAlignment(self: *@This()) core.HResult!VerticalAlignment {
        var this: ?*IContentPresenter4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getVerticalContentAlignment();
    }
    pub fn putVerticalContentAlignment(self: *@This(), value: VerticalAlignment) core.HResult!void {
        var this: ?*IContentPresenter4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putVerticalContentAlignment(value);
    }
    pub fn getBackgroundTransition(self: *@This()) core.HResult!*BrushTransition {
        var this: ?*IContentPresenter5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getBackgroundTransition();
    }
    pub fn putBackgroundTransition(self: *@This(), value: *BrushTransition) core.HResult!void {
        var this: ?*IContentPresenter5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putBackgroundTransition(value);
    }
    pub fn getBackgroundSizing(self: *@This()) core.HResult!BackgroundSizing {
        var this: ?*IContentPresenter5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getBackgroundSizing();
    }
    pub fn putBackgroundSizing(self: *@This(), value: BackgroundSizing) core.HResult!void {
        var this: ?*IContentPresenter5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenter5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putBackgroundSizing(value);
    }
    pub fn OnContentTemplateChanged(self: *@This(), oldContentTemplate: *DataTemplate, newContentTemplate: *DataTemplate) core.HResult!void {
        var this: ?*IContentPresenterOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenterOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnContentTemplateChanged(oldContentTemplate, newContentTemplate);
    }
    pub fn OnContentTemplateSelectorChanged(self: *@This(), oldContentTemplateSelector: *DataTemplateSelector, newContentTemplateSelector: *DataTemplateSelector) core.HResult!void {
        var this: ?*IContentPresenterOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IContentPresenterOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnContentTemplateSelectorChanged(oldContentTemplateSelector, newContentTemplateSelector);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getTextWrappingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStatics4Cache.get();
        return try _f.getTextWrappingProperty();
    }
    pub fn getMaxLinesProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStatics4Cache.get();
        return try _f.getMaxLinesProperty();
    }
    pub fn getLineStackingStrategyProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStatics4Cache.get();
        return try _f.getLineStackingStrategyProperty();
    }
    pub fn getLineHeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStatics4Cache.get();
        return try _f.getLineHeightProperty();
    }
    pub fn getBorderBrushProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStatics4Cache.get();
        return try _f.getBorderBrushProperty();
    }
    pub fn getBorderThicknessProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStatics4Cache.get();
        return try _f.getBorderThicknessProperty();
    }
    pub fn getCornerRadiusProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStatics4Cache.get();
        return try _f.getCornerRadiusProperty();
    }
    pub fn getPaddingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStatics4Cache.get();
        return try _f.getPaddingProperty();
    }
    pub fn getBackgroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStatics4Cache.get();
        return try _f.getBackgroundProperty();
    }
    pub fn getHorizontalContentAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStatics4Cache.get();
        return try _f.getHorizontalContentAlignmentProperty();
    }
    pub fn getVerticalContentAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStatics4Cache.get();
        return try _f.getVerticalContentAlignmentProperty();
    }
    pub fn getContentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStaticsCache.get();
        return try _f.getContentProperty();
    }
    pub fn getContentTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStaticsCache.get();
        return try _f.getContentTemplateProperty();
    }
    pub fn getContentTemplateSelectorProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStaticsCache.get();
        return try _f.getContentTemplateSelectorProperty();
    }
    pub fn getContentTransitionsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStaticsCache.get();
        return try _f.getContentTransitionsProperty();
    }
    pub fn getFontSizeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStaticsCache.get();
        return try _f.getFontSizeProperty();
    }
    pub fn getFontFamilyProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStaticsCache.get();
        return try _f.getFontFamilyProperty();
    }
    pub fn getFontWeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStaticsCache.get();
        return try _f.getFontWeightProperty();
    }
    pub fn getFontStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStaticsCache.get();
        return try _f.getFontStyleProperty();
    }
    pub fn getFontStretchProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStaticsCache.get();
        return try _f.getFontStretchProperty();
    }
    pub fn getCharacterSpacingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStaticsCache.get();
        return try _f.getCharacterSpacingProperty();
    }
    pub fn getForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStaticsCache.get();
        return try _f.getForegroundProperty();
    }
    pub fn getBackgroundSizingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStatics5Cache.get();
        return try _f.getBackgroundSizingProperty();
    }
    pub fn getIsTextScaleFactorEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStatics3Cache.get();
        return try _f.getIsTextScaleFactorEnabledProperty();
    }
    pub fn getOpticalMarginAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStatics2Cache.get();
        return try _f.getOpticalMarginAlignmentProperty();
    }
    pub fn getTextLineBoundsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IContentPresenterStatics2Cache.get();
        return try _f.getTextLineBoundsProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ContentPresenter {
        const _f = @This().IContentPresenterFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ContentPresenter";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IContentPresenter.GUID;
    pub const IID: Guid = IContentPresenter.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IContentPresenter.SIGNATURE);
    var _IContentPresenterStatics4Cache: FactoryCache(IContentPresenterStatics4, RUNTIME_NAME) = .{};
    var _IContentPresenterStaticsCache: FactoryCache(IContentPresenterStatics, RUNTIME_NAME) = .{};
    var _IContentPresenterStatics5Cache: FactoryCache(IContentPresenterStatics5, RUNTIME_NAME) = .{};
    var _IContentPresenterStatics3Cache: FactoryCache(IContentPresenterStatics3, RUNTIME_NAME) = .{};
    var _IContentPresenterStatics2Cache: FactoryCache(IContentPresenterStatics2, RUNTIME_NAME) = .{};
    var _IContentPresenterFactoryCache: FactoryCache(IContentPresenterFactory, RUNTIME_NAME) = .{};
};
pub const ContextMenuEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getHandled(self: *@This()) core.HResult!bool {
        const this: *IContextMenuEventArgs = @ptrCast(self);
        return try this.getHandled();
    }
    pub fn putHandled(self: *@This(), value: bool) core.HResult!void {
        const this: *IContextMenuEventArgs = @ptrCast(self);
        return try this.putHandled(value);
    }
    pub fn getCursorLeft(self: *@This()) core.HResult!f64 {
        const this: *IContextMenuEventArgs = @ptrCast(self);
        return try this.getCursorLeft();
    }
    pub fn getCursorTop(self: *@This()) core.HResult!f64 {
        const this: *IContextMenuEventArgs = @ptrCast(self);
        return try this.getCursorTop();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ContextMenuEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IContextMenuEventArgs.GUID;
    pub const IID: Guid = IContextMenuEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IContextMenuEventArgs.SIGNATURE);
};
pub const ContextMenuOpeningEventHandler = extern struct {
    vtable: *const VTable,
    _refs: @import("std").atomic.Value(u32),
    _cb: *const fn (context: ?*anyopaque) callconv(.winapi) void,
    _context: ?*anyopaque = null,
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn init(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *ContextMenuEventArgs) callconv(.winapi) void,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
        };
        return _r;
    }
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn initWithState(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *ContextMenuEventArgs) callconv(.winapi) void,
        context: anytype,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
            ._context = @ptrCast(context),
        };
        return _r;
    }
    /// This calls Release and voids the returned ref count. If ref count is 0 the memory is released,
    /// Otherwise the memory stays until all references are released, including all references Windows holds.
    ///
    /// The caller *MUST* always call deinit/Release at least once for every AddRef and init called.
    pub fn deinit(self: *@This()) void {
        _ = Release(@ptrCast(self));
    }
    fn QueryInterface(self: *anyopaque, riid: *const Guid, out: *?*anyopaque) callconv(.c) HRESULT {
        const me: *@This() = @ptrCast(@alignCast(self));
        // TODO: Handle IMarshal
        if (core.wiredGuidEql(riid, &IID) or
            core.wiredGuidEql(riid, &IUnknown.IID) or
            core.wiredGuidEql(riid, &IAgileObject.IID))
        {
            out.* = @as(?*anyopaque, @ptrCast(me));
            _ = AddRef(self);
            return 0;
        }
        out.* = null;
        return -2147467262; // E_NOINTERFACE
    }
    fn AddRef(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        return this._refs.fetchAdd(1, .monotonic) + 1;
    }
    fn Release(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        const left = this._refs.fetchSub(1, .acq_rel) - 1;
        if (left == 0) @import("std").heap.c_allocator.destroy(this);
        return left;
    }
    pub fn Invoke(self: *anyopaque, sender: *IInspectable, e: *ContextMenuEventArgs) callconv(.winapi) HRESULT {
        const this: *@This() = @ptrCast(@alignCast(self));
        this._cb(this._context, sender, e);
        return 0;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "df945151-745c-4446-b2fc-216d765847a0";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.pinterface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        Invoke: *const fn(self: *anyopaque, sender: *IInspectable, e: *ContextMenuEventArgs) callconv(.winapi) HRESULT
    };
    pub const VTABLE = VTable {
        .QueryInterface = QueryInterface,
        .AddRef = AddRef,
        .Release = Release,
        .Invoke = Invoke,
    };
};
pub const ControlTemplate = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getTargetType(self: *@This()) core.HResult!TypeName {
        const this: *IControlTemplate = @ptrCast(self);
        return try this.getTargetType();
    }
    pub fn putTargetType(self: *@This(), value: TypeName) core.HResult!void {
        const this: *IControlTemplate = @ptrCast(self);
        return try this.putTargetType(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IControlTemplate.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ControlTemplate";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IControlTemplate.GUID;
    pub const IID: Guid = IControlTemplate.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IControlTemplate.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const DataTemplateSelector = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn SelectTemplateWithContainer(self: *@This(), item: *IInspectable, container: *DependencyObject) core.HResult!*DataTemplate {
        const this: *IDataTemplateSelector = @ptrCast(self);
        return try this.SelectTemplateWithContainer(item, container);
    }
    pub fn SelectTemplate(self: *@This(), item: *IInspectable) core.HResult!*DataTemplate {
        var this: ?*IDataTemplateSelector2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IDataTemplateSelector2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.SelectTemplate(item);
    }
    pub fn SelectTemplateCoreWithContainer(self: *@This(), item: *IInspectable, container: *DependencyObject) core.HResult!*DataTemplate {
        var this: ?*IDataTemplateSelectorOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IDataTemplateSelectorOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.SelectTemplateCoreWithContainer(item, container);
    }
    pub fn SelectTemplateCore(self: *@This(), item: *IInspectable) core.HResult!*DataTemplate {
        var this: ?*IDataTemplateSelectorOverrides2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IDataTemplateSelectorOverrides2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.SelectTemplateCore(item);
    }
    pub fn GetElement(self: *@This(), args: *ElementFactoryGetArgs) core.HResult!*UIElement {
        var this: ?*IElementFactory = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IElementFactory.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GetElement(args);
    }
    pub fn RecycleElement(self: *@This(), args: *ElementFactoryRecycleArgs) core.HResult!void {
        var this: ?*IElementFactory = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IElementFactory.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.RecycleElement(args);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*DataTemplateSelector {
        const _f = @This().IDataTemplateSelectorFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.DataTemplateSelector";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IDataTemplateSelector.GUID;
    pub const IID: Guid = IDataTemplateSelector.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IDataTemplateSelector.SIGNATURE);
    var _IDataTemplateSelectorFactoryCache: FactoryCache(IDataTemplateSelectorFactory, RUNTIME_NAME) = .{};
};
pub const DatePickedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getOldDate(self: *@This()) core.HResult!DateTime {
        const this: *IDatePickedEventArgs = @ptrCast(self);
        return try this.getOldDate();
    }
    pub fn getNewDate(self: *@This()) core.HResult!DateTime {
        const this: *IDatePickedEventArgs = @ptrCast(self);
        return try this.getNewDate();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IDatePickedEventArgs.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.DatePickedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IDatePickedEventArgs.GUID;
    pub const IID: Guid = IDatePickedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IDatePickedEventArgs.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const DatePicker = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        const this: *IDatePicker = @ptrCast(self);
        return try this.getHeader();
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IDatePicker = @ptrCast(self);
        return try this.putHeader(value);
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        const this: *IDatePicker = @ptrCast(self);
        return try this.getHeaderTemplate();
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const this: *IDatePicker = @ptrCast(self);
        return try this.putHeaderTemplate(value);
    }
    pub fn getCalendarIdentifier(self: *@This()) core.HResult!HSTRING {
        const this: *IDatePicker = @ptrCast(self);
        return try this.getCalendarIdentifier();
    }
    pub fn putCalendarIdentifier(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IDatePicker = @ptrCast(self);
        return try this.putCalendarIdentifier(value);
    }
    pub fn getDate(self: *@This()) core.HResult!DateTime {
        const this: *IDatePicker = @ptrCast(self);
        return try this.getDate();
    }
    pub fn putDate(self: *@This(), value: DateTime) core.HResult!void {
        const this: *IDatePicker = @ptrCast(self);
        return try this.putDate(value);
    }
    pub fn getDayVisible(self: *@This()) core.HResult!bool {
        const this: *IDatePicker = @ptrCast(self);
        return try this.getDayVisible();
    }
    pub fn putDayVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IDatePicker = @ptrCast(self);
        return try this.putDayVisible(value);
    }
    pub fn getMonthVisible(self: *@This()) core.HResult!bool {
        const this: *IDatePicker = @ptrCast(self);
        return try this.getMonthVisible();
    }
    pub fn putMonthVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IDatePicker = @ptrCast(self);
        return try this.putMonthVisible(value);
    }
    pub fn getYearVisible(self: *@This()) core.HResult!bool {
        const this: *IDatePicker = @ptrCast(self);
        return try this.getYearVisible();
    }
    pub fn putYearVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IDatePicker = @ptrCast(self);
        return try this.putYearVisible(value);
    }
    pub fn getDayFormat(self: *@This()) core.HResult!HSTRING {
        const this: *IDatePicker = @ptrCast(self);
        return try this.getDayFormat();
    }
    pub fn putDayFormat(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IDatePicker = @ptrCast(self);
        return try this.putDayFormat(value);
    }
    pub fn getMonthFormat(self: *@This()) core.HResult!HSTRING {
        const this: *IDatePicker = @ptrCast(self);
        return try this.getMonthFormat();
    }
    pub fn putMonthFormat(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IDatePicker = @ptrCast(self);
        return try this.putMonthFormat(value);
    }
    pub fn getYearFormat(self: *@This()) core.HResult!HSTRING {
        const this: *IDatePicker = @ptrCast(self);
        return try this.getYearFormat();
    }
    pub fn putYearFormat(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IDatePicker = @ptrCast(self);
        return try this.putYearFormat(value);
    }
    pub fn getMinYear(self: *@This()) core.HResult!DateTime {
        const this: *IDatePicker = @ptrCast(self);
        return try this.getMinYear();
    }
    pub fn putMinYear(self: *@This(), value: DateTime) core.HResult!void {
        const this: *IDatePicker = @ptrCast(self);
        return try this.putMinYear(value);
    }
    pub fn getMaxYear(self: *@This()) core.HResult!DateTime {
        const this: *IDatePicker = @ptrCast(self);
        return try this.getMaxYear();
    }
    pub fn putMaxYear(self: *@This(), value: DateTime) core.HResult!void {
        const this: *IDatePicker = @ptrCast(self);
        return try this.putMaxYear(value);
    }
    pub fn getOrientation(self: *@This()) core.HResult!Orientation {
        const this: *IDatePicker = @ptrCast(self);
        return try this.getOrientation();
    }
    pub fn putOrientation(self: *@This(), value: Orientation) core.HResult!void {
        const this: *IDatePicker = @ptrCast(self);
        return try this.putOrientation(value);
    }
    pub fn addDateChanged(self: *@This(), handler: *EventHandler(DatePickerValueChangedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IDatePicker = @ptrCast(self);
        return try this.addDateChanged(handler);
    }
    pub fn removeDateChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IDatePicker = @ptrCast(self);
        return try this.removeDateChanged(token);
    }
    pub fn getLightDismissOverlayMode(self: *@This()) core.HResult!LightDismissOverlayMode {
        var this: ?*IDatePicker2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IDatePicker2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getLightDismissOverlayMode();
    }
    pub fn putLightDismissOverlayMode(self: *@This(), value: LightDismissOverlayMode) core.HResult!void {
        var this: ?*IDatePicker2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IDatePicker2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putLightDismissOverlayMode(value);
    }
    pub fn getSelectedDate(self: *@This()) core.HResult!*IReference(DateTime) {
        var this: ?*IDatePicker3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IDatePicker3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectedDate();
    }
    pub fn putSelectedDate(self: *@This(), value: *IReference(DateTime)) core.HResult!void {
        var this: ?*IDatePicker3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IDatePicker3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSelectedDate(value);
    }
    pub fn addSelectedDateChanged(self: *@This(), handler: *TypedEventHandler(DatePicker,DatePickerSelectedValueChangedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IDatePicker3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IDatePicker3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addSelectedDateChanged(handler);
    }
    pub fn removeSelectedDateChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IDatePicker3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IDatePicker3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeSelectedDateChanged(token);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getSelectedDateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerStatics3Cache.get();
        return try _f.getSelectedDateProperty();
    }
    pub fn getHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerStaticsCache.get();
        return try _f.getHeaderProperty();
    }
    pub fn getHeaderTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerStaticsCache.get();
        return try _f.getHeaderTemplateProperty();
    }
    pub fn getCalendarIdentifierProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerStaticsCache.get();
        return try _f.getCalendarIdentifierProperty();
    }
    pub fn getDateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerStaticsCache.get();
        return try _f.getDateProperty();
    }
    pub fn getDayVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerStaticsCache.get();
        return try _f.getDayVisibleProperty();
    }
    pub fn getMonthVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerStaticsCache.get();
        return try _f.getMonthVisibleProperty();
    }
    pub fn getYearVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerStaticsCache.get();
        return try _f.getYearVisibleProperty();
    }
    pub fn getDayFormatProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerStaticsCache.get();
        return try _f.getDayFormatProperty();
    }
    pub fn getMonthFormatProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerStaticsCache.get();
        return try _f.getMonthFormatProperty();
    }
    pub fn getYearFormatProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerStaticsCache.get();
        return try _f.getYearFormatProperty();
    }
    pub fn getMinYearProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerStaticsCache.get();
        return try _f.getMinYearProperty();
    }
    pub fn getMaxYearProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerStaticsCache.get();
        return try _f.getMaxYearProperty();
    }
    pub fn getOrientationProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerStaticsCache.get();
        return try _f.getOrientationProperty();
    }
    pub fn getLightDismissOverlayModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerStatics2Cache.get();
        return try _f.getLightDismissOverlayModeProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*DatePicker {
        const _f = @This().IDatePickerFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.DatePicker";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IDatePicker.GUID;
    pub const IID: Guid = IDatePicker.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IDatePicker.SIGNATURE);
    var _IDatePickerStatics3Cache: FactoryCache(IDatePickerStatics3, RUNTIME_NAME) = .{};
    var _IDatePickerStaticsCache: FactoryCache(IDatePickerStatics, RUNTIME_NAME) = .{};
    var _IDatePickerStatics2Cache: FactoryCache(IDatePickerStatics2, RUNTIME_NAME) = .{};
    var _IDatePickerFactoryCache: FactoryCache(IDatePickerFactory, RUNTIME_NAME) = .{};
};
pub const DatePickerFlyout = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getCalendarIdentifier(self: *@This()) core.HResult!HSTRING {
        const this: *IDatePickerFlyout = @ptrCast(self);
        return try this.getCalendarIdentifier();
    }
    pub fn putCalendarIdentifier(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IDatePickerFlyout = @ptrCast(self);
        return try this.putCalendarIdentifier(value);
    }
    pub fn getDate(self: *@This()) core.HResult!DateTime {
        const this: *IDatePickerFlyout = @ptrCast(self);
        return try this.getDate();
    }
    pub fn putDate(self: *@This(), value: DateTime) core.HResult!void {
        const this: *IDatePickerFlyout = @ptrCast(self);
        return try this.putDate(value);
    }
    pub fn getDayVisible(self: *@This()) core.HResult!bool {
        const this: *IDatePickerFlyout = @ptrCast(self);
        return try this.getDayVisible();
    }
    pub fn putDayVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IDatePickerFlyout = @ptrCast(self);
        return try this.putDayVisible(value);
    }
    pub fn getMonthVisible(self: *@This()) core.HResult!bool {
        const this: *IDatePickerFlyout = @ptrCast(self);
        return try this.getMonthVisible();
    }
    pub fn putMonthVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IDatePickerFlyout = @ptrCast(self);
        return try this.putMonthVisible(value);
    }
    pub fn getYearVisible(self: *@This()) core.HResult!bool {
        const this: *IDatePickerFlyout = @ptrCast(self);
        return try this.getYearVisible();
    }
    pub fn putYearVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IDatePickerFlyout = @ptrCast(self);
        return try this.putYearVisible(value);
    }
    pub fn getMinYear(self: *@This()) core.HResult!DateTime {
        const this: *IDatePickerFlyout = @ptrCast(self);
        return try this.getMinYear();
    }
    pub fn putMinYear(self: *@This(), value: DateTime) core.HResult!void {
        const this: *IDatePickerFlyout = @ptrCast(self);
        return try this.putMinYear(value);
    }
    pub fn getMaxYear(self: *@This()) core.HResult!DateTime {
        const this: *IDatePickerFlyout = @ptrCast(self);
        return try this.getMaxYear();
    }
    pub fn putMaxYear(self: *@This(), value: DateTime) core.HResult!void {
        const this: *IDatePickerFlyout = @ptrCast(self);
        return try this.putMaxYear(value);
    }
    pub fn addDatePicked(self: *@This(), handler: *TypedEventHandler(DatePickerFlyout,DatePickedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IDatePickerFlyout = @ptrCast(self);
        return try this.addDatePicked(handler);
    }
    pub fn removeDatePicked(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IDatePickerFlyout = @ptrCast(self);
        return try this.removeDatePicked(token);
    }
    pub fn ShowAtAsync(self: *@This(), target: *FrameworkElement) core.HResult!*IAsyncOperation(IReference(DateTime)) {
        const this: *IDatePickerFlyout = @ptrCast(self);
        return try this.ShowAtAsync(target);
    }
    pub fn getDayFormat(self: *@This()) core.HResult!HSTRING {
        var this: ?*IDatePickerFlyout2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IDatePickerFlyout2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDayFormat();
    }
    pub fn putDayFormat(self: *@This(), value: HSTRING) core.HResult!void {
        var this: ?*IDatePickerFlyout2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IDatePickerFlyout2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putDayFormat(value);
    }
    pub fn getMonthFormat(self: *@This()) core.HResult!HSTRING {
        var this: ?*IDatePickerFlyout2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IDatePickerFlyout2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getMonthFormat();
    }
    pub fn putMonthFormat(self: *@This(), value: HSTRING) core.HResult!void {
        var this: ?*IDatePickerFlyout2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IDatePickerFlyout2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putMonthFormat(value);
    }
    pub fn getYearFormat(self: *@This()) core.HResult!HSTRING {
        var this: ?*IDatePickerFlyout2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IDatePickerFlyout2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getYearFormat();
    }
    pub fn putYearFormat(self: *@This(), value: HSTRING) core.HResult!void {
        var this: ?*IDatePickerFlyout2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IDatePickerFlyout2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putYearFormat(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IDatePickerFlyout.IID)));
    }
    pub fn getCalendarIdentifierProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerFlyoutStaticsCache.get();
        return try _f.getCalendarIdentifierProperty();
    }
    pub fn getDateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerFlyoutStaticsCache.get();
        return try _f.getDateProperty();
    }
    pub fn getDayVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerFlyoutStaticsCache.get();
        return try _f.getDayVisibleProperty();
    }
    pub fn getMonthVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerFlyoutStaticsCache.get();
        return try _f.getMonthVisibleProperty();
    }
    pub fn getYearVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerFlyoutStaticsCache.get();
        return try _f.getYearVisibleProperty();
    }
    pub fn getMinYearProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerFlyoutStaticsCache.get();
        return try _f.getMinYearProperty();
    }
    pub fn getMaxYearProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerFlyoutStaticsCache.get();
        return try _f.getMaxYearProperty();
    }
    pub fn getDayFormatProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerFlyoutStatics2Cache.get();
        return try _f.getDayFormatProperty();
    }
    pub fn getMonthFormatProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerFlyoutStatics2Cache.get();
        return try _f.getMonthFormatProperty();
    }
    pub fn getYearFormatProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerFlyoutStatics2Cache.get();
        return try _f.getYearFormatProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.DatePickerFlyout";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IDatePickerFlyout.GUID;
    pub const IID: Guid = IDatePickerFlyout.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IDatePickerFlyout.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IDatePickerFlyoutStaticsCache: FactoryCache(IDatePickerFlyoutStatics, RUNTIME_NAME) = .{};
    var _IDatePickerFlyoutStatics2Cache: FactoryCache(IDatePickerFlyoutStatics2, RUNTIME_NAME) = .{};
};
pub const DatePickerFlyoutItem = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getPrimaryText(self: *@This()) core.HResult!HSTRING {
        const this: *IDatePickerFlyoutItem = @ptrCast(self);
        return try this.getPrimaryText();
    }
    pub fn putPrimaryText(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IDatePickerFlyoutItem = @ptrCast(self);
        return try this.putPrimaryText(value);
    }
    pub fn getSecondaryText(self: *@This()) core.HResult!HSTRING {
        const this: *IDatePickerFlyoutItem = @ptrCast(self);
        return try this.getSecondaryText();
    }
    pub fn putSecondaryText(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IDatePickerFlyoutItem = @ptrCast(self);
        return try this.putSecondaryText(value);
    }
    pub fn GetCustomProperty(self: *@This(), name: HSTRING) core.HResult!*ICustomProperty {
        var this: ?*ICustomPropertyProvider = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICustomPropertyProvider.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GetCustomProperty(name);
    }
    pub fn GetIndexedProperty(self: *@This(), name: HSTRING, ty: TypeName) core.HResult!*ICustomProperty {
        var this: ?*ICustomPropertyProvider = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICustomPropertyProvider.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GetIndexedProperty(name, ty);
    }
    pub fn GetStringRepresentation(self: *@This()) core.HResult!HSTRING {
        var this: ?*ICustomPropertyProvider = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICustomPropertyProvider.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GetStringRepresentation();
    }
    pub fn getType(self: *@This()) core.HResult!TypeName {
        var this: ?*ICustomPropertyProvider = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ICustomPropertyProvider.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getType();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getPrimaryTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerFlyoutItemStaticsCache.get();
        return try _f.getPrimaryTextProperty();
    }
    pub fn getSecondaryTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerFlyoutItemStaticsCache.get();
        return try _f.getSecondaryTextProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.DatePickerFlyoutItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IDatePickerFlyoutItem.GUID;
    pub const IID: Guid = IDatePickerFlyoutItem.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IDatePickerFlyoutItem.SIGNATURE);
    var _IDatePickerFlyoutItemStaticsCache: FactoryCache(IDatePickerFlyoutItemStatics, RUNTIME_NAME) = .{};
};
pub const DatePickerFlyoutPresenter = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsDefaultShadowEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IDatePickerFlyoutPresenter2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IDatePickerFlyoutPresenter2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsDefaultShadowEnabled();
    }
    pub fn putIsDefaultShadowEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IDatePickerFlyoutPresenter2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IDatePickerFlyoutPresenter2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsDefaultShadowEnabled(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getIsDefaultShadowEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IDatePickerFlyoutPresenterStatics2Cache.get();
        return try _f.getIsDefaultShadowEnabledProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.DatePickerFlyoutPresenter";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IDatePickerFlyoutPresenter.GUID;
    pub const IID: Guid = IDatePickerFlyoutPresenter.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IDatePickerFlyoutPresenter.SIGNATURE);
    var _IDatePickerFlyoutPresenterStatics2Cache: FactoryCache(IDatePickerFlyoutPresenterStatics2, RUNTIME_NAME) = .{};
};
pub const DatePickerSelectedValueChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getOldDate(self: *@This()) core.HResult!*IReference(DateTime) {
        const this: *IDatePickerSelectedValueChangedEventArgs = @ptrCast(self);
        return try this.getOldDate();
    }
    pub fn getNewDate(self: *@This()) core.HResult!*IReference(DateTime) {
        const this: *IDatePickerSelectedValueChangedEventArgs = @ptrCast(self);
        return try this.getNewDate();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.DatePickerSelectedValueChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IDatePickerSelectedValueChangedEventArgs.GUID;
    pub const IID: Guid = IDatePickerSelectedValueChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IDatePickerSelectedValueChangedEventArgs.SIGNATURE);
};
pub const DatePickerValueChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getOldDate(self: *@This()) core.HResult!DateTime {
        const this: *IDatePickerValueChangedEventArgs = @ptrCast(self);
        return try this.getOldDate();
    }
    pub fn getNewDate(self: *@This()) core.HResult!DateTime {
        const this: *IDatePickerValueChangedEventArgs = @ptrCast(self);
        return try this.getNewDate();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.DatePickerValueChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IDatePickerValueChangedEventArgs.GUID;
    pub const IID: Guid = IDatePickerValueChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IDatePickerValueChangedEventArgs.SIGNATURE);
};
pub const DisabledFormattingAccelerators = enum(i32) {
    None = 0,
    Bold = 1,
    Italic = 2,
    Underline = 4,
    All = -1,
};
pub const DragItemsCompletedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getItems(self: *@This()) core.HResult!*IVectorView(IInspectable) {
        const this: *IDragItemsCompletedEventArgs = @ptrCast(self);
        return try this.getItems();
    }
    pub fn getDropResult(self: *@This()) core.HResult!DataPackageOperation {
        const this: *IDragItemsCompletedEventArgs = @ptrCast(self);
        return try this.getDropResult();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.DragItemsCompletedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IDragItemsCompletedEventArgs.GUID;
    pub const IID: Guid = IDragItemsCompletedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IDragItemsCompletedEventArgs.SIGNATURE);
};
pub const DragItemsStartingEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getCancel(self: *@This()) core.HResult!bool {
        const this: *IDragItemsStartingEventArgs = @ptrCast(self);
        return try this.getCancel();
    }
    pub fn putCancel(self: *@This(), value: bool) core.HResult!void {
        const this: *IDragItemsStartingEventArgs = @ptrCast(self);
        return try this.putCancel(value);
    }
    pub fn getItems(self: *@This()) core.HResult!*IVector(IInspectable) {
        const this: *IDragItemsStartingEventArgs = @ptrCast(self);
        return try this.getItems();
    }
    pub fn getData(self: *@This()) core.HResult!*DataPackage {
        const this: *IDragItemsStartingEventArgs = @ptrCast(self);
        return try this.getData();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IDragItemsStartingEventArgs.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.DragItemsStartingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IDragItemsStartingEventArgs.GUID;
    pub const IID: Guid = IDragItemsStartingEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IDragItemsStartingEventArgs.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const DragItemsStartingEventHandler = extern struct {
    vtable: *const VTable,
    _refs: @import("std").atomic.Value(u32),
    _cb: *const fn (context: ?*anyopaque) callconv(.winapi) void,
    _context: ?*anyopaque = null,
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn init(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *DragItemsStartingEventArgs) callconv(.winapi) void,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
        };
        return _r;
    }
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn initWithState(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *DragItemsStartingEventArgs) callconv(.winapi) void,
        context: anytype,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
            ._context = @ptrCast(context),
        };
        return _r;
    }
    /// This calls Release and voids the returned ref count. If ref count is 0 the memory is released,
    /// Otherwise the memory stays until all references are released, including all references Windows holds.
    ///
    /// The caller *MUST* always call deinit/Release at least once for every AddRef and init called.
    pub fn deinit(self: *@This()) void {
        _ = Release(@ptrCast(self));
    }
    fn QueryInterface(self: *anyopaque, riid: *const Guid, out: *?*anyopaque) callconv(.c) HRESULT {
        const me: *@This() = @ptrCast(@alignCast(self));
        // TODO: Handle IMarshal
        if (core.wiredGuidEql(riid, &IID) or
            core.wiredGuidEql(riid, &IUnknown.IID) or
            core.wiredGuidEql(riid, &IAgileObject.IID))
        {
            out.* = @as(?*anyopaque, @ptrCast(me));
            _ = AddRef(self);
            return 0;
        }
        out.* = null;
        return -2147467262; // E_NOINTERFACE
    }
    fn AddRef(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        return this._refs.fetchAdd(1, .monotonic) + 1;
    }
    fn Release(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        const left = this._refs.fetchSub(1, .acq_rel) - 1;
        if (left == 0) @import("std").heap.c_allocator.destroy(this);
        return left;
    }
    pub fn Invoke(self: *anyopaque, sender: *IInspectable, e: *DragItemsStartingEventArgs) callconv(.winapi) HRESULT {
        const this: *@This() = @ptrCast(@alignCast(self));
        this._cb(this._context, sender, e);
        return 0;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.DragItemsStartingEventHandler";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3aaeab4c-14cb-4434-becc-88a8585c2f89";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.pinterface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        Invoke: *const fn(self: *anyopaque, sender: *IInspectable, e: *DragItemsStartingEventArgs) callconv(.winapi) HRESULT
    };
    pub const VTABLE = VTable {
        .QueryInterface = QueryInterface,
        .AddRef = AddRef,
        .Release = Release,
        .Invoke = Invoke,
    };
};
pub const DropDownButton = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*DropDownButton {
        const _f = @This().IDropDownButtonFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.DropDownButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IDropDownButton.GUID;
    pub const IID: Guid = IDropDownButton.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IDropDownButton.SIGNATURE);
    var _IDropDownButtonFactoryCache: FactoryCache(IDropDownButtonFactory, RUNTIME_NAME) = .{};
};
pub const DropDownButtonAutomationPeer = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getExpandCollapseState(self: *@This()) core.HResult!ExpandCollapseState {
        var this: ?*IExpandCollapseProvider = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IExpandCollapseProvider.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getExpandCollapseState();
    }
    pub fn Collapse(self: *@This()) core.HResult!void {
        var this: ?*IExpandCollapseProvider = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IExpandCollapseProvider.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.Collapse();
    }
    pub fn Expand(self: *@This()) core.HResult!void {
        var this: ?*IExpandCollapseProvider = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IExpandCollapseProvider.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.Expand();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(owner: *DropDownButton, baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*DropDownButtonAutomationPeer {
        const _f = @This().IDropDownButtonAutomationPeerFactoryCache.get();
        return try _f.CreateInstance(owner, baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.DropDownButtonAutomationPeer";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IDropDownButtonAutomationPeer.GUID;
    pub const IID: Guid = IDropDownButtonAutomationPeer.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IDropDownButtonAutomationPeer.SIGNATURE);
    var _IDropDownButtonAutomationPeerFactoryCache: FactoryCache(IDropDownButtonAutomationPeerFactory, RUNTIME_NAME) = .{};
};
pub const DynamicOverflowItemsChangingEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getAction(self: *@This()) core.HResult!CommandBarDynamicOverflowAction {
        const this: *IDynamicOverflowItemsChangingEventArgs = @ptrCast(self);
        return try this.getAction();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IDynamicOverflowItemsChangingEventArgs.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.DynamicOverflowItemsChangingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IDynamicOverflowItemsChangingEventArgs.GUID;
    pub const IID: Guid = IDynamicOverflowItemsChangingEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IDynamicOverflowItemsChangingEventArgs.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const FlipView = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getUseTouchAnimationsForAllNavigation(self: *@This()) core.HResult!bool {
        var this: ?*IFlipView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IFlipView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getUseTouchAnimationsForAllNavigation();
    }
    pub fn putUseTouchAnimationsForAllNavigation(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IFlipView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IFlipView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putUseTouchAnimationsForAllNavigation(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getUseTouchAnimationsForAllNavigationProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFlipViewStatics2Cache.get();
        return try _f.getUseTouchAnimationsForAllNavigationProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*FlipView {
        const _f = @This().IFlipViewFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.FlipView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IFlipView.GUID;
    pub const IID: Guid = IFlipView.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IFlipView.SIGNATURE);
    var _IFlipViewStatics2Cache: FactoryCache(IFlipViewStatics2, RUNTIME_NAME) = .{};
    var _IFlipViewFactoryCache: FactoryCache(IFlipViewFactory, RUNTIME_NAME) = .{};
};
pub const FlipViewItem = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*FlipViewItem {
        const _f = @This().IFlipViewItemFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.FlipViewItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IFlipViewItem.GUID;
    pub const IID: Guid = IFlipViewItem.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IFlipViewItem.SIGNATURE);
    var _IFlipViewItemFactoryCache: FactoryCache(IFlipViewItemFactory, RUNTIME_NAME) = .{};
};
pub const Flyout = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getContent(self: *@This()) core.HResult!*UIElement {
        const this: *IFlyout = @ptrCast(self);
        return try this.getContent();
    }
    pub fn putContent(self: *@This(), value: *UIElement) core.HResult!void {
        const this: *IFlyout = @ptrCast(self);
        return try this.putContent(value);
    }
    pub fn getFlyoutPresenterStyle(self: *@This()) core.HResult!*Style {
        const this: *IFlyout = @ptrCast(self);
        return try this.getFlyoutPresenterStyle();
    }
    pub fn putFlyoutPresenterStyle(self: *@This(), value: *Style) core.HResult!void {
        const this: *IFlyout = @ptrCast(self);
        return try this.putFlyoutPresenterStyle(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getContentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFlyoutStaticsCache.get();
        return try _f.getContentProperty();
    }
    pub fn getFlyoutPresenterStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFlyoutStaticsCache.get();
        return try _f.getFlyoutPresenterStyleProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*Flyout {
        const _f = @This().IFlyoutFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.Flyout";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IFlyout.GUID;
    pub const IID: Guid = IFlyout.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IFlyout.SIGNATURE);
    var _IFlyoutStaticsCache: FactoryCache(IFlyoutStatics, RUNTIME_NAME) = .{};
    var _IFlyoutFactoryCache: FactoryCache(IFlyoutFactory, RUNTIME_NAME) = .{};
};
pub const FlyoutPresenter = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsDefaultShadowEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IFlyoutPresenter2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IFlyoutPresenter2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsDefaultShadowEnabled();
    }
    pub fn putIsDefaultShadowEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IFlyoutPresenter2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IFlyoutPresenter2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsDefaultShadowEnabled(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getIsDefaultShadowEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFlyoutPresenterStatics2Cache.get();
        return try _f.getIsDefaultShadowEnabledProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*FlyoutPresenter {
        const _f = @This().IFlyoutPresenterFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.FlyoutPresenter";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IFlyoutPresenter.GUID;
    pub const IID: Guid = IFlyoutPresenter.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IFlyoutPresenter.SIGNATURE);
    var _IFlyoutPresenterStatics2Cache: FactoryCache(IFlyoutPresenterStatics2, RUNTIME_NAME) = .{};
    var _IFlyoutPresenterFactoryCache: FactoryCache(IFlyoutPresenterFactory, RUNTIME_NAME) = .{};
};
pub const FocusDisengagedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.FocusDisengagedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IFocusDisengagedEventArgs.GUID;
    pub const IID: Guid = IFocusDisengagedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IFocusDisengagedEventArgs.SIGNATURE);
};
pub const FocusEngagedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getHandled(self: *@This()) core.HResult!bool {
        var this: ?*IFocusEngagedEventArgs2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IFocusEngagedEventArgs2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getHandled();
    }
    pub fn putHandled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IFocusEngagedEventArgs2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IFocusEngagedEventArgs2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putHandled(value);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.FocusEngagedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IFocusEngagedEventArgs.GUID;
    pub const IID: Guid = IFocusEngagedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IFocusEngagedEventArgs.SIGNATURE);
};
pub const FontIcon = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getGlyph(self: *@This()) core.HResult!HSTRING {
        const this: *IFontIcon = @ptrCast(self);
        return try this.getGlyph();
    }
    pub fn putGlyph(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IFontIcon = @ptrCast(self);
        return try this.putGlyph(value);
    }
    pub fn getFontSize(self: *@This()) core.HResult!f64 {
        const this: *IFontIcon = @ptrCast(self);
        return try this.getFontSize();
    }
    pub fn putFontSize(self: *@This(), value: f64) core.HResult!void {
        const this: *IFontIcon = @ptrCast(self);
        return try this.putFontSize(value);
    }
    pub fn getFontFamily(self: *@This()) core.HResult!*FontFamily {
        const this: *IFontIcon = @ptrCast(self);
        return try this.getFontFamily();
    }
    pub fn putFontFamily(self: *@This(), value: *FontFamily) core.HResult!void {
        const this: *IFontIcon = @ptrCast(self);
        return try this.putFontFamily(value);
    }
    pub fn getFontWeight(self: *@This()) core.HResult!FontWeight {
        const this: *IFontIcon = @ptrCast(self);
        return try this.getFontWeight();
    }
    pub fn putFontWeight(self: *@This(), value: FontWeight) core.HResult!void {
        const this: *IFontIcon = @ptrCast(self);
        return try this.putFontWeight(value);
    }
    pub fn getFontStyle(self: *@This()) core.HResult!FontStyle {
        const this: *IFontIcon = @ptrCast(self);
        return try this.getFontStyle();
    }
    pub fn putFontStyle(self: *@This(), value: FontStyle) core.HResult!void {
        const this: *IFontIcon = @ptrCast(self);
        return try this.putFontStyle(value);
    }
    pub fn getIsTextScaleFactorEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IFontIcon2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IFontIcon2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsTextScaleFactorEnabled();
    }
    pub fn putIsTextScaleFactorEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IFontIcon2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IFontIcon2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsTextScaleFactorEnabled(value);
    }
    pub fn getMirroredWhenRightToLeft(self: *@This()) core.HResult!bool {
        var this: ?*IFontIcon3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IFontIcon3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getMirroredWhenRightToLeft();
    }
    pub fn putMirroredWhenRightToLeft(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IFontIcon3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IFontIcon3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putMirroredWhenRightToLeft(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getMirroredWhenRightToLeftProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFontIconStatics3Cache.get();
        return try _f.getMirroredWhenRightToLeftProperty();
    }
    pub fn getGlyphProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFontIconStaticsCache.get();
        return try _f.getGlyphProperty();
    }
    pub fn getFontSizeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFontIconStaticsCache.get();
        return try _f.getFontSizeProperty();
    }
    pub fn getFontFamilyProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFontIconStaticsCache.get();
        return try _f.getFontFamilyProperty();
    }
    pub fn getFontWeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFontIconStaticsCache.get();
        return try _f.getFontWeightProperty();
    }
    pub fn getFontStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFontIconStaticsCache.get();
        return try _f.getFontStyleProperty();
    }
    pub fn getIsTextScaleFactorEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFontIconStatics2Cache.get();
        return try _f.getIsTextScaleFactorEnabledProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*FontIcon {
        const _f = @This().IFontIconFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.FontIcon";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IFontIcon.GUID;
    pub const IID: Guid = IFontIcon.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IFontIcon.SIGNATURE);
    var _IFontIconStatics3Cache: FactoryCache(IFontIconStatics3, RUNTIME_NAME) = .{};
    var _IFontIconStaticsCache: FactoryCache(IFontIconStatics, RUNTIME_NAME) = .{};
    var _IFontIconStatics2Cache: FactoryCache(IFontIconStatics2, RUNTIME_NAME) = .{};
    var _IFontIconFactoryCache: FactoryCache(IFontIconFactory, RUNTIME_NAME) = .{};
};
pub const FontIconSource = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getGlyph(self: *@This()) core.HResult!HSTRING {
        const this: *IFontIconSource = @ptrCast(self);
        return try this.getGlyph();
    }
    pub fn putGlyph(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IFontIconSource = @ptrCast(self);
        return try this.putGlyph(value);
    }
    pub fn getFontSize(self: *@This()) core.HResult!f64 {
        const this: *IFontIconSource = @ptrCast(self);
        return try this.getFontSize();
    }
    pub fn putFontSize(self: *@This(), value: f64) core.HResult!void {
        const this: *IFontIconSource = @ptrCast(self);
        return try this.putFontSize(value);
    }
    pub fn getFontFamily(self: *@This()) core.HResult!*FontFamily {
        const this: *IFontIconSource = @ptrCast(self);
        return try this.getFontFamily();
    }
    pub fn putFontFamily(self: *@This(), value: *FontFamily) core.HResult!void {
        const this: *IFontIconSource = @ptrCast(self);
        return try this.putFontFamily(value);
    }
    pub fn getFontWeight(self: *@This()) core.HResult!FontWeight {
        const this: *IFontIconSource = @ptrCast(self);
        return try this.getFontWeight();
    }
    pub fn putFontWeight(self: *@This(), value: FontWeight) core.HResult!void {
        const this: *IFontIconSource = @ptrCast(self);
        return try this.putFontWeight(value);
    }
    pub fn getFontStyle(self: *@This()) core.HResult!FontStyle {
        const this: *IFontIconSource = @ptrCast(self);
        return try this.getFontStyle();
    }
    pub fn putFontStyle(self: *@This(), value: FontStyle) core.HResult!void {
        const this: *IFontIconSource = @ptrCast(self);
        return try this.putFontStyle(value);
    }
    pub fn getIsTextScaleFactorEnabled(self: *@This()) core.HResult!bool {
        const this: *IFontIconSource = @ptrCast(self);
        return try this.getIsTextScaleFactorEnabled();
    }
    pub fn putIsTextScaleFactorEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IFontIconSource = @ptrCast(self);
        return try this.putIsTextScaleFactorEnabled(value);
    }
    pub fn getMirroredWhenRightToLeft(self: *@This()) core.HResult!bool {
        const this: *IFontIconSource = @ptrCast(self);
        return try this.getMirroredWhenRightToLeft();
    }
    pub fn putMirroredWhenRightToLeft(self: *@This(), value: bool) core.HResult!void {
        const this: *IFontIconSource = @ptrCast(self);
        return try this.putMirroredWhenRightToLeft(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getGlyphProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFontIconSourceStaticsCache.get();
        return try _f.getGlyphProperty();
    }
    pub fn getFontSizeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFontIconSourceStaticsCache.get();
        return try _f.getFontSizeProperty();
    }
    pub fn getFontFamilyProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFontIconSourceStaticsCache.get();
        return try _f.getFontFamilyProperty();
    }
    pub fn getFontWeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFontIconSourceStaticsCache.get();
        return try _f.getFontWeightProperty();
    }
    pub fn getFontStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFontIconSourceStaticsCache.get();
        return try _f.getFontStyleProperty();
    }
    pub fn getIsTextScaleFactorEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFontIconSourceStaticsCache.get();
        return try _f.getIsTextScaleFactorEnabledProperty();
    }
    pub fn getMirroredWhenRightToLeftProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFontIconSourceStaticsCache.get();
        return try _f.getMirroredWhenRightToLeftProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*FontIconSource {
        const _f = @This().IFontIconSourceFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.FontIconSource";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IFontIconSource.GUID;
    pub const IID: Guid = IFontIconSource.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IFontIconSource.SIGNATURE);
    var _IFontIconSourceStaticsCache: FactoryCache(IFontIconSourceStatics, RUNTIME_NAME) = .{};
    var _IFontIconSourceFactoryCache: FactoryCache(IFontIconSourceFactory, RUNTIME_NAME) = .{};
};
pub const Frame = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getCacheSize(self: *@This()) core.HResult!i32 {
        const this: *IFrame = @ptrCast(self);
        return try this.getCacheSize();
    }
    pub fn putCacheSize(self: *@This(), value: i32) core.HResult!void {
        const this: *IFrame = @ptrCast(self);
        return try this.putCacheSize(value);
    }
    pub fn getCanGoBack(self: *@This()) core.HResult!bool {
        const this: *IFrame = @ptrCast(self);
        return try this.getCanGoBack();
    }
    pub fn getCanGoForward(self: *@This()) core.HResult!bool {
        const this: *IFrame = @ptrCast(self);
        return try this.getCanGoForward();
    }
    pub fn getCurrentSourcePageType(self: *@This()) core.HResult!TypeName {
        const this: *IFrame = @ptrCast(self);
        return try this.getCurrentSourcePageType();
    }
    pub fn getSourcePageType(self: *@This()) core.HResult!TypeName {
        const this: *IFrame = @ptrCast(self);
        return try this.getSourcePageType();
    }
    pub fn putSourcePageType(self: *@This(), value: TypeName) core.HResult!void {
        const this: *IFrame = @ptrCast(self);
        return try this.putSourcePageType(value);
    }
    pub fn getBackStackDepth(self: *@This()) core.HResult!i32 {
        const this: *IFrame = @ptrCast(self);
        return try this.getBackStackDepth();
    }
    pub fn addNavigated(self: *@This(), handler: *NavigatedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IFrame = @ptrCast(self);
        return try this.addNavigated(handler);
    }
    pub fn removeNavigated(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IFrame = @ptrCast(self);
        return try this.removeNavigated(token);
    }
    pub fn addNavigating(self: *@This(), handler: *NavigatingCancelEventHandler) core.HResult!EventRegistrationToken {
        const this: *IFrame = @ptrCast(self);
        return try this.addNavigating(handler);
    }
    pub fn removeNavigating(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IFrame = @ptrCast(self);
        return try this.removeNavigating(token);
    }
    pub fn addNavigationFailed(self: *@This(), handler: *NavigationFailedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IFrame = @ptrCast(self);
        return try this.addNavigationFailed(handler);
    }
    pub fn removeNavigationFailed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IFrame = @ptrCast(self);
        return try this.removeNavigationFailed(token);
    }
    pub fn addNavigationStopped(self: *@This(), handler: *NavigationStoppedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IFrame = @ptrCast(self);
        return try this.addNavigationStopped(handler);
    }
    pub fn removeNavigationStopped(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IFrame = @ptrCast(self);
        return try this.removeNavigationStopped(token);
    }
    pub fn GoBack(self: *@This()) core.HResult!void {
        const this: *IFrame = @ptrCast(self);
        return try this.GoBack();
    }
    pub fn GoForward(self: *@This()) core.HResult!void {
        const this: *IFrame = @ptrCast(self);
        return try this.GoForward();
    }
    pub fn NavigateWithParameter(self: *@This(), sourcePageType: TypeName, parameter: *IInspectable) core.HResult!bool {
        const this: *IFrame = @ptrCast(self);
        return try this.NavigateWithParameter(sourcePageType, parameter);
    }
    pub fn GetNavigationState(self: *@This()) core.HResult!HSTRING {
        const this: *IFrame = @ptrCast(self);
        return try this.GetNavigationState();
    }
    pub fn SetNavigationState(self: *@This(), navigationState: HSTRING) core.HResult!void {
        const this: *IFrame = @ptrCast(self);
        return try this.SetNavigationState(navigationState);
    }
    pub fn getBackStack(self: *@This()) core.HResult!*IVector(PageStackEntry) {
        var this: ?*IFrame2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IFrame2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getBackStack();
    }
    pub fn getForwardStack(self: *@This()) core.HResult!*IVector(PageStackEntry) {
        var this: ?*IFrame2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IFrame2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getForwardStack();
    }
    pub fn NavigateWithParameterAndInfoOverride(self: *@This(), sourcePageType: TypeName, parameter: *IInspectable, infoOverride: *NavigationTransitionInfo) core.HResult!bool {
        var this: ?*IFrame2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IFrame2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.NavigateWithParameterAndInfoOverride(sourcePageType, parameter, infoOverride);
    }
    pub fn GoBackWithTransitionInfoOverride(self: *@This(), transitionInfoOverride: *NavigationTransitionInfo) core.HResult!void {
        var this: ?*IFrame3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IFrame3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GoBackWithTransitionInfoOverride(transitionInfoOverride);
    }
    pub fn SetNavigationStateWithSuppressNavigate(self: *@This(), navigationState: HSTRING, suppressNavigate: bool) core.HResult!void {
        var this: ?*IFrame4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IFrame4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.SetNavigationStateWithSuppressNavigate(navigationState, suppressNavigate);
    }
    pub fn getIsNavigationStackEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IFrame5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IFrame5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsNavigationStackEnabled();
    }
    pub fn putIsNavigationStackEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IFrame5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IFrame5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsNavigationStackEnabled(value);
    }
    pub fn NavigateToType(self: *@This(), sourcePageType: TypeName, parameter: *IInspectable, navigationOptions: *FrameNavigationOptions) core.HResult!bool {
        var this: ?*IFrame5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IFrame5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.NavigateToType(sourcePageType, parameter, navigationOptions);
    }
    pub fn Navigate(self: *@This(), sourcePageType: TypeName) core.HResult!bool {
        var this: ?*INavigate = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigate.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.Navigate(sourcePageType);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getBackStackProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFrameStatics2Cache.get();
        return try _f.getBackStackProperty();
    }
    pub fn getForwardStackProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFrameStatics2Cache.get();
        return try _f.getForwardStackProperty();
    }
    pub fn getIsNavigationStackEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFrameStatics5Cache.get();
        return try _f.getIsNavigationStackEnabledProperty();
    }
    pub fn getCacheSizeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFrameStaticsCache.get();
        return try _f.getCacheSizeProperty();
    }
    pub fn getCanGoBackProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFrameStaticsCache.get();
        return try _f.getCanGoBackProperty();
    }
    pub fn getCanGoForwardProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFrameStaticsCache.get();
        return try _f.getCanGoForwardProperty();
    }
    pub fn getCurrentSourcePageTypeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFrameStaticsCache.get();
        return try _f.getCurrentSourcePageTypeProperty();
    }
    pub fn getSourcePageTypeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFrameStaticsCache.get();
        return try _f.getSourcePageTypeProperty();
    }
    pub fn getBackStackDepthProperty() core.HResult!*DependencyProperty {
        const _f = @This().IFrameStaticsCache.get();
        return try _f.getBackStackDepthProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*Frame {
        const _f = @This().IFrameFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.Frame";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IFrame.GUID;
    pub const IID: Guid = IFrame.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IFrame.SIGNATURE);
    var _IFrameStatics2Cache: FactoryCache(IFrameStatics2, RUNTIME_NAME) = .{};
    var _IFrameStatics5Cache: FactoryCache(IFrameStatics5, RUNTIME_NAME) = .{};
    var _IFrameStaticsCache: FactoryCache(IFrameStatics, RUNTIME_NAME) = .{};
    var _IFrameFactoryCache: FactoryCache(IFrameFactory, RUNTIME_NAME) = .{};
};
pub const Grid = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getRowDefinitions(self: *@This()) core.HResult!*RowDefinitionCollection {
        const this: *IGrid = @ptrCast(self);
        return try this.getRowDefinitions();
    }
    pub fn getColumnDefinitions(self: *@This()) core.HResult!*ColumnDefinitionCollection {
        const this: *IGrid = @ptrCast(self);
        return try this.getColumnDefinitions();
    }
    pub fn getBorderBrush(self: *@This()) core.HResult!*Brush {
        var this: ?*IGrid2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IGrid2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getBorderBrush();
    }
    pub fn putBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*IGrid2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IGrid2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putBorderBrush(value);
    }
    pub fn getBorderThickness(self: *@This()) core.HResult!Thickness {
        var this: ?*IGrid2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IGrid2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getBorderThickness();
    }
    pub fn putBorderThickness(self: *@This(), value: Thickness) core.HResult!void {
        var this: ?*IGrid2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IGrid2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putBorderThickness(value);
    }
    pub fn getCornerRadius(self: *@This()) core.HResult!CornerRadius {
        var this: ?*IGrid2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IGrid2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCornerRadius();
    }
    pub fn putCornerRadius(self: *@This(), value: CornerRadius) core.HResult!void {
        var this: ?*IGrid2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IGrid2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putCornerRadius(value);
    }
    pub fn getPadding(self: *@This()) core.HResult!Thickness {
        var this: ?*IGrid2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IGrid2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getPadding();
    }
    pub fn putPadding(self: *@This(), value: Thickness) core.HResult!void {
        var this: ?*IGrid2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IGrid2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putPadding(value);
    }
    pub fn getRowSpacing(self: *@This()) core.HResult!f64 {
        var this: ?*IGrid3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IGrid3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getRowSpacing();
    }
    pub fn putRowSpacing(self: *@This(), value: f64) core.HResult!void {
        var this: ?*IGrid3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IGrid3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putRowSpacing(value);
    }
    pub fn getColumnSpacing(self: *@This()) core.HResult!f64 {
        var this: ?*IGrid3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IGrid3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getColumnSpacing();
    }
    pub fn putColumnSpacing(self: *@This(), value: f64) core.HResult!void {
        var this: ?*IGrid3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IGrid3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putColumnSpacing(value);
    }
    pub fn getBackgroundSizing(self: *@This()) core.HResult!BackgroundSizing {
        var this: ?*IGrid4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IGrid4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getBackgroundSizing();
    }
    pub fn putBackgroundSizing(self: *@This(), value: BackgroundSizing) core.HResult!void {
        var this: ?*IGrid4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IGrid4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putBackgroundSizing(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getRowProperty() core.HResult!*DependencyProperty {
        const _f = @This().IGridStaticsCache.get();
        return try _f.getRowProperty();
    }
    pub fn GetRow(element: *FrameworkElement) core.HResult!i32 {
        const _f = @This().IGridStaticsCache.get();
        return try _f.GetRow(element);
    }
    pub fn SetRow(element: *FrameworkElement, value: i32) core.HResult!void {
        const _f = @This().IGridStaticsCache.get();
        return try _f.SetRow(element, value);
    }
    pub fn getColumnProperty() core.HResult!*DependencyProperty {
        const _f = @This().IGridStaticsCache.get();
        return try _f.getColumnProperty();
    }
    pub fn GetColumn(element: *FrameworkElement) core.HResult!i32 {
        const _f = @This().IGridStaticsCache.get();
        return try _f.GetColumn(element);
    }
    pub fn SetColumn(element: *FrameworkElement, value: i32) core.HResult!void {
        const _f = @This().IGridStaticsCache.get();
        return try _f.SetColumn(element, value);
    }
    pub fn getRowSpanProperty() core.HResult!*DependencyProperty {
        const _f = @This().IGridStaticsCache.get();
        return try _f.getRowSpanProperty();
    }
    pub fn GetRowSpan(element: *FrameworkElement) core.HResult!i32 {
        const _f = @This().IGridStaticsCache.get();
        return try _f.GetRowSpan(element);
    }
    pub fn SetRowSpan(element: *FrameworkElement, value: i32) core.HResult!void {
        const _f = @This().IGridStaticsCache.get();
        return try _f.SetRowSpan(element, value);
    }
    pub fn getColumnSpanProperty() core.HResult!*DependencyProperty {
        const _f = @This().IGridStaticsCache.get();
        return try _f.getColumnSpanProperty();
    }
    pub fn GetColumnSpan(element: *FrameworkElement) core.HResult!i32 {
        const _f = @This().IGridStaticsCache.get();
        return try _f.GetColumnSpan(element);
    }
    pub fn SetColumnSpan(element: *FrameworkElement, value: i32) core.HResult!void {
        const _f = @This().IGridStaticsCache.get();
        return try _f.SetColumnSpan(element, value);
    }
    pub fn getRowSpacingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IGridStatics3Cache.get();
        return try _f.getRowSpacingProperty();
    }
    pub fn getColumnSpacingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IGridStatics3Cache.get();
        return try _f.getColumnSpacingProperty();
    }
    pub fn getBorderBrushProperty() core.HResult!*DependencyProperty {
        const _f = @This().IGridStatics2Cache.get();
        return try _f.getBorderBrushProperty();
    }
    pub fn getBorderThicknessProperty() core.HResult!*DependencyProperty {
        const _f = @This().IGridStatics2Cache.get();
        return try _f.getBorderThicknessProperty();
    }
    pub fn getCornerRadiusProperty() core.HResult!*DependencyProperty {
        const _f = @This().IGridStatics2Cache.get();
        return try _f.getCornerRadiusProperty();
    }
    pub fn getPaddingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IGridStatics2Cache.get();
        return try _f.getPaddingProperty();
    }
    pub fn getBackgroundSizingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IGridStatics4Cache.get();
        return try _f.getBackgroundSizingProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*Grid {
        const _f = @This().IGridFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.Grid";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IGrid.GUID;
    pub const IID: Guid = IGrid.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IGrid.SIGNATURE);
    var _IGridStaticsCache: FactoryCache(IGridStatics, RUNTIME_NAME) = .{};
    var _IGridStatics3Cache: FactoryCache(IGridStatics3, RUNTIME_NAME) = .{};
    var _IGridStatics2Cache: FactoryCache(IGridStatics2, RUNTIME_NAME) = .{};
    var _IGridStatics4Cache: FactoryCache(IGridStatics4, RUNTIME_NAME) = .{};
    var _IGridFactoryCache: FactoryCache(IGridFactory, RUNTIME_NAME) = .{};
};
pub const ListViewBase = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getSelectedItems(self: *@This()) core.HResult!*IVector(IInspectable) {
        const this: *IListViewBase = @ptrCast(self);
        return try this.getSelectedItems();
    }
    pub fn getSelectionMode(self: *@This()) core.HResult!ListViewSelectionMode {
        const this: *IListViewBase = @ptrCast(self);
        return try this.getSelectionMode();
    }
    pub fn putSelectionMode(self: *@This(), value: ListViewSelectionMode) core.HResult!void {
        const this: *IListViewBase = @ptrCast(self);
        return try this.putSelectionMode(value);
    }
    pub fn getIsSwipeEnabled(self: *@This()) core.HResult!bool {
        const this: *IListViewBase = @ptrCast(self);
        return try this.getIsSwipeEnabled();
    }
    pub fn putIsSwipeEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IListViewBase = @ptrCast(self);
        return try this.putIsSwipeEnabled(value);
    }
    pub fn getCanDragItems(self: *@This()) core.HResult!bool {
        const this: *IListViewBase = @ptrCast(self);
        return try this.getCanDragItems();
    }
    pub fn putCanDragItems(self: *@This(), value: bool) core.HResult!void {
        const this: *IListViewBase = @ptrCast(self);
        return try this.putCanDragItems(value);
    }
    pub fn getCanReorderItems(self: *@This()) core.HResult!bool {
        const this: *IListViewBase = @ptrCast(self);
        return try this.getCanReorderItems();
    }
    pub fn putCanReorderItems(self: *@This(), value: bool) core.HResult!void {
        const this: *IListViewBase = @ptrCast(self);
        return try this.putCanReorderItems(value);
    }
    pub fn getIsItemClickEnabled(self: *@This()) core.HResult!bool {
        const this: *IListViewBase = @ptrCast(self);
        return try this.getIsItemClickEnabled();
    }
    pub fn putIsItemClickEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IListViewBase = @ptrCast(self);
        return try this.putIsItemClickEnabled(value);
    }
    pub fn getDataFetchSize(self: *@This()) core.HResult!f64 {
        const this: *IListViewBase = @ptrCast(self);
        return try this.getDataFetchSize();
    }
    pub fn putDataFetchSize(self: *@This(), value: f64) core.HResult!void {
        const this: *IListViewBase = @ptrCast(self);
        return try this.putDataFetchSize(value);
    }
    pub fn getIncrementalLoadingThreshold(self: *@This()) core.HResult!f64 {
        const this: *IListViewBase = @ptrCast(self);
        return try this.getIncrementalLoadingThreshold();
    }
    pub fn putIncrementalLoadingThreshold(self: *@This(), value: f64) core.HResult!void {
        const this: *IListViewBase = @ptrCast(self);
        return try this.putIncrementalLoadingThreshold(value);
    }
    pub fn getIncrementalLoadingTrigger(self: *@This()) core.HResult!IncrementalLoadingTrigger {
        const this: *IListViewBase = @ptrCast(self);
        return try this.getIncrementalLoadingTrigger();
    }
    pub fn putIncrementalLoadingTrigger(self: *@This(), value: IncrementalLoadingTrigger) core.HResult!void {
        const this: *IListViewBase = @ptrCast(self);
        return try this.putIncrementalLoadingTrigger(value);
    }
    pub fn addItemClick(self: *@This(), handler: *ItemClickEventHandler) core.HResult!EventRegistrationToken {
        const this: *IListViewBase = @ptrCast(self);
        return try this.addItemClick(handler);
    }
    pub fn removeItemClick(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IListViewBase = @ptrCast(self);
        return try this.removeItemClick(token);
    }
    pub fn addDragItemsStarting(self: *@This(), handler: *DragItemsStartingEventHandler) core.HResult!EventRegistrationToken {
        const this: *IListViewBase = @ptrCast(self);
        return try this.addDragItemsStarting(handler);
    }
    pub fn removeDragItemsStarting(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IListViewBase = @ptrCast(self);
        return try this.removeDragItemsStarting(token);
    }
    pub fn ScrollIntoView(self: *@This(), item: *IInspectable) core.HResult!void {
        const this: *IListViewBase = @ptrCast(self);
        return try this.ScrollIntoView(item);
    }
    pub fn SelectAll(self: *@This()) core.HResult!void {
        const this: *IListViewBase = @ptrCast(self);
        return try this.SelectAll();
    }
    pub fn LoadMoreItemsAsync(self: *@This()) core.HResult!*IAsyncOperation(LoadMoreItemsResult) {
        const this: *IListViewBase = @ptrCast(self);
        return try this.LoadMoreItemsAsync();
    }
    pub fn ScrollIntoViewWithAlignment(self: *@This(), item: *IInspectable, alignment: ScrollIntoViewAlignment) core.HResult!void {
        const this: *IListViewBase = @ptrCast(self);
        return try this.ScrollIntoViewWithAlignment(item, alignment);
    }
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        const this: *IListViewBase = @ptrCast(self);
        return try this.getHeader();
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IListViewBase = @ptrCast(self);
        return try this.putHeader(value);
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        const this: *IListViewBase = @ptrCast(self);
        return try this.getHeaderTemplate();
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const this: *IListViewBase = @ptrCast(self);
        return try this.putHeaderTemplate(value);
    }
    pub fn getHeaderTransitions(self: *@This()) core.HResult!*TransitionCollection {
        const this: *IListViewBase = @ptrCast(self);
        return try this.getHeaderTransitions();
    }
    pub fn putHeaderTransitions(self: *@This(), value: *TransitionCollection) core.HResult!void {
        const this: *IListViewBase = @ptrCast(self);
        return try this.putHeaderTransitions(value);
    }
    pub fn getShowsScrollingPlaceholders(self: *@This()) core.HResult!bool {
        var this: ?*IListViewBase2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getShowsScrollingPlaceholders();
    }
    pub fn putShowsScrollingPlaceholders(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IListViewBase2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putShowsScrollingPlaceholders(value);
    }
    pub fn addContainerContentChanging(self: *@This(), handler: *TypedEventHandler(ListViewBase,ContainerContentChangingEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IListViewBase2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addContainerContentChanging(handler);
    }
    pub fn removeContainerContentChanging(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IListViewBase2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeContainerContentChanging(token);
    }
    pub fn SetDesiredContainerUpdateDuration(self: *@This(), duration: TimeSpan) core.HResult!void {
        var this: ?*IListViewBase2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.SetDesiredContainerUpdateDuration(duration);
    }
    pub fn getFooter(self: *@This()) core.HResult!*IInspectable {
        var this: ?*IListViewBase2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getFooter();
    }
    pub fn putFooter(self: *@This(), value: *IInspectable) core.HResult!void {
        var this: ?*IListViewBase2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putFooter(value);
    }
    pub fn getFooterTemplate(self: *@This()) core.HResult!*DataTemplate {
        var this: ?*IListViewBase2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getFooterTemplate();
    }
    pub fn putFooterTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        var this: ?*IListViewBase2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putFooterTemplate(value);
    }
    pub fn getFooterTransitions(self: *@This()) core.HResult!*TransitionCollection {
        var this: ?*IListViewBase2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getFooterTransitions();
    }
    pub fn putFooterTransitions(self: *@This(), value: *TransitionCollection) core.HResult!void {
        var this: ?*IListViewBase2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putFooterTransitions(value);
    }
    pub fn getReorderMode(self: *@This()) core.HResult!ListViewReorderMode {
        var this: ?*IListViewBase3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getReorderMode();
    }
    pub fn putReorderMode(self: *@This(), value: ListViewReorderMode) core.HResult!void {
        var this: ?*IListViewBase3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putReorderMode(value);
    }
    pub fn getSelectedRanges(self: *@This()) core.HResult!*IVectorView(ItemIndexRange) {
        var this: ?*IListViewBase4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectedRanges();
    }
    pub fn getIsMultiSelectCheckBoxEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IListViewBase4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsMultiSelectCheckBoxEnabled();
    }
    pub fn putIsMultiSelectCheckBoxEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IListViewBase4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsMultiSelectCheckBoxEnabled(value);
    }
    pub fn addDragItemsCompleted(self: *@This(), handler: *TypedEventHandler(ListViewBase,DragItemsCompletedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IListViewBase4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addDragItemsCompleted(handler);
    }
    pub fn removeDragItemsCompleted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IListViewBase4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeDragItemsCompleted(token);
    }
    pub fn addChoosingItemContainer(self: *@This(), handler: *TypedEventHandler(ListViewBase,ChoosingItemContainerEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IListViewBase4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addChoosingItemContainer(handler);
    }
    pub fn removeChoosingItemContainer(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IListViewBase4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeChoosingItemContainer(token);
    }
    pub fn addChoosingGroupHeaderContainer(self: *@This(), handler: *TypedEventHandler(ListViewBase,ChoosingGroupHeaderContainerEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IListViewBase4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addChoosingGroupHeaderContainer(handler);
    }
    pub fn removeChoosingGroupHeaderContainer(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IListViewBase4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeChoosingGroupHeaderContainer(token);
    }
    pub fn SelectRange(self: *@This(), itemIndexRange: *ItemIndexRange) core.HResult!void {
        var this: ?*IListViewBase4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.SelectRange(itemIndexRange);
    }
    pub fn DeselectRange(self: *@This(), itemIndexRange: *ItemIndexRange) core.HResult!void {
        var this: ?*IListViewBase4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.DeselectRange(itemIndexRange);
    }
    pub fn getSingleSelectionFollowsFocus(self: *@This()) core.HResult!bool {
        var this: ?*IListViewBase5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSingleSelectionFollowsFocus();
    }
    pub fn putSingleSelectionFollowsFocus(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IListViewBase5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSingleSelectionFollowsFocus(value);
    }
    pub fn IsDragSource(self: *@This()) core.HResult!bool {
        var this: ?*IListViewBase5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.IsDragSource();
    }
    pub fn TryStartConnectedAnimationAsync(self: *@This(), animation: *ConnectedAnimation, item: *IInspectable, elementName: HSTRING) core.HResult!*IAsyncOperation(bool) {
        var this: ?*IListViewBase6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.TryStartConnectedAnimationAsync(animation, item, elementName);
    }
    pub fn PrepareConnectedAnimation(self: *@This(), key: HSTRING, item: *IInspectable, elementName: HSTRING) core.HResult!*ConnectedAnimation {
        var this: ?*IListViewBase6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListViewBase6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.PrepareConnectedAnimation(key, item, elementName);
    }
    pub fn getSemanticZoomOwner(self: *@This()) core.HResult!*SemanticZoom {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSemanticZoomOwner();
    }
    pub fn putSemanticZoomOwner(self: *@This(), value: *SemanticZoom) core.HResult!void {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSemanticZoomOwner(value);
    }
    pub fn getIsActiveView(self: *@This()) core.HResult!bool {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsActiveView();
    }
    pub fn putIsActiveView(self: *@This(), value: bool) core.HResult!void {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsActiveView(value);
    }
    pub fn getIsZoomedInView(self: *@This()) core.HResult!bool {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsZoomedInView();
    }
    pub fn putIsZoomedInView(self: *@This(), value: bool) core.HResult!void {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsZoomedInView(value);
    }
    pub fn InitializeViewChange(self: *@This()) core.HResult!void {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.InitializeViewChange();
    }
    pub fn CompleteViewChange(self: *@This()) core.HResult!void {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.CompleteViewChange();
    }
    pub fn MakeVisible(self: *@This(), item: *SemanticZoomLocation) core.HResult!void {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.MakeVisible(item);
    }
    pub fn StartViewChangeFrom(self: *@This(), source: *SemanticZoomLocation, destination: *SemanticZoomLocation) core.HResult!void {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.StartViewChangeFrom(source, destination);
    }
    pub fn StartViewChangeTo(self: *@This(), source: *SemanticZoomLocation, destination: *SemanticZoomLocation) core.HResult!void {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.StartViewChangeTo(source, destination);
    }
    pub fn CompleteViewChangeFrom(self: *@This(), source: *SemanticZoomLocation, destination: *SemanticZoomLocation) core.HResult!void {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.CompleteViewChangeFrom(source, destination);
    }
    pub fn CompleteViewChangeTo(self: *@This(), source: *SemanticZoomLocation, destination: *SemanticZoomLocation) core.HResult!void {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.CompleteViewChangeTo(source, destination);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getSingleSelectionFollowsFocusProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListViewBaseStatics5Cache.get();
        return try _f.getSingleSelectionFollowsFocusProperty();
    }
    pub fn getIsMultiSelectCheckBoxEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListViewBaseStatics4Cache.get();
        return try _f.getIsMultiSelectCheckBoxEnabledProperty();
    }
    pub fn getShowsScrollingPlaceholdersProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListViewBaseStatics2Cache.get();
        return try _f.getShowsScrollingPlaceholdersProperty();
    }
    pub fn getFooterProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListViewBaseStatics2Cache.get();
        return try _f.getFooterProperty();
    }
    pub fn getFooterTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListViewBaseStatics2Cache.get();
        return try _f.getFooterTemplateProperty();
    }
    pub fn getFooterTransitionsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListViewBaseStatics2Cache.get();
        return try _f.getFooterTransitionsProperty();
    }
    pub fn getSelectionModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListViewBaseStaticsCache.get();
        return try _f.getSelectionModeProperty();
    }
    pub fn getIsSwipeEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListViewBaseStaticsCache.get();
        return try _f.getIsSwipeEnabledProperty();
    }
    pub fn getCanDragItemsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListViewBaseStaticsCache.get();
        return try _f.getCanDragItemsProperty();
    }
    pub fn getCanReorderItemsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListViewBaseStaticsCache.get();
        return try _f.getCanReorderItemsProperty();
    }
    pub fn getIsItemClickEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListViewBaseStaticsCache.get();
        return try _f.getIsItemClickEnabledProperty();
    }
    pub fn getDataFetchSizeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListViewBaseStaticsCache.get();
        return try _f.getDataFetchSizeProperty();
    }
    pub fn getIncrementalLoadingThresholdProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListViewBaseStaticsCache.get();
        return try _f.getIncrementalLoadingThresholdProperty();
    }
    pub fn getIncrementalLoadingTriggerProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListViewBaseStaticsCache.get();
        return try _f.getIncrementalLoadingTriggerProperty();
    }
    pub fn getSemanticZoomOwnerProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListViewBaseStaticsCache.get();
        return try _f.getSemanticZoomOwnerProperty();
    }
    pub fn getIsActiveViewProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListViewBaseStaticsCache.get();
        return try _f.getIsActiveViewProperty();
    }
    pub fn getIsZoomedInViewProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListViewBaseStaticsCache.get();
        return try _f.getIsZoomedInViewProperty();
    }
    pub fn getHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListViewBaseStaticsCache.get();
        return try _f.getHeaderProperty();
    }
    pub fn getHeaderTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListViewBaseStaticsCache.get();
        return try _f.getHeaderTemplateProperty();
    }
    pub fn getHeaderTransitionsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListViewBaseStaticsCache.get();
        return try _f.getHeaderTransitionsProperty();
    }
    pub fn getReorderModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListViewBaseStatics3Cache.get();
        return try _f.getReorderModeProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ListViewBase {
        const _f = @This().IListViewBaseFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ListViewBase";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IListViewBase.GUID;
    pub const IID: Guid = IListViewBase.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IListViewBase.SIGNATURE);
    var _IListViewBaseStatics5Cache: FactoryCache(IListViewBaseStatics5, RUNTIME_NAME) = .{};
    var _IListViewBaseStatics4Cache: FactoryCache(IListViewBaseStatics4, RUNTIME_NAME) = .{};
    var _IListViewBaseStatics2Cache: FactoryCache(IListViewBaseStatics2, RUNTIME_NAME) = .{};
    var _IListViewBaseStaticsCache: FactoryCache(IListViewBaseStatics, RUNTIME_NAME) = .{};
    var _IListViewBaseStatics3Cache: FactoryCache(IListViewBaseStatics3, RUNTIME_NAME) = .{};
    var _IListViewBaseFactoryCache: FactoryCache(IListViewBaseFactory, RUNTIME_NAME) = .{};
};
pub const GridView = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*GridView {
        const _f = @This().IGridViewFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.GridView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IGridView.GUID;
    pub const IID: Guid = IGridView.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IGridView.SIGNATURE);
    var _IGridViewFactoryCache: FactoryCache(IGridViewFactory, RUNTIME_NAME) = .{};
};
pub const ListViewBaseHeaderItem = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ListViewBaseHeaderItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IListViewBaseHeaderItem.GUID;
    pub const IID: Guid = IListViewBaseHeaderItem.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IListViewBaseHeaderItem.SIGNATURE);
    var _IListViewBaseHeaderItemFactoryCache: FactoryCache(IListViewBaseHeaderItemFactory, RUNTIME_NAME) = .{};
};
pub const GridViewHeaderItem = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*GridViewHeaderItem {
        const _f = @This().IGridViewHeaderItemFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.GridViewHeaderItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IGridViewHeaderItem.GUID;
    pub const IID: Guid = IGridViewHeaderItem.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IGridViewHeaderItem.SIGNATURE);
    var _IGridViewHeaderItemFactoryCache: FactoryCache(IGridViewHeaderItemFactory, RUNTIME_NAME) = .{};
};
pub const GridViewItem = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getTemplateSettings(self: *@This()) core.HResult!*GridViewItemTemplateSettings {
        const this: *IGridViewItem = @ptrCast(self);
        return try this.getTemplateSettings();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*GridViewItem {
        const _f = @This().IGridViewItemFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.GridViewItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IGridViewItem.GUID;
    pub const IID: Guid = IGridViewItem.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IGridViewItem.SIGNATURE);
    var _IGridViewItemFactoryCache: FactoryCache(IGridViewItemFactory, RUNTIME_NAME) = .{};
};
pub const GroupItem = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*GroupItem {
        const _f = @This().IGroupItemFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.GroupItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IGroupItem.GUID;
    pub const IID: Guid = IGroupItem.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IGroupItem.SIGNATURE);
    var _IGroupItemFactoryCache: FactoryCache(IGroupItemFactory, RUNTIME_NAME) = .{};
};
pub const GroupStyle = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getPanel(self: *@This()) core.HResult!*ItemsPanelTemplate {
        const this: *IGroupStyle = @ptrCast(self);
        return try this.getPanel();
    }
    pub fn putPanel(self: *@This(), value: *ItemsPanelTemplate) core.HResult!void {
        const this: *IGroupStyle = @ptrCast(self);
        return try this.putPanel(value);
    }
    pub fn getContainerStyle(self: *@This()) core.HResult!*Style {
        const this: *IGroupStyle = @ptrCast(self);
        return try this.getContainerStyle();
    }
    pub fn putContainerStyle(self: *@This(), value: *Style) core.HResult!void {
        const this: *IGroupStyle = @ptrCast(self);
        return try this.putContainerStyle(value);
    }
    pub fn getContainerStyleSelector(self: *@This()) core.HResult!*StyleSelector {
        const this: *IGroupStyle = @ptrCast(self);
        return try this.getContainerStyleSelector();
    }
    pub fn putContainerStyleSelector(self: *@This(), value: *StyleSelector) core.HResult!void {
        const this: *IGroupStyle = @ptrCast(self);
        return try this.putContainerStyleSelector(value);
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        const this: *IGroupStyle = @ptrCast(self);
        return try this.getHeaderTemplate();
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const this: *IGroupStyle = @ptrCast(self);
        return try this.putHeaderTemplate(value);
    }
    pub fn getHeaderTemplateSelector(self: *@This()) core.HResult!*DataTemplateSelector {
        const this: *IGroupStyle = @ptrCast(self);
        return try this.getHeaderTemplateSelector();
    }
    pub fn putHeaderTemplateSelector(self: *@This(), value: *DataTemplateSelector) core.HResult!void {
        const this: *IGroupStyle = @ptrCast(self);
        return try this.putHeaderTemplateSelector(value);
    }
    pub fn getHidesIfEmpty(self: *@This()) core.HResult!bool {
        const this: *IGroupStyle = @ptrCast(self);
        return try this.getHidesIfEmpty();
    }
    pub fn putHidesIfEmpty(self: *@This(), value: bool) core.HResult!void {
        const this: *IGroupStyle = @ptrCast(self);
        return try this.putHidesIfEmpty(value);
    }
    pub fn getHeaderContainerStyle(self: *@This()) core.HResult!*Style {
        var this: ?*IGroupStyle2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IGroupStyle2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getHeaderContainerStyle();
    }
    pub fn putHeaderContainerStyle(self: *@This(), value: *Style) core.HResult!void {
        var this: ?*IGroupStyle2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IGroupStyle2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putHeaderContainerStyle(value);
    }
    pub fn addPropertyChanged(self: *@This(), handler: *PropertyChangedEventHandler) core.HResult!EventRegistrationToken {
        var this: ?*INotifyPropertyChanged = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INotifyPropertyChanged.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addPropertyChanged(handler);
    }
    pub fn removePropertyChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*INotifyPropertyChanged = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INotifyPropertyChanged.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removePropertyChanged(token);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*GroupStyle {
        const _f = @This().IGroupStyleFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.GroupStyle";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IGroupStyle.GUID;
    pub const IID: Guid = IGroupStyle.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IGroupStyle.SIGNATURE);
    var _IGroupStyleFactoryCache: FactoryCache(IGroupStyleFactory, RUNTIME_NAME) = .{};
};
pub const GroupStyleSelector = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn SelectGroupStyle(self: *@This(), group: *IInspectable, level: u32) core.HResult!*GroupStyle {
        const this: *IGroupStyleSelector = @ptrCast(self);
        return try this.SelectGroupStyle(group, level);
    }
    pub fn SelectGroupStyleCore(self: *@This(), group: *IInspectable, level: u32) core.HResult!*GroupStyle {
        var this: ?*IGroupStyleSelectorOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IGroupStyleSelectorOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.SelectGroupStyleCore(group, level);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*GroupStyleSelector {
        const _f = @This().IGroupStyleSelectorFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.GroupStyleSelector";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IGroupStyleSelector.GUID;
    pub const IID: Guid = IGroupStyleSelector.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IGroupStyleSelector.SIGNATURE);
    var _IGroupStyleSelectorFactoryCache: FactoryCache(IGroupStyleSelectorFactory, RUNTIME_NAME) = .{};
};
pub const HandwritingPanelClosedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.HandwritingPanelClosedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IHandwritingPanelClosedEventArgs.GUID;
    pub const IID: Guid = IHandwritingPanelClosedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IHandwritingPanelClosedEventArgs.SIGNATURE);
};
pub const HandwritingPanelOpenedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.HandwritingPanelOpenedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IHandwritingPanelOpenedEventArgs.GUID;
    pub const IID: Guid = IHandwritingPanelOpenedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IHandwritingPanelOpenedEventArgs.SIGNATURE);
};
pub const HandwritingPanelPlacementAlignment = enum(i32) {
    Auto = 0,
    TopLeft = 1,
    TopRight = 2,
    BottomLeft = 3,
    BottomRight = 4,
};
pub const HandwritingView = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getPlacementTarget(self: *@This()) core.HResult!*UIElement {
        const this: *IHandwritingView = @ptrCast(self);
        return try this.getPlacementTarget();
    }
    pub fn putPlacementTarget(self: *@This(), value: *UIElement) core.HResult!void {
        const this: *IHandwritingView = @ptrCast(self);
        return try this.putPlacementTarget(value);
    }
    pub fn getPlacementAlignment(self: *@This()) core.HResult!HandwritingPanelPlacementAlignment {
        const this: *IHandwritingView = @ptrCast(self);
        return try this.getPlacementAlignment();
    }
    pub fn putPlacementAlignment(self: *@This(), value: HandwritingPanelPlacementAlignment) core.HResult!void {
        const this: *IHandwritingView = @ptrCast(self);
        return try this.putPlacementAlignment(value);
    }
    pub fn getIsOpen(self: *@This()) core.HResult!bool {
        const this: *IHandwritingView = @ptrCast(self);
        return try this.getIsOpen();
    }
    pub fn getAreCandidatesEnabled(self: *@This()) core.HResult!bool {
        const this: *IHandwritingView = @ptrCast(self);
        return try this.getAreCandidatesEnabled();
    }
    pub fn putAreCandidatesEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IHandwritingView = @ptrCast(self);
        return try this.putAreCandidatesEnabled(value);
    }
    pub fn addOpened(self: *@This(), handler: *TypedEventHandler(HandwritingView,HandwritingPanelOpenedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IHandwritingView = @ptrCast(self);
        return try this.addOpened(handler);
    }
    pub fn removeOpened(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IHandwritingView = @ptrCast(self);
        return try this.removeOpened(token);
    }
    pub fn addClosed(self: *@This(), handler: *TypedEventHandler(HandwritingView,HandwritingPanelClosedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IHandwritingView = @ptrCast(self);
        return try this.addClosed(handler);
    }
    pub fn removeClosed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IHandwritingView = @ptrCast(self);
        return try this.removeClosed(token);
    }
    pub fn TryClose(self: *@This()) core.HResult!bool {
        const this: *IHandwritingView = @ptrCast(self);
        return try this.TryClose();
    }
    pub fn TryOpen(self: *@This()) core.HResult!bool {
        const this: *IHandwritingView = @ptrCast(self);
        return try this.TryOpen();
    }
    pub fn getIsSwitchToKeyboardEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IHandwritingView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IHandwritingView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsSwitchToKeyboardEnabled();
    }
    pub fn putIsSwitchToKeyboardEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IHandwritingView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IHandwritingView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsSwitchToKeyboardEnabled(value);
    }
    pub fn getIsCommandBarOpen(self: *@This()) core.HResult!bool {
        var this: ?*IHandwritingView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IHandwritingView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsCommandBarOpen();
    }
    pub fn putIsCommandBarOpen(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IHandwritingView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IHandwritingView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsCommandBarOpen(value);
    }
    pub fn getInputDeviceTypes(self: *@This()) core.HResult!CoreInputDeviceTypes {
        var this: ?*IHandwritingView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IHandwritingView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getInputDeviceTypes();
    }
    pub fn putInputDeviceTypes(self: *@This(), value: CoreInputDeviceTypes) core.HResult!void {
        var this: ?*IHandwritingView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IHandwritingView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putInputDeviceTypes(value);
    }
    pub fn addCandidatesChanged(self: *@This(), handler: *TypedEventHandler(HandwritingView,HandwritingViewCandidatesChangedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IHandwritingView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IHandwritingView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addCandidatesChanged(handler);
    }
    pub fn removeCandidatesChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IHandwritingView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IHandwritingView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeCandidatesChanged(token);
    }
    pub fn addTextSubmitted(self: *@This(), handler: *TypedEventHandler(HandwritingView,HandwritingViewTextSubmittedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IHandwritingView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IHandwritingView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addTextSubmitted(handler);
    }
    pub fn removeTextSubmitted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IHandwritingView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IHandwritingView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeTextSubmitted(token);
    }
    pub fn GetCandidates(self: *@This(), candidatesSessionId: u32) core.HResult!*IVectorView(HSTRING) {
        var this: ?*IHandwritingView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IHandwritingView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GetCandidates(candidatesSessionId);
    }
    pub fn SelectCandidate(self: *@This(), candidatesSessionId: u32, selectedCandidateIndex: u32) core.HResult!void {
        var this: ?*IHandwritingView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IHandwritingView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.SelectCandidate(candidatesSessionId, selectedCandidateIndex);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getIsSwitchToKeyboardEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IHandwritingViewStatics2Cache.get();
        return try _f.getIsSwitchToKeyboardEnabledProperty();
    }
    pub fn getIsCommandBarOpenProperty() core.HResult!*DependencyProperty {
        const _f = @This().IHandwritingViewStatics2Cache.get();
        return try _f.getIsCommandBarOpenProperty();
    }
    pub fn getPlacementTargetProperty() core.HResult!*DependencyProperty {
        const _f = @This().IHandwritingViewStaticsCache.get();
        return try _f.getPlacementTargetProperty();
    }
    pub fn getPlacementAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IHandwritingViewStaticsCache.get();
        return try _f.getPlacementAlignmentProperty();
    }
    pub fn getIsOpenProperty() core.HResult!*DependencyProperty {
        const _f = @This().IHandwritingViewStaticsCache.get();
        return try _f.getIsOpenProperty();
    }
    pub fn getAreCandidatesEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IHandwritingViewStaticsCache.get();
        return try _f.getAreCandidatesEnabledProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*HandwritingView {
        const _f = @This().IHandwritingViewFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.HandwritingView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IHandwritingView.GUID;
    pub const IID: Guid = IHandwritingView.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IHandwritingView.SIGNATURE);
    var _IHandwritingViewStatics2Cache: FactoryCache(IHandwritingViewStatics2, RUNTIME_NAME) = .{};
    var _IHandwritingViewStaticsCache: FactoryCache(IHandwritingViewStatics, RUNTIME_NAME) = .{};
    var _IHandwritingViewFactoryCache: FactoryCache(IHandwritingViewFactory, RUNTIME_NAME) = .{};
};
pub const HandwritingViewCandidatesChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getCandidatesSessionId(self: *@This()) core.HResult!u32 {
        const this: *IHandwritingViewCandidatesChangedEventArgs = @ptrCast(self);
        return try this.getCandidatesSessionId();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.HandwritingViewCandidatesChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IHandwritingViewCandidatesChangedEventArgs.GUID;
    pub const IID: Guid = IHandwritingViewCandidatesChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IHandwritingViewCandidatesChangedEventArgs.SIGNATURE);
};
pub const HandwritingViewTextSubmittedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.HandwritingViewTextSubmittedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IHandwritingViewTextSubmittedEventArgs.GUID;
    pub const IID: Guid = IHandwritingViewTextSubmittedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IHandwritingViewTextSubmittedEventArgs.SIGNATURE);
};
pub const Hub = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        const this: *IHub = @ptrCast(self);
        return try this.getHeader();
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IHub = @ptrCast(self);
        return try this.putHeader(value);
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        const this: *IHub = @ptrCast(self);
        return try this.getHeaderTemplate();
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const this: *IHub = @ptrCast(self);
        return try this.putHeaderTemplate(value);
    }
    pub fn getOrientation(self: *@This()) core.HResult!Orientation {
        const this: *IHub = @ptrCast(self);
        return try this.getOrientation();
    }
    pub fn putOrientation(self: *@This(), value: Orientation) core.HResult!void {
        const this: *IHub = @ptrCast(self);
        return try this.putOrientation(value);
    }
    pub fn getDefaultSectionIndex(self: *@This()) core.HResult!i32 {
        const this: *IHub = @ptrCast(self);
        return try this.getDefaultSectionIndex();
    }
    pub fn putDefaultSectionIndex(self: *@This(), value: i32) core.HResult!void {
        const this: *IHub = @ptrCast(self);
        return try this.putDefaultSectionIndex(value);
    }
    pub fn getSections(self: *@This()) core.HResult!*IVector(HubSection) {
        const this: *IHub = @ptrCast(self);
        return try this.getSections();
    }
    pub fn getSectionsInView(self: *@This()) core.HResult!*IVector(HubSection) {
        const this: *IHub = @ptrCast(self);
        return try this.getSectionsInView();
    }
    pub fn getSectionHeaders(self: *@This()) core.HResult!*IObservableVector(IInspectable) {
        const this: *IHub = @ptrCast(self);
        return try this.getSectionHeaders();
    }
    pub fn addSectionHeaderClick(self: *@This(), handler: *HubSectionHeaderClickEventHandler) core.HResult!EventRegistrationToken {
        const this: *IHub = @ptrCast(self);
        return try this.addSectionHeaderClick(handler);
    }
    pub fn removeSectionHeaderClick(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IHub = @ptrCast(self);
        return try this.removeSectionHeaderClick(token);
    }
    pub fn addSectionsInViewChanged(self: *@This(), handler: *SectionsInViewChangedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IHub = @ptrCast(self);
        return try this.addSectionsInViewChanged(handler);
    }
    pub fn removeSectionsInViewChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IHub = @ptrCast(self);
        return try this.removeSectionsInViewChanged(token);
    }
    pub fn ScrollToSection(self: *@This(), section: *HubSection) core.HResult!void {
        const this: *IHub = @ptrCast(self);
        return try this.ScrollToSection(section);
    }
    pub fn getSemanticZoomOwner(self: *@This()) core.HResult!*SemanticZoom {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSemanticZoomOwner();
    }
    pub fn putSemanticZoomOwner(self: *@This(), value: *SemanticZoom) core.HResult!void {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSemanticZoomOwner(value);
    }
    pub fn getIsActiveView(self: *@This()) core.HResult!bool {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsActiveView();
    }
    pub fn putIsActiveView(self: *@This(), value: bool) core.HResult!void {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsActiveView(value);
    }
    pub fn getIsZoomedInView(self: *@This()) core.HResult!bool {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsZoomedInView();
    }
    pub fn putIsZoomedInView(self: *@This(), value: bool) core.HResult!void {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsZoomedInView(value);
    }
    pub fn InitializeViewChange(self: *@This()) core.HResult!void {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.InitializeViewChange();
    }
    pub fn CompleteViewChange(self: *@This()) core.HResult!void {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.CompleteViewChange();
    }
    pub fn MakeVisible(self: *@This(), item: *SemanticZoomLocation) core.HResult!void {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.MakeVisible(item);
    }
    pub fn StartViewChangeFrom(self: *@This(), source: *SemanticZoomLocation, destination: *SemanticZoomLocation) core.HResult!void {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.StartViewChangeFrom(source, destination);
    }
    pub fn StartViewChangeTo(self: *@This(), source: *SemanticZoomLocation, destination: *SemanticZoomLocation) core.HResult!void {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.StartViewChangeTo(source, destination);
    }
    pub fn CompleteViewChangeFrom(self: *@This(), source: *SemanticZoomLocation, destination: *SemanticZoomLocation) core.HResult!void {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.CompleteViewChangeFrom(source, destination);
    }
    pub fn CompleteViewChangeTo(self: *@This(), source: *SemanticZoomLocation, destination: *SemanticZoomLocation) core.HResult!void {
        var this: ?*ISemanticZoomInformation = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISemanticZoomInformation.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.CompleteViewChangeTo(source, destination);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IHubStaticsCache.get();
        return try _f.getHeaderProperty();
    }
    pub fn getHeaderTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IHubStaticsCache.get();
        return try _f.getHeaderTemplateProperty();
    }
    pub fn getOrientationProperty() core.HResult!*DependencyProperty {
        const _f = @This().IHubStaticsCache.get();
        return try _f.getOrientationProperty();
    }
    pub fn getDefaultSectionIndexProperty() core.HResult!*DependencyProperty {
        const _f = @This().IHubStaticsCache.get();
        return try _f.getDefaultSectionIndexProperty();
    }
    pub fn getSemanticZoomOwnerProperty() core.HResult!*DependencyProperty {
        const _f = @This().IHubStaticsCache.get();
        return try _f.getSemanticZoomOwnerProperty();
    }
    pub fn getIsActiveViewProperty() core.HResult!*DependencyProperty {
        const _f = @This().IHubStaticsCache.get();
        return try _f.getIsActiveViewProperty();
    }
    pub fn getIsZoomedInViewProperty() core.HResult!*DependencyProperty {
        const _f = @This().IHubStaticsCache.get();
        return try _f.getIsZoomedInViewProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*Hub {
        const _f = @This().IHubFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.Hub";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IHub.GUID;
    pub const IID: Guid = IHub.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IHub.SIGNATURE);
    var _IHubStaticsCache: FactoryCache(IHubStatics, RUNTIME_NAME) = .{};
    var _IHubFactoryCache: FactoryCache(IHubFactory, RUNTIME_NAME) = .{};
};
pub const HubSection = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        const this: *IHubSection = @ptrCast(self);
        return try this.getHeader();
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IHubSection = @ptrCast(self);
        return try this.putHeader(value);
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        const this: *IHubSection = @ptrCast(self);
        return try this.getHeaderTemplate();
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const this: *IHubSection = @ptrCast(self);
        return try this.putHeaderTemplate(value);
    }
    pub fn getContentTemplate(self: *@This()) core.HResult!*DataTemplate {
        const this: *IHubSection = @ptrCast(self);
        return try this.getContentTemplate();
    }
    pub fn putContentTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const this: *IHubSection = @ptrCast(self);
        return try this.putContentTemplate(value);
    }
    pub fn getIsHeaderInteractive(self: *@This()) core.HResult!bool {
        const this: *IHubSection = @ptrCast(self);
        return try this.getIsHeaderInteractive();
    }
    pub fn putIsHeaderInteractive(self: *@This(), value: bool) core.HResult!void {
        const this: *IHubSection = @ptrCast(self);
        return try this.putIsHeaderInteractive(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IHubSectionStaticsCache.get();
        return try _f.getHeaderProperty();
    }
    pub fn getHeaderTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IHubSectionStaticsCache.get();
        return try _f.getHeaderTemplateProperty();
    }
    pub fn getContentTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IHubSectionStaticsCache.get();
        return try _f.getContentTemplateProperty();
    }
    pub fn getIsHeaderInteractiveProperty() core.HResult!*DependencyProperty {
        const _f = @This().IHubSectionStaticsCache.get();
        return try _f.getIsHeaderInteractiveProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*HubSection {
        const _f = @This().IHubSectionFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.HubSection";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IHubSection.GUID;
    pub const IID: Guid = IHubSection.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IHubSection.SIGNATURE);
    var _IHubSectionStaticsCache: FactoryCache(IHubSectionStatics, RUNTIME_NAME) = .{};
    var _IHubSectionFactoryCache: FactoryCache(IHubSectionFactory, RUNTIME_NAME) = .{};
};
pub const HubSectionCollection = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getSize(self: *@This()) core.HResult!u32 {
        const this: *IVector(HubSection) = @ptrCast(self);
        return try this.getSize();
    }
    pub fn GetView(self: *@This()) core.HResult!*IVectorView(HubSection) {
        const this: *IVector(HubSection) = @ptrCast(self);
        return try this.GetView();
    }
    pub fn RemoveAt(self: *@This(), index: u32) core.HResult!void {
        const this: *IVector(HubSection) = @ptrCast(self);
        return try this.RemoveAt(index);
    }
    pub fn RemoveAtEnd(self: *@This()) core.HResult!void {
        const this: *IVector(HubSection) = @ptrCast(self);
        return try this.RemoveAtEnd();
    }
    pub fn Clear(self: *@This()) core.HResult!void {
        const this: *IVector(HubSection) = @ptrCast(self);
        return try this.Clear();
    }
    pub fn First(self: *@This()) core.HResult!*IIterator(HubSection) {
        var this: ?*IIterable(HubSection) = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IIterable.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.First();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.HubSectionCollection";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IVector.GUID;
    pub const IID: Guid = IVector.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IVector.SIGNATURE);
};
pub const HubSectionHeaderClickEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getSection(self: *@This()) core.HResult!*HubSection {
        const this: *IHubSectionHeaderClickEventArgs = @ptrCast(self);
        return try this.getSection();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IHubSectionHeaderClickEventArgs.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.HubSectionHeaderClickEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IHubSectionHeaderClickEventArgs.GUID;
    pub const IID: Guid = IHubSectionHeaderClickEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IHubSectionHeaderClickEventArgs.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const HubSectionHeaderClickEventHandler = extern struct {
    vtable: *const VTable,
    _refs: @import("std").atomic.Value(u32),
    _cb: *const fn (context: ?*anyopaque) callconv(.winapi) void,
    _context: ?*anyopaque = null,
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn init(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *HubSectionHeaderClickEventArgs) callconv(.winapi) void,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
        };
        return _r;
    }
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn initWithState(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *HubSectionHeaderClickEventArgs) callconv(.winapi) void,
        context: anytype,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
            ._context = @ptrCast(context),
        };
        return _r;
    }
    /// This calls Release and voids the returned ref count. If ref count is 0 the memory is released,
    /// Otherwise the memory stays until all references are released, including all references Windows holds.
    ///
    /// The caller *MUST* always call deinit/Release at least once for every AddRef and init called.
    pub fn deinit(self: *@This()) void {
        _ = Release(@ptrCast(self));
    }
    fn QueryInterface(self: *anyopaque, riid: *const Guid, out: *?*anyopaque) callconv(.c) HRESULT {
        const me: *@This() = @ptrCast(@alignCast(self));
        // TODO: Handle IMarshal
        if (core.wiredGuidEql(riid, &IID) or
            core.wiredGuidEql(riid, &IUnknown.IID) or
            core.wiredGuidEql(riid, &IAgileObject.IID))
        {
            out.* = @as(?*anyopaque, @ptrCast(me));
            _ = AddRef(self);
            return 0;
        }
        out.* = null;
        return -2147467262; // E_NOINTERFACE
    }
    fn AddRef(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        return this._refs.fetchAdd(1, .monotonic) + 1;
    }
    fn Release(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        const left = this._refs.fetchSub(1, .acq_rel) - 1;
        if (left == 0) @import("std").heap.c_allocator.destroy(this);
        return left;
    }
    pub fn Invoke(self: *anyopaque, sender: *IInspectable, e: *HubSectionHeaderClickEventArgs) callconv(.winapi) HRESULT {
        const this: *@This() = @ptrCast(@alignCast(self));
        this._cb(this._context, sender, e);
        return 0;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.HubSectionHeaderClickEventHandler";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "afe17b9b-9c63-4583-88e4-c59019b7f49d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.pinterface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        Invoke: *const fn(self: *anyopaque, sender: *IInspectable, e: *HubSectionHeaderClickEventArgs) callconv(.winapi) HRESULT
    };
    pub const VTABLE = VTable {
        .QueryInterface = QueryInterface,
        .AddRef = AddRef,
        .Release = Release,
        .Invoke = Invoke,
    };
};
pub const HyperlinkButton = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getNavigateUri(self: *@This()) core.HResult!*Uri {
        const this: *IHyperlinkButton = @ptrCast(self);
        return try this.getNavigateUri();
    }
    pub fn putNavigateUri(self: *@This(), value: *Uri) core.HResult!void {
        const this: *IHyperlinkButton = @ptrCast(self);
        return try this.putNavigateUri(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getNavigateUriProperty() core.HResult!*DependencyProperty {
        const _f = @This().IHyperlinkButtonStaticsCache.get();
        return try _f.getNavigateUriProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*HyperlinkButton {
        const _f = @This().IHyperlinkButtonFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.HyperlinkButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IHyperlinkButton.GUID;
    pub const IID: Guid = IHyperlinkButton.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IHyperlinkButton.SIGNATURE);
    var _IHyperlinkButtonStaticsCache: FactoryCache(IHyperlinkButtonStatics, RUNTIME_NAME) = .{};
    var _IHyperlinkButtonFactoryCache: FactoryCache(IHyperlinkButtonFactory, RUNTIME_NAME) = .{};
};
pub const IAnchorRequestedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getAnchor(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_Anchor(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putAnchor(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_Anchor(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAnchorCandidates(self: *@This()) core.HResult!*IVector(UIElement) {
        var _r: *IVector(UIElement) = undefined;
        const _c = self.vtable.get_AnchorCandidates(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAnchorRequestedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5175f55d-4785-5a72-b462-eb11e9bdf897";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Anchor: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_Anchor: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
        get_AnchorCandidates: *const fn(self: *anyopaque, _r: **IVector(UIElement)) callconv(.winapi) HRESULT,
    };
};
pub const IAppBar = extern struct {
    vtable: *const VTable,
    pub fn getIsOpen(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsOpen(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsOpen(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsOpen(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsSticky(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsSticky(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsSticky(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsSticky(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addOpened(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Opened(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeOpened(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Opened(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addClosed(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Closed(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeClosed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Closed(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBar";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "7b0fc253-86a5-4b43-9872-0b8a6234b74b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsOpen: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsOpen: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsSticky: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsSticky: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        add_Opened: *const fn(self: *anyopaque, handler: *EventHandler(IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Opened: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_Closed: *const fn(self: *anyopaque, handler: *EventHandler(IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Closed: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IAppBar2 = extern struct {
    vtable: *const VTable,
    pub fn getClosedDisplayMode(self: *@This()) core.HResult!AppBarClosedDisplayMode {
        var _r: AppBarClosedDisplayMode = undefined;
        const _c = self.vtable.get_ClosedDisplayMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putClosedDisplayMode(self: *@This(), value: AppBarClosedDisplayMode) core.HResult!void {
        const _c = self.vtable.put_ClosedDisplayMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBar2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c3ab17b3-7ad7-4676-9910-7fe3f0e8e993";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ClosedDisplayMode: *const fn(self: *anyopaque, _r: *AppBarClosedDisplayMode) callconv(.winapi) HRESULT,
        put_ClosedDisplayMode: *const fn(self: *anyopaque, value: AppBarClosedDisplayMode) callconv(.winapi) HRESULT,
    };
};
pub const IAppBar3 = extern struct {
    vtable: *const VTable,
    pub fn getTemplateSettings(self: *@This()) core.HResult!*AppBarTemplateSettings {
        var _r: *AppBarTemplateSettings = undefined;
        const _c = self.vtable.get_TemplateSettings(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addOpening(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Opening(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeOpening(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Opening(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addClosing(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Closing(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeClosing(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Closing(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBar3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "982b001f-752e-4e7a-b055-54802c9ea749";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TemplateSettings: *const fn(self: *anyopaque, _r: **AppBarTemplateSettings) callconv(.winapi) HRESULT,
        add_Opening: *const fn(self: *anyopaque, handler: *EventHandler(IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Opening: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_Closing: *const fn(self: *anyopaque, handler: *EventHandler(IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Closing: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IAppBar4 = extern struct {
    vtable: *const VTable,
    pub fn getLightDismissOverlayMode(self: *@This()) core.HResult!LightDismissOverlayMode {
        var _r: LightDismissOverlayMode = undefined;
        const _c = self.vtable.get_LightDismissOverlayMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putLightDismissOverlayMode(self: *@This(), value: LightDismissOverlayMode) core.HResult!void {
        const _c = self.vtable.put_LightDismissOverlayMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBar4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "94ebc8cd-0a64-4da3-bf43-f13100a46605";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LightDismissOverlayMode: *const fn(self: *anyopaque, _r: *LightDismissOverlayMode) callconv(.winapi) HRESULT,
        put_LightDismissOverlayMode: *const fn(self: *anyopaque, value: LightDismissOverlayMode) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarButton = extern struct {
    vtable: *const VTable,
    pub fn getLabel(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Label(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putLabel(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_Label(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIcon(self: *@This()) core.HResult!*IconElement {
        var _r: *IconElement = undefined;
        const _c = self.vtable.get_Icon(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIcon(self: *@This(), value: *IconElement) core.HResult!void {
        const _c = self.vtable.put_Icon(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4459a451-69e8-440c-9896-4bb4f5f642d1";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Label: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_Label: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_Icon: *const fn(self: *anyopaque, _r: **IconElement) callconv(.winapi) HRESULT,
        put_Icon: *const fn(self: *anyopaque, value: *IconElement) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarButton3 = extern struct {
    vtable: *const VTable,
    pub fn getLabelPosition(self: *@This()) core.HResult!CommandBarLabelPosition {
        var _r: CommandBarLabelPosition = undefined;
        const _c = self.vtable.get_LabelPosition(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putLabelPosition(self: *@This(), value: CommandBarLabelPosition) core.HResult!void {
        const _c = self.vtable.put_LabelPosition(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarButton3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0b282150-198b-4e84-8f1c-9f6a8ba267a7";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LabelPosition: *const fn(self: *anyopaque, _r: *CommandBarLabelPosition) callconv(.winapi) HRESULT,
        put_LabelPosition: *const fn(self: *anyopaque, value: CommandBarLabelPosition) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarButton4 = extern struct {
    vtable: *const VTable,
    pub fn getKeyboardAcceleratorTextOverride(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_KeyboardAcceleratorTextOverride(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putKeyboardAcceleratorTextOverride(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_KeyboardAcceleratorTextOverride(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarButton4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "958fce6b-fd08-4414-8458-9d40866dc84e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_KeyboardAcceleratorTextOverride: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_KeyboardAcceleratorTextOverride: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarButton5 = extern struct {
    vtable: *const VTable,
    pub fn getTemplateSettings(self: *@This()) core.HResult!*AppBarButtonTemplateSettings {
        var _r: *AppBarButtonTemplateSettings = undefined;
        const _c = self.vtable.get_TemplateSettings(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarButton5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4096fc7f-1aec-4b0f-a031-ca8c4e06d2ed";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TemplateSettings: *const fn(self: *anyopaque, _r: **AppBarButtonTemplateSettings) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarButtonFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*AppBarButton {
        var _r: *AppBarButton = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarButtonFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "bdbb1bb6-cb2e-4276-abd6-7935130510e0";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **AppBarButton) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarButtonStatics = extern struct {
    vtable: *const VTable,
    pub fn getLabelProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LabelProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIconProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IconProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsCompactProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsCompactProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarButtonStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "7ccd13e6-5301-407f-874e-dc9160aa07af";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LabelProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IconProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsCompactProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarButtonStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getLabelPositionProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LabelPositionProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsInOverflowProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsInOverflowProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDynamicOverflowOrderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DynamicOverflowOrderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarButtonStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4d7bf314-2ede-4328-8906-752a1f27cdfa";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LabelPositionProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsInOverflowProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DynamicOverflowOrderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarButtonStatics4 = extern struct {
    vtable: *const VTable,
    pub fn getKeyboardAcceleratorTextOverrideProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_KeyboardAcceleratorTextOverrideProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarButtonStatics4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1c0ae26a-c755-4fe6-a3b6-0e3394e952c0";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_KeyboardAcceleratorTextOverrideProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarElementContainer = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarElementContainer";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1d5ba067-a990-5dab-a9c3-e6be56642a1a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarElementContainerFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*AppBarElementContainer {
        var _r: *AppBarElementContainer = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarElementContainerFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b506530e-8897-5d6f-a43e-f0586338d282";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **AppBarElementContainer) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarElementContainerStatics = extern struct {
    vtable: *const VTable,
    pub fn getIsCompactProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsCompactProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsInOverflowProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsInOverflowProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDynamicOverflowOrderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DynamicOverflowOrderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarElementContainerStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ebbef840-c745-5a6f-8671-9a41eb2196e7";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsCompactProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsInOverflowProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DynamicOverflowOrderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*AppBar {
        var _r: *AppBar = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "614708d1-8e65-43cb-92d7-8eee17515f8d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **AppBar) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarOverrides = extern struct {
    vtable: *const VTable,
    pub fn OnClosed(self: *@This(), e: *IInspectable) core.HResult!void {
        const _c = self.vtable.OnClosed(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnOpened(self: *@This(), e: *IInspectable) core.HResult!void {
        const _c = self.vtable.OnOpened(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarOverrides";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f003e4e2-7b0f-4f4a-970d-ae8a0eaa9b70";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        OnClosed: *const fn(self: *anyopaque, e: *IInspectable) callconv(.winapi) HRESULT,
        OnOpened: *const fn(self: *anyopaque, e: *IInspectable) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarOverrides3 = extern struct {
    vtable: *const VTable,
    pub fn OnClosing(self: *@This(), e: *IInspectable) core.HResult!void {
        const _c = self.vtable.OnClosing(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnOpening(self: *@This(), e: *IInspectable) core.HResult!void {
        const _c = self.vtable.OnOpening(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarOverrides3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "412bbbc8-51d0-4b49-ab62-a3dd6bdcb298";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        OnClosing: *const fn(self: *anyopaque, e: *IInspectable) callconv(.winapi) HRESULT,
        OnOpening: *const fn(self: *anyopaque, e: *IInspectable) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarSeparator = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarSeparator";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1b0795a1-1bc1-4d53-95ea-fb0a2cccc905";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarSeparatorFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*AppBarSeparator {
        var _r: *AppBarSeparator = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarSeparatorFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "05da25cd-f407-48de-8b50-ff87d1e2818f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **AppBarSeparator) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarSeparatorStatics = extern struct {
    vtable: *const VTable,
    pub fn getIsCompactProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsCompactProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarSeparatorStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "37f23484-5b35-4663-a75d-f2d50cb9c619";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsCompactProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarSeparatorStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getIsInOverflowProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsInOverflowProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDynamicOverflowOrderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DynamicOverflowOrderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarSeparatorStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "36c753f9-7373-4e5e-9ba4-c3622a003c4e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsInOverflowProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DynamicOverflowOrderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarStatics = extern struct {
    vtable: *const VTable,
    pub fn getIsOpenProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsOpenProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsStickyProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsStickyProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "79bb7e8d-dca9-4b5f-a448-37b13238ed76";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsOpenProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsStickyProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getClosedDisplayModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ClosedDisplayModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "222355e9-0384-49de-8738-dfc9d409ac5d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ClosedDisplayModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarStatics4 = extern struct {
    vtable: *const VTable,
    pub fn getLightDismissOverlayModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LightDismissOverlayModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarStatics4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ba02082e-1165-4451-94b3-eb3ac73e4196";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LightDismissOverlayModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarToggleButton = extern struct {
    vtable: *const VTable,
    pub fn getLabel(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Label(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putLabel(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_Label(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIcon(self: *@This()) core.HResult!*IconElement {
        var _r: *IconElement = undefined;
        const _c = self.vtable.get_Icon(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIcon(self: *@This(), value: *IconElement) core.HResult!void {
        const _c = self.vtable.put_Icon(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarToggleButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "2e914438-fd53-4b8d-858b-3644269f8e4d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Label: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_Label: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_Icon: *const fn(self: *anyopaque, _r: **IconElement) callconv(.winapi) HRESULT,
        put_Icon: *const fn(self: *anyopaque, value: *IconElement) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarToggleButton3 = extern struct {
    vtable: *const VTable,
    pub fn getLabelPosition(self: *@This()) core.HResult!CommandBarLabelPosition {
        var _r: CommandBarLabelPosition = undefined;
        const _c = self.vtable.get_LabelPosition(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putLabelPosition(self: *@This(), value: CommandBarLabelPosition) core.HResult!void {
        const _c = self.vtable.put_LabelPosition(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarToggleButton3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ef9a85e5-16ff-4d72-b9e8-9b861eaf84a8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LabelPosition: *const fn(self: *anyopaque, _r: *CommandBarLabelPosition) callconv(.winapi) HRESULT,
        put_LabelPosition: *const fn(self: *anyopaque, value: CommandBarLabelPosition) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarToggleButton4 = extern struct {
    vtable: *const VTable,
    pub fn getKeyboardAcceleratorTextOverride(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_KeyboardAcceleratorTextOverride(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putKeyboardAcceleratorTextOverride(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_KeyboardAcceleratorTextOverride(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarToggleButton4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b86b736e-3eaf-4751-a897-00029f1f6aca";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_KeyboardAcceleratorTextOverride: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_KeyboardAcceleratorTextOverride: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarToggleButton5 = extern struct {
    vtable: *const VTable,
    pub fn getTemplateSettings(self: *@This()) core.HResult!*AppBarToggleButtonTemplateSettings {
        var _r: *AppBarToggleButtonTemplateSettings = undefined;
        const _c = self.vtable.get_TemplateSettings(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarToggleButton5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9dca3357-c130-4fb6-a1e2-d2b348fe43be";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TemplateSettings: *const fn(self: *anyopaque, _r: **AppBarToggleButtonTemplateSettings) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarToggleButtonFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*AppBarToggleButton {
        var _r: *AppBarToggleButton = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarToggleButtonFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "028aa7d4-8f54-45a6-9f90-13605656d793";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **AppBarToggleButton) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarToggleButtonStatics = extern struct {
    vtable: *const VTable,
    pub fn getLabelProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LabelProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIconProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IconProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsCompactProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsCompactProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarToggleButtonStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "fe5aaf96-7929-4da1-aa67-cddf73a3e4b5";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LabelProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IconProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsCompactProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarToggleButtonStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getLabelPositionProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LabelPositionProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsInOverflowProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsInOverflowProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDynamicOverflowOrderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DynamicOverflowOrderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarToggleButtonStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "bd4c65bf-2edd-44d1-acd5-35c00e2f21bc";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LabelPositionProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsInOverflowProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DynamicOverflowOrderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IAppBarToggleButtonStatics4 = extern struct {
    vtable: *const VTable,
    pub fn getKeyboardAcceleratorTextOverrideProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_KeyboardAcceleratorTextOverrideProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAppBarToggleButtonStatics4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a478b984-e916-4137-bdbd-95bd46ff3ce6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_KeyboardAcceleratorTextOverrideProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IAutoSuggestBox = extern struct {
    vtable: *const VTable,
    pub fn getMaxSuggestionListHeight(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_MaxSuggestionListHeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxSuggestionListHeight(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_MaxSuggestionListHeight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsSuggestionListOpen(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsSuggestionListOpen(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsSuggestionListOpen(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsSuggestionListOpen(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextMemberPath(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_TextMemberPath(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextMemberPath(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_TextMemberPath(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Text(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putText(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_Text(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getUpdateTextOnSelect(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_UpdateTextOnSelect(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putUpdateTextOnSelect(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_UpdateTextOnSelect(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPlaceholderText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_PlaceholderText(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPlaceholderText(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_PlaceholderText(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Header(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Header(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAutoMaximizeSuggestionArea(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_AutoMaximizeSuggestionArea(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putAutoMaximizeSuggestionArea(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_AutoMaximizeSuggestionArea(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextBoxStyle(self: *@This()) core.HResult!*Style {
        var _r: *Style = undefined;
        const _c = self.vtable.get_TextBoxStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextBoxStyle(self: *@This(), value: *Style) core.HResult!void {
        const _c = self.vtable.put_TextBoxStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addSuggestionChosen(self: *@This(), handler: *TypedEventHandler(AutoSuggestBox,AutoSuggestBoxSuggestionChosenEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_SuggestionChosen(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeSuggestionChosen(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_SuggestionChosen(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addTextChanged(self: *@This(), handler: *TypedEventHandler(AutoSuggestBox,AutoSuggestBoxTextChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_TextChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeTextChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_TextChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAutoSuggestBox";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "103e9b13-3400-4a16-90b9-6912bf06974f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_MaxSuggestionListHeight: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_MaxSuggestionListHeight: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_IsSuggestionListOpen: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsSuggestionListOpen: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_TextMemberPath: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_TextMemberPath: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_Text: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_Text: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_UpdateTextOnSelect: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_UpdateTextOnSelect: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_PlaceholderText: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_PlaceholderText: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_Header: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Header: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_AutoMaximizeSuggestionArea: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_AutoMaximizeSuggestionArea: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_TextBoxStyle: *const fn(self: *anyopaque, _r: **Style) callconv(.winapi) HRESULT,
        put_TextBoxStyle: *const fn(self: *anyopaque, value: *Style) callconv(.winapi) HRESULT,
        add_SuggestionChosen: *const fn(self: *anyopaque, handler: *TypedEventHandler(AutoSuggestBox,AutoSuggestBoxSuggestionChosenEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_SuggestionChosen: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_TextChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(AutoSuggestBox,AutoSuggestBoxTextChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_TextChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IAutoSuggestBox2 = extern struct {
    vtable: *const VTable,
    pub fn getQueryIcon(self: *@This()) core.HResult!*IconElement {
        var _r: *IconElement = undefined;
        const _c = self.vtable.get_QueryIcon(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putQueryIcon(self: *@This(), value: *IconElement) core.HResult!void {
        const _c = self.vtable.put_QueryIcon(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addQuerySubmitted(self: *@This(), handler: *TypedEventHandler(AutoSuggestBox,AutoSuggestBoxQuerySubmittedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_QuerySubmitted(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeQuerySubmitted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_QuerySubmitted(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAutoSuggestBox2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "aa87ddde-e679-45b2-a7c9-9aedc39db886";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_QueryIcon: *const fn(self: *anyopaque, _r: **IconElement) callconv(.winapi) HRESULT,
        put_QueryIcon: *const fn(self: *anyopaque, value: *IconElement) callconv(.winapi) HRESULT,
        add_QuerySubmitted: *const fn(self: *anyopaque, handler: *TypedEventHandler(AutoSuggestBox,AutoSuggestBoxQuerySubmittedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_QuerySubmitted: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IAutoSuggestBox3 = extern struct {
    vtable: *const VTable,
    pub fn getLightDismissOverlayMode(self: *@This()) core.HResult!LightDismissOverlayMode {
        var _r: LightDismissOverlayMode = undefined;
        const _c = self.vtable.get_LightDismissOverlayMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putLightDismissOverlayMode(self: *@This(), value: LightDismissOverlayMode) core.HResult!void {
        const _c = self.vtable.put_LightDismissOverlayMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAutoSuggestBox3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9bbbfcef-f32d-402e-9009-05bdbaf6336e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LightDismissOverlayMode: *const fn(self: *anyopaque, _r: *LightDismissOverlayMode) callconv(.winapi) HRESULT,
        put_LightDismissOverlayMode: *const fn(self: *anyopaque, value: LightDismissOverlayMode) callconv(.winapi) HRESULT,
    };
};
pub const IAutoSuggestBox4 = extern struct {
    vtable: *const VTable,
    pub fn getDescription(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Description(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDescription(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Description(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAutoSuggestBox4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c22df897-a3e8-5051-b3cc-b5f0f5262950";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Description: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Description: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
    };
};
pub const IAutoSuggestBoxQuerySubmittedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getQueryText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_QueryText(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getChosenSuggestion(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_ChosenSuggestion(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAutoSuggestBoxQuerySubmittedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "78dcb116-818a-4cb5-bca7-382ce6ddc90d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_QueryText: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        get_ChosenSuggestion: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
    };
};
pub const IAutoSuggestBoxStatics = extern struct {
    vtable: *const VTable,
    pub fn getMaxSuggestionListHeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxSuggestionListHeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsSuggestionListOpenProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsSuggestionListOpenProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextMemberPathProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextMemberPathProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getUpdateTextOnSelectProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_UpdateTextOnSelectProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPlaceholderTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlaceholderTextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getAutoMaximizeSuggestionAreaProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AutoMaximizeSuggestionAreaProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextBoxStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextBoxStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ee22c7f4-c15d-4ff3-8a94-f50dfdfbe89a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_MaxSuggestionListHeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsSuggestionListOpenProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextMemberPathProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_UpdateTextOnSelectProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PlaceholderTextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_AutoMaximizeSuggestionAreaProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextBoxStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IAutoSuggestBoxStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getQueryIconProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_QueryIconProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1cd297a8-8e6a-41ef-a95d-7157dc0c7106";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_QueryIconProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IAutoSuggestBoxStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getLightDismissOverlayModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LightDismissOverlayModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "2cead2dd-c4d5-4ab2-8a13-afddcf067c86";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LightDismissOverlayModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IAutoSuggestBoxStatics4 = extern struct {
    vtable: *const VTable,
    pub fn getDescriptionProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DescriptionProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d63efaae-b9df-58d8-a00a-dbfe9ffdedd0";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_DescriptionProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IAutoSuggestBoxSuggestionChosenEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getSelectedItem(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_SelectedItem(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAutoSuggestBoxSuggestionChosenEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "396f7254-1ed5-4bc5-a060-655530bca6ba";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectedItem: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
    };
};
pub const IAutoSuggestBoxTextChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getReason(self: *@This()) core.HResult!AutoSuggestionBoxTextChangeReason {
        var _r: AutoSuggestionBoxTextChangeReason = undefined;
        const _c = self.vtable.get_Reason(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putReason(self: *@This(), value: AutoSuggestionBoxTextChangeReason) core.HResult!void {
        const _c = self.vtable.put_Reason(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn CheckCurrent(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.CheckCurrent(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAutoSuggestBoxTextChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3a6f7254-1ed5-4bc5-a060-655530bca6ba";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Reason: *const fn(self: *anyopaque, _r: *AutoSuggestionBoxTextChangeReason) callconv(.winapi) HRESULT,
        put_Reason: *const fn(self: *anyopaque, value: AutoSuggestionBoxTextChangeReason) callconv(.winapi) HRESULT,
        CheckCurrent: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
    };
};
pub const IAutoSuggestBoxTextChangedEventArgsStatics = extern struct {
    vtable: *const VTable,
    pub fn getReasonProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ReasonProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IAutoSuggestBoxTextChangedEventArgsStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "fef7772b-9f45-44db-8c27-bda3f933e7b5";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ReasonProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IBackClickEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getHandled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_Handled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHandled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_Handled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IBackClickEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "2ae6146c-477e-48c9-8830-2c464b7c7104";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Handled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_Handled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IBitmapIcon = extern struct {
    vtable: *const VTable,
    pub fn getUriSource(self: *@This()) core.HResult!*Uri {
        var _r: *Uri = undefined;
        const _c = self.vtable.get_UriSource(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putUriSource(self: *@This(), value: *Uri) core.HResult!void {
        const _c = self.vtable.put_UriSource(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IBitmapIcon";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e8fe17cb-35f7-40f3-a185-48b397b73e68";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_UriSource: *const fn(self: *anyopaque, _r: **Uri) callconv(.winapi) HRESULT,
        put_UriSource: *const fn(self: *anyopaque, value: *Uri) callconv(.winapi) HRESULT,
    };
};
pub const IBitmapIcon2 = extern struct {
    vtable: *const VTable,
    pub fn getShowAsMonochrome(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_ShowAsMonochrome(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putShowAsMonochrome(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_ShowAsMonochrome(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IBitmapIcon2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0624a20a-9dd1-4201-bb20-42863da15658";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ShowAsMonochrome: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_ShowAsMonochrome: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IBitmapIconFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*BitmapIcon {
        var _r: *BitmapIcon = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IBitmapIconFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "46d64b1d-7a49-4f66-9729-2848c788e402";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **BitmapIcon) callconv(.winapi) HRESULT,
    };
};
pub const IBitmapIconSource = extern struct {
    vtable: *const VTable,
    pub fn getUriSource(self: *@This()) core.HResult!*Uri {
        var _r: *Uri = undefined;
        const _c = self.vtable.get_UriSource(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putUriSource(self: *@This(), value: *Uri) core.HResult!void {
        const _c = self.vtable.put_UriSource(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getShowAsMonochrome(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_ShowAsMonochrome(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putShowAsMonochrome(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_ShowAsMonochrome(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IBitmapIconSource";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c8e33dc7-d4ae-4a87-947f-ac4d0bcf5af4";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_UriSource: *const fn(self: *anyopaque, _r: **Uri) callconv(.winapi) HRESULT,
        put_UriSource: *const fn(self: *anyopaque, value: *Uri) callconv(.winapi) HRESULT,
        get_ShowAsMonochrome: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_ShowAsMonochrome: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IBitmapIconSourceFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*BitmapIconSource {
        var _r: *BitmapIconSource = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IBitmapIconSourceFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6509e5c6-44b6-4cd1-86cd-c3189b12c43c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **BitmapIconSource) callconv(.winapi) HRESULT,
    };
};
pub const IBitmapIconSourceStatics = extern struct {
    vtable: *const VTable,
    pub fn getUriSourceProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_UriSourceProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getShowAsMonochromeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ShowAsMonochromeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IBitmapIconSourceStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5a105887-e494-4d2b-8528-39472296133f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_UriSourceProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ShowAsMonochromeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IBitmapIconStatics = extern struct {
    vtable: *const VTable,
    pub fn getUriSourceProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_UriSourceProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IBitmapIconStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e072d117-e4e7-4e0c-9470-53ff1ce84f67";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_UriSourceProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IBitmapIconStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getShowAsMonochromeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ShowAsMonochromeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IBitmapIconStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9745026b-b742-4a89-a5d7-a0e5fb809af1";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ShowAsMonochromeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IBorder = extern struct {
    vtable: *const VTable,
    pub fn getBorderBrush(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_BorderBrush(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_BorderBrush(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBorderThickness(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_BorderThickness(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBorderThickness(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_BorderThickness(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBackground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_Background(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBackground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_Background(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCornerRadius(self: *@This()) core.HResult!CornerRadius {
        var _r: CornerRadius = undefined;
        const _c = self.vtable.get_CornerRadius(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCornerRadius(self: *@This(), value: CornerRadius) core.HResult!void {
        const _c = self.vtable.put_CornerRadius(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPadding(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_Padding(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPadding(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_Padding(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getChild(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_Child(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putChild(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_Child(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getChildTransitions(self: *@This()) core.HResult!*TransitionCollection {
        var _r: *TransitionCollection = undefined;
        const _c = self.vtable.get_ChildTransitions(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putChildTransitions(self: *@This(), value: *TransitionCollection) core.HResult!void {
        const _c = self.vtable.put_ChildTransitions(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IBorder";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "797c4539-45bd-4633-a044-bfb02ef5170f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BorderBrush: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_BorderBrush: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_BorderThickness: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_BorderThickness: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
        get_Background: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_Background: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_CornerRadius: *const fn(self: *anyopaque, _r: *CornerRadius) callconv(.winapi) HRESULT,
        put_CornerRadius: *const fn(self: *anyopaque, value: CornerRadius) callconv(.winapi) HRESULT,
        get_Padding: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_Padding: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
        get_Child: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_Child: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
        get_ChildTransitions: *const fn(self: *anyopaque, _r: **TransitionCollection) callconv(.winapi) HRESULT,
        put_ChildTransitions: *const fn(self: *anyopaque, value: *TransitionCollection) callconv(.winapi) HRESULT,
    };
};
pub const IBorder2 = extern struct {
    vtable: *const VTable,
    pub fn getBackgroundSizing(self: *@This()) core.HResult!BackgroundSizing {
        var _r: BackgroundSizing = undefined;
        const _c = self.vtable.get_BackgroundSizing(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBackgroundSizing(self: *@This(), value: BackgroundSizing) core.HResult!void {
        const _c = self.vtable.put_BackgroundSizing(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBackgroundTransition(self: *@This()) core.HResult!*BrushTransition {
        var _r: *BrushTransition = undefined;
        const _c = self.vtable.get_BackgroundTransition(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBackgroundTransition(self: *@This(), value: *BrushTransition) core.HResult!void {
        const _c = self.vtable.put_BackgroundTransition(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IBorder2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a1efbd9d-cb8b-56b5-878d-3a7f43bc9730";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BackgroundSizing: *const fn(self: *anyopaque, _r: *BackgroundSizing) callconv(.winapi) HRESULT,
        put_BackgroundSizing: *const fn(self: *anyopaque, value: BackgroundSizing) callconv(.winapi) HRESULT,
        get_BackgroundTransition: *const fn(self: *anyopaque, _r: **BrushTransition) callconv(.winapi) HRESULT,
        put_BackgroundTransition: *const fn(self: *anyopaque, value: *BrushTransition) callconv(.winapi) HRESULT,
    };
};
pub const IBorderStatics = extern struct {
    vtable: *const VTable,
    pub fn getBorderBrushProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BorderBrushProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBorderThicknessProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BorderThicknessProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBackgroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BackgroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCornerRadiusProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CornerRadiusProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPaddingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PaddingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getChildTransitionsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ChildTransitionsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IBorderStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b81d1639-e911-4fd7-a4c4-b9c7f008b7fc";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BorderBrushProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BorderThicknessProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BackgroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CornerRadiusProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PaddingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ChildTransitionsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IBorderStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getBackgroundSizingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BackgroundSizingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IBorderStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a26d4476-803f-5040-a0f3-e66db3733166";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BackgroundSizingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IButton = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "280335ae-5570-46c7-8e0b-602be71229a2";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IButtonFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*Button {
        var _r: *Button = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IButtonFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "80a13c19-843a-451c-8cf5-44c701b0e216";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **Button) callconv(.winapi) HRESULT,
    };
};
pub const IButtonStaticsWithFlyout = extern struct {
    vtable: *const VTable,
    pub fn getFlyoutProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FlyoutProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IButtonStaticsWithFlyout";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "90143898-a16c-4759-b2f0-a5f7e625169e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_FlyoutProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IButtonWithFlyout = extern struct {
    vtable: *const VTable,
    pub fn getFlyout(self: *@This()) core.HResult!*FlyoutBase {
        var _r: *FlyoutBase = undefined;
        const _c = self.vtable.get_Flyout(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFlyout(self: *@This(), value: *FlyoutBase) core.HResult!void {
        const _c = self.vtable.put_Flyout(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IButtonWithFlyout";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "09108f87-df6c-4180-9b3a-e60845825811";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Flyout: *const fn(self: *anyopaque, _r: **FlyoutBase) callconv(.winapi) HRESULT,
        put_Flyout: *const fn(self: *anyopaque, value: *FlyoutBase) callconv(.winapi) HRESULT,
    };
};
pub const ICalendarDatePicker = extern struct {
    vtable: *const VTable,
    pub fn getDate(self: *@This()) core.HResult!*IReference(DateTime) {
        var _r: *IReference(DateTime) = undefined;
        const _c = self.vtable.get_Date(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDate(self: *@This(), value: *IReference(DateTime)) core.HResult!void {
        const _c = self.vtable.put_Date(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsCalendarOpen(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsCalendarOpen(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsCalendarOpen(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsCalendarOpen(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDateFormat(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_DateFormat(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDateFormat(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_DateFormat(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPlaceholderText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_PlaceholderText(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPlaceholderText(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_PlaceholderText(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Header(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Header(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_HeaderTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_HeaderTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCalendarViewStyle(self: *@This()) core.HResult!*Style {
        var _r: *Style = undefined;
        const _c = self.vtable.get_CalendarViewStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCalendarViewStyle(self: *@This(), value: *Style) core.HResult!void {
        const _c = self.vtable.put_CalendarViewStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMinDate(self: *@This()) core.HResult!DateTime {
        var _r: DateTime = undefined;
        const _c = self.vtable.get_MinDate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMinDate(self: *@This(), value: DateTime) core.HResult!void {
        const _c = self.vtable.put_MinDate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMaxDate(self: *@This()) core.HResult!DateTime {
        var _r: DateTime = undefined;
        const _c = self.vtable.get_MaxDate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxDate(self: *@This(), value: DateTime) core.HResult!void {
        const _c = self.vtable.put_MaxDate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsTodayHighlighted(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsTodayHighlighted(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsTodayHighlighted(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsTodayHighlighted(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDisplayMode(self: *@This()) core.HResult!CalendarViewDisplayMode {
        var _r: CalendarViewDisplayMode = undefined;
        const _c = self.vtable.get_DisplayMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDisplayMode(self: *@This(), value: CalendarViewDisplayMode) core.HResult!void {
        const _c = self.vtable.put_DisplayMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFirstDayOfWeek(self: *@This()) core.HResult!DayOfWeek {
        var _r: DayOfWeek = undefined;
        const _c = self.vtable.get_FirstDayOfWeek(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFirstDayOfWeek(self: *@This(), value: DayOfWeek) core.HResult!void {
        const _c = self.vtable.put_FirstDayOfWeek(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDayOfWeekFormat(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_DayOfWeekFormat(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDayOfWeekFormat(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_DayOfWeekFormat(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCalendarIdentifier(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_CalendarIdentifier(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCalendarIdentifier(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_CalendarIdentifier(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsOutOfScopeEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsOutOfScopeEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsOutOfScopeEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsOutOfScopeEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsGroupLabelVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsGroupLabelVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsGroupLabelVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsGroupLabelVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addCalendarViewDayItemChanging(self: *@This(), handler: *CalendarViewDayItemChangingEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_CalendarViewDayItemChanging(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeCalendarViewDayItemChanging(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_CalendarViewDayItemChanging(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addDateChanged(self: *@This(), handler: *TypedEventHandler(CalendarDatePicker,CalendarDatePickerDateChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_DateChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeDateChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_DateChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addOpened(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Opened(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeOpened(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Opened(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addClosed(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Closed(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeClosed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Closed(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn SetDisplayDate(self: *@This(), date: DateTime) core.HResult!void {
        const _c = self.vtable.SetDisplayDate(@ptrCast(self), date);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn SetYearDecadeDisplayDimensions(self: *@This(), columns: i32, rows: i32) core.HResult!void {
        const _c = self.vtable.SetYearDecadeDisplayDimensions(@ptrCast(self), columns, rows);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICalendarDatePicker";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "63c9c16f-668c-4491-9444-d45d8bf4fa29";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Date: *const fn(self: *anyopaque, _r: **IReference(DateTime)) callconv(.winapi) HRESULT,
        put_Date: *const fn(self: *anyopaque, value: *IReference(DateTime)) callconv(.winapi) HRESULT,
        get_IsCalendarOpen: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsCalendarOpen: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_DateFormat: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_DateFormat: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_PlaceholderText: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_PlaceholderText: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_Header: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Header: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_HeaderTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_HeaderTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_CalendarViewStyle: *const fn(self: *anyopaque, _r: **Style) callconv(.winapi) HRESULT,
        put_CalendarViewStyle: *const fn(self: *anyopaque, value: *Style) callconv(.winapi) HRESULT,
        get_MinDate: *const fn(self: *anyopaque, _r: *DateTime) callconv(.winapi) HRESULT,
        put_MinDate: *const fn(self: *anyopaque, value: DateTime) callconv(.winapi) HRESULT,
        get_MaxDate: *const fn(self: *anyopaque, _r: *DateTime) callconv(.winapi) HRESULT,
        put_MaxDate: *const fn(self: *anyopaque, value: DateTime) callconv(.winapi) HRESULT,
        get_IsTodayHighlighted: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsTodayHighlighted: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_DisplayMode: *const fn(self: *anyopaque, _r: *CalendarViewDisplayMode) callconv(.winapi) HRESULT,
        put_DisplayMode: *const fn(self: *anyopaque, value: CalendarViewDisplayMode) callconv(.winapi) HRESULT,
        get_FirstDayOfWeek: *const fn(self: *anyopaque, _r: *DayOfWeek) callconv(.winapi) HRESULT,
        put_FirstDayOfWeek: *const fn(self: *anyopaque, value: DayOfWeek) callconv(.winapi) HRESULT,
        get_DayOfWeekFormat: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_DayOfWeekFormat: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_CalendarIdentifier: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_CalendarIdentifier: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_IsOutOfScopeEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsOutOfScopeEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsGroupLabelVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsGroupLabelVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        add_CalendarViewDayItemChanging: *const fn(self: *anyopaque, handler: *CalendarViewDayItemChangingEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_CalendarViewDayItemChanging: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_DateChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(CalendarDatePicker,CalendarDatePickerDateChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_DateChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_Opened: *const fn(self: *anyopaque, handler: *EventHandler(IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Opened: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_Closed: *const fn(self: *anyopaque, handler: *EventHandler(IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Closed: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        SetDisplayDate: *const fn(self: *anyopaque, date: DateTime) callconv(.winapi) HRESULT,
        SetYearDecadeDisplayDimensions: *const fn(self: *anyopaque, columns: i32, rows: i32) callconv(.winapi) HRESULT,
    };
};
pub const ICalendarDatePicker2 = extern struct {
    vtable: *const VTable,
    pub fn getLightDismissOverlayMode(self: *@This()) core.HResult!LightDismissOverlayMode {
        var _r: LightDismissOverlayMode = undefined;
        const _c = self.vtable.get_LightDismissOverlayMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putLightDismissOverlayMode(self: *@This(), value: LightDismissOverlayMode) core.HResult!void {
        const _c = self.vtable.put_LightDismissOverlayMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICalendarDatePicker2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b216c159-2411-4a60-a7aa-27416b49481e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LightDismissOverlayMode: *const fn(self: *anyopaque, _r: *LightDismissOverlayMode) callconv(.winapi) HRESULT,
        put_LightDismissOverlayMode: *const fn(self: *anyopaque, value: LightDismissOverlayMode) callconv(.winapi) HRESULT,
    };
};
pub const ICalendarDatePicker3 = extern struct {
    vtable: *const VTable,
    pub fn getDescription(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Description(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDescription(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Description(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICalendarDatePicker3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "645856c0-db7b-5e75-85e9-f623e3457ea6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Description: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Description: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
    };
};
pub const ICalendarDatePickerDateChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getNewDate(self: *@This()) core.HResult!*IReference(DateTime) {
        var _r: *IReference(DateTime) = undefined;
        const _c = self.vtable.get_NewDate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOldDate(self: *@This()) core.HResult!*IReference(DateTime) {
        var _r: *IReference(DateTime) = undefined;
        const _c = self.vtable.get_OldDate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICalendarDatePickerDateChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "60d90db2-5010-46ba-842d-a4152c6504e7";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_NewDate: *const fn(self: *anyopaque, _r: **IReference(DateTime)) callconv(.winapi) HRESULT,
        get_OldDate: *const fn(self: *anyopaque, _r: **IReference(DateTime)) callconv(.winapi) HRESULT,
    };
};
pub const ICalendarDatePickerFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*CalendarDatePicker {
        var _r: *CalendarDatePicker = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICalendarDatePickerFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "107aad5d-38be-42af-a957-fc86a5cf1e9a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **CalendarDatePicker) callconv(.winapi) HRESULT,
    };
};
pub const ICalendarDatePickerStatics = extern struct {
    vtable: *const VTable,
    pub fn getDateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsCalendarOpenProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsCalendarOpenProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDateFormatProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DateFormatProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPlaceholderTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlaceholderTextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCalendarViewStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CalendarViewStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMinDateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MinDateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaxDateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxDateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsTodayHighlightedProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsTodayHighlightedProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDisplayModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DisplayModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFirstDayOfWeekProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FirstDayOfWeekProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDayOfWeekFormatProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DayOfWeekFormatProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCalendarIdentifierProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CalendarIdentifierProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsOutOfScopeEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsOutOfScopeEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsGroupLabelVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsGroupLabelVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICalendarDatePickerStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "39a3d291-afab-4b94-8395-ba7b874e3c8c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_DateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsCalendarOpenProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DateFormatProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PlaceholderTextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CalendarViewStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MinDateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaxDateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsTodayHighlightedProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DisplayModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FirstDayOfWeekProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DayOfWeekFormatProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CalendarIdentifierProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsOutOfScopeEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsGroupLabelVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ICalendarDatePickerStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getLightDismissOverlayModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LightDismissOverlayModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICalendarDatePickerStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "30206b58-a2f6-4a00-8d13-33c46b6b8e0d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LightDismissOverlayModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ICalendarDatePickerStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getDescriptionProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DescriptionProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICalendarDatePickerStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b188741d-cf69-568c-9707-baaaec2b64db";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_DescriptionProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ICalendarView = extern struct {
    vtable: *const VTable,
    pub fn getCalendarIdentifier(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_CalendarIdentifier(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCalendarIdentifier(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_CalendarIdentifier(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDayOfWeekFormat(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_DayOfWeekFormat(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDayOfWeekFormat(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_DayOfWeekFormat(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsGroupLabelVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsGroupLabelVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsGroupLabelVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsGroupLabelVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDisplayMode(self: *@This()) core.HResult!CalendarViewDisplayMode {
        var _r: CalendarViewDisplayMode = undefined;
        const _c = self.vtable.get_DisplayMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDisplayMode(self: *@This(), value: CalendarViewDisplayMode) core.HResult!void {
        const _c = self.vtable.put_DisplayMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFirstDayOfWeek(self: *@This()) core.HResult!DayOfWeek {
        var _r: DayOfWeek = undefined;
        const _c = self.vtable.get_FirstDayOfWeek(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFirstDayOfWeek(self: *@This(), value: DayOfWeek) core.HResult!void {
        const _c = self.vtable.put_FirstDayOfWeek(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsOutOfScopeEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsOutOfScopeEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsOutOfScopeEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsOutOfScopeEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsTodayHighlighted(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsTodayHighlighted(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsTodayHighlighted(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsTodayHighlighted(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMaxDate(self: *@This()) core.HResult!DateTime {
        var _r: DateTime = undefined;
        const _c = self.vtable.get_MaxDate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxDate(self: *@This(), value: DateTime) core.HResult!void {
        const _c = self.vtable.put_MaxDate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMinDate(self: *@This()) core.HResult!DateTime {
        var _r: DateTime = undefined;
        const _c = self.vtable.get_MinDate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMinDate(self: *@This(), value: DateTime) core.HResult!void {
        const _c = self.vtable.put_MinDate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getNumberOfWeeksInView(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_NumberOfWeeksInView(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putNumberOfWeeksInView(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_NumberOfWeeksInView(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectedDates(self: *@This()) core.HResult!*IVector(DateTime) {
        var _r: *IVector(DateTime) = undefined;
        const _c = self.vtable.get_SelectedDates(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionMode(self: *@This()) core.HResult!CalendarViewSelectionMode {
        var _r: CalendarViewSelectionMode = undefined;
        const _c = self.vtable.get_SelectionMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectionMode(self: *@This(), value: CalendarViewSelectionMode) core.HResult!void {
        const _c = self.vtable.put_SelectionMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*CalendarViewTemplateSettings {
        var _r: *CalendarViewTemplateSettings = undefined;
        const _c = self.vtable.get_TemplateSettings(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFocusBorderBrush(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_FocusBorderBrush(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFocusBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_FocusBorderBrush(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectedHoverBorderBrush(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_SelectedHoverBorderBrush(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectedHoverBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_SelectedHoverBorderBrush(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectedPressedBorderBrush(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_SelectedPressedBorderBrush(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectedPressedBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_SelectedPressedBorderBrush(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectedBorderBrush(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_SelectedBorderBrush(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectedBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_SelectedBorderBrush(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHoverBorderBrush(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_HoverBorderBrush(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHoverBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_HoverBorderBrush(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPressedBorderBrush(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_PressedBorderBrush(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPressedBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_PressedBorderBrush(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCalendarItemBorderBrush(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_CalendarItemBorderBrush(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCalendarItemBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_CalendarItemBorderBrush(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOutOfScopeBackground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_OutOfScopeBackground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOutOfScopeBackground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_OutOfScopeBackground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCalendarItemBackground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_CalendarItemBackground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCalendarItemBackground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_CalendarItemBackground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPressedForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_PressedForeground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPressedForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_PressedForeground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTodayForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_TodayForeground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTodayForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_TodayForeground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBlackoutForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_BlackoutForeground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBlackoutForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_BlackoutForeground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectedForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_SelectedForeground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectedForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_SelectedForeground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOutOfScopeForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_OutOfScopeForeground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOutOfScopeForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_OutOfScopeForeground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCalendarItemForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_CalendarItemForeground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCalendarItemForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_CalendarItemForeground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDayItemFontFamily(self: *@This()) core.HResult!*FontFamily {
        var _r: *FontFamily = undefined;
        const _c = self.vtable.get_DayItemFontFamily(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDayItemFontFamily(self: *@This(), value: *FontFamily) core.HResult!void {
        const _c = self.vtable.put_DayItemFontFamily(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDayItemFontSize(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_DayItemFontSize(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDayItemFontSize(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_DayItemFontSize(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDayItemFontStyle(self: *@This()) core.HResult!FontStyle {
        var _r: FontStyle = undefined;
        const _c = self.vtable.get_DayItemFontStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDayItemFontStyle(self: *@This(), value: FontStyle) core.HResult!void {
        const _c = self.vtable.put_DayItemFontStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDayItemFontWeight(self: *@This()) core.HResult!FontWeight {
        var _r: FontWeight = undefined;
        const _c = self.vtable.get_DayItemFontWeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDayItemFontWeight(self: *@This(), value: FontWeight) core.HResult!void {
        const _c = self.vtable.put_DayItemFontWeight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTodayFontWeight(self: *@This()) core.HResult!FontWeight {
        var _r: FontWeight = undefined;
        const _c = self.vtable.get_TodayFontWeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTodayFontWeight(self: *@This(), value: FontWeight) core.HResult!void {
        const _c = self.vtable.put_TodayFontWeight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFirstOfMonthLabelFontFamily(self: *@This()) core.HResult!*FontFamily {
        var _r: *FontFamily = undefined;
        const _c = self.vtable.get_FirstOfMonthLabelFontFamily(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFirstOfMonthLabelFontFamily(self: *@This(), value: *FontFamily) core.HResult!void {
        const _c = self.vtable.put_FirstOfMonthLabelFontFamily(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFirstOfMonthLabelFontSize(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_FirstOfMonthLabelFontSize(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFirstOfMonthLabelFontSize(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_FirstOfMonthLabelFontSize(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFirstOfMonthLabelFontStyle(self: *@This()) core.HResult!FontStyle {
        var _r: FontStyle = undefined;
        const _c = self.vtable.get_FirstOfMonthLabelFontStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFirstOfMonthLabelFontStyle(self: *@This(), value: FontStyle) core.HResult!void {
        const _c = self.vtable.put_FirstOfMonthLabelFontStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFirstOfMonthLabelFontWeight(self: *@This()) core.HResult!FontWeight {
        var _r: FontWeight = undefined;
        const _c = self.vtable.get_FirstOfMonthLabelFontWeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFirstOfMonthLabelFontWeight(self: *@This(), value: FontWeight) core.HResult!void {
        const _c = self.vtable.put_FirstOfMonthLabelFontWeight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMonthYearItemFontFamily(self: *@This()) core.HResult!*FontFamily {
        var _r: *FontFamily = undefined;
        const _c = self.vtable.get_MonthYearItemFontFamily(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMonthYearItemFontFamily(self: *@This(), value: *FontFamily) core.HResult!void {
        const _c = self.vtable.put_MonthYearItemFontFamily(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMonthYearItemFontSize(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_MonthYearItemFontSize(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMonthYearItemFontSize(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_MonthYearItemFontSize(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMonthYearItemFontStyle(self: *@This()) core.HResult!FontStyle {
        var _r: FontStyle = undefined;
        const _c = self.vtable.get_MonthYearItemFontStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMonthYearItemFontStyle(self: *@This(), value: FontStyle) core.HResult!void {
        const _c = self.vtable.put_MonthYearItemFontStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMonthYearItemFontWeight(self: *@This()) core.HResult!FontWeight {
        var _r: FontWeight = undefined;
        const _c = self.vtable.get_MonthYearItemFontWeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMonthYearItemFontWeight(self: *@This(), value: FontWeight) core.HResult!void {
        const _c = self.vtable.put_MonthYearItemFontWeight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFirstOfYearDecadeLabelFontFamily(self: *@This()) core.HResult!*FontFamily {
        var _r: *FontFamily = undefined;
        const _c = self.vtable.get_FirstOfYearDecadeLabelFontFamily(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFirstOfYearDecadeLabelFontFamily(self: *@This(), value: *FontFamily) core.HResult!void {
        const _c = self.vtable.put_FirstOfYearDecadeLabelFontFamily(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFirstOfYearDecadeLabelFontSize(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_FirstOfYearDecadeLabelFontSize(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFirstOfYearDecadeLabelFontSize(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_FirstOfYearDecadeLabelFontSize(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFirstOfYearDecadeLabelFontStyle(self: *@This()) core.HResult!FontStyle {
        var _r: FontStyle = undefined;
        const _c = self.vtable.get_FirstOfYearDecadeLabelFontStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFirstOfYearDecadeLabelFontStyle(self: *@This(), value: FontStyle) core.HResult!void {
        const _c = self.vtable.put_FirstOfYearDecadeLabelFontStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFirstOfYearDecadeLabelFontWeight(self: *@This()) core.HResult!FontWeight {
        var _r: FontWeight = undefined;
        const _c = self.vtable.get_FirstOfYearDecadeLabelFontWeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFirstOfYearDecadeLabelFontWeight(self: *@This(), value: FontWeight) core.HResult!void {
        const _c = self.vtable.put_FirstOfYearDecadeLabelFontWeight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHorizontalDayItemAlignment(self: *@This()) core.HResult!HorizontalAlignment {
        var _r: HorizontalAlignment = undefined;
        const _c = self.vtable.get_HorizontalDayItemAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHorizontalDayItemAlignment(self: *@This(), value: HorizontalAlignment) core.HResult!void {
        const _c = self.vtable.put_HorizontalDayItemAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getVerticalDayItemAlignment(self: *@This()) core.HResult!VerticalAlignment {
        var _r: VerticalAlignment = undefined;
        const _c = self.vtable.get_VerticalDayItemAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putVerticalDayItemAlignment(self: *@This(), value: VerticalAlignment) core.HResult!void {
        const _c = self.vtable.put_VerticalDayItemAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHorizontalFirstOfMonthLabelAlignment(self: *@This()) core.HResult!HorizontalAlignment {
        var _r: HorizontalAlignment = undefined;
        const _c = self.vtable.get_HorizontalFirstOfMonthLabelAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHorizontalFirstOfMonthLabelAlignment(self: *@This(), value: HorizontalAlignment) core.HResult!void {
        const _c = self.vtable.put_HorizontalFirstOfMonthLabelAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getVerticalFirstOfMonthLabelAlignment(self: *@This()) core.HResult!VerticalAlignment {
        var _r: VerticalAlignment = undefined;
        const _c = self.vtable.get_VerticalFirstOfMonthLabelAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putVerticalFirstOfMonthLabelAlignment(self: *@This(), value: VerticalAlignment) core.HResult!void {
        const _c = self.vtable.put_VerticalFirstOfMonthLabelAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCalendarItemBorderThickness(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_CalendarItemBorderThickness(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCalendarItemBorderThickness(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_CalendarItemBorderThickness(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCalendarViewDayItemStyle(self: *@This()) core.HResult!*Style {
        var _r: *Style = undefined;
        const _c = self.vtable.get_CalendarViewDayItemStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCalendarViewDayItemStyle(self: *@This(), value: *Style) core.HResult!void {
        const _c = self.vtable.put_CalendarViewDayItemStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addCalendarViewDayItemChanging(self: *@This(), handler: *TypedEventHandler(CalendarView,CalendarViewDayItemChangingEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_CalendarViewDayItemChanging(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeCalendarViewDayItemChanging(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_CalendarViewDayItemChanging(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addSelectedDatesChanged(self: *@This(), handler: *TypedEventHandler(CalendarView,CalendarViewSelectedDatesChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_SelectedDatesChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeSelectedDatesChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_SelectedDatesChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn SetDisplayDate(self: *@This(), date: DateTime) core.HResult!void {
        const _c = self.vtable.SetDisplayDate(@ptrCast(self), date);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn SetYearDecadeDisplayDimensions(self: *@This(), columns: i32, rows: i32) core.HResult!void {
        const _c = self.vtable.SetYearDecadeDisplayDimensions(@ptrCast(self), columns, rows);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICalendarView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "cd639203-dfb5-4312-ac07-c0391824607b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CalendarIdentifier: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_CalendarIdentifier: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_DayOfWeekFormat: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_DayOfWeekFormat: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_IsGroupLabelVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsGroupLabelVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_DisplayMode: *const fn(self: *anyopaque, _r: *CalendarViewDisplayMode) callconv(.winapi) HRESULT,
        put_DisplayMode: *const fn(self: *anyopaque, value: CalendarViewDisplayMode) callconv(.winapi) HRESULT,
        get_FirstDayOfWeek: *const fn(self: *anyopaque, _r: *DayOfWeek) callconv(.winapi) HRESULT,
        put_FirstDayOfWeek: *const fn(self: *anyopaque, value: DayOfWeek) callconv(.winapi) HRESULT,
        get_IsOutOfScopeEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsOutOfScopeEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsTodayHighlighted: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsTodayHighlighted: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_MaxDate: *const fn(self: *anyopaque, _r: *DateTime) callconv(.winapi) HRESULT,
        put_MaxDate: *const fn(self: *anyopaque, value: DateTime) callconv(.winapi) HRESULT,
        get_MinDate: *const fn(self: *anyopaque, _r: *DateTime) callconv(.winapi) HRESULT,
        put_MinDate: *const fn(self: *anyopaque, value: DateTime) callconv(.winapi) HRESULT,
        get_NumberOfWeeksInView: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_NumberOfWeeksInView: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_SelectedDates: *const fn(self: *anyopaque, _r: **IVector(DateTime)) callconv(.winapi) HRESULT,
        get_SelectionMode: *const fn(self: *anyopaque, _r: *CalendarViewSelectionMode) callconv(.winapi) HRESULT,
        put_SelectionMode: *const fn(self: *anyopaque, value: CalendarViewSelectionMode) callconv(.winapi) HRESULT,
        get_TemplateSettings: *const fn(self: *anyopaque, _r: **CalendarViewTemplateSettings) callconv(.winapi) HRESULT,
        get_FocusBorderBrush: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_FocusBorderBrush: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_SelectedHoverBorderBrush: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_SelectedHoverBorderBrush: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_SelectedPressedBorderBrush: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_SelectedPressedBorderBrush: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_SelectedBorderBrush: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_SelectedBorderBrush: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_HoverBorderBrush: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_HoverBorderBrush: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_PressedBorderBrush: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_PressedBorderBrush: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_CalendarItemBorderBrush: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_CalendarItemBorderBrush: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_OutOfScopeBackground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_OutOfScopeBackground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_CalendarItemBackground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_CalendarItemBackground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_PressedForeground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_PressedForeground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_TodayForeground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_TodayForeground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_BlackoutForeground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_BlackoutForeground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_SelectedForeground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_SelectedForeground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_OutOfScopeForeground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_OutOfScopeForeground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_CalendarItemForeground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_CalendarItemForeground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_DayItemFontFamily: *const fn(self: *anyopaque, _r: **FontFamily) callconv(.winapi) HRESULT,
        put_DayItemFontFamily: *const fn(self: *anyopaque, value: *FontFamily) callconv(.winapi) HRESULT,
        get_DayItemFontSize: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_DayItemFontSize: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_DayItemFontStyle: *const fn(self: *anyopaque, _r: *FontStyle) callconv(.winapi) HRESULT,
        put_DayItemFontStyle: *const fn(self: *anyopaque, value: FontStyle) callconv(.winapi) HRESULT,
        get_DayItemFontWeight: *const fn(self: *anyopaque, _r: *FontWeight) callconv(.winapi) HRESULT,
        put_DayItemFontWeight: *const fn(self: *anyopaque, value: FontWeight) callconv(.winapi) HRESULT,
        get_TodayFontWeight: *const fn(self: *anyopaque, _r: *FontWeight) callconv(.winapi) HRESULT,
        put_TodayFontWeight: *const fn(self: *anyopaque, value: FontWeight) callconv(.winapi) HRESULT,
        get_FirstOfMonthLabelFontFamily: *const fn(self: *anyopaque, _r: **FontFamily) callconv(.winapi) HRESULT,
        put_FirstOfMonthLabelFontFamily: *const fn(self: *anyopaque, value: *FontFamily) callconv(.winapi) HRESULT,
        get_FirstOfMonthLabelFontSize: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_FirstOfMonthLabelFontSize: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_FirstOfMonthLabelFontStyle: *const fn(self: *anyopaque, _r: *FontStyle) callconv(.winapi) HRESULT,
        put_FirstOfMonthLabelFontStyle: *const fn(self: *anyopaque, value: FontStyle) callconv(.winapi) HRESULT,
        get_FirstOfMonthLabelFontWeight: *const fn(self: *anyopaque, _r: *FontWeight) callconv(.winapi) HRESULT,
        put_FirstOfMonthLabelFontWeight: *const fn(self: *anyopaque, value: FontWeight) callconv(.winapi) HRESULT,
        get_MonthYearItemFontFamily: *const fn(self: *anyopaque, _r: **FontFamily) callconv(.winapi) HRESULT,
        put_MonthYearItemFontFamily: *const fn(self: *anyopaque, value: *FontFamily) callconv(.winapi) HRESULT,
        get_MonthYearItemFontSize: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_MonthYearItemFontSize: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_MonthYearItemFontStyle: *const fn(self: *anyopaque, _r: *FontStyle) callconv(.winapi) HRESULT,
        put_MonthYearItemFontStyle: *const fn(self: *anyopaque, value: FontStyle) callconv(.winapi) HRESULT,
        get_MonthYearItemFontWeight: *const fn(self: *anyopaque, _r: *FontWeight) callconv(.winapi) HRESULT,
        put_MonthYearItemFontWeight: *const fn(self: *anyopaque, value: FontWeight) callconv(.winapi) HRESULT,
        get_FirstOfYearDecadeLabelFontFamily: *const fn(self: *anyopaque, _r: **FontFamily) callconv(.winapi) HRESULT,
        put_FirstOfYearDecadeLabelFontFamily: *const fn(self: *anyopaque, value: *FontFamily) callconv(.winapi) HRESULT,
        get_FirstOfYearDecadeLabelFontSize: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_FirstOfYearDecadeLabelFontSize: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_FirstOfYearDecadeLabelFontStyle: *const fn(self: *anyopaque, _r: *FontStyle) callconv(.winapi) HRESULT,
        put_FirstOfYearDecadeLabelFontStyle: *const fn(self: *anyopaque, value: FontStyle) callconv(.winapi) HRESULT,
        get_FirstOfYearDecadeLabelFontWeight: *const fn(self: *anyopaque, _r: *FontWeight) callconv(.winapi) HRESULT,
        put_FirstOfYearDecadeLabelFontWeight: *const fn(self: *anyopaque, value: FontWeight) callconv(.winapi) HRESULT,
        get_HorizontalDayItemAlignment: *const fn(self: *anyopaque, _r: *HorizontalAlignment) callconv(.winapi) HRESULT,
        put_HorizontalDayItemAlignment: *const fn(self: *anyopaque, value: HorizontalAlignment) callconv(.winapi) HRESULT,
        get_VerticalDayItemAlignment: *const fn(self: *anyopaque, _r: *VerticalAlignment) callconv(.winapi) HRESULT,
        put_VerticalDayItemAlignment: *const fn(self: *anyopaque, value: VerticalAlignment) callconv(.winapi) HRESULT,
        get_HorizontalFirstOfMonthLabelAlignment: *const fn(self: *anyopaque, _r: *HorizontalAlignment) callconv(.winapi) HRESULT,
        put_HorizontalFirstOfMonthLabelAlignment: *const fn(self: *anyopaque, value: HorizontalAlignment) callconv(.winapi) HRESULT,
        get_VerticalFirstOfMonthLabelAlignment: *const fn(self: *anyopaque, _r: *VerticalAlignment) callconv(.winapi) HRESULT,
        put_VerticalFirstOfMonthLabelAlignment: *const fn(self: *anyopaque, value: VerticalAlignment) callconv(.winapi) HRESULT,
        get_CalendarItemBorderThickness: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_CalendarItemBorderThickness: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
        get_CalendarViewDayItemStyle: *const fn(self: *anyopaque, _r: **Style) callconv(.winapi) HRESULT,
        put_CalendarViewDayItemStyle: *const fn(self: *anyopaque, value: *Style) callconv(.winapi) HRESULT,
        add_CalendarViewDayItemChanging: *const fn(self: *anyopaque, handler: *TypedEventHandler(CalendarView,CalendarViewDayItemChangingEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_CalendarViewDayItemChanging: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_SelectedDatesChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(CalendarView,CalendarViewSelectedDatesChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_SelectedDatesChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        SetDisplayDate: *const fn(self: *anyopaque, date: DateTime) callconv(.winapi) HRESULT,
        SetYearDecadeDisplayDimensions: *const fn(self: *anyopaque, columns: i32, rows: i32) callconv(.winapi) HRESULT,
    };
};
pub const ICalendarView2 = extern struct {
    vtable: *const VTable,
    pub fn getSelectedDisabledBorderBrush(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_SelectedDisabledBorderBrush(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectedDisabledBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_SelectedDisabledBorderBrush(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTodaySelectedInnerBorderBrush(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_TodaySelectedInnerBorderBrush(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTodaySelectedInnerBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_TodaySelectedInnerBorderBrush(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBlackoutStrikethroughBrush(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_BlackoutStrikethroughBrush(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBlackoutStrikethroughBrush(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_BlackoutStrikethroughBrush(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBlackoutBackground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_BlackoutBackground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBlackoutBackground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_BlackoutBackground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCalendarItemHoverBackground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_CalendarItemHoverBackground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCalendarItemHoverBackground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_CalendarItemHoverBackground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCalendarItemPressedBackground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_CalendarItemPressedBackground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCalendarItemPressedBackground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_CalendarItemPressedBackground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCalendarItemDisabledBackground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_CalendarItemDisabledBackground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCalendarItemDisabledBackground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_CalendarItemDisabledBackground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTodayBackground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_TodayBackground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTodayBackground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_TodayBackground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTodayBlackoutBackground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_TodayBlackoutBackground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTodayBlackoutBackground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_TodayBlackoutBackground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTodayHoverBackground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_TodayHoverBackground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTodayHoverBackground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_TodayHoverBackground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTodayPressedBackground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_TodayPressedBackground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTodayPressedBackground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_TodayPressedBackground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTodayDisabledBackground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_TodayDisabledBackground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTodayDisabledBackground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_TodayDisabledBackground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTodayBlackoutForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_TodayBlackoutForeground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTodayBlackoutForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_TodayBlackoutForeground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectedHoverForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_SelectedHoverForeground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectedHoverForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_SelectedHoverForeground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectedPressedForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_SelectedPressedForeground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectedPressedForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_SelectedPressedForeground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectedDisabledForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_SelectedDisabledForeground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectedDisabledForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_SelectedDisabledForeground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOutOfScopeHoverForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_OutOfScopeHoverForeground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOutOfScopeHoverForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_OutOfScopeHoverForeground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOutOfScopePressedForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_OutOfScopePressedForeground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOutOfScopePressedForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_OutOfScopePressedForeground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDisabledForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_DisabledForeground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDisabledForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_DisabledForeground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDayItemMargin(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_DayItemMargin(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDayItemMargin(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_DayItemMargin(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMonthYearItemMargin(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_MonthYearItemMargin(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMonthYearItemMargin(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_MonthYearItemMargin(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFirstOfMonthLabelMargin(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_FirstOfMonthLabelMargin(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFirstOfMonthLabelMargin(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_FirstOfMonthLabelMargin(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFirstOfYearDecadeLabelMargin(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_FirstOfYearDecadeLabelMargin(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFirstOfYearDecadeLabelMargin(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_FirstOfYearDecadeLabelMargin(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCalendarItemCornerRadius(self: *@This()) core.HResult!CornerRadius {
        var _r: CornerRadius = undefined;
        const _c = self.vtable.get_CalendarItemCornerRadius(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCalendarItemCornerRadius(self: *@This(), value: CornerRadius) core.HResult!void {
        const _c = self.vtable.put_CalendarItemCornerRadius(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICalendarView2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f55ab64a-5504-5d9e-9d20-2ffdb88fc56b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectedDisabledBorderBrush: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_SelectedDisabledBorderBrush: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_TodaySelectedInnerBorderBrush: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_TodaySelectedInnerBorderBrush: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_BlackoutStrikethroughBrush: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_BlackoutStrikethroughBrush: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_BlackoutBackground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_BlackoutBackground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_CalendarItemHoverBackground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_CalendarItemHoverBackground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_CalendarItemPressedBackground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_CalendarItemPressedBackground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_CalendarItemDisabledBackground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_CalendarItemDisabledBackground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_TodayBackground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_TodayBackground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_TodayBlackoutBackground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_TodayBlackoutBackground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_TodayHoverBackground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_TodayHoverBackground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_TodayPressedBackground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_TodayPressedBackground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_TodayDisabledBackground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_TodayDisabledBackground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_TodayBlackoutForeground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_TodayBlackoutForeground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_SelectedHoverForeground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_SelectedHoverForeground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_SelectedPressedForeground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_SelectedPressedForeground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_SelectedDisabledForeground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_SelectedDisabledForeground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_OutOfScopeHoverForeground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_OutOfScopeHoverForeground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_OutOfScopePressedForeground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_OutOfScopePressedForeground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_DisabledForeground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_DisabledForeground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_DayItemMargin: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_DayItemMargin: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
        get_MonthYearItemMargin: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_MonthYearItemMargin: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
        get_FirstOfMonthLabelMargin: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_FirstOfMonthLabelMargin: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
        get_FirstOfYearDecadeLabelMargin: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_FirstOfYearDecadeLabelMargin: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
        get_CalendarItemCornerRadius: *const fn(self: *anyopaque, _r: *CornerRadius) callconv(.winapi) HRESULT,
        put_CalendarItemCornerRadius: *const fn(self: *anyopaque, value: CornerRadius) callconv(.winapi) HRESULT,
    };
};
pub const ICalendarViewDayItem = extern struct {
    vtable: *const VTable,
    pub fn getIsBlackout(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsBlackout(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsBlackout(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsBlackout(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDate(self: *@This()) core.HResult!DateTime {
        var _r: DateTime = undefined;
        const _c = self.vtable.get_Date(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetDensityColors(self: *@This(), colors: *IIterable(Color)) core.HResult!void {
        const _c = self.vtable.SetDensityColors(@ptrCast(self), colors);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICalendarViewDayItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0fdb2dc5-32c1-4b8f-befc-017b555b32d2";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsBlackout: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsBlackout: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_Date: *const fn(self: *anyopaque, _r: *DateTime) callconv(.winapi) HRESULT,
        SetDensityColors: *const fn(self: *anyopaque, colors: *IIterable(Color)) callconv(.winapi) HRESULT,
    };
};
pub const ICalendarViewDayItemChangingEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getInRecycleQueue(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_InRecycleQueue(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItem(self: *@This()) core.HResult!*CalendarViewDayItem {
        var _r: *CalendarViewDayItem = undefined;
        const _c = self.vtable.get_Item(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPhase(self: *@This()) core.HResult!u32 {
        var _r: u32 = undefined;
        const _c = self.vtable.get_Phase(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn RegisterUpdateCallback(self: *@This(), callback: *TypedEventHandler(CalendarView,CalendarViewDayItemChangingEventArgs)) core.HResult!void {
        const _c = self.vtable.RegisterUpdateCallback(@ptrCast(self), callback);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn RegisterUpdateCallbackWithCallbackPhaseAndCallback(self: *@This(), callbackPhase: u32, callback: *TypedEventHandler(CalendarView,CalendarViewDayItemChangingEventArgs)) core.HResult!void {
        const _c = self.vtable.RegisterUpdateCallbackWithCallbackPhaseAndCallback(@ptrCast(self), callbackPhase, callback);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICalendarViewDayItemChangingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "73146666-1fb1-44f9-b7ad-4de859ecc565";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_InRecycleQueue: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_Item: *const fn(self: *anyopaque, _r: **CalendarViewDayItem) callconv(.winapi) HRESULT,
        get_Phase: *const fn(self: *anyopaque, _r: *u32) callconv(.winapi) HRESULT,
        RegisterUpdateCallback: *const fn(self: *anyopaque, callback: *TypedEventHandler(CalendarView,CalendarViewDayItemChangingEventArgs)) callconv(.winapi) HRESULT,
        RegisterUpdateCallbackWithCallbackPhaseAndCallback: *const fn(self: *anyopaque, callbackPhase: u32, callback: *TypedEventHandler(CalendarView,CalendarViewDayItemChangingEventArgs)) callconv(.winapi) HRESULT,
    };
};
pub const ICalendarViewDayItemFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*CalendarViewDayItem {
        var _r: *CalendarViewDayItem = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICalendarViewDayItemFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "62112bdc-1d2f-4e44-9baf-1665749521f2";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **CalendarViewDayItem) callconv(.winapi) HRESULT,
    };
};
pub const ICalendarViewDayItemStatics = extern struct {
    vtable: *const VTable,
    pub fn getIsBlackoutProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsBlackoutProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICalendarViewDayItemStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c3a1dbbf-bd88-488b-b916-d00d69b1735a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsBlackoutProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ICalendarViewFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*CalendarView {
        var _r: *CalendarView = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICalendarViewFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3d8f82e3-6cc6-423e-8d7c-7014d954ddef";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **CalendarView) callconv(.winapi) HRESULT,
    };
};
pub const ICalendarViewSelectedDatesChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getAddedDates(self: *@This()) core.HResult!*IVectorView(DateTime) {
        var _r: *IVectorView(DateTime) = undefined;
        const _c = self.vtable.get_AddedDates(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getRemovedDates(self: *@This()) core.HResult!*IVectorView(DateTime) {
        var _r: *IVectorView(DateTime) = undefined;
        const _c = self.vtable.get_RemovedDates(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICalendarViewSelectedDatesChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ee6069f6-13ef-4896-8ffc-5302b1b17539";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_AddedDates: *const fn(self: *anyopaque, _r: **IVectorView(DateTime)) callconv(.winapi) HRESULT,
        get_RemovedDates: *const fn(self: *anyopaque, _r: **IVectorView(DateTime)) callconv(.winapi) HRESULT,
    };
};
pub const ICalendarViewStatics = extern struct {
    vtable: *const VTable,
    pub fn getCalendarIdentifierProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CalendarIdentifierProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDayOfWeekFormatProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DayOfWeekFormatProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsGroupLabelVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsGroupLabelVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDisplayModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DisplayModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFirstDayOfWeekProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FirstDayOfWeekProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsOutOfScopeEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsOutOfScopeEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsTodayHighlightedProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsTodayHighlightedProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaxDateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxDateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMinDateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MinDateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getNumberOfWeeksInViewProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_NumberOfWeeksInViewProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedDatesProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedDatesProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectionModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTemplateSettingsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TemplateSettingsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFocusBorderBrushProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FocusBorderBrushProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedHoverBorderBrushProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedHoverBorderBrushProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedPressedBorderBrushProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedPressedBorderBrushProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedBorderBrushProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedBorderBrushProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHoverBorderBrushProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HoverBorderBrushProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPressedBorderBrushProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PressedBorderBrushProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCalendarItemBorderBrushProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CalendarItemBorderBrushProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOutOfScopeBackgroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OutOfScopeBackgroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCalendarItemBackgroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CalendarItemBackgroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPressedForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PressedForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTodayForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TodayForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBlackoutForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BlackoutForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOutOfScopeForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OutOfScopeForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCalendarItemForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CalendarItemForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDayItemFontFamilyProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DayItemFontFamilyProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDayItemFontSizeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DayItemFontSizeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDayItemFontStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DayItemFontStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDayItemFontWeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DayItemFontWeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTodayFontWeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TodayFontWeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFirstOfMonthLabelFontFamilyProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FirstOfMonthLabelFontFamilyProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFirstOfMonthLabelFontSizeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FirstOfMonthLabelFontSizeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFirstOfMonthLabelFontStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FirstOfMonthLabelFontStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFirstOfMonthLabelFontWeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FirstOfMonthLabelFontWeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMonthYearItemFontFamilyProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MonthYearItemFontFamilyProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMonthYearItemFontSizeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MonthYearItemFontSizeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMonthYearItemFontStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MonthYearItemFontStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMonthYearItemFontWeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MonthYearItemFontWeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFirstOfYearDecadeLabelFontFamilyProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FirstOfYearDecadeLabelFontFamilyProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFirstOfYearDecadeLabelFontSizeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FirstOfYearDecadeLabelFontSizeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFirstOfYearDecadeLabelFontStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FirstOfYearDecadeLabelFontStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFirstOfYearDecadeLabelFontWeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FirstOfYearDecadeLabelFontWeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHorizontalDayItemAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HorizontalDayItemAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getVerticalDayItemAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_VerticalDayItemAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHorizontalFirstOfMonthLabelAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HorizontalFirstOfMonthLabelAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getVerticalFirstOfMonthLabelAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_VerticalFirstOfMonthLabelAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCalendarItemBorderThicknessProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CalendarItemBorderThicknessProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCalendarViewDayItemStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CalendarViewDayItemStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICalendarViewStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "7260f1c4-2f5d-41bd-99bb-4571b20b79a8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CalendarIdentifierProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DayOfWeekFormatProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsGroupLabelVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DisplayModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FirstDayOfWeekProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsOutOfScopeEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsTodayHighlightedProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaxDateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MinDateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_NumberOfWeeksInViewProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectedDatesProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectionModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TemplateSettingsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FocusBorderBrushProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectedHoverBorderBrushProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectedPressedBorderBrushProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectedBorderBrushProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HoverBorderBrushProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PressedBorderBrushProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CalendarItemBorderBrushProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OutOfScopeBackgroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CalendarItemBackgroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PressedForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TodayForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BlackoutForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectedForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OutOfScopeForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CalendarItemForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DayItemFontFamilyProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DayItemFontSizeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DayItemFontStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DayItemFontWeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TodayFontWeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FirstOfMonthLabelFontFamilyProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FirstOfMonthLabelFontSizeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FirstOfMonthLabelFontStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FirstOfMonthLabelFontWeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MonthYearItemFontFamilyProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MonthYearItemFontSizeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MonthYearItemFontStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MonthYearItemFontWeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FirstOfYearDecadeLabelFontFamilyProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FirstOfYearDecadeLabelFontSizeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FirstOfYearDecadeLabelFontStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FirstOfYearDecadeLabelFontWeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HorizontalDayItemAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_VerticalDayItemAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HorizontalFirstOfMonthLabelAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_VerticalFirstOfMonthLabelAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CalendarItemBorderThicknessProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CalendarViewDayItemStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ICalendarViewStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getSelectedDisabledBorderBrushProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedDisabledBorderBrushProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTodaySelectedInnerBorderBrushProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TodaySelectedInnerBorderBrushProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBlackoutStrikethroughBrushProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BlackoutStrikethroughBrushProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBlackoutBackgroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BlackoutBackgroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCalendarItemHoverBackgroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CalendarItemHoverBackgroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCalendarItemPressedBackgroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CalendarItemPressedBackgroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCalendarItemDisabledBackgroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CalendarItemDisabledBackgroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTodayBackgroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TodayBackgroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTodayBlackoutBackgroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TodayBlackoutBackgroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTodayHoverBackgroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TodayHoverBackgroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTodayPressedBackgroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TodayPressedBackgroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTodayDisabledBackgroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TodayDisabledBackgroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTodayBlackoutForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TodayBlackoutForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedHoverForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedHoverForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedPressedForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedPressedForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedDisabledForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedDisabledForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOutOfScopeHoverForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OutOfScopeHoverForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOutOfScopePressedForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OutOfScopePressedForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDisabledForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DisabledForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDayItemMarginProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DayItemMarginProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMonthYearItemMarginProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MonthYearItemMarginProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFirstOfMonthLabelMarginProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FirstOfMonthLabelMarginProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFirstOfYearDecadeLabelMarginProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FirstOfYearDecadeLabelMarginProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCalendarItemCornerRadiusProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CalendarItemCornerRadiusProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICalendarViewStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f29e5024-b8fb-50c8-8a38-d443abb37009";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectedDisabledBorderBrushProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TodaySelectedInnerBorderBrushProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BlackoutStrikethroughBrushProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BlackoutBackgroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CalendarItemHoverBackgroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CalendarItemPressedBackgroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CalendarItemDisabledBackgroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TodayBackgroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TodayBlackoutBackgroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TodayHoverBackgroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TodayPressedBackgroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TodayDisabledBackgroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TodayBlackoutForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectedHoverForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectedPressedForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectedDisabledForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OutOfScopeHoverForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OutOfScopePressedForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DisabledForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DayItemMarginProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MonthYearItemMarginProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FirstOfMonthLabelMarginProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FirstOfYearDecadeLabelMarginProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CalendarItemCornerRadiusProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ICandidateWindowBoundsChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getBounds(self: *@This()) core.HResult!Rect {
        var _r: Rect = undefined;
        const _c = self.vtable.get_Bounds(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICandidateWindowBoundsChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8a946458-83b0-4c32-9450-5169a5838b55";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Bounds: *const fn(self: *anyopaque, _r: *Rect) callconv(.winapi) HRESULT,
    };
};
pub const ICanvas = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICanvas";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "79190e19-cd38-4823-aeae-64a77132f519";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const ICanvasFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*Canvas {
        var _r: *Canvas = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICanvasFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1b328bd1-b400-4a8e-943b-5ad2c45be0df";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **Canvas) callconv(.winapi) HRESULT,
    };
};
pub const ICanvasStatics = extern struct {
    vtable: *const VTable,
    pub fn getLeftProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LeftProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetLeft(self: *@This(), element: *UIElement) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.GetLeft(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetLeft(self: *@This(), element: *UIElement, length: f64) core.HResult!void {
        const _c = self.vtable.SetLeft(@ptrCast(self), element, length);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTopProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TopProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetTop(self: *@This(), element: *UIElement) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.GetTop(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetTop(self: *@This(), element: *UIElement, length: f64) core.HResult!void {
        const _c = self.vtable.SetTop(@ptrCast(self), element, length);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getZIndexProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ZIndexProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetZIndex(self: *@This(), element: *UIElement) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.GetZIndex(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetZIndex(self: *@This(), element: *UIElement, value: i32) core.HResult!void {
        const _c = self.vtable.SetZIndex(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICanvasStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "40ce5c46-2962-446f-aafb-4cdc486939c9";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LeftProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetLeft: *const fn(self: *anyopaque, element: *UIElement, _r: *f64) callconv(.winapi) HRESULT,
        SetLeft: *const fn(self: *anyopaque, element: *UIElement, length: f64) callconv(.winapi) HRESULT,
        get_TopProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetTop: *const fn(self: *anyopaque, element: *UIElement, _r: *f64) callconv(.winapi) HRESULT,
        SetTop: *const fn(self: *anyopaque, element: *UIElement, length: f64) callconv(.winapi) HRESULT,
        get_ZIndexProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetZIndex: *const fn(self: *anyopaque, element: *UIElement, _r: *i32) callconv(.winapi) HRESULT,
        SetZIndex: *const fn(self: *anyopaque, element: *UIElement, value: i32) callconv(.winapi) HRESULT,
    };
};
pub const ICaptureElement = extern struct {
    vtable: *const VTable,
    pub fn getSource(self: *@This()) core.HResult!*MediaCapture {
        var _r: *MediaCapture = undefined;
        const _c = self.vtable.get_Source(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSource(self: *@This(), value: *MediaCapture) core.HResult!void {
        const _c = self.vtable.put_Source(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getStretch(self: *@This()) core.HResult!Stretch {
        var _r: Stretch = undefined;
        const _c = self.vtable.get_Stretch(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putStretch(self: *@This(), value: Stretch) core.HResult!void {
        const _c = self.vtable.put_Stretch(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICaptureElement";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "31a5c0e7-f307-4d4a-b626-e978863f5b74";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Source: *const fn(self: *anyopaque, _r: **MediaCapture) callconv(.winapi) HRESULT,
        put_Source: *const fn(self: *anyopaque, value: *MediaCapture) callconv(.winapi) HRESULT,
        get_Stretch: *const fn(self: *anyopaque, _r: *Stretch) callconv(.winapi) HRESULT,
        put_Stretch: *const fn(self: *anyopaque, value: Stretch) callconv(.winapi) HRESULT,
    };
};
pub const ICaptureElementStatics = extern struct {
    vtable: *const VTable,
    pub fn getSourceProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SourceProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getStretchProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_StretchProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICaptureElementStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1e438ded-7da6-409e-806e-305ae4ad9b3f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SourceProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_StretchProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ICheckBox = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICheckBox";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "2294c894-7e2a-4b70-b088-8f5d814875ba";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const ICheckBoxFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*CheckBox {
        var _r: *CheckBox = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICheckBoxFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4fa6aabb-3f4b-4301-be07-1172ea61eefb";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **CheckBox) callconv(.winapi) HRESULT,
    };
};
pub const IChoosingGroupHeaderContainerEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getGroupHeaderContainer(self: *@This()) core.HResult!*ListViewBaseHeaderItem {
        var _r: *ListViewBaseHeaderItem = undefined;
        const _c = self.vtable.get_GroupHeaderContainer(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putGroupHeaderContainer(self: *@This(), value: *ListViewBaseHeaderItem) core.HResult!void {
        const _c = self.vtable.put_GroupHeaderContainer(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getGroupIndex(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_GroupIndex(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getGroup(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Group(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IChoosingGroupHeaderContainerEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "67db44d6-d201-4d72-beac-5e8e58afd8c7";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_GroupHeaderContainer: *const fn(self: *anyopaque, _r: **ListViewBaseHeaderItem) callconv(.winapi) HRESULT,
        put_GroupHeaderContainer: *const fn(self: *anyopaque, value: *ListViewBaseHeaderItem) callconv(.winapi) HRESULT,
        get_GroupIndex: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_Group: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
    };
};
pub const IChoosingItemContainerEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getItemIndex(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_ItemIndex(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItem(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Item(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemContainer(self: *@This()) core.HResult!*SelectorItem {
        var _r: *SelectorItem = undefined;
        const _c = self.vtable.get_ItemContainer(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemContainer(self: *@This(), value: *SelectorItem) core.HResult!void {
        const _c = self.vtable.put_ItemContainer(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsContainerPrepared(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsContainerPrepared(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsContainerPrepared(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsContainerPrepared(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IChoosingItemContainerEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9bb43bce-ae67-4a80-8363-e3fe1b244f2c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ItemIndex: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_Item: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        get_ItemContainer: *const fn(self: *anyopaque, _r: **SelectorItem) callconv(.winapi) HRESULT,
        put_ItemContainer: *const fn(self: *anyopaque, value: *SelectorItem) callconv(.winapi) HRESULT,
        get_IsContainerPrepared: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsContainerPrepared: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const ICleanUpVirtualizedItemEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getValue(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Value(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getUIElement(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_UIElement(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCancel(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_Cancel(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCancel(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_Cancel(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICleanUpVirtualizedItemEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ea05cce9-937c-4120-8406-792185784338";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Value: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        get_UIElement: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        get_Cancel: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_Cancel: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IColorChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getOldColor(self: *@This()) core.HResult!Color {
        var _r: Color = undefined;
        const _c = self.vtable.get_OldColor(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getNewColor(self: *@This()) core.HResult!Color {
        var _r: Color = undefined;
        const _c = self.vtable.get_NewColor(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IColorChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "34f7201f-aad0-4c3a-b97b-2abf36455539";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_OldColor: *const fn(self: *anyopaque, _r: *Color) callconv(.winapi) HRESULT,
        get_NewColor: *const fn(self: *anyopaque, _r: *Color) callconv(.winapi) HRESULT,
    };
};
pub const IColorPicker = extern struct {
    vtable: *const VTable,
    pub fn getColor(self: *@This()) core.HResult!Color {
        var _r: Color = undefined;
        const _c = self.vtable.get_Color(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putColor(self: *@This(), value: Color) core.HResult!void {
        const _c = self.vtable.put_Color(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPreviousColor(self: *@This()) core.HResult!*IReference(Color) {
        var _r: *IReference(Color) = undefined;
        const _c = self.vtable.get_PreviousColor(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPreviousColor(self: *@This(), value: *IReference(Color)) core.HResult!void {
        const _c = self.vtable.put_PreviousColor(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsAlphaEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsAlphaEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsAlphaEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsAlphaEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsColorSpectrumVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsColorSpectrumVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsColorSpectrumVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsColorSpectrumVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsColorPreviewVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsColorPreviewVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsColorPreviewVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsColorPreviewVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsColorSliderVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsColorSliderVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsColorSliderVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsColorSliderVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsAlphaSliderVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsAlphaSliderVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsAlphaSliderVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsAlphaSliderVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsMoreButtonVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsMoreButtonVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsMoreButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsMoreButtonVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsColorChannelTextInputVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsColorChannelTextInputVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsColorChannelTextInputVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsColorChannelTextInputVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsAlphaTextInputVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsAlphaTextInputVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsAlphaTextInputVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsAlphaTextInputVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsHexInputVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsHexInputVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsHexInputVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsHexInputVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMinHue(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_MinHue(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMinHue(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_MinHue(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMaxHue(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_MaxHue(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxHue(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_MaxHue(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMinSaturation(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_MinSaturation(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMinSaturation(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_MinSaturation(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMaxSaturation(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_MaxSaturation(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxSaturation(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_MaxSaturation(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMinValue(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_MinValue(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMinValue(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_MinValue(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMaxValue(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_MaxValue(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxValue(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_MaxValue(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getColorSpectrumShape(self: *@This()) core.HResult!ColorSpectrumShape {
        var _r: ColorSpectrumShape = undefined;
        const _c = self.vtable.get_ColorSpectrumShape(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putColorSpectrumShape(self: *@This(), value: ColorSpectrumShape) core.HResult!void {
        const _c = self.vtable.put_ColorSpectrumShape(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getColorSpectrumComponents(self: *@This()) core.HResult!ColorSpectrumComponents {
        var _r: ColorSpectrumComponents = undefined;
        const _c = self.vtable.get_ColorSpectrumComponents(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putColorSpectrumComponents(self: *@This(), value: ColorSpectrumComponents) core.HResult!void {
        const _c = self.vtable.put_ColorSpectrumComponents(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addColorChanged(self: *@This(), handler: *TypedEventHandler(ColorPicker,ColorChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ColorChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeColorChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ColorChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IColorPicker";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6232e371-5c64-43cb-8b35-7f82dde36740";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Color: *const fn(self: *anyopaque, _r: *Color) callconv(.winapi) HRESULT,
        put_Color: *const fn(self: *anyopaque, value: Color) callconv(.winapi) HRESULT,
        get_PreviousColor: *const fn(self: *anyopaque, _r: **IReference(Color)) callconv(.winapi) HRESULT,
        put_PreviousColor: *const fn(self: *anyopaque, value: *IReference(Color)) callconv(.winapi) HRESULT,
        get_IsAlphaEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsAlphaEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsColorSpectrumVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsColorSpectrumVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsColorPreviewVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsColorPreviewVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsColorSliderVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsColorSliderVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsAlphaSliderVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsAlphaSliderVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsMoreButtonVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsMoreButtonVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsColorChannelTextInputVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsColorChannelTextInputVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsAlphaTextInputVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsAlphaTextInputVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsHexInputVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsHexInputVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_MinHue: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_MinHue: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_MaxHue: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_MaxHue: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_MinSaturation: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_MinSaturation: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_MaxSaturation: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_MaxSaturation: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_MinValue: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_MinValue: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_MaxValue: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_MaxValue: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_ColorSpectrumShape: *const fn(self: *anyopaque, _r: *ColorSpectrumShape) callconv(.winapi) HRESULT,
        put_ColorSpectrumShape: *const fn(self: *anyopaque, value: ColorSpectrumShape) callconv(.winapi) HRESULT,
        get_ColorSpectrumComponents: *const fn(self: *anyopaque, _r: *ColorSpectrumComponents) callconv(.winapi) HRESULT,
        put_ColorSpectrumComponents: *const fn(self: *anyopaque, value: ColorSpectrumComponents) callconv(.winapi) HRESULT,
        add_ColorChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(ColorPicker,ColorChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ColorChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IColorPickerFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ColorPicker {
        var _r: *ColorPicker = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IColorPickerFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "abae07ff-aecf-481d-9204-201c3894cd1b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **ColorPicker) callconv(.winapi) HRESULT,
    };
};
pub const IColorPickerStatics = extern struct {
    vtable: *const VTable,
    pub fn getColorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ColorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPreviousColorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PreviousColorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsAlphaEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsAlphaEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsColorSpectrumVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsColorSpectrumVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsColorPreviewVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsColorPreviewVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsColorSliderVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsColorSliderVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsAlphaSliderVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsAlphaSliderVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsMoreButtonVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsMoreButtonVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsColorChannelTextInputVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsColorChannelTextInputVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsAlphaTextInputVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsAlphaTextInputVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsHexInputVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsHexInputVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMinHueProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MinHueProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaxHueProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxHueProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMinSaturationProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MinSaturationProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaxSaturationProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxSaturationProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMinValueProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MinValueProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaxValueProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxValueProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getColorSpectrumShapeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ColorSpectrumShapeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getColorSpectrumComponentsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ColorSpectrumComponentsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IColorPickerStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "67ca9be7-1574-451a-b6df-fe57d9d07b46";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ColorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PreviousColorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsAlphaEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsColorSpectrumVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsColorPreviewVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsColorSliderVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsAlphaSliderVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsMoreButtonVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsColorChannelTextInputVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsAlphaTextInputVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsHexInputVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MinHueProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaxHueProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MinSaturationProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaxSaturationProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MinValueProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaxValueProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ColorSpectrumShapeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ColorSpectrumComponentsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IColumnDefinition = extern struct {
    vtable: *const VTable,
    pub fn getWidth(self: *@This()) core.HResult!GridLength {
        var _r: GridLength = undefined;
        const _c = self.vtable.get_Width(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putWidth(self: *@This(), value: GridLength) core.HResult!void {
        const _c = self.vtable.put_Width(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMaxWidth(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_MaxWidth(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxWidth(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_MaxWidth(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMinWidth(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_MinWidth(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMinWidth(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_MinWidth(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getActualWidth(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_ActualWidth(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IColumnDefinition";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f7f1b229-f024-467f-970a-7e705615db7b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Width: *const fn(self: *anyopaque, _r: *GridLength) callconv(.winapi) HRESULT,
        put_Width: *const fn(self: *anyopaque, value: GridLength) callconv(.winapi) HRESULT,
        get_MaxWidth: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_MaxWidth: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_MinWidth: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_MinWidth: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_ActualWidth: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
    };
};
pub const IColumnDefinitionStatics = extern struct {
    vtable: *const VTable,
    pub fn getWidthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_WidthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaxWidthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxWidthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMinWidthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MinWidthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IColumnDefinitionStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "06b0d728-d044-40c6-942e-ae60eac74851";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_WidthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaxWidthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MinWidthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IComboBox = extern struct {
    vtable: *const VTable,
    pub fn getIsDropDownOpen(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsDropDownOpen(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsDropDownOpen(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsDropDownOpen(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsEditable(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsEditable(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsSelectionBoxHighlighted(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsSelectionBoxHighlighted(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaxDropDownHeight(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_MaxDropDownHeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxDropDownHeight(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_MaxDropDownHeight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectionBoxItem(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_SelectionBoxItem(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionBoxItemTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_SelectionBoxItemTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*ComboBoxTemplateSettings {
        var _r: *ComboBoxTemplateSettings = undefined;
        const _c = self.vtable.get_TemplateSettings(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addDropDownClosed(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_DropDownClosed(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeDropDownClosed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_DropDownClosed(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addDropDownOpened(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_DropDownOpened(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeDropDownOpened(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_DropDownOpened(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IComboBox";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b9a8d05c-ac97-47f1-a5f4-3f9f4d4b116c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsDropDownOpen: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsDropDownOpen: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsEditable: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_IsSelectionBoxHighlighted: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_MaxDropDownHeight: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_MaxDropDownHeight: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_SelectionBoxItem: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        get_SelectionBoxItemTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        get_TemplateSettings: *const fn(self: *anyopaque, _r: **ComboBoxTemplateSettings) callconv(.winapi) HRESULT,
        add_DropDownClosed: *const fn(self: *anyopaque, handler: *EventHandler(IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_DropDownClosed: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_DropDownOpened: *const fn(self: *anyopaque, handler: *EventHandler(IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_DropDownOpened: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IComboBox2 = extern struct {
    vtable: *const VTable,
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Header(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Header(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_HeaderTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_HeaderTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPlaceholderText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_PlaceholderText(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPlaceholderText(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_PlaceholderText(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IComboBox2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ea0cbf91-ca36-4fad-972a-2e53a6718b9f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Header: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Header: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_HeaderTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_HeaderTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_PlaceholderText: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_PlaceholderText: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
    };
};
pub const IComboBox3 = extern struct {
    vtable: *const VTable,
    pub fn getLightDismissOverlayMode(self: *@This()) core.HResult!LightDismissOverlayMode {
        var _r: LightDismissOverlayMode = undefined;
        const _c = self.vtable.get_LightDismissOverlayMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putLightDismissOverlayMode(self: *@This(), value: LightDismissOverlayMode) core.HResult!void {
        const _c = self.vtable.put_LightDismissOverlayMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsTextSearchEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsTextSearchEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsTextSearchEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsTextSearchEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IComboBox3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "52400a63-476c-4bb6-b781-019324d3fed9";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LightDismissOverlayMode: *const fn(self: *anyopaque, _r: *LightDismissOverlayMode) callconv(.winapi) HRESULT,
        put_LightDismissOverlayMode: *const fn(self: *anyopaque, value: LightDismissOverlayMode) callconv(.winapi) HRESULT,
        get_IsTextSearchEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsTextSearchEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IComboBox4 = extern struct {
    vtable: *const VTable,
    pub fn getSelectionChangedTrigger(self: *@This()) core.HResult!ComboBoxSelectionChangedTrigger {
        var _r: ComboBoxSelectionChangedTrigger = undefined;
        const _c = self.vtable.get_SelectionChangedTrigger(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectionChangedTrigger(self: *@This(), value: ComboBoxSelectionChangedTrigger) core.HResult!void {
        const _c = self.vtable.put_SelectionChangedTrigger(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IComboBox4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b7974f49-b05c-47f9-9aaf-d6f9187be5fd";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectionChangedTrigger: *const fn(self: *anyopaque, _r: *ComboBoxSelectionChangedTrigger) callconv(.winapi) HRESULT,
        put_SelectionChangedTrigger: *const fn(self: *anyopaque, value: ComboBoxSelectionChangedTrigger) callconv(.winapi) HRESULT,
    };
};
pub const IComboBox5 = extern struct {
    vtable: *const VTable,
    pub fn getPlaceholderForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_PlaceholderForeground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPlaceholderForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_PlaceholderForeground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IComboBox5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ab79d646-800a-4a28-969b-34bb8fb458cf";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PlaceholderForeground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_PlaceholderForeground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
    };
};
pub const IComboBox6 = extern struct {
    vtable: *const VTable,
    pub fn putIsEditable(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsEditable(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Text(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putText(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_Text(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextBoxStyle(self: *@This()) core.HResult!*Style {
        var _r: *Style = undefined;
        const _c = self.vtable.get_TextBoxStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextBoxStyle(self: *@This(), value: *Style) core.HResult!void {
        const _c = self.vtable.put_TextBoxStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDescription(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Description(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDescription(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Description(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addTextSubmitted(self: *@This(), handler: *TypedEventHandler(ComboBox,ComboBoxTextSubmittedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_TextSubmitted(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeTextSubmitted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_TextSubmitted(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IComboBox6";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "61aad6a5-81fb-5f87-bae3-369fbe2ea1f3";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        put_IsEditable: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_Text: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_Text: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_TextBoxStyle: *const fn(self: *anyopaque, _r: **Style) callconv(.winapi) HRESULT,
        put_TextBoxStyle: *const fn(self: *anyopaque, value: *Style) callconv(.winapi) HRESULT,
        get_Description: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Description: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        add_TextSubmitted: *const fn(self: *anyopaque, handler: *TypedEventHandler(ComboBox,ComboBoxTextSubmittedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_TextSubmitted: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IComboBoxFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ComboBox {
        var _r: *ComboBox = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IComboBoxFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ac0d0444-a65b-4abd-86df-3016049efedc";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **ComboBox) callconv(.winapi) HRESULT,
    };
};
pub const IComboBoxItem = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IComboBoxItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "993fd6d2-2aae-4f3b-b44d-5648f4d06114";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IComboBoxItemFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ComboBoxItem {
        var _r: *ComboBoxItem = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IComboBoxItemFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8fffe867-d94c-4e87-8fc4-6ebcd63c5ac2";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **ComboBoxItem) callconv(.winapi) HRESULT,
    };
};
pub const IComboBoxOverrides = extern struct {
    vtable: *const VTable,
    pub fn OnDropDownClosed(self: *@This(), e: *IInspectable) core.HResult!void {
        const _c = self.vtable.OnDropDownClosed(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnDropDownOpened(self: *@This(), e: *IInspectable) core.HResult!void {
        const _c = self.vtable.OnDropDownOpened(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IComboBoxOverrides";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4f016541-bcfe-4a22-8932-c914981c2240";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        OnDropDownClosed: *const fn(self: *anyopaque, e: *IInspectable) callconv(.winapi) HRESULT,
        OnDropDownOpened: *const fn(self: *anyopaque, e: *IInspectable) callconv(.winapi) HRESULT,
    };
};
pub const IComboBoxStatics = extern struct {
    vtable: *const VTable,
    pub fn getIsDropDownOpenProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsDropDownOpenProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaxDropDownHeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxDropDownHeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IComboBoxStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3e14c9b1-d15b-4dc9-8110-cf3a117b96e7";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsDropDownOpenProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaxDropDownHeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IComboBoxStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPlaceholderTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlaceholderTextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IComboBoxStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "93988a11-402c-4b13-96d1-7220266b9220";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PlaceholderTextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IComboBoxStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getLightDismissOverlayModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LightDismissOverlayModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsTextSearchEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsTextSearchEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IComboBoxStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "949e140f-ce7f-4e41-bdc5-d1d3388ad0a6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LightDismissOverlayModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsTextSearchEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IComboBoxStatics4 = extern struct {
    vtable: *const VTable,
    pub fn getSelectionChangedTriggerProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectionChangedTriggerProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IComboBoxStatics4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d9f58358-f7b0-46ce-8061-ad83ec2f2dd4";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectionChangedTriggerProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IComboBoxStatics5 = extern struct {
    vtable: *const VTable,
    pub fn getPlaceholderForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlaceholderForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IComboBoxStatics5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b802cef1-a264-444a-9a61-aa8867b7a63c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PlaceholderForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IComboBoxStatics6 = extern struct {
    vtable: *const VTable,
    pub fn getIsEditableProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsEditableProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextBoxStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextBoxStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDescriptionProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DescriptionProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IComboBoxStatics6";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "516c88e0-ec6b-54ac-8c57-5ec080ee05c8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsEditableProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextBoxStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DescriptionProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IComboBoxTextSubmittedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Text(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHandled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_Handled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHandled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_Handled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IComboBoxTextSubmittedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "cb698cbb-6879-558e-af82-df1d08f62afa";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Text: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        get_Handled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_Handled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const ICommandBar = extern struct {
    vtable: *const VTable,
    pub fn getPrimaryCommands(self: *@This()) core.HResult!*IObservableVector(ICommandBarElement) {
        var _r: *IObservableVector(ICommandBarElement) = undefined;
        const _c = self.vtable.get_PrimaryCommands(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSecondaryCommands(self: *@This()) core.HResult!*IObservableVector(ICommandBarElement) {
        var _r: *IObservableVector(ICommandBarElement) = undefined;
        const _c = self.vtable.get_SecondaryCommands(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICommandBar";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "98bc4280-4a3d-4cee-bd07-22ce94c5af76";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PrimaryCommands: *const fn(self: *anyopaque, _r: **IObservableVector(ICommandBarElement)) callconv(.winapi) HRESULT,
        get_SecondaryCommands: *const fn(self: *anyopaque, _r: **IObservableVector(ICommandBarElement)) callconv(.winapi) HRESULT,
    };
};
pub const ICommandBar2 = extern struct {
    vtable: *const VTable,
    pub fn getCommandBarOverflowPresenterStyle(self: *@This()) core.HResult!*Style {
        var _r: *Style = undefined;
        const _c = self.vtable.get_CommandBarOverflowPresenterStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCommandBarOverflowPresenterStyle(self: *@This(), value: *Style) core.HResult!void {
        const _c = self.vtable.put_CommandBarOverflowPresenterStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCommandBarTemplateSettings(self: *@This()) core.HResult!*CommandBarTemplateSettings {
        var _r: *CommandBarTemplateSettings = undefined;
        const _c = self.vtable.get_CommandBarTemplateSettings(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICommandBar2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "57662f58-5b32-475d-be64-4ca36e7b97d4";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CommandBarOverflowPresenterStyle: *const fn(self: *anyopaque, _r: **Style) callconv(.winapi) HRESULT,
        put_CommandBarOverflowPresenterStyle: *const fn(self: *anyopaque, value: *Style) callconv(.winapi) HRESULT,
        get_CommandBarTemplateSettings: *const fn(self: *anyopaque, _r: **CommandBarTemplateSettings) callconv(.winapi) HRESULT,
    };
};
pub const ICommandBar3 = extern struct {
    vtable: *const VTable,
    pub fn getDefaultLabelPosition(self: *@This()) core.HResult!CommandBarDefaultLabelPosition {
        var _r: CommandBarDefaultLabelPosition = undefined;
        const _c = self.vtable.get_DefaultLabelPosition(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDefaultLabelPosition(self: *@This(), value: CommandBarDefaultLabelPosition) core.HResult!void {
        const _c = self.vtable.put_DefaultLabelPosition(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOverflowButtonVisibility(self: *@This()) core.HResult!CommandBarOverflowButtonVisibility {
        var _r: CommandBarOverflowButtonVisibility = undefined;
        const _c = self.vtable.get_OverflowButtonVisibility(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOverflowButtonVisibility(self: *@This(), value: CommandBarOverflowButtonVisibility) core.HResult!void {
        const _c = self.vtable.put_OverflowButtonVisibility(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsDynamicOverflowEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsDynamicOverflowEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsDynamicOverflowEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsDynamicOverflowEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addDynamicOverflowItemsChanging(self: *@This(), handler: *TypedEventHandler(CommandBar,DynamicOverflowItemsChangingEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_DynamicOverflowItemsChanging(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeDynamicOverflowItemsChanging(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_DynamicOverflowItemsChanging(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICommandBar3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "40ebbc23-2a79-48b3-9a67-649b852d8589";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_DefaultLabelPosition: *const fn(self: *anyopaque, _r: *CommandBarDefaultLabelPosition) callconv(.winapi) HRESULT,
        put_DefaultLabelPosition: *const fn(self: *anyopaque, value: CommandBarDefaultLabelPosition) callconv(.winapi) HRESULT,
        get_OverflowButtonVisibility: *const fn(self: *anyopaque, _r: *CommandBarOverflowButtonVisibility) callconv(.winapi) HRESULT,
        put_OverflowButtonVisibility: *const fn(self: *anyopaque, value: CommandBarOverflowButtonVisibility) callconv(.winapi) HRESULT,
        get_IsDynamicOverflowEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsDynamicOverflowEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        add_DynamicOverflowItemsChanging: *const fn(self: *anyopaque, handler: *TypedEventHandler(CommandBar,DynamicOverflowItemsChangingEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_DynamicOverflowItemsChanging: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const ICommandBarElement = extern struct {
    vtable: *const VTable,
    pub fn getIsCompact(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsCompact(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsCompact(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsCompact(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICommandBarElement";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "67918e1b-f2d5-44d1-8b84-92b87f80a350";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsCompact: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsCompact: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const ICommandBarElement2 = extern struct {
    vtable: *const VTable,
    pub fn getIsInOverflow(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsInOverflow(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDynamicOverflowOrder(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_DynamicOverflowOrder(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDynamicOverflowOrder(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_DynamicOverflowOrder(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICommandBarElement2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a9bf1236-4402-4688-b987-9d2b9b7bf2bd";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsInOverflow: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_DynamicOverflowOrder: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_DynamicOverflowOrder: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
    };
};
pub const ICommandBarFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*CommandBar {
        var _r: *CommandBar = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICommandBarFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "67bdeb44-20e1-4177-ad44-f617b374e8e8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **CommandBar) callconv(.winapi) HRESULT,
    };
};
pub const ICommandBarFlyout = extern struct {
    vtable: *const VTable,
    pub fn getPrimaryCommands(self: *@This()) core.HResult!*IObservableVector(ICommandBarElement) {
        var _r: *IObservableVector(ICommandBarElement) = undefined;
        const _c = self.vtable.get_PrimaryCommands(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSecondaryCommands(self: *@This()) core.HResult!*IObservableVector(ICommandBarElement) {
        var _r: *IObservableVector(ICommandBarElement) = undefined;
        const _c = self.vtable.get_SecondaryCommands(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICommandBarFlyout";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "fecd2c4d-f16a-58cd-8aca-db0f046f25c3";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PrimaryCommands: *const fn(self: *anyopaque, _r: **IObservableVector(ICommandBarElement)) callconv(.winapi) HRESULT,
        get_SecondaryCommands: *const fn(self: *anyopaque, _r: **IObservableVector(ICommandBarElement)) callconv(.winapi) HRESULT,
    };
};
pub const ICommandBarFlyoutFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*CommandBarFlyout {
        var _r: *CommandBarFlyout = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICommandBarFlyoutFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "dd6441b3-6df1-593d-b80c-daf5c1daee41";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **CommandBarFlyout) callconv(.winapi) HRESULT,
    };
};
pub const ICommandBarOverflowPresenter = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICommandBarOverflowPresenter";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6e7a9427-58ef-4366-a017-18c193d56b14";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const ICommandBarOverflowPresenterFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*CommandBarOverflowPresenter {
        var _r: *CommandBarOverflowPresenter = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICommandBarOverflowPresenterFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8323f774-5aaa-4049-b78f-218c6a19c37e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **CommandBarOverflowPresenter) callconv(.winapi) HRESULT,
    };
};
pub const ICommandBarStatics = extern struct {
    vtable: *const VTable,
    pub fn getPrimaryCommandsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PrimaryCommandsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSecondaryCommandsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SecondaryCommandsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICommandBarStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5bd981ea-e278-409c-b522-f946ca253b44";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PrimaryCommandsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SecondaryCommandsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ICommandBarStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getCommandBarOverflowPresenterStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CommandBarOverflowPresenterStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICommandBarStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3d9ec8e3-51a9-4e34-956c-7081d06f26f8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CommandBarOverflowPresenterStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ICommandBarStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getDefaultLabelPositionProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DefaultLabelPositionProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOverflowButtonVisibilityProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OverflowButtonVisibilityProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsDynamicOverflowEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsDynamicOverflowEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ICommandBarStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b45a24a4-8af1-4843-b319-e03fc45ab726";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_DefaultLabelPositionProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OverflowButtonVisibilityProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsDynamicOverflowEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IContainerContentChangingEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getItemContainer(self: *@This()) core.HResult!*SelectorItem {
        var _r: *SelectorItem = undefined;
        const _c = self.vtable.get_ItemContainer(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getInRecycleQueue(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_InRecycleQueue(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemIndex(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_ItemIndex(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItem(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Item(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPhase(self: *@This()) core.HResult!u32 {
        var _r: u32 = undefined;
        const _c = self.vtable.get_Phase(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHandled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_Handled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHandled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_Handled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn RegisterUpdateCallback(self: *@This(), callback: *TypedEventHandler(ListViewBase,ContainerContentChangingEventArgs)) core.HResult!void {
        const _c = self.vtable.RegisterUpdateCallback(@ptrCast(self), callback);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn RegisterUpdateCallbackWithCallbackPhaseAndCallback(self: *@This(), callbackPhase: u32, callback: *TypedEventHandler(ListViewBase,ContainerContentChangingEventArgs)) core.HResult!void {
        const _c = self.vtable.RegisterUpdateCallbackWithCallbackPhaseAndCallback(@ptrCast(self), callbackPhase, callback);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContainerContentChangingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "07deeaa7-018f-4dda-b399-fd4e13a31bea";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ItemContainer: *const fn(self: *anyopaque, _r: **SelectorItem) callconv(.winapi) HRESULT,
        get_InRecycleQueue: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_ItemIndex: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_Item: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        get_Phase: *const fn(self: *anyopaque, _r: *u32) callconv(.winapi) HRESULT,
        get_Handled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_Handled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        RegisterUpdateCallback: *const fn(self: *anyopaque, callback: *TypedEventHandler(ListViewBase,ContainerContentChangingEventArgs)) callconv(.winapi) HRESULT,
        RegisterUpdateCallbackWithCallbackPhaseAndCallback: *const fn(self: *anyopaque, callbackPhase: u32, callback: *TypedEventHandler(ListViewBase,ContainerContentChangingEventArgs)) callconv(.winapi) HRESULT,
    };
};
pub const IContentControl = extern struct {
    vtable: *const VTable,
    pub fn getContent(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Content(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putContent(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Content(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getContentTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_ContentTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putContentTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_ContentTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getContentTemplateSelector(self: *@This()) core.HResult!*DataTemplateSelector {
        var _r: *DataTemplateSelector = undefined;
        const _c = self.vtable.get_ContentTemplateSelector(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putContentTemplateSelector(self: *@This(), value: *DataTemplateSelector) core.HResult!void {
        const _c = self.vtable.put_ContentTemplateSelector(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getContentTransitions(self: *@This()) core.HResult!*TransitionCollection {
        var _r: *TransitionCollection = undefined;
        const _c = self.vtable.get_ContentTransitions(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putContentTransitions(self: *@This(), value: *TransitionCollection) core.HResult!void {
        const _c = self.vtable.put_ContentTransitions(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentControl";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a26dd1dc-cd44-435c-be94-01d6241c231c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Content: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Content: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_ContentTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_ContentTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_ContentTemplateSelector: *const fn(self: *anyopaque, _r: **DataTemplateSelector) callconv(.winapi) HRESULT,
        put_ContentTemplateSelector: *const fn(self: *anyopaque, value: *DataTemplateSelector) callconv(.winapi) HRESULT,
        get_ContentTransitions: *const fn(self: *anyopaque, _r: **TransitionCollection) callconv(.winapi) HRESULT,
        put_ContentTransitions: *const fn(self: *anyopaque, value: *TransitionCollection) callconv(.winapi) HRESULT,
    };
};
pub const IContentControl2 = extern struct {
    vtable: *const VTable,
    pub fn getContentTemplateRoot(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_ContentTemplateRoot(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentControl2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "652c208c-8ccf-4399-bd3e-5a015aa1bc03";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ContentTemplateRoot: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
    };
};
pub const IContentControlFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ContentControl {
        var _r: *ContentControl = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentControlFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ab017b19-196e-4ed5-a27f-55c58fb1673f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **ContentControl) callconv(.winapi) HRESULT,
    };
};
pub const IContentControlOverrides = extern struct {
    vtable: *const VTable,
    pub fn OnContentChanged(self: *@This(), oldContent: *IInspectable, newContent: *IInspectable) core.HResult!void {
        const _c = self.vtable.OnContentChanged(@ptrCast(self), oldContent, newContent);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnContentTemplateChanged(self: *@This(), oldContentTemplate: *DataTemplate, newContentTemplate: *DataTemplate) core.HResult!void {
        const _c = self.vtable.OnContentTemplateChanged(@ptrCast(self), oldContentTemplate, newContentTemplate);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnContentTemplateSelectorChanged(self: *@This(), oldContentTemplateSelector: *DataTemplateSelector, newContentTemplateSelector: *DataTemplateSelector) core.HResult!void {
        const _c = self.vtable.OnContentTemplateSelectorChanged(@ptrCast(self), oldContentTemplateSelector, newContentTemplateSelector);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentControlOverrides";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5f4c0b10-e38e-4b5d-be1a-5ed04246a635";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        OnContentChanged: *const fn(self: *anyopaque, oldContent: *IInspectable, newContent: *IInspectable) callconv(.winapi) HRESULT,
        OnContentTemplateChanged: *const fn(self: *anyopaque, oldContentTemplate: *DataTemplate, newContentTemplate: *DataTemplate) callconv(.winapi) HRESULT,
        OnContentTemplateSelectorChanged: *const fn(self: *anyopaque, oldContentTemplateSelector: *DataTemplateSelector, newContentTemplateSelector: *DataTemplateSelector) callconv(.winapi) HRESULT,
    };
};
pub const IContentControlStatics = extern struct {
    vtable: *const VTable,
    pub fn getContentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ContentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getContentTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ContentTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getContentTemplateSelectorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ContentTemplateSelectorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getContentTransitionsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ContentTransitionsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentControlStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "116982a4-5cf5-4c05-a53f-15e4876c85ec";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ContentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ContentTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ContentTemplateSelectorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ContentTransitionsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IContentDialog = extern struct {
    vtable: *const VTable,
    pub fn getTitle(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Title(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTitle(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Title(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTitleTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_TitleTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTitleTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_TitleTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFullSizeDesired(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_FullSizeDesired(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFullSizeDesired(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_FullSizeDesired(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPrimaryButtonText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_PrimaryButtonText(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPrimaryButtonText(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_PrimaryButtonText(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSecondaryButtonText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_SecondaryButtonText(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSecondaryButtonText(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_SecondaryButtonText(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPrimaryButtonCommand(self: *@This()) core.HResult!*ICommand {
        var _r: *ICommand = undefined;
        const _c = self.vtable.get_PrimaryButtonCommand(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPrimaryButtonCommand(self: *@This(), value: *ICommand) core.HResult!void {
        const _c = self.vtable.put_PrimaryButtonCommand(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSecondaryButtonCommand(self: *@This()) core.HResult!*ICommand {
        var _r: *ICommand = undefined;
        const _c = self.vtable.get_SecondaryButtonCommand(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSecondaryButtonCommand(self: *@This(), value: *ICommand) core.HResult!void {
        const _c = self.vtable.put_SecondaryButtonCommand(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPrimaryButtonCommandParameter(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_PrimaryButtonCommandParameter(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPrimaryButtonCommandParameter(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_PrimaryButtonCommandParameter(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSecondaryButtonCommandParameter(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_SecondaryButtonCommandParameter(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSecondaryButtonCommandParameter(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_SecondaryButtonCommandParameter(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsPrimaryButtonEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsPrimaryButtonEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsPrimaryButtonEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsPrimaryButtonEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsSecondaryButtonEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsSecondaryButtonEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsSecondaryButtonEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsSecondaryButtonEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addClosing(self: *@This(), handler: *TypedEventHandler(ContentDialog,ContentDialogClosingEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Closing(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeClosing(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Closing(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addClosed(self: *@This(), handler: *TypedEventHandler(ContentDialog,ContentDialogClosedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Closed(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeClosed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Closed(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addOpened(self: *@This(), handler: *TypedEventHandler(ContentDialog,ContentDialogOpenedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Opened(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeOpened(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Opened(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addPrimaryButtonClick(self: *@This(), handler: *TypedEventHandler(ContentDialog,ContentDialogButtonClickEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_PrimaryButtonClick(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removePrimaryButtonClick(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_PrimaryButtonClick(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addSecondaryButtonClick(self: *@This(), handler: *TypedEventHandler(ContentDialog,ContentDialogButtonClickEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_SecondaryButtonClick(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeSecondaryButtonClick(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_SecondaryButtonClick(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Hide(self: *@This()) core.HResult!void {
        const _c = self.vtable.Hide(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn ShowAsync(self: *@This()) core.HResult!*IAsyncOperation(ContentDialogResult) {
        var _r: *IAsyncOperation(ContentDialogResult) = undefined;
        const _c = self.vtable.ShowAsync(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentDialog";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "38dc4404-d24e-40d8-9415-349464c1afdc";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Title: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Title: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_TitleTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_TitleTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_FullSizeDesired: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_FullSizeDesired: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_PrimaryButtonText: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_PrimaryButtonText: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_SecondaryButtonText: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_SecondaryButtonText: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_PrimaryButtonCommand: *const fn(self: *anyopaque, _r: **ICommand) callconv(.winapi) HRESULT,
        put_PrimaryButtonCommand: *const fn(self: *anyopaque, value: *ICommand) callconv(.winapi) HRESULT,
        get_SecondaryButtonCommand: *const fn(self: *anyopaque, _r: **ICommand) callconv(.winapi) HRESULT,
        put_SecondaryButtonCommand: *const fn(self: *anyopaque, value: *ICommand) callconv(.winapi) HRESULT,
        get_PrimaryButtonCommandParameter: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_PrimaryButtonCommandParameter: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_SecondaryButtonCommandParameter: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_SecondaryButtonCommandParameter: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_IsPrimaryButtonEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsPrimaryButtonEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsSecondaryButtonEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsSecondaryButtonEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        add_Closing: *const fn(self: *anyopaque, handler: *TypedEventHandler(ContentDialog,ContentDialogClosingEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Closing: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_Closed: *const fn(self: *anyopaque, handler: *TypedEventHandler(ContentDialog,ContentDialogClosedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Closed: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_Opened: *const fn(self: *anyopaque, handler: *TypedEventHandler(ContentDialog,ContentDialogOpenedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Opened: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_PrimaryButtonClick: *const fn(self: *anyopaque, handler: *TypedEventHandler(ContentDialog,ContentDialogButtonClickEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_PrimaryButtonClick: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_SecondaryButtonClick: *const fn(self: *anyopaque, handler: *TypedEventHandler(ContentDialog,ContentDialogButtonClickEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_SecondaryButtonClick: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        Hide: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        ShowAsync: *const fn(self: *anyopaque, _r: **IAsyncOperation(ContentDialogResult)) callconv(.winapi) HRESULT,
    };
};
pub const IContentDialog2 = extern struct {
    vtable: *const VTable,
    pub fn getCloseButtonText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_CloseButtonText(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCloseButtonText(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_CloseButtonText(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCloseButtonCommand(self: *@This()) core.HResult!*ICommand {
        var _r: *ICommand = undefined;
        const _c = self.vtable.get_CloseButtonCommand(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCloseButtonCommand(self: *@This(), value: *ICommand) core.HResult!void {
        const _c = self.vtable.put_CloseButtonCommand(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCloseButtonCommandParameter(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_CloseButtonCommandParameter(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCloseButtonCommandParameter(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_CloseButtonCommandParameter(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPrimaryButtonStyle(self: *@This()) core.HResult!*Style {
        var _r: *Style = undefined;
        const _c = self.vtable.get_PrimaryButtonStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPrimaryButtonStyle(self: *@This(), value: *Style) core.HResult!void {
        const _c = self.vtable.put_PrimaryButtonStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSecondaryButtonStyle(self: *@This()) core.HResult!*Style {
        var _r: *Style = undefined;
        const _c = self.vtable.get_SecondaryButtonStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSecondaryButtonStyle(self: *@This(), value: *Style) core.HResult!void {
        const _c = self.vtable.put_SecondaryButtonStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCloseButtonStyle(self: *@This()) core.HResult!*Style {
        var _r: *Style = undefined;
        const _c = self.vtable.get_CloseButtonStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCloseButtonStyle(self: *@This(), value: *Style) core.HResult!void {
        const _c = self.vtable.put_CloseButtonStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDefaultButton(self: *@This()) core.HResult!ContentDialogButton {
        var _r: ContentDialogButton = undefined;
        const _c = self.vtable.get_DefaultButton(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDefaultButton(self: *@This(), value: ContentDialogButton) core.HResult!void {
        const _c = self.vtable.put_DefaultButton(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addCloseButtonClick(self: *@This(), handler: *TypedEventHandler(ContentDialog,ContentDialogButtonClickEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_CloseButtonClick(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeCloseButtonClick(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_CloseButtonClick(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentDialog2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "2f93eb45-ee43-4303-9b38-3fe1a111ecbf";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CloseButtonText: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_CloseButtonText: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_CloseButtonCommand: *const fn(self: *anyopaque, _r: **ICommand) callconv(.winapi) HRESULT,
        put_CloseButtonCommand: *const fn(self: *anyopaque, value: *ICommand) callconv(.winapi) HRESULT,
        get_CloseButtonCommandParameter: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_CloseButtonCommandParameter: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_PrimaryButtonStyle: *const fn(self: *anyopaque, _r: **Style) callconv(.winapi) HRESULT,
        put_PrimaryButtonStyle: *const fn(self: *anyopaque, value: *Style) callconv(.winapi) HRESULT,
        get_SecondaryButtonStyle: *const fn(self: *anyopaque, _r: **Style) callconv(.winapi) HRESULT,
        put_SecondaryButtonStyle: *const fn(self: *anyopaque, value: *Style) callconv(.winapi) HRESULT,
        get_CloseButtonStyle: *const fn(self: *anyopaque, _r: **Style) callconv(.winapi) HRESULT,
        put_CloseButtonStyle: *const fn(self: *anyopaque, value: *Style) callconv(.winapi) HRESULT,
        get_DefaultButton: *const fn(self: *anyopaque, _r: *ContentDialogButton) callconv(.winapi) HRESULT,
        put_DefaultButton: *const fn(self: *anyopaque, value: ContentDialogButton) callconv(.winapi) HRESULT,
        add_CloseButtonClick: *const fn(self: *anyopaque, handler: *TypedEventHandler(ContentDialog,ContentDialogButtonClickEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_CloseButtonClick: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IContentDialog3 = extern struct {
    vtable: *const VTable,
    pub fn ShowAsync(self: *@This(), placement: ContentDialogPlacement) core.HResult!*IAsyncOperation(ContentDialogResult) {
        var _r: *IAsyncOperation(ContentDialogResult) = undefined;
        const _c = self.vtable.ShowAsync(@ptrCast(self), placement, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentDialog3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9d9a089e-f954-4ede-b07f-6b069a9c0180";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        ShowAsync: *const fn(self: *anyopaque, placement: ContentDialogPlacement, _r: **IAsyncOperation(ContentDialogResult)) callconv(.winapi) HRESULT,
    };
};
pub const IContentDialogButtonClickDeferral = extern struct {
    vtable: *const VTable,
    pub fn Complete(self: *@This()) core.HResult!void {
        const _c = self.vtable.Complete(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentDialogButtonClickDeferral";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "bd0d3637-19ce-4946-8e77-bd03fe8ebe03";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        Complete: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
    };
};
pub const IContentDialogButtonClickEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getCancel(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_Cancel(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCancel(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_Cancel(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn GetDeferral(self: *@This()) core.HResult!*ContentDialogButtonClickDeferral {
        var _r: *ContentDialogButtonClickDeferral = undefined;
        const _c = self.vtable.GetDeferral(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentDialogButtonClickEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5f34c205-8afa-4cf2-8ca0-264d73bed63d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Cancel: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_Cancel: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        GetDeferral: *const fn(self: *anyopaque, _r: **ContentDialogButtonClickDeferral) callconv(.winapi) HRESULT,
    };
};
pub const IContentDialogClosedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getResult(self: *@This()) core.HResult!ContentDialogResult {
        var _r: ContentDialogResult = undefined;
        const _c = self.vtable.get_Result(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentDialogClosedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "905522ef-2cba-4af8-b666-cc36c22732fb";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Result: *const fn(self: *anyopaque, _r: *ContentDialogResult) callconv(.winapi) HRESULT,
    };
};
pub const IContentDialogClosingDeferral = extern struct {
    vtable: *const VTable,
    pub fn Complete(self: *@This()) core.HResult!void {
        const _c = self.vtable.Complete(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentDialogClosingDeferral";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "215d4d11-7e30-4cb9-a710-5a4f9cca8b42";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        Complete: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
    };
};
pub const IContentDialogClosingEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getResult(self: *@This()) core.HResult!ContentDialogResult {
        var _r: ContentDialogResult = undefined;
        const _c = self.vtable.get_Result(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCancel(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_Cancel(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCancel(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_Cancel(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn GetDeferral(self: *@This()) core.HResult!*ContentDialogClosingDeferral {
        var _r: *ContentDialogClosingDeferral = undefined;
        const _c = self.vtable.GetDeferral(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentDialogClosingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "db3c1c34-3bbf-47d4-be4f-c9ec115918b9";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Result: *const fn(self: *anyopaque, _r: *ContentDialogResult) callconv(.winapi) HRESULT,
        get_Cancel: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_Cancel: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        GetDeferral: *const fn(self: *anyopaque, _r: **ContentDialogClosingDeferral) callconv(.winapi) HRESULT,
    };
};
pub const IContentDialogFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ContentDialog {
        var _r: *ContentDialog = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentDialogFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "05557178-9d8e-4315-b37d-680c14012c35";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **ContentDialog) callconv(.winapi) HRESULT,
    };
};
pub const IContentDialogOpenedEventArgs = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentDialogOpenedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0966b315-5f59-4999-9e3e-374c0f174b04";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IContentDialogStatics = extern struct {
    vtable: *const VTable,
    pub fn getTitleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TitleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTitleTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TitleTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFullSizeDesiredProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FullSizeDesiredProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPrimaryButtonTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PrimaryButtonTextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSecondaryButtonTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SecondaryButtonTextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPrimaryButtonCommandProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PrimaryButtonCommandProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSecondaryButtonCommandProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SecondaryButtonCommandProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPrimaryButtonCommandParameterProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PrimaryButtonCommandParameterProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSecondaryButtonCommandParameterProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SecondaryButtonCommandParameterProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsPrimaryButtonEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsPrimaryButtonEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsSecondaryButtonEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsSecondaryButtonEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentDialogStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "23ab47a6-508a-4f33-b786-f2fa96d869af";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TitleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TitleTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FullSizeDesiredProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PrimaryButtonTextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SecondaryButtonTextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PrimaryButtonCommandProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SecondaryButtonCommandProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PrimaryButtonCommandParameterProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SecondaryButtonCommandParameterProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsPrimaryButtonEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsSecondaryButtonEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IContentDialogStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getCloseButtonTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CloseButtonTextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCloseButtonCommandProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CloseButtonCommandProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCloseButtonCommandParameterProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CloseButtonCommandParameterProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPrimaryButtonStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PrimaryButtonStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSecondaryButtonStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SecondaryButtonStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCloseButtonStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CloseButtonStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDefaultButtonProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DefaultButtonProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentDialogStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "329825b2-8fb0-4125-bb07-e79a5a03819f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CloseButtonTextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CloseButtonCommandProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CloseButtonCommandParameterProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PrimaryButtonStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SecondaryButtonStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CloseButtonStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DefaultButtonProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IContentLinkChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getChangeKind(self: *@This()) core.HResult!ContentLinkChangeKind {
        var _r: ContentLinkChangeKind = undefined;
        const _c = self.vtable.get_ChangeKind(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getContentLinkInfo(self: *@This()) core.HResult!*ContentLinkInfo {
        var _r: *ContentLinkInfo = undefined;
        const _c = self.vtable.get_ContentLinkInfo(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextRange(self: *@This()) core.HResult!TextRange {
        var _r: TextRange = undefined;
        const _c = self.vtable.get_TextRange(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentLinkChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "64f3f1de-89fb-4b77-8b9b-191b6d19290a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ChangeKind: *const fn(self: *anyopaque, _r: *ContentLinkChangeKind) callconv(.winapi) HRESULT,
        get_ContentLinkInfo: *const fn(self: *anyopaque, _r: **ContentLinkInfo) callconv(.winapi) HRESULT,
        get_TextRange: *const fn(self: *anyopaque, _r: *TextRange) callconv(.winapi) HRESULT,
    };
};
pub const IContentPresenter = extern struct {
    vtable: *const VTable,
    pub fn getContent(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Content(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putContent(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Content(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getContentTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_ContentTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putContentTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_ContentTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getContentTemplateSelector(self: *@This()) core.HResult!*DataTemplateSelector {
        var _r: *DataTemplateSelector = undefined;
        const _c = self.vtable.get_ContentTemplateSelector(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putContentTemplateSelector(self: *@This(), value: *DataTemplateSelector) core.HResult!void {
        const _c = self.vtable.put_ContentTemplateSelector(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getContentTransitions(self: *@This()) core.HResult!*TransitionCollection {
        var _r: *TransitionCollection = undefined;
        const _c = self.vtable.get_ContentTransitions(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putContentTransitions(self: *@This(), value: *TransitionCollection) core.HResult!void {
        const _c = self.vtable.put_ContentTransitions(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontSize(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_FontSize(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontSize(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_FontSize(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontFamily(self: *@This()) core.HResult!*FontFamily {
        var _r: *FontFamily = undefined;
        const _c = self.vtable.get_FontFamily(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontFamily(self: *@This(), value: *FontFamily) core.HResult!void {
        const _c = self.vtable.put_FontFamily(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontWeight(self: *@This()) core.HResult!FontWeight {
        var _r: FontWeight = undefined;
        const _c = self.vtable.get_FontWeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontWeight(self: *@This(), value: FontWeight) core.HResult!void {
        const _c = self.vtable.put_FontWeight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontStyle(self: *@This()) core.HResult!FontStyle {
        var _r: FontStyle = undefined;
        const _c = self.vtable.get_FontStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontStyle(self: *@This(), value: FontStyle) core.HResult!void {
        const _c = self.vtable.put_FontStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontStretch(self: *@This()) core.HResult!FontStretch {
        var _r: FontStretch = undefined;
        const _c = self.vtable.get_FontStretch(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontStretch(self: *@This(), value: FontStretch) core.HResult!void {
        const _c = self.vtable.put_FontStretch(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCharacterSpacing(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_CharacterSpacing(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCharacterSpacing(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_CharacterSpacing(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_Foreground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_Foreground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentPresenter";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "79fde5b4-cd37-491c-8845-daf472defff6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Content: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Content: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_ContentTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_ContentTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_ContentTemplateSelector: *const fn(self: *anyopaque, _r: **DataTemplateSelector) callconv(.winapi) HRESULT,
        put_ContentTemplateSelector: *const fn(self: *anyopaque, value: *DataTemplateSelector) callconv(.winapi) HRESULT,
        get_ContentTransitions: *const fn(self: *anyopaque, _r: **TransitionCollection) callconv(.winapi) HRESULT,
        put_ContentTransitions: *const fn(self: *anyopaque, value: *TransitionCollection) callconv(.winapi) HRESULT,
        get_FontSize: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_FontSize: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_FontFamily: *const fn(self: *anyopaque, _r: **FontFamily) callconv(.winapi) HRESULT,
        put_FontFamily: *const fn(self: *anyopaque, value: *FontFamily) callconv(.winapi) HRESULT,
        get_FontWeight: *const fn(self: *anyopaque, _r: *FontWeight) callconv(.winapi) HRESULT,
        put_FontWeight: *const fn(self: *anyopaque, value: FontWeight) callconv(.winapi) HRESULT,
        get_FontStyle: *const fn(self: *anyopaque, _r: *FontStyle) callconv(.winapi) HRESULT,
        put_FontStyle: *const fn(self: *anyopaque, value: FontStyle) callconv(.winapi) HRESULT,
        get_FontStretch: *const fn(self: *anyopaque, _r: *FontStretch) callconv(.winapi) HRESULT,
        put_FontStretch: *const fn(self: *anyopaque, value: FontStretch) callconv(.winapi) HRESULT,
        get_CharacterSpacing: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_CharacterSpacing: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_Foreground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_Foreground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
    };
};
pub const IContentPresenter2 = extern struct {
    vtable: *const VTable,
    pub fn getOpticalMarginAlignment(self: *@This()) core.HResult!OpticalMarginAlignment {
        var _r: OpticalMarginAlignment = undefined;
        const _c = self.vtable.get_OpticalMarginAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOpticalMarginAlignment(self: *@This(), value: OpticalMarginAlignment) core.HResult!void {
        const _c = self.vtable.put_OpticalMarginAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextLineBounds(self: *@This()) core.HResult!TextLineBounds {
        var _r: TextLineBounds = undefined;
        const _c = self.vtable.get_TextLineBounds(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextLineBounds(self: *@This(), value: TextLineBounds) core.HResult!void {
        const _c = self.vtable.put_TextLineBounds(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentPresenter2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5138e958-335d-4210-8bbb-0aa2b4b5c29e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_OpticalMarginAlignment: *const fn(self: *anyopaque, _r: *OpticalMarginAlignment) callconv(.winapi) HRESULT,
        put_OpticalMarginAlignment: *const fn(self: *anyopaque, value: OpticalMarginAlignment) callconv(.winapi) HRESULT,
        get_TextLineBounds: *const fn(self: *anyopaque, _r: *TextLineBounds) callconv(.winapi) HRESULT,
        put_TextLineBounds: *const fn(self: *anyopaque, value: TextLineBounds) callconv(.winapi) HRESULT,
    };
};
pub const IContentPresenter3 = extern struct {
    vtable: *const VTable,
    pub fn getIsTextScaleFactorEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsTextScaleFactorEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsTextScaleFactorEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsTextScaleFactorEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentPresenter3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b038876a-9c4d-4402-ac56-a223487dc6c8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsTextScaleFactorEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsTextScaleFactorEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IContentPresenter4 = extern struct {
    vtable: *const VTable,
    pub fn getTextWrapping(self: *@This()) core.HResult!TextWrapping {
        var _r: TextWrapping = undefined;
        const _c = self.vtable.get_TextWrapping(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextWrapping(self: *@This(), value: TextWrapping) core.HResult!void {
        const _c = self.vtable.put_TextWrapping(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMaxLines(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_MaxLines(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxLines(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_MaxLines(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getLineStackingStrategy(self: *@This()) core.HResult!LineStackingStrategy {
        var _r: LineStackingStrategy = undefined;
        const _c = self.vtable.get_LineStackingStrategy(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putLineStackingStrategy(self: *@This(), value: LineStackingStrategy) core.HResult!void {
        const _c = self.vtable.put_LineStackingStrategy(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getLineHeight(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_LineHeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putLineHeight(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_LineHeight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBorderBrush(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_BorderBrush(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_BorderBrush(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBorderThickness(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_BorderThickness(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBorderThickness(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_BorderThickness(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCornerRadius(self: *@This()) core.HResult!CornerRadius {
        var _r: CornerRadius = undefined;
        const _c = self.vtable.get_CornerRadius(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCornerRadius(self: *@This(), value: CornerRadius) core.HResult!void {
        const _c = self.vtable.put_CornerRadius(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPadding(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_Padding(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPadding(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_Padding(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBackground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_Background(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBackground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_Background(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHorizontalContentAlignment(self: *@This()) core.HResult!HorizontalAlignment {
        var _r: HorizontalAlignment = undefined;
        const _c = self.vtable.get_HorizontalContentAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHorizontalContentAlignment(self: *@This(), value: HorizontalAlignment) core.HResult!void {
        const _c = self.vtable.put_HorizontalContentAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getVerticalContentAlignment(self: *@This()) core.HResult!VerticalAlignment {
        var _r: VerticalAlignment = undefined;
        const _c = self.vtable.get_VerticalContentAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putVerticalContentAlignment(self: *@This(), value: VerticalAlignment) core.HResult!void {
        const _c = self.vtable.put_VerticalContentAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentPresenter4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "997b1b17-3bf8-432b-8fd9-68c7bab21f9d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TextWrapping: *const fn(self: *anyopaque, _r: *TextWrapping) callconv(.winapi) HRESULT,
        put_TextWrapping: *const fn(self: *anyopaque, value: TextWrapping) callconv(.winapi) HRESULT,
        get_MaxLines: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_MaxLines: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_LineStackingStrategy: *const fn(self: *anyopaque, _r: *LineStackingStrategy) callconv(.winapi) HRESULT,
        put_LineStackingStrategy: *const fn(self: *anyopaque, value: LineStackingStrategy) callconv(.winapi) HRESULT,
        get_LineHeight: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_LineHeight: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_BorderBrush: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_BorderBrush: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_BorderThickness: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_BorderThickness: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
        get_CornerRadius: *const fn(self: *anyopaque, _r: *CornerRadius) callconv(.winapi) HRESULT,
        put_CornerRadius: *const fn(self: *anyopaque, value: CornerRadius) callconv(.winapi) HRESULT,
        get_Padding: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_Padding: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
        get_Background: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_Background: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_HorizontalContentAlignment: *const fn(self: *anyopaque, _r: *HorizontalAlignment) callconv(.winapi) HRESULT,
        put_HorizontalContentAlignment: *const fn(self: *anyopaque, value: HorizontalAlignment) callconv(.winapi) HRESULT,
        get_VerticalContentAlignment: *const fn(self: *anyopaque, _r: *VerticalAlignment) callconv(.winapi) HRESULT,
        put_VerticalContentAlignment: *const fn(self: *anyopaque, value: VerticalAlignment) callconv(.winapi) HRESULT,
    };
};
pub const IContentPresenter5 = extern struct {
    vtable: *const VTable,
    pub fn getBackgroundTransition(self: *@This()) core.HResult!*BrushTransition {
        var _r: *BrushTransition = undefined;
        const _c = self.vtable.get_BackgroundTransition(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBackgroundTransition(self: *@This(), value: *BrushTransition) core.HResult!void {
        const _c = self.vtable.put_BackgroundTransition(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBackgroundSizing(self: *@This()) core.HResult!BackgroundSizing {
        var _r: BackgroundSizing = undefined;
        const _c = self.vtable.get_BackgroundSizing(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBackgroundSizing(self: *@This(), value: BackgroundSizing) core.HResult!void {
        const _c = self.vtable.put_BackgroundSizing(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentPresenter5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d248970c-b785-5e7f-9c11-8a6cd3d5929b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BackgroundTransition: *const fn(self: *anyopaque, _r: **BrushTransition) callconv(.winapi) HRESULT,
        put_BackgroundTransition: *const fn(self: *anyopaque, value: *BrushTransition) callconv(.winapi) HRESULT,
        get_BackgroundSizing: *const fn(self: *anyopaque, _r: *BackgroundSizing) callconv(.winapi) HRESULT,
        put_BackgroundSizing: *const fn(self: *anyopaque, value: BackgroundSizing) callconv(.winapi) HRESULT,
    };
};
pub const IContentPresenterFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ContentPresenter {
        var _r: *ContentPresenter = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentPresenterFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3339d4f7-4815-44c4-9f76-68c83880ef10";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **ContentPresenter) callconv(.winapi) HRESULT,
    };
};
pub const IContentPresenterOverrides = extern struct {
    vtable: *const VTable,
    pub fn OnContentTemplateChanged(self: *@This(), oldContentTemplate: *DataTemplate, newContentTemplate: *DataTemplate) core.HResult!void {
        const _c = self.vtable.OnContentTemplateChanged(@ptrCast(self), oldContentTemplate, newContentTemplate);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnContentTemplateSelectorChanged(self: *@This(), oldContentTemplateSelector: *DataTemplateSelector, newContentTemplateSelector: *DataTemplateSelector) core.HResult!void {
        const _c = self.vtable.OnContentTemplateSelectorChanged(@ptrCast(self), oldContentTemplateSelector, newContentTemplateSelector);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentPresenterOverrides";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a76339ed-32ff-438b-aad5-1d68fae93426";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        OnContentTemplateChanged: *const fn(self: *anyopaque, oldContentTemplate: *DataTemplate, newContentTemplate: *DataTemplate) callconv(.winapi) HRESULT,
        OnContentTemplateSelectorChanged: *const fn(self: *anyopaque, oldContentTemplateSelector: *DataTemplateSelector, newContentTemplateSelector: *DataTemplateSelector) callconv(.winapi) HRESULT,
    };
};
pub const IContentPresenterStatics = extern struct {
    vtable: *const VTable,
    pub fn getContentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ContentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getContentTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ContentTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getContentTemplateSelectorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ContentTemplateSelectorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getContentTransitionsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ContentTransitionsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontSizeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontSizeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontFamilyProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontFamilyProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontWeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontWeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontStretchProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontStretchProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCharacterSpacingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CharacterSpacingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentPresenterStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "18c2893b-da2e-4426-b85a-2c7e2171bedf";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ContentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ContentTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ContentTemplateSelectorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ContentTransitionsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontSizeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontFamilyProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontWeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontStretchProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CharacterSpacingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IContentPresenterStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getOpticalMarginAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OpticalMarginAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextLineBoundsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextLineBoundsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentPresenterStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c7d89dd9-06e6-46be-a8a0-9c117d3024a3";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_OpticalMarginAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextLineBoundsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IContentPresenterStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getIsTextScaleFactorEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsTextScaleFactorEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentPresenterStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "cbe6cf5b-38b1-4d5d-b098-bc94b35c8ddf";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsTextScaleFactorEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IContentPresenterStatics4 = extern struct {
    vtable: *const VTable,
    pub fn getTextWrappingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextWrappingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaxLinesProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxLinesProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLineStackingStrategyProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LineStackingStrategyProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLineHeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LineHeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBorderBrushProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BorderBrushProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBorderThicknessProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BorderThicknessProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCornerRadiusProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CornerRadiusProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPaddingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PaddingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBackgroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BackgroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHorizontalContentAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HorizontalContentAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getVerticalContentAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_VerticalContentAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentPresenterStatics4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ff8be292-af28-47eb-a5c3-dc44ced40fd2";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TextWrappingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaxLinesProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_LineStackingStrategyProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_LineHeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BorderBrushProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BorderThicknessProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CornerRadiusProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PaddingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BackgroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HorizontalContentAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_VerticalContentAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IContentPresenterStatics5 = extern struct {
    vtable: *const VTable,
    pub fn getBackgroundSizingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BackgroundSizingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContentPresenterStatics5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "169e700f-e8e6-5f6a-b97e-7ef8f7006f49";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BackgroundSizingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IContextMenuEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getHandled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_Handled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHandled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_Handled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCursorLeft(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_CursorLeft(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCursorTop(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_CursorTop(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IContextMenuEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1f7df263-c14b-4528-b6f0-637999d83cc6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Handled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_Handled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_CursorLeft: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        get_CursorTop: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
    };
};
pub const IControl = extern struct {
    vtable: *const VTable,
    pub fn getFontSize(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_FontSize(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontSize(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_FontSize(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontFamily(self: *@This()) core.HResult!*FontFamily {
        var _r: *FontFamily = undefined;
        const _c = self.vtable.get_FontFamily(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontFamily(self: *@This(), value: *FontFamily) core.HResult!void {
        const _c = self.vtable.put_FontFamily(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontWeight(self: *@This()) core.HResult!FontWeight {
        var _r: FontWeight = undefined;
        const _c = self.vtable.get_FontWeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontWeight(self: *@This(), value: FontWeight) core.HResult!void {
        const _c = self.vtable.put_FontWeight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontStyle(self: *@This()) core.HResult!FontStyle {
        var _r: FontStyle = undefined;
        const _c = self.vtable.get_FontStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontStyle(self: *@This(), value: FontStyle) core.HResult!void {
        const _c = self.vtable.put_FontStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontStretch(self: *@This()) core.HResult!FontStretch {
        var _r: FontStretch = undefined;
        const _c = self.vtable.get_FontStretch(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontStretch(self: *@This(), value: FontStretch) core.HResult!void {
        const _c = self.vtable.put_FontStretch(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCharacterSpacing(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_CharacterSpacing(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCharacterSpacing(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_CharacterSpacing(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_Foreground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_Foreground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsTabStop(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsTabStop(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsTabStop(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsTabStop(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTabIndex(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_TabIndex(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTabIndex(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_TabIndex(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTabNavigation(self: *@This()) core.HResult!KeyboardNavigationMode {
        var _r: KeyboardNavigationMode = undefined;
        const _c = self.vtable.get_TabNavigation(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTabNavigation(self: *@This(), value: KeyboardNavigationMode) core.HResult!void {
        const _c = self.vtable.put_TabNavigation(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTemplate(self: *@This()) core.HResult!*ControlTemplate {
        var _r: *ControlTemplate = undefined;
        const _c = self.vtable.get_Template(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTemplate(self: *@This(), value: *ControlTemplate) core.HResult!void {
        const _c = self.vtable.put_Template(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPadding(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_Padding(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPadding(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_Padding(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHorizontalContentAlignment(self: *@This()) core.HResult!HorizontalAlignment {
        var _r: HorizontalAlignment = undefined;
        const _c = self.vtable.get_HorizontalContentAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHorizontalContentAlignment(self: *@This(), value: HorizontalAlignment) core.HResult!void {
        const _c = self.vtable.put_HorizontalContentAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getVerticalContentAlignment(self: *@This()) core.HResult!VerticalAlignment {
        var _r: VerticalAlignment = undefined;
        const _c = self.vtable.get_VerticalContentAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putVerticalContentAlignment(self: *@This(), value: VerticalAlignment) core.HResult!void {
        const _c = self.vtable.put_VerticalContentAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBackground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_Background(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBackground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_Background(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBorderThickness(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_BorderThickness(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBorderThickness(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_BorderThickness(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBorderBrush(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_BorderBrush(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_BorderBrush(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFocusState(self: *@This()) core.HResult!FocusState {
        var _r: FocusState = undefined;
        const _c = self.vtable.get_FocusState(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addIsEnabledChanged(self: *@This(), handler: *DependencyPropertyChangedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_IsEnabledChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeIsEnabledChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_IsEnabledChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn ApplyTemplate(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.ApplyTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn Focus(self: *@This(), value: FocusState) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.Focus(@ptrCast(self), value, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IControl";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a8912263-2951-4f58-a9c5-5a134eaa7f07";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_FontSize: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_FontSize: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_FontFamily: *const fn(self: *anyopaque, _r: **FontFamily) callconv(.winapi) HRESULT,
        put_FontFamily: *const fn(self: *anyopaque, value: *FontFamily) callconv(.winapi) HRESULT,
        get_FontWeight: *const fn(self: *anyopaque, _r: *FontWeight) callconv(.winapi) HRESULT,
        put_FontWeight: *const fn(self: *anyopaque, value: FontWeight) callconv(.winapi) HRESULT,
        get_FontStyle: *const fn(self: *anyopaque, _r: *FontStyle) callconv(.winapi) HRESULT,
        put_FontStyle: *const fn(self: *anyopaque, value: FontStyle) callconv(.winapi) HRESULT,
        get_FontStretch: *const fn(self: *anyopaque, _r: *FontStretch) callconv(.winapi) HRESULT,
        put_FontStretch: *const fn(self: *anyopaque, value: FontStretch) callconv(.winapi) HRESULT,
        get_CharacterSpacing: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_CharacterSpacing: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_Foreground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_Foreground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_IsTabStop: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsTabStop: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_TabIndex: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_TabIndex: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_TabNavigation: *const fn(self: *anyopaque, _r: *KeyboardNavigationMode) callconv(.winapi) HRESULT,
        put_TabNavigation: *const fn(self: *anyopaque, value: KeyboardNavigationMode) callconv(.winapi) HRESULT,
        get_Template: *const fn(self: *anyopaque, _r: **ControlTemplate) callconv(.winapi) HRESULT,
        put_Template: *const fn(self: *anyopaque, value: *ControlTemplate) callconv(.winapi) HRESULT,
        get_Padding: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_Padding: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
        get_HorizontalContentAlignment: *const fn(self: *anyopaque, _r: *HorizontalAlignment) callconv(.winapi) HRESULT,
        put_HorizontalContentAlignment: *const fn(self: *anyopaque, value: HorizontalAlignment) callconv(.winapi) HRESULT,
        get_VerticalContentAlignment: *const fn(self: *anyopaque, _r: *VerticalAlignment) callconv(.winapi) HRESULT,
        put_VerticalContentAlignment: *const fn(self: *anyopaque, value: VerticalAlignment) callconv(.winapi) HRESULT,
        get_Background: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_Background: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_BorderThickness: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_BorderThickness: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
        get_BorderBrush: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_BorderBrush: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_FocusState: *const fn(self: *anyopaque, _r: *FocusState) callconv(.winapi) HRESULT,
        add_IsEnabledChanged: *const fn(self: *anyopaque, handler: *DependencyPropertyChangedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_IsEnabledChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        ApplyTemplate: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        Focus: *const fn(self: *anyopaque, value: FocusState, _r: *bool) callconv(.winapi) HRESULT,
    };
};
pub const IControl2 = extern struct {
    vtable: *const VTable,
    pub fn getIsTextScaleFactorEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsTextScaleFactorEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsTextScaleFactorEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsTextScaleFactorEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IControl2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "43e0fe10-14ec-427e-8c57-dee60df60aa8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsTextScaleFactorEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsTextScaleFactorEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IControl3 = extern struct {
    vtable: *const VTable,
    pub fn getUseSystemFocusVisuals(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_UseSystemFocusVisuals(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putUseSystemFocusVisuals(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_UseSystemFocusVisuals(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IControl3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "077b29e4-dade-4f55-9b96-09e21b28eb1c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_UseSystemFocusVisuals: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_UseSystemFocusVisuals: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IControl4 = extern struct {
    vtable: *const VTable,
    pub fn getIsFocusEngagementEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsFocusEngagementEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsFocusEngagementEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsFocusEngagementEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsFocusEngaged(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsFocusEngaged(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsFocusEngaged(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsFocusEngaged(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getRequiresPointer(self: *@This()) core.HResult!RequiresPointer {
        var _r: RequiresPointer = undefined;
        const _c = self.vtable.get_RequiresPointer(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putRequiresPointer(self: *@This(), value: RequiresPointer) core.HResult!void {
        const _c = self.vtable.put_RequiresPointer(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getXYFocusLeft(self: *@This()) core.HResult!*DependencyObject {
        var _r: *DependencyObject = undefined;
        const _c = self.vtable.get_XYFocusLeft(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putXYFocusLeft(self: *@This(), value: *DependencyObject) core.HResult!void {
        const _c = self.vtable.put_XYFocusLeft(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getXYFocusRight(self: *@This()) core.HResult!*DependencyObject {
        var _r: *DependencyObject = undefined;
        const _c = self.vtable.get_XYFocusRight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putXYFocusRight(self: *@This(), value: *DependencyObject) core.HResult!void {
        const _c = self.vtable.put_XYFocusRight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getXYFocusUp(self: *@This()) core.HResult!*DependencyObject {
        var _r: *DependencyObject = undefined;
        const _c = self.vtable.get_XYFocusUp(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putXYFocusUp(self: *@This(), value: *DependencyObject) core.HResult!void {
        const _c = self.vtable.put_XYFocusUp(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getXYFocusDown(self: *@This()) core.HResult!*DependencyObject {
        var _r: *DependencyObject = undefined;
        const _c = self.vtable.get_XYFocusDown(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putXYFocusDown(self: *@This(), value: *DependencyObject) core.HResult!void {
        const _c = self.vtable.put_XYFocusDown(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getElementSoundMode(self: *@This()) core.HResult!ElementSoundMode {
        var _r: ElementSoundMode = undefined;
        const _c = self.vtable.get_ElementSoundMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putElementSoundMode(self: *@This(), value: ElementSoundMode) core.HResult!void {
        const _c = self.vtable.put_ElementSoundMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addFocusEngaged(self: *@This(), handler: *TypedEventHandler(Control,FocusEngagedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_FocusEngaged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeFocusEngaged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_FocusEngaged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addFocusDisengaged(self: *@This(), handler: *TypedEventHandler(Control,FocusDisengagedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_FocusDisengaged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeFocusDisengaged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_FocusDisengaged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn RemoveFocusEngagement(self: *@This()) core.HResult!void {
        const _c = self.vtable.RemoveFocusEngagement(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IControl4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0e18aeee-5f2e-44ea-8513-d3875c0a7513";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsFocusEngagementEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsFocusEngagementEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsFocusEngaged: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsFocusEngaged: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_RequiresPointer: *const fn(self: *anyopaque, _r: *RequiresPointer) callconv(.winapi) HRESULT,
        put_RequiresPointer: *const fn(self: *anyopaque, value: RequiresPointer) callconv(.winapi) HRESULT,
        get_XYFocusLeft: *const fn(self: *anyopaque, _r: **DependencyObject) callconv(.winapi) HRESULT,
        put_XYFocusLeft: *const fn(self: *anyopaque, value: *DependencyObject) callconv(.winapi) HRESULT,
        get_XYFocusRight: *const fn(self: *anyopaque, _r: **DependencyObject) callconv(.winapi) HRESULT,
        put_XYFocusRight: *const fn(self: *anyopaque, value: *DependencyObject) callconv(.winapi) HRESULT,
        get_XYFocusUp: *const fn(self: *anyopaque, _r: **DependencyObject) callconv(.winapi) HRESULT,
        put_XYFocusUp: *const fn(self: *anyopaque, value: *DependencyObject) callconv(.winapi) HRESULT,
        get_XYFocusDown: *const fn(self: *anyopaque, _r: **DependencyObject) callconv(.winapi) HRESULT,
        put_XYFocusDown: *const fn(self: *anyopaque, value: *DependencyObject) callconv(.winapi) HRESULT,
        get_ElementSoundMode: *const fn(self: *anyopaque, _r: *ElementSoundMode) callconv(.winapi) HRESULT,
        put_ElementSoundMode: *const fn(self: *anyopaque, value: ElementSoundMode) callconv(.winapi) HRESULT,
        add_FocusEngaged: *const fn(self: *anyopaque, handler: *TypedEventHandler(Control,FocusEngagedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_FocusEngaged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_FocusDisengaged: *const fn(self: *anyopaque, handler: *TypedEventHandler(Control,FocusDisengagedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_FocusDisengaged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        RemoveFocusEngagement: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
    };
};
pub const IControl5 = extern struct {
    vtable: *const VTable,
    pub fn getDefaultStyleResourceUri(self: *@This()) core.HResult!*Uri {
        var _r: *Uri = undefined;
        const _c = self.vtable.get_DefaultStyleResourceUri(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDefaultStyleResourceUri(self: *@This(), value: *Uri) core.HResult!void {
        const _c = self.vtable.put_DefaultStyleResourceUri(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IControl5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5ebb51d5-9e58-49b7-bc2d-0155ff118664";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_DefaultStyleResourceUri: *const fn(self: *anyopaque, _r: **Uri) callconv(.winapi) HRESULT,
        put_DefaultStyleResourceUri: *const fn(self: *anyopaque, value: *Uri) callconv(.winapi) HRESULT,
    };
};
pub const IControl7 = extern struct {
    vtable: *const VTable,
    pub fn getBackgroundSizing(self: *@This()) core.HResult!BackgroundSizing {
        var _r: BackgroundSizing = undefined;
        const _c = self.vtable.get_BackgroundSizing(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBackgroundSizing(self: *@This(), value: BackgroundSizing) core.HResult!void {
        const _c = self.vtable.put_BackgroundSizing(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCornerRadius(self: *@This()) core.HResult!CornerRadius {
        var _r: CornerRadius = undefined;
        const _c = self.vtable.get_CornerRadius(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCornerRadius(self: *@This(), value: CornerRadius) core.HResult!void {
        const _c = self.vtable.put_CornerRadius(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IControl7";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3550dbe1-e561-5934-a3ef-7db8bf6e3b45";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BackgroundSizing: *const fn(self: *anyopaque, _r: *BackgroundSizing) callconv(.winapi) HRESULT,
        put_BackgroundSizing: *const fn(self: *anyopaque, value: BackgroundSizing) callconv(.winapi) HRESULT,
        get_CornerRadius: *const fn(self: *anyopaque, _r: *CornerRadius) callconv(.winapi) HRESULT,
        put_CornerRadius: *const fn(self: *anyopaque, value: CornerRadius) callconv(.winapi) HRESULT,
    };
};
pub const IControlFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*Control {
        var _r: *Control = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IControlFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b12b1d5a-6419-4e16-b212-a45336b75778";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **Control) callconv(.winapi) HRESULT,
    };
};
pub const IControlOverrides = extern struct {
    vtable: *const VTable,
    pub fn OnPointerEntered(self: *@This(), e: *PointerRoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnPointerEntered(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnPointerPressed(self: *@This(), e: *PointerRoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnPointerPressed(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnPointerMoved(self: *@This(), e: *PointerRoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnPointerMoved(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnPointerReleased(self: *@This(), e: *PointerRoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnPointerReleased(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnPointerExited(self: *@This(), e: *PointerRoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnPointerExited(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnPointerCaptureLost(self: *@This(), e: *PointerRoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnPointerCaptureLost(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnPointerCanceled(self: *@This(), e: *PointerRoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnPointerCanceled(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnPointerWheelChanged(self: *@This(), e: *PointerRoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnPointerWheelChanged(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnTapped(self: *@This(), e: *TappedRoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnTapped(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnDoubleTapped(self: *@This(), e: *DoubleTappedRoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnDoubleTapped(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnHolding(self: *@This(), e: *HoldingRoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnHolding(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnRightTapped(self: *@This(), e: *RightTappedRoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnRightTapped(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnManipulationStarting(self: *@This(), e: *ManipulationStartingRoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnManipulationStarting(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnManipulationInertiaStarting(self: *@This(), e: *ManipulationInertiaStartingRoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnManipulationInertiaStarting(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnManipulationStarted(self: *@This(), e: *ManipulationStartedRoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnManipulationStarted(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnManipulationDelta(self: *@This(), e: *ManipulationDeltaRoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnManipulationDelta(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnManipulationCompleted(self: *@This(), e: *ManipulationCompletedRoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnManipulationCompleted(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnKeyUp(self: *@This(), e: *KeyRoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnKeyUp(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnKeyDown(self: *@This(), e: *KeyRoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnKeyDown(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnGotFocus(self: *@This(), e: *RoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnGotFocus(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnLostFocus(self: *@This(), e: *RoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnLostFocus(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnDragEnter(self: *@This(), e: *DragEventArgs) core.HResult!void {
        const _c = self.vtable.OnDragEnter(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnDragLeave(self: *@This(), e: *DragEventArgs) core.HResult!void {
        const _c = self.vtable.OnDragLeave(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnDragOver(self: *@This(), e: *DragEventArgs) core.HResult!void {
        const _c = self.vtable.OnDragOver(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnDrop(self: *@This(), e: *DragEventArgs) core.HResult!void {
        const _c = self.vtable.OnDrop(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IControlOverrides";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a09691df-9824-41fe-b530-b0d8990e64c1";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        OnPointerEntered: *const fn(self: *anyopaque, e: *PointerRoutedEventArgs) callconv(.winapi) HRESULT,
        OnPointerPressed: *const fn(self: *anyopaque, e: *PointerRoutedEventArgs) callconv(.winapi) HRESULT,
        OnPointerMoved: *const fn(self: *anyopaque, e: *PointerRoutedEventArgs) callconv(.winapi) HRESULT,
        OnPointerReleased: *const fn(self: *anyopaque, e: *PointerRoutedEventArgs) callconv(.winapi) HRESULT,
        OnPointerExited: *const fn(self: *anyopaque, e: *PointerRoutedEventArgs) callconv(.winapi) HRESULT,
        OnPointerCaptureLost: *const fn(self: *anyopaque, e: *PointerRoutedEventArgs) callconv(.winapi) HRESULT,
        OnPointerCanceled: *const fn(self: *anyopaque, e: *PointerRoutedEventArgs) callconv(.winapi) HRESULT,
        OnPointerWheelChanged: *const fn(self: *anyopaque, e: *PointerRoutedEventArgs) callconv(.winapi) HRESULT,
        OnTapped: *const fn(self: *anyopaque, e: *TappedRoutedEventArgs) callconv(.winapi) HRESULT,
        OnDoubleTapped: *const fn(self: *anyopaque, e: *DoubleTappedRoutedEventArgs) callconv(.winapi) HRESULT,
        OnHolding: *const fn(self: *anyopaque, e: *HoldingRoutedEventArgs) callconv(.winapi) HRESULT,
        OnRightTapped: *const fn(self: *anyopaque, e: *RightTappedRoutedEventArgs) callconv(.winapi) HRESULT,
        OnManipulationStarting: *const fn(self: *anyopaque, e: *ManipulationStartingRoutedEventArgs) callconv(.winapi) HRESULT,
        OnManipulationInertiaStarting: *const fn(self: *anyopaque, e: *ManipulationInertiaStartingRoutedEventArgs) callconv(.winapi) HRESULT,
        OnManipulationStarted: *const fn(self: *anyopaque, e: *ManipulationStartedRoutedEventArgs) callconv(.winapi) HRESULT,
        OnManipulationDelta: *const fn(self: *anyopaque, e: *ManipulationDeltaRoutedEventArgs) callconv(.winapi) HRESULT,
        OnManipulationCompleted: *const fn(self: *anyopaque, e: *ManipulationCompletedRoutedEventArgs) callconv(.winapi) HRESULT,
        OnKeyUp: *const fn(self: *anyopaque, e: *KeyRoutedEventArgs) callconv(.winapi) HRESULT,
        OnKeyDown: *const fn(self: *anyopaque, e: *KeyRoutedEventArgs) callconv(.winapi) HRESULT,
        OnGotFocus: *const fn(self: *anyopaque, e: *RoutedEventArgs) callconv(.winapi) HRESULT,
        OnLostFocus: *const fn(self: *anyopaque, e: *RoutedEventArgs) callconv(.winapi) HRESULT,
        OnDragEnter: *const fn(self: *anyopaque, e: *DragEventArgs) callconv(.winapi) HRESULT,
        OnDragLeave: *const fn(self: *anyopaque, e: *DragEventArgs) callconv(.winapi) HRESULT,
        OnDragOver: *const fn(self: *anyopaque, e: *DragEventArgs) callconv(.winapi) HRESULT,
        OnDrop: *const fn(self: *anyopaque, e: *DragEventArgs) callconv(.winapi) HRESULT,
    };
};
pub const IControlOverrides6 = extern struct {
    vtable: *const VTable,
    pub fn OnPreviewKeyDown(self: *@This(), e: *KeyRoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnPreviewKeyDown(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnPreviewKeyUp(self: *@This(), e: *KeyRoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnPreviewKeyUp(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnCharacterReceived(self: *@This(), e: *CharacterReceivedRoutedEventArgs) core.HResult!void {
        const _c = self.vtable.OnCharacterReceived(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IControlOverrides6";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e194c96a-d8cc-4339-a0e1-2e9c420879ec";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        OnPreviewKeyDown: *const fn(self: *anyopaque, e: *KeyRoutedEventArgs) callconv(.winapi) HRESULT,
        OnPreviewKeyUp: *const fn(self: *anyopaque, e: *KeyRoutedEventArgs) callconv(.winapi) HRESULT,
        OnCharacterReceived: *const fn(self: *anyopaque, e: *CharacterReceivedRoutedEventArgs) callconv(.winapi) HRESULT,
    };
};
pub const IControlProtected = extern struct {
    vtable: *const VTable,
    pub fn getDefaultStyleKey(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_DefaultStyleKey(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDefaultStyleKey(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_DefaultStyleKey(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn GetTemplateChild(self: *@This(), childName: HSTRING) core.HResult!*DependencyObject {
        var _r: *DependencyObject = undefined;
        const _c = self.vtable.GetTemplateChild(@ptrCast(self), childName, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IControlProtected";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1791587a-2a7c-4981-a2d8-ab99fffc65b9";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_DefaultStyleKey: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_DefaultStyleKey: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        GetTemplateChild: *const fn(self: *anyopaque, childName: HSTRING, _r: **DependencyObject) callconv(.winapi) HRESULT,
    };
};
pub const IControlStatics = extern struct {
    vtable: *const VTable,
    pub fn getFontSizeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontSizeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontFamilyProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontFamilyProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontWeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontWeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontStretchProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontStretchProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCharacterSpacingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CharacterSpacingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsTabStopProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsTabStopProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTabIndexProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TabIndexProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTabNavigationProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TabNavigationProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPaddingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PaddingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHorizontalContentAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HorizontalContentAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getVerticalContentAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_VerticalContentAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBackgroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BackgroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBorderThicknessProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BorderThicknessProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBorderBrushProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BorderBrushProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDefaultStyleKeyProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DefaultStyleKeyProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFocusStateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FocusStateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IControlStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "473b305b-877d-4c35-8fca-46a05f96607a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_FontSizeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontFamilyProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontWeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontStretchProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CharacterSpacingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsTabStopProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TabIndexProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TabNavigationProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PaddingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HorizontalContentAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_VerticalContentAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BackgroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BorderThicknessProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BorderBrushProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DefaultStyleKeyProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FocusStateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IControlStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getIsTextScaleFactorEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsTextScaleFactorEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IControlStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "32233e36-ab74-4a25-a556-45293135b2c5";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsTextScaleFactorEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IControlStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getUseSystemFocusVisualsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_UseSystemFocusVisualsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsTemplateFocusTargetProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsTemplateFocusTargetProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetIsTemplateFocusTarget(self: *@This(), element: *FrameworkElement) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.GetIsTemplateFocusTarget(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetIsTemplateFocusTarget(self: *@This(), element: *FrameworkElement, value: bool) core.HResult!void {
        const _c = self.vtable.SetIsTemplateFocusTarget(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IControlStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "aad15e61-e4b9-4d72-b653-934149aa5003";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_UseSystemFocusVisualsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsTemplateFocusTargetProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetIsTemplateFocusTarget: *const fn(self: *anyopaque, element: *FrameworkElement, _r: *bool) callconv(.winapi) HRESULT,
        SetIsTemplateFocusTarget: *const fn(self: *anyopaque, element: *FrameworkElement, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IControlStatics4 = extern struct {
    vtable: *const VTable,
    pub fn getIsFocusEngagementEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsFocusEngagementEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsFocusEngagedProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsFocusEngagedProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getRequiresPointerProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_RequiresPointerProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getXYFocusLeftProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_XYFocusLeftProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getXYFocusRightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_XYFocusRightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getXYFocusUpProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_XYFocusUpProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getXYFocusDownProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_XYFocusDownProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getElementSoundModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ElementSoundModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IControlStatics4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "59fda728-c05a-4ec2-8a4b-06ad69b66e15";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsFocusEngagementEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsFocusEngagedProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_RequiresPointerProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_XYFocusLeftProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_XYFocusRightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_XYFocusUpProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_XYFocusDownProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ElementSoundModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IControlStatics5 = extern struct {
    vtable: *const VTable,
    pub fn getDefaultStyleResourceUriProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DefaultStyleResourceUriProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsTemplateKeyTipTargetProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsTemplateKeyTipTargetProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetIsTemplateKeyTipTarget(self: *@This(), element: *DependencyObject) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.GetIsTemplateKeyTipTarget(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetIsTemplateKeyTipTarget(self: *@This(), element: *DependencyObject, value: bool) core.HResult!void {
        const _c = self.vtable.SetIsTemplateKeyTipTarget(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IControlStatics5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f635b5a3-ef8e-404f-877b-5580473710a6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_DefaultStyleResourceUriProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsTemplateKeyTipTargetProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetIsTemplateKeyTipTarget: *const fn(self: *anyopaque, element: *DependencyObject, _r: *bool) callconv(.winapi) HRESULT,
        SetIsTemplateKeyTipTarget: *const fn(self: *anyopaque, element: *DependencyObject, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IControlStatics7 = extern struct {
    vtable: *const VTable,
    pub fn getBackgroundSizingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BackgroundSizingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCornerRadiusProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CornerRadiusProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IControlStatics7";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "aee1ca45-c910-5dab-a266-fdf50c0bedd2";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BackgroundSizingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CornerRadiusProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IControlTemplate = extern struct {
    vtable: *const VTable,
    pub fn getTargetType(self: *@This()) core.HResult!TypeName {
        var _r: TypeName = undefined;
        const _c = self.vtable.get_TargetType(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTargetType(self: *@This(), value: TypeName) core.HResult!void {
        const _c = self.vtable.put_TargetType(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IControlTemplate";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "efd2418e-41e0-48bb-8b82-91eda1ba3fe2";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TargetType: *const fn(self: *anyopaque, _r: *TypeName) callconv(.winapi) HRESULT,
        put_TargetType: *const fn(self: *anyopaque, value: TypeName) callconv(.winapi) HRESULT,
    };
};
pub const IDataTemplateSelector = extern struct {
    vtable: *const VTable,
    pub fn SelectTemplate(self: *@This(), item: *IInspectable, container: *DependencyObject) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.SelectTemplate(@ptrCast(self), item, container, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDataTemplateSelector";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a907d496-46a0-4cd7-8dbe-f9a581df60b1";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        SelectTemplate: *const fn(self: *anyopaque, item: *IInspectable, container: *DependencyObject, _r: **DataTemplate) callconv(.winapi) HRESULT,
    };
};
pub const IDataTemplateSelector2 = extern struct {
    vtable: *const VTable,
    pub fn SelectTemplate(self: *@This(), item: *IInspectable) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.SelectTemplate(@ptrCast(self), item, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDataTemplateSelector2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3792bc47-8c4b-4257-a5ae-cc3f8ed786eb";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        SelectTemplate: *const fn(self: *anyopaque, item: *IInspectable, _r: **DataTemplate) callconv(.winapi) HRESULT,
    };
};
pub const IDataTemplateSelectorFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*DataTemplateSelector {
        var _r: *DataTemplateSelector = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDataTemplateSelectorFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "511baad0-210a-457d-9521-433d2b11b7d2";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **DataTemplateSelector) callconv(.winapi) HRESULT,
    };
};
pub const IDataTemplateSelectorOverrides = extern struct {
    vtable: *const VTable,
    pub fn SelectTemplateCore(self: *@This(), item: *IInspectable, container: *DependencyObject) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.SelectTemplateCore(@ptrCast(self), item, container, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDataTemplateSelectorOverrides";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "2d162925-5966-4bfa-8638-4d345689f6cf";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        SelectTemplateCore: *const fn(self: *anyopaque, item: *IInspectable, container: *DependencyObject, _r: **DataTemplate) callconv(.winapi) HRESULT,
    };
};
pub const IDataTemplateSelectorOverrides2 = extern struct {
    vtable: *const VTable,
    pub fn SelectTemplateCore(self: *@This(), item: *IInspectable) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.SelectTemplateCore(@ptrCast(self), item, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDataTemplateSelectorOverrides2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6c3fb5fc-8e84-4c91-ac15-04a1d885500f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        SelectTemplateCore: *const fn(self: *anyopaque, item: *IInspectable, _r: **DataTemplate) callconv(.winapi) HRESULT,
    };
};
pub const IDatePickedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getOldDate(self: *@This()) core.HResult!DateTime {
        var _r: DateTime = undefined;
        const _c = self.vtable.get_OldDate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getNewDate(self: *@This()) core.HResult!DateTime {
        var _r: DateTime = undefined;
        const _c = self.vtable.get_NewDate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDatePickedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a1527b12-59c1-4521-b28c-b176675e7c5a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_OldDate: *const fn(self: *anyopaque, _r: *DateTime) callconv(.winapi) HRESULT,
        get_NewDate: *const fn(self: *anyopaque, _r: *DateTime) callconv(.winapi) HRESULT,
    };
};
pub const IDatePicker = extern struct {
    vtable: *const VTable,
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Header(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Header(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_HeaderTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_HeaderTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCalendarIdentifier(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_CalendarIdentifier(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCalendarIdentifier(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_CalendarIdentifier(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDate(self: *@This()) core.HResult!DateTime {
        var _r: DateTime = undefined;
        const _c = self.vtable.get_Date(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDate(self: *@This(), value: DateTime) core.HResult!void {
        const _c = self.vtable.put_Date(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDayVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_DayVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDayVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_DayVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMonthVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_MonthVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMonthVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_MonthVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getYearVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_YearVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putYearVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_YearVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDayFormat(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_DayFormat(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDayFormat(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_DayFormat(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMonthFormat(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_MonthFormat(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMonthFormat(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_MonthFormat(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getYearFormat(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_YearFormat(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putYearFormat(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_YearFormat(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMinYear(self: *@This()) core.HResult!DateTime {
        var _r: DateTime = undefined;
        const _c = self.vtable.get_MinYear(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMinYear(self: *@This(), value: DateTime) core.HResult!void {
        const _c = self.vtable.put_MinYear(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMaxYear(self: *@This()) core.HResult!DateTime {
        var _r: DateTime = undefined;
        const _c = self.vtable.get_MaxYear(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxYear(self: *@This(), value: DateTime) core.HResult!void {
        const _c = self.vtable.put_MaxYear(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOrientation(self: *@This()) core.HResult!Orientation {
        var _r: Orientation = undefined;
        const _c = self.vtable.get_Orientation(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOrientation(self: *@This(), value: Orientation) core.HResult!void {
        const _c = self.vtable.put_Orientation(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addDateChanged(self: *@This(), handler: *EventHandler(DatePickerValueChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_DateChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeDateChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_DateChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDatePicker";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "06da3946-08b8-4103-8b8a-093efd6a7657";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Header: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Header: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_HeaderTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_HeaderTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_CalendarIdentifier: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_CalendarIdentifier: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_Date: *const fn(self: *anyopaque, _r: *DateTime) callconv(.winapi) HRESULT,
        put_Date: *const fn(self: *anyopaque, value: DateTime) callconv(.winapi) HRESULT,
        get_DayVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_DayVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_MonthVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_MonthVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_YearVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_YearVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_DayFormat: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_DayFormat: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_MonthFormat: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_MonthFormat: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_YearFormat: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_YearFormat: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_MinYear: *const fn(self: *anyopaque, _r: *DateTime) callconv(.winapi) HRESULT,
        put_MinYear: *const fn(self: *anyopaque, value: DateTime) callconv(.winapi) HRESULT,
        get_MaxYear: *const fn(self: *anyopaque, _r: *DateTime) callconv(.winapi) HRESULT,
        put_MaxYear: *const fn(self: *anyopaque, value: DateTime) callconv(.winapi) HRESULT,
        get_Orientation: *const fn(self: *anyopaque, _r: *Orientation) callconv(.winapi) HRESULT,
        put_Orientation: *const fn(self: *anyopaque, value: Orientation) callconv(.winapi) HRESULT,
        add_DateChanged: *const fn(self: *anyopaque, handler: *EventHandler(DatePickerValueChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_DateChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IDatePicker2 = extern struct {
    vtable: *const VTable,
    pub fn getLightDismissOverlayMode(self: *@This()) core.HResult!LightDismissOverlayMode {
        var _r: LightDismissOverlayMode = undefined;
        const _c = self.vtable.get_LightDismissOverlayMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putLightDismissOverlayMode(self: *@This(), value: LightDismissOverlayMode) core.HResult!void {
        const _c = self.vtable.put_LightDismissOverlayMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDatePicker2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "bb28b475-2c1f-4340-9e30-948f99c9e57a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LightDismissOverlayMode: *const fn(self: *anyopaque, _r: *LightDismissOverlayMode) callconv(.winapi) HRESULT,
        put_LightDismissOverlayMode: *const fn(self: *anyopaque, value: LightDismissOverlayMode) callconv(.winapi) HRESULT,
    };
};
pub const IDatePicker3 = extern struct {
    vtable: *const VTable,
    pub fn getSelectedDate(self: *@This()) core.HResult!*IReference(DateTime) {
        var _r: *IReference(DateTime) = undefined;
        const _c = self.vtable.get_SelectedDate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectedDate(self: *@This(), value: *IReference(DateTime)) core.HResult!void {
        const _c = self.vtable.put_SelectedDate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addSelectedDateChanged(self: *@This(), handler: *TypedEventHandler(DatePicker,DatePickerSelectedValueChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_SelectedDateChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeSelectedDateChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_SelectedDateChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDatePicker3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "7da12a3b-a764-5ae1-abae-6affc1428e1e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectedDate: *const fn(self: *anyopaque, _r: **IReference(DateTime)) callconv(.winapi) HRESULT,
        put_SelectedDate: *const fn(self: *anyopaque, value: *IReference(DateTime)) callconv(.winapi) HRESULT,
        add_SelectedDateChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(DatePicker,DatePickerSelectedValueChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_SelectedDateChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IDatePickerFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*DatePicker {
        var _r: *DatePicker = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDatePickerFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "eec3ca84-9896-4a7d-bb35-6fb21eaeca11";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **DatePicker) callconv(.winapi) HRESULT,
    };
};
pub const IDatePickerFlyout = extern struct {
    vtable: *const VTable,
    pub fn getCalendarIdentifier(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_CalendarIdentifier(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCalendarIdentifier(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_CalendarIdentifier(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDate(self: *@This()) core.HResult!DateTime {
        var _r: DateTime = undefined;
        const _c = self.vtable.get_Date(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDate(self: *@This(), value: DateTime) core.HResult!void {
        const _c = self.vtable.put_Date(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDayVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_DayVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDayVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_DayVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMonthVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_MonthVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMonthVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_MonthVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getYearVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_YearVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putYearVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_YearVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMinYear(self: *@This()) core.HResult!DateTime {
        var _r: DateTime = undefined;
        const _c = self.vtable.get_MinYear(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMinYear(self: *@This(), value: DateTime) core.HResult!void {
        const _c = self.vtable.put_MinYear(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMaxYear(self: *@This()) core.HResult!DateTime {
        var _r: DateTime = undefined;
        const _c = self.vtable.get_MaxYear(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxYear(self: *@This(), value: DateTime) core.HResult!void {
        const _c = self.vtable.put_MaxYear(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addDatePicked(self: *@This(), handler: *TypedEventHandler(DatePickerFlyout,DatePickedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_DatePicked(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeDatePicked(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_DatePicked(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn ShowAtAsync(self: *@This(), target: *FrameworkElement) core.HResult!*IAsyncOperation(IReference(DateTime)) {
        var _r: *IAsyncOperation(IReference(DateTime)) = undefined;
        const _c = self.vtable.ShowAtAsync(@ptrCast(self), target, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDatePickerFlyout";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "fbf33b1a-a3a4-4df8-9228-23a5ac27df4e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CalendarIdentifier: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_CalendarIdentifier: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_Date: *const fn(self: *anyopaque, _r: *DateTime) callconv(.winapi) HRESULT,
        put_Date: *const fn(self: *anyopaque, value: DateTime) callconv(.winapi) HRESULT,
        get_DayVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_DayVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_MonthVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_MonthVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_YearVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_YearVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_MinYear: *const fn(self: *anyopaque, _r: *DateTime) callconv(.winapi) HRESULT,
        put_MinYear: *const fn(self: *anyopaque, value: DateTime) callconv(.winapi) HRESULT,
        get_MaxYear: *const fn(self: *anyopaque, _r: *DateTime) callconv(.winapi) HRESULT,
        put_MaxYear: *const fn(self: *anyopaque, value: DateTime) callconv(.winapi) HRESULT,
        add_DatePicked: *const fn(self: *anyopaque, handler: *TypedEventHandler(DatePickerFlyout,DatePickedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_DatePicked: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        ShowAtAsync: *const fn(self: *anyopaque, target: *FrameworkElement, _r: **IAsyncOperation(IReference(DateTime))) callconv(.winapi) HRESULT,
    };
};
pub const IDatePickerFlyout2 = extern struct {
    vtable: *const VTable,
    pub fn getDayFormat(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_DayFormat(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDayFormat(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_DayFormat(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMonthFormat(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_MonthFormat(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMonthFormat(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_MonthFormat(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getYearFormat(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_YearFormat(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putYearFormat(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_YearFormat(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDatePickerFlyout2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "cfb18dbb-9931-4119-8bda-54a86fdfac84";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_DayFormat: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_DayFormat: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_MonthFormat: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_MonthFormat: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_YearFormat: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_YearFormat: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
    };
};
pub const IDatePickerFlyoutItem = extern struct {
    vtable: *const VTable,
    pub fn getPrimaryText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_PrimaryText(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPrimaryText(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_PrimaryText(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSecondaryText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_SecondaryText(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSecondaryText(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_SecondaryText(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDatePickerFlyoutItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9d9bc289-00d2-4aac-9c85-d74f06367887";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PrimaryText: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_PrimaryText: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_SecondaryText: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_SecondaryText: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
    };
};
pub const IDatePickerFlyoutItemStatics = extern struct {
    vtable: *const VTable,
    pub fn getPrimaryTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PrimaryTextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSecondaryTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SecondaryTextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDatePickerFlyoutItemStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "aa9c91da-07f6-4cdf-89b4-dda3bdb0ea6b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PrimaryTextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SecondaryTextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IDatePickerFlyoutPresenter = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDatePickerFlyoutPresenter";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "7c62f70e-2ddc-4381-832f-54cbdfaa849a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IDatePickerFlyoutPresenter2 = extern struct {
    vtable: *const VTable,
    pub fn getIsDefaultShadowEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsDefaultShadowEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsDefaultShadowEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsDefaultShadowEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDatePickerFlyoutPresenter2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c5b2578f-96d8-55cc-97ee-3f88fc85e479";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsDefaultShadowEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsDefaultShadowEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IDatePickerFlyoutPresenterStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getIsDefaultShadowEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsDefaultShadowEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDatePickerFlyoutPresenterStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4dc0c49e-1f8e-5966-bbdb-215750c73aba";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsDefaultShadowEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IDatePickerFlyoutStatics = extern struct {
    vtable: *const VTable,
    pub fn getCalendarIdentifierProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CalendarIdentifierProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDayVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DayVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMonthVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MonthVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getYearVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_YearVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMinYearProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MinYearProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaxYearProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxYearProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDatePickerFlyoutStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "cd570377-5845-4c12-8c10-592d9fcc7cd9";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CalendarIdentifierProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DayVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MonthVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_YearVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MinYearProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaxYearProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IDatePickerFlyoutStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getDayFormatProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DayFormatProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMonthFormatProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MonthFormatProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getYearFormatProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_YearFormatProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDatePickerFlyoutStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "afd3e569-81e6-4b54-84a9-68079b73e34e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_DayFormatProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MonthFormatProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_YearFormatProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IDatePickerSelectedValueChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getOldDate(self: *@This()) core.HResult!*IReference(DateTime) {
        var _r: *IReference(DateTime) = undefined;
        const _c = self.vtable.get_OldDate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getNewDate(self: *@This()) core.HResult!*IReference(DateTime) {
        var _r: *IReference(DateTime) = undefined;
        const _c = self.vtable.get_NewDate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDatePickerSelectedValueChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "564dceed-744a-5c3a-9bd2-4dcd9919a7b7";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_OldDate: *const fn(self: *anyopaque, _r: **IReference(DateTime)) callconv(.winapi) HRESULT,
        get_NewDate: *const fn(self: *anyopaque, _r: **IReference(DateTime)) callconv(.winapi) HRESULT,
    };
};
pub const IDatePickerStatics = extern struct {
    vtable: *const VTable,
    pub fn getHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCalendarIdentifierProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CalendarIdentifierProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDayVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DayVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMonthVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MonthVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getYearVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_YearVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDayFormatProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DayFormatProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMonthFormatProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MonthFormatProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getYearFormatProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_YearFormatProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMinYearProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MinYearProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaxYearProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxYearProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOrientationProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OrientationProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDatePickerStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "182e7c69-2116-4c67-b513-713364831d79";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CalendarIdentifierProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DayVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MonthVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_YearVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DayFormatProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MonthFormatProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_YearFormatProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MinYearProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaxYearProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OrientationProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IDatePickerStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getLightDismissOverlayModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LightDismissOverlayModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDatePickerStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f1076df6-fba6-4550-8b88-a6420847f60d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LightDismissOverlayModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IDatePickerStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getSelectedDateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedDateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDatePickerStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a9f80afe-a30a-5f26-a446-fec2075d4a0e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectedDateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IDatePickerValueChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getOldDate(self: *@This()) core.HResult!DateTime {
        var _r: DateTime = undefined;
        const _c = self.vtable.get_OldDate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getNewDate(self: *@This()) core.HResult!DateTime {
        var _r: DateTime = undefined;
        const _c = self.vtable.get_NewDate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDatePickerValueChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1ae661b2-b1b4-4273-96e0-19daff187446";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_OldDate: *const fn(self: *anyopaque, _r: *DateTime) callconv(.winapi) HRESULT,
        get_NewDate: *const fn(self: *anyopaque, _r: *DateTime) callconv(.winapi) HRESULT,
    };
};
pub const IDragItemsCompletedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getItems(self: *@This()) core.HResult!*IVectorView(IInspectable) {
        var _r: *IVectorView(IInspectable) = undefined;
        const _c = self.vtable.get_Items(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDropResult(self: *@This()) core.HResult!DataPackageOperation {
        var _r: DataPackageOperation = undefined;
        const _c = self.vtable.get_DropResult(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDragItemsCompletedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "af05f22f-9e78-4b21-9a8e-41c2d1367a2a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Items: *const fn(self: *anyopaque, _r: **IVectorView(IInspectable)) callconv(.winapi) HRESULT,
        get_DropResult: *const fn(self: *anyopaque, _r: *DataPackageOperation) callconv(.winapi) HRESULT,
    };
};
pub const IDragItemsStartingEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getCancel(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_Cancel(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCancel(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_Cancel(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getItems(self: *@This()) core.HResult!*IVector(IInspectable) {
        var _r: *IVector(IInspectable) = undefined;
        const _c = self.vtable.get_Items(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getData(self: *@This()) core.HResult!*DataPackage {
        var _r: *DataPackage = undefined;
        const _c = self.vtable.get_Data(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDragItemsStartingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "71cf215c-daed-4783-aa11-dc574d2713e9";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Cancel: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_Cancel: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_Items: *const fn(self: *anyopaque, _r: **IVector(IInspectable)) callconv(.winapi) HRESULT,
        get_Data: *const fn(self: *anyopaque, _r: **DataPackage) callconv(.winapi) HRESULT,
    };
};
pub const IDropDownButton = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDropDownButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "671f74e6-2a27-5fa8-b0a2-79b2e71ebd87";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IDropDownButtonAutomationPeer = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDropDownButtonAutomationPeer";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "72f294f1-bff6-5d07-9db4-54134506bc80";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IDropDownButtonAutomationPeerFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), owner: *DropDownButton, baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*DropDownButtonAutomationPeer {
        var _r: *DropDownButtonAutomationPeer = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), owner, baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDropDownButtonAutomationPeerFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b8c449b2-6354-5c0c-9e95-e0c99a293a44";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, owner: *DropDownButton, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **DropDownButtonAutomationPeer) callconv(.winapi) HRESULT,
    };
};
pub const IDropDownButtonFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*DropDownButton {
        var _r: *DropDownButton = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDropDownButtonFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0d9f8ab5-e70d-52bd-9ca0-36ceecaa642a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **DropDownButton) callconv(.winapi) HRESULT,
    };
};
pub const IDynamicOverflowItemsChangingEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getAction(self: *@This()) core.HResult!CommandBarDynamicOverflowAction {
        var _r: CommandBarDynamicOverflowAction = undefined;
        const _c = self.vtable.get_Action(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IDynamicOverflowItemsChangingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c93c736f-6f6e-4e43-90d9-9b46a0d88b9f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Action: *const fn(self: *anyopaque, _r: *CommandBarDynamicOverflowAction) callconv(.winapi) HRESULT,
    };
};
pub const IFlipView = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFlipView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a1582f68-3d7d-4d3b-b71d-488eed1e3493";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IFlipView2 = extern struct {
    vtable: *const VTable,
    pub fn getUseTouchAnimationsForAllNavigation(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_UseTouchAnimationsForAllNavigation(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putUseTouchAnimationsForAllNavigation(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_UseTouchAnimationsForAllNavigation(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFlipView2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c4fea4fd-7af3-4952-9fd9-9e0987fc4f29";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_UseTouchAnimationsForAllNavigation: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_UseTouchAnimationsForAllNavigation: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IFlipViewFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*FlipView {
        var _r: *FlipView = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFlipViewFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f1dea9be-9ae8-4d4b-ab43-16d31e05f4f3";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **FlipView) callconv(.winapi) HRESULT,
    };
};
pub const IFlipViewItem = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFlipViewItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "56196565-ce2b-4bda-a36b-82a2b8b0d4c0";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IFlipViewItemFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*FlipViewItem {
        var _r: *FlipViewItem = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFlipViewItemFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f21d91fe-22a0-4412-a853-9d6a6e8f2aaf";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **FlipViewItem) callconv(.winapi) HRESULT,
    };
};
pub const IFlipViewStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getUseTouchAnimationsForAllNavigationProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_UseTouchAnimationsForAllNavigationProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFlipViewStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "70e3d93f-4308-4ba2-bbce-e2cb0ed34476";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_UseTouchAnimationsForAllNavigationProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IFlyout = extern struct {
    vtable: *const VTable,
    pub fn getContent(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_Content(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putContent(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_Content(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFlyoutPresenterStyle(self: *@This()) core.HResult!*Style {
        var _r: *Style = undefined;
        const _c = self.vtable.get_FlyoutPresenterStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFlyoutPresenterStyle(self: *@This(), value: *Style) core.HResult!void {
        const _c = self.vtable.put_FlyoutPresenterStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFlyout";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6584ebdf-cbc7-4e19-843a-a14f24a793ea";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Content: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_Content: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
        get_FlyoutPresenterStyle: *const fn(self: *anyopaque, _r: **Style) callconv(.winapi) HRESULT,
        put_FlyoutPresenterStyle: *const fn(self: *anyopaque, value: *Style) callconv(.winapi) HRESULT,
    };
};
pub const IFlyoutFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*Flyout {
        var _r: *Flyout = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFlyoutFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4bed4933-008e-4b03-a385-79fe5266ddba";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **Flyout) callconv(.winapi) HRESULT,
    };
};
pub const IFlyoutPresenter = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFlyoutPresenter";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "827d5b79-e37b-46a5-8d44-63a11a580e83";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IFlyoutPresenter2 = extern struct {
    vtable: *const VTable,
    pub fn getIsDefaultShadowEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsDefaultShadowEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsDefaultShadowEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsDefaultShadowEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFlyoutPresenter2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4f857e92-36b4-5048-9051-a992b43e8a1d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsDefaultShadowEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsDefaultShadowEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IFlyoutPresenterFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*FlyoutPresenter {
        var _r: *FlyoutPresenter = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFlyoutPresenterFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ee4d668f-da76-469a-acd7-3060e613ade7";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **FlyoutPresenter) callconv(.winapi) HRESULT,
    };
};
pub const IFlyoutPresenterStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getIsDefaultShadowEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsDefaultShadowEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFlyoutPresenterStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1492ae4b-2727-5e8e-9105-6d7a2b1185b2";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsDefaultShadowEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IFlyoutStatics = extern struct {
    vtable: *const VTable,
    pub fn getContentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ContentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFlyoutPresenterStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FlyoutPresenterStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFlyoutStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "61364e0b-db75-47e1-b2c3-5b901c3d74b6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ContentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FlyoutPresenterStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IFocusDisengagedEventArgs = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFocusDisengagedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5e14280f-953e-4cf8-b9ea-c530a1ce02ad";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IFocusEngagedEventArgs = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFocusEngagedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a69fc352-da66-404c-823f-5358594e70bb";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IFocusEngagedEventArgs2 = extern struct {
    vtable: *const VTable,
    pub fn getHandled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_Handled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHandled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_Handled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFocusEngagedEventArgs2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4a59e0f4-87c0-4ccd-93c4-a3a01ce39265";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Handled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_Handled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IFontIcon = extern struct {
    vtable: *const VTable,
    pub fn getGlyph(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Glyph(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putGlyph(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_Glyph(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontSize(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_FontSize(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontSize(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_FontSize(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontFamily(self: *@This()) core.HResult!*FontFamily {
        var _r: *FontFamily = undefined;
        const _c = self.vtable.get_FontFamily(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontFamily(self: *@This(), value: *FontFamily) core.HResult!void {
        const _c = self.vtable.put_FontFamily(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontWeight(self: *@This()) core.HResult!FontWeight {
        var _r: FontWeight = undefined;
        const _c = self.vtable.get_FontWeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontWeight(self: *@This(), value: FontWeight) core.HResult!void {
        const _c = self.vtable.put_FontWeight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontStyle(self: *@This()) core.HResult!FontStyle {
        var _r: FontStyle = undefined;
        const _c = self.vtable.get_FontStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontStyle(self: *@This(), value: FontStyle) core.HResult!void {
        const _c = self.vtable.put_FontStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFontIcon";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d4d61391-39ac-4950-9166-3606c264418b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Glyph: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_Glyph: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_FontSize: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_FontSize: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_FontFamily: *const fn(self: *anyopaque, _r: **FontFamily) callconv(.winapi) HRESULT,
        put_FontFamily: *const fn(self: *anyopaque, value: *FontFamily) callconv(.winapi) HRESULT,
        get_FontWeight: *const fn(self: *anyopaque, _r: *FontWeight) callconv(.winapi) HRESULT,
        put_FontWeight: *const fn(self: *anyopaque, value: FontWeight) callconv(.winapi) HRESULT,
        get_FontStyle: *const fn(self: *anyopaque, _r: *FontStyle) callconv(.winapi) HRESULT,
        put_FontStyle: *const fn(self: *anyopaque, value: FontStyle) callconv(.winapi) HRESULT,
    };
};
pub const IFontIcon2 = extern struct {
    vtable: *const VTable,
    pub fn getIsTextScaleFactorEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsTextScaleFactorEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsTextScaleFactorEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsTextScaleFactorEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFontIcon2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f6ebd84d-37e8-46ee-a574-41ad550482e0";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsTextScaleFactorEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsTextScaleFactorEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IFontIcon3 = extern struct {
    vtable: *const VTable,
    pub fn getMirroredWhenRightToLeft(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_MirroredWhenRightToLeft(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMirroredWhenRightToLeft(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_MirroredWhenRightToLeft(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFontIcon3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6155d919-1c6c-4950-8794-231ef0914d94";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_MirroredWhenRightToLeft: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_MirroredWhenRightToLeft: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IFontIconFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*FontIcon {
        var _r: *FontIcon = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFontIconFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1c781b6b-37bf-4ddc-a1a8-1b77db3cf0ea";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **FontIcon) callconv(.winapi) HRESULT,
    };
};
pub const IFontIconSource = extern struct {
    vtable: *const VTable,
    pub fn getGlyph(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Glyph(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putGlyph(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_Glyph(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontSize(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_FontSize(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontSize(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_FontSize(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontFamily(self: *@This()) core.HResult!*FontFamily {
        var _r: *FontFamily = undefined;
        const _c = self.vtable.get_FontFamily(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontFamily(self: *@This(), value: *FontFamily) core.HResult!void {
        const _c = self.vtable.put_FontFamily(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontWeight(self: *@This()) core.HResult!FontWeight {
        var _r: FontWeight = undefined;
        const _c = self.vtable.get_FontWeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontWeight(self: *@This(), value: FontWeight) core.HResult!void {
        const _c = self.vtable.put_FontWeight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontStyle(self: *@This()) core.HResult!FontStyle {
        var _r: FontStyle = undefined;
        const _c = self.vtable.get_FontStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontStyle(self: *@This(), value: FontStyle) core.HResult!void {
        const _c = self.vtable.put_FontStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsTextScaleFactorEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsTextScaleFactorEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsTextScaleFactorEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsTextScaleFactorEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMirroredWhenRightToLeft(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_MirroredWhenRightToLeft(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMirroredWhenRightToLeft(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_MirroredWhenRightToLeft(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFontIconSource";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "2211ac9a-74e3-43ed-b61c-21afc7df4d10";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Glyph: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_Glyph: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_FontSize: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_FontSize: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_FontFamily: *const fn(self: *anyopaque, _r: **FontFamily) callconv(.winapi) HRESULT,
        put_FontFamily: *const fn(self: *anyopaque, value: *FontFamily) callconv(.winapi) HRESULT,
        get_FontWeight: *const fn(self: *anyopaque, _r: *FontWeight) callconv(.winapi) HRESULT,
        put_FontWeight: *const fn(self: *anyopaque, value: FontWeight) callconv(.winapi) HRESULT,
        get_FontStyle: *const fn(self: *anyopaque, _r: *FontStyle) callconv(.winapi) HRESULT,
        put_FontStyle: *const fn(self: *anyopaque, value: FontStyle) callconv(.winapi) HRESULT,
        get_IsTextScaleFactorEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsTextScaleFactorEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_MirroredWhenRightToLeft: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_MirroredWhenRightToLeft: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IFontIconSourceFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*FontIconSource {
        var _r: *FontIconSource = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFontIconSourceFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8bdcf6bd-fc06-42b8-b30b-7505082ac38f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **FontIconSource) callconv(.winapi) HRESULT,
    };
};
pub const IFontIconSourceStatics = extern struct {
    vtable: *const VTable,
    pub fn getGlyphProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_GlyphProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontSizeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontSizeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontFamilyProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontFamilyProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontWeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontWeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsTextScaleFactorEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsTextScaleFactorEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMirroredWhenRightToLeftProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MirroredWhenRightToLeftProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFontIconSourceStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8c0e422f-8269-43b1-b95a-ef070e86770d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_GlyphProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontSizeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontFamilyProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontWeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsTextScaleFactorEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MirroredWhenRightToLeftProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IFontIconStatics = extern struct {
    vtable: *const VTable,
    pub fn getGlyphProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_GlyphProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontSizeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontSizeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontFamilyProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontFamilyProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontWeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontWeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFontIconStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b3be7bf6-1467-4086-bbcb-4e21d97a7b4d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_GlyphProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontSizeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontFamilyProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontWeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IFontIconStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getIsTextScaleFactorEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsTextScaleFactorEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFontIconStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e6080672-08f8-43d3-8790-4604290cbebd";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsTextScaleFactorEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IFontIconStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getMirroredWhenRightToLeftProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MirroredWhenRightToLeftProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFontIconStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a4528b17-b084-4bd5-aab4-feae9d3b5d26";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_MirroredWhenRightToLeftProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IFrame = extern struct {
    vtable: *const VTable,
    pub fn getCacheSize(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_CacheSize(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCacheSize(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_CacheSize(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCanGoBack(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_CanGoBack(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCanGoForward(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_CanGoForward(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCurrentSourcePageType(self: *@This()) core.HResult!TypeName {
        var _r: TypeName = undefined;
        const _c = self.vtable.get_CurrentSourcePageType(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSourcePageType(self: *@This()) core.HResult!TypeName {
        var _r: TypeName = undefined;
        const _c = self.vtable.get_SourcePageType(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSourcePageType(self: *@This(), value: TypeName) core.HResult!void {
        const _c = self.vtable.put_SourcePageType(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBackStackDepth(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_BackStackDepth(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addNavigated(self: *@This(), handler: *NavigatedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Navigated(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeNavigated(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Navigated(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addNavigating(self: *@This(), handler: *NavigatingCancelEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Navigating(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeNavigating(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Navigating(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addNavigationFailed(self: *@This(), handler: *NavigationFailedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_NavigationFailed(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeNavigationFailed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_NavigationFailed(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addNavigationStopped(self: *@This(), handler: *NavigationStoppedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_NavigationStopped(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeNavigationStopped(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_NavigationStopped(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn GoBack(self: *@This()) core.HResult!void {
        const _c = self.vtable.GoBack(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn GoForward(self: *@This()) core.HResult!void {
        const _c = self.vtable.GoForward(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Navigate(self: *@This(), sourcePageType: TypeName, parameter: *IInspectable) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.Navigate(@ptrCast(self), sourcePageType, parameter, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetNavigationState(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.GetNavigationState(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetNavigationState(self: *@This(), navigationState: HSTRING) core.HResult!void {
        const _c = self.vtable.SetNavigationState(@ptrCast(self), navigationState);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFrame";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "68ea500b-3fe9-4735-b6a0-e7601933b089";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CacheSize: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_CacheSize: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_CanGoBack: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_CanGoForward: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_CurrentSourcePageType: *const fn(self: *anyopaque, _r: *TypeName) callconv(.winapi) HRESULT,
        get_SourcePageType: *const fn(self: *anyopaque, _r: *TypeName) callconv(.winapi) HRESULT,
        put_SourcePageType: *const fn(self: *anyopaque, value: TypeName) callconv(.winapi) HRESULT,
        get_BackStackDepth: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        add_Navigated: *const fn(self: *anyopaque, handler: *NavigatedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Navigated: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_Navigating: *const fn(self: *anyopaque, handler: *NavigatingCancelEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Navigating: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_NavigationFailed: *const fn(self: *anyopaque, handler: *NavigationFailedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_NavigationFailed: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_NavigationStopped: *const fn(self: *anyopaque, handler: *NavigationStoppedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_NavigationStopped: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        GoBack: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        GoForward: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        Navigate: *const fn(self: *anyopaque, sourcePageType: TypeName, parameter: *IInspectable, _r: *bool) callconv(.winapi) HRESULT,
        GetNavigationState: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        SetNavigationState: *const fn(self: *anyopaque, navigationState: HSTRING) callconv(.winapi) HRESULT,
    };
};
pub const IFrame2 = extern struct {
    vtable: *const VTable,
    pub fn getBackStack(self: *@This()) core.HResult!*IVector(PageStackEntry) {
        var _r: *IVector(PageStackEntry) = undefined;
        const _c = self.vtable.get_BackStack(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getForwardStack(self: *@This()) core.HResult!*IVector(PageStackEntry) {
        var _r: *IVector(PageStackEntry) = undefined;
        const _c = self.vtable.get_ForwardStack(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn Navigate(self: *@This(), sourcePageType: TypeName, parameter: *IInspectable, infoOverride: *NavigationTransitionInfo) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.Navigate(@ptrCast(self), sourcePageType, parameter, infoOverride, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFrame2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3f367f87-9f5a-4b04-b818-b554c069597a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BackStack: *const fn(self: *anyopaque, _r: **IVector(PageStackEntry)) callconv(.winapi) HRESULT,
        get_ForwardStack: *const fn(self: *anyopaque, _r: **IVector(PageStackEntry)) callconv(.winapi) HRESULT,
        Navigate: *const fn(self: *anyopaque, sourcePageType: TypeName, parameter: *IInspectable, infoOverride: *NavigationTransitionInfo, _r: *bool) callconv(.winapi) HRESULT,
    };
};
pub const IFrame3 = extern struct {
    vtable: *const VTable,
    pub fn GoBack(self: *@This(), transitionInfoOverride: *NavigationTransitionInfo) core.HResult!void {
        const _c = self.vtable.GoBack(@ptrCast(self), transitionInfoOverride);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFrame3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "648a2b4d-53ca-4b5a-aa8e-3cc7440f4a67";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        GoBack: *const fn(self: *anyopaque, transitionInfoOverride: *NavigationTransitionInfo) callconv(.winapi) HRESULT,
    };
};
pub const IFrame4 = extern struct {
    vtable: *const VTable,
    pub fn SetNavigationState(self: *@This(), navigationState: HSTRING, suppressNavigate: bool) core.HResult!void {
        const _c = self.vtable.SetNavigationState(@ptrCast(self), navigationState, suppressNavigate);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFrame4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9b17c21a-bd2b-4a00-99eb-946be9618084";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        SetNavigationState: *const fn(self: *anyopaque, navigationState: HSTRING, suppressNavigate: bool) callconv(.winapi) HRESULT,
    };
};
pub const IFrame5 = extern struct {
    vtable: *const VTable,
    pub fn getIsNavigationStackEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsNavigationStackEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsNavigationStackEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsNavigationStackEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn NavigateToType(self: *@This(), sourcePageType: TypeName, parameter: *IInspectable, navigationOptions: *FrameNavigationOptions) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.NavigateToType(@ptrCast(self), sourcePageType, parameter, navigationOptions, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFrame5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "453fb92e-82b5-5f93-92ab-15341806c9da";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsNavigationStackEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsNavigationStackEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        NavigateToType: *const fn(self: *anyopaque, sourcePageType: TypeName, parameter: *IInspectable, navigationOptions: *FrameNavigationOptions, _r: *bool) callconv(.winapi) HRESULT,
    };
};
pub const IFrameFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*Frame {
        var _r: *Frame = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFrameFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "02ee93d4-448e-469e-9799-0a8a1f70f171";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **Frame) callconv(.winapi) HRESULT,
    };
};
pub const IFrameStatics = extern struct {
    vtable: *const VTable,
    pub fn getCacheSizeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CacheSizeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCanGoBackProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CanGoBackProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCanGoForwardProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CanGoForwardProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCurrentSourcePageTypeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CurrentSourcePageTypeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSourcePageTypeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SourcePageTypeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBackStackDepthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BackStackDepthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFrameStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d5acf0e9-d967-471b-8459-c8af4341511b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CacheSizeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CanGoBackProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CanGoForwardProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CurrentSourcePageTypeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SourcePageTypeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BackStackDepthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IFrameStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getBackStackProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BackStackProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getForwardStackProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ForwardStackProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFrameStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e4b5cdfe-42f0-4462-a1c1-5d259dd82a03";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BackStackProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ForwardStackProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IFrameStatics5 = extern struct {
    vtable: *const VTable,
    pub fn getIsNavigationStackEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsNavigationStackEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IFrameStatics5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "53c89b25-f0e0-58f1-a06d-441075914ff8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsNavigationStackEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IGrid = extern struct {
    vtable: *const VTable,
    pub fn getRowDefinitions(self: *@This()) core.HResult!*RowDefinitionCollection {
        var _r: *RowDefinitionCollection = undefined;
        const _c = self.vtable.get_RowDefinitions(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getColumnDefinitions(self: *@This()) core.HResult!*ColumnDefinitionCollection {
        var _r: *ColumnDefinitionCollection = undefined;
        const _c = self.vtable.get_ColumnDefinitions(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGrid";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "fd104460-2e15-4ba3-8b8f-fa693a4161e9";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_RowDefinitions: *const fn(self: *anyopaque, _r: **RowDefinitionCollection) callconv(.winapi) HRESULT,
        get_ColumnDefinitions: *const fn(self: *anyopaque, _r: **ColumnDefinitionCollection) callconv(.winapi) HRESULT,
    };
};
pub const IGrid2 = extern struct {
    vtable: *const VTable,
    pub fn getBorderBrush(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_BorderBrush(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_BorderBrush(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBorderThickness(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_BorderThickness(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBorderThickness(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_BorderThickness(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCornerRadius(self: *@This()) core.HResult!CornerRadius {
        var _r: CornerRadius = undefined;
        const _c = self.vtable.get_CornerRadius(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCornerRadius(self: *@This(), value: CornerRadius) core.HResult!void {
        const _c = self.vtable.put_CornerRadius(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPadding(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_Padding(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPadding(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_Padding(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGrid2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f76efa41-380e-45db-be87-9e1326ba4b57";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BorderBrush: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_BorderBrush: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_BorderThickness: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_BorderThickness: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
        get_CornerRadius: *const fn(self: *anyopaque, _r: *CornerRadius) callconv(.winapi) HRESULT,
        put_CornerRadius: *const fn(self: *anyopaque, value: CornerRadius) callconv(.winapi) HRESULT,
        get_Padding: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_Padding: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
    };
};
pub const IGrid3 = extern struct {
    vtable: *const VTable,
    pub fn getRowSpacing(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_RowSpacing(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putRowSpacing(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_RowSpacing(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getColumnSpacing(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_ColumnSpacing(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putColumnSpacing(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_ColumnSpacing(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGrid3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "12dfc5fc-2342-4dd2-9e7d-2090a171d1ef";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_RowSpacing: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_RowSpacing: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_ColumnSpacing: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_ColumnSpacing: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
    };
};
pub const IGrid4 = extern struct {
    vtable: *const VTable,
    pub fn getBackgroundSizing(self: *@This()) core.HResult!BackgroundSizing {
        var _r: BackgroundSizing = undefined;
        const _c = self.vtable.get_BackgroundSizing(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBackgroundSizing(self: *@This(), value: BackgroundSizing) core.HResult!void {
        const _c = self.vtable.put_BackgroundSizing(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGrid4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ed02d274-81f1-5ac2-a0c3-bbdaf5a3ffee";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BackgroundSizing: *const fn(self: *anyopaque, _r: *BackgroundSizing) callconv(.winapi) HRESULT,
        put_BackgroundSizing: *const fn(self: *anyopaque, value: BackgroundSizing) callconv(.winapi) HRESULT,
    };
};
pub const IGridFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*Grid {
        var _r: *Grid = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGridFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ae814041-c531-43b4-bf99-12f506f7b01c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **Grid) callconv(.winapi) HRESULT,
    };
};
pub const IGridStatics = extern struct {
    vtable: *const VTable,
    pub fn getRowProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_RowProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetRow(self: *@This(), element: *FrameworkElement) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.GetRow(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetRow(self: *@This(), element: *FrameworkElement, value: i32) core.HResult!void {
        const _c = self.vtable.SetRow(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getColumnProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ColumnProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetColumn(self: *@This(), element: *FrameworkElement) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.GetColumn(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetColumn(self: *@This(), element: *FrameworkElement, value: i32) core.HResult!void {
        const _c = self.vtable.SetColumn(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getRowSpanProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_RowSpanProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetRowSpan(self: *@This(), element: *FrameworkElement) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.GetRowSpan(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetRowSpan(self: *@This(), element: *FrameworkElement, value: i32) core.HResult!void {
        const _c = self.vtable.SetRowSpan(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getColumnSpanProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ColumnSpanProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetColumnSpan(self: *@This(), element: *FrameworkElement) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.GetColumnSpan(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetColumnSpan(self: *@This(), element: *FrameworkElement, value: i32) core.HResult!void {
        const _c = self.vtable.SetColumnSpan(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGridStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "64fe2e9f-f951-42b6-a9ce-bb179af11595";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_RowProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetRow: *const fn(self: *anyopaque, element: *FrameworkElement, _r: *i32) callconv(.winapi) HRESULT,
        SetRow: *const fn(self: *anyopaque, element: *FrameworkElement, value: i32) callconv(.winapi) HRESULT,
        get_ColumnProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetColumn: *const fn(self: *anyopaque, element: *FrameworkElement, _r: *i32) callconv(.winapi) HRESULT,
        SetColumn: *const fn(self: *anyopaque, element: *FrameworkElement, value: i32) callconv(.winapi) HRESULT,
        get_RowSpanProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetRowSpan: *const fn(self: *anyopaque, element: *FrameworkElement, _r: *i32) callconv(.winapi) HRESULT,
        SetRowSpan: *const fn(self: *anyopaque, element: *FrameworkElement, value: i32) callconv(.winapi) HRESULT,
        get_ColumnSpanProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetColumnSpan: *const fn(self: *anyopaque, element: *FrameworkElement, _r: *i32) callconv(.winapi) HRESULT,
        SetColumnSpan: *const fn(self: *anyopaque, element: *FrameworkElement, value: i32) callconv(.winapi) HRESULT,
    };
};
pub const IGridStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getBorderBrushProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BorderBrushProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBorderThicknessProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BorderThicknessProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCornerRadiusProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CornerRadiusProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPaddingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PaddingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGridStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "2d666658-58b6-4a1b-841b-875ba93b5d6a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BorderBrushProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BorderThicknessProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CornerRadiusProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PaddingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IGridStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getRowSpacingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_RowSpacingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getColumnSpacingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ColumnSpacingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGridStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c3fba437-5a0c-407a-9621-79545386d811";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_RowSpacingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ColumnSpacingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IGridStatics4 = extern struct {
    vtable: *const VTable,
    pub fn getBackgroundSizingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BackgroundSizingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGridStatics4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "691af349-1f63-57aa-8726-9cdcc1b14c02";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BackgroundSizingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IGridView = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGridView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "026ae934-b67e-4d80-8f72-8aa64b4d827b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IGridViewFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*GridView {
        var _r: *GridView = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGridViewFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d9bcca89-09f9-4c6e-a83e-f199146f0e7d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **GridView) callconv(.winapi) HRESULT,
    };
};
pub const IGridViewHeaderItem = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGridViewHeaderItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "72d75d7e-5dc3-4ffc-9b1c-939b5c37161c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IGridViewHeaderItemFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*GridViewHeaderItem {
        var _r: *GridViewHeaderItem = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGridViewHeaderItemFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "36e0c96e-b56a-4b3b-8bac-7aef5e6f9945";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **GridViewHeaderItem) callconv(.winapi) HRESULT,
    };
};
pub const IGridViewItem = extern struct {
    vtable: *const VTable,
    pub fn getTemplateSettings(self: *@This()) core.HResult!*GridViewItemTemplateSettings {
        var _r: *GridViewItemTemplateSettings = undefined;
        const _c = self.vtable.get_TemplateSettings(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGridViewItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "7d9901f1-e7c1-4e83-b470-c9d6d7bda9f5";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TemplateSettings: *const fn(self: *anyopaque, _r: **GridViewItemTemplateSettings) callconv(.winapi) HRESULT,
    };
};
pub const IGridViewItemFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*GridViewItem {
        var _r: *GridViewItem = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGridViewItemFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "229b00af-3fa6-43e9-979d-07ea0d6280dc";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **GridViewItem) callconv(.winapi) HRESULT,
    };
};
pub const IGroupItem = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGroupItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4ae8d5d1-7228-4a16-a61f-88c0e8f45c76";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IGroupItemFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*GroupItem {
        var _r: *GroupItem = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGroupItemFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d9a1d53e-b1e0-4319-9808-7a9e887e13b0";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **GroupItem) callconv(.winapi) HRESULT,
    };
};
pub const IGroupStyle = extern struct {
    vtable: *const VTable,
    pub fn getPanel(self: *@This()) core.HResult!*ItemsPanelTemplate {
        var _r: *ItemsPanelTemplate = undefined;
        const _c = self.vtable.get_Panel(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPanel(self: *@This(), value: *ItemsPanelTemplate) core.HResult!void {
        const _c = self.vtable.put_Panel(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getContainerStyle(self: *@This()) core.HResult!*Style {
        var _r: *Style = undefined;
        const _c = self.vtable.get_ContainerStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putContainerStyle(self: *@This(), value: *Style) core.HResult!void {
        const _c = self.vtable.put_ContainerStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getContainerStyleSelector(self: *@This()) core.HResult!*StyleSelector {
        var _r: *StyleSelector = undefined;
        const _c = self.vtable.get_ContainerStyleSelector(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putContainerStyleSelector(self: *@This(), value: *StyleSelector) core.HResult!void {
        const _c = self.vtable.put_ContainerStyleSelector(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_HeaderTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_HeaderTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeaderTemplateSelector(self: *@This()) core.HResult!*DataTemplateSelector {
        var _r: *DataTemplateSelector = undefined;
        const _c = self.vtable.get_HeaderTemplateSelector(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderTemplateSelector(self: *@This(), value: *DataTemplateSelector) core.HResult!void {
        const _c = self.vtable.put_HeaderTemplateSelector(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHidesIfEmpty(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_HidesIfEmpty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHidesIfEmpty(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_HidesIfEmpty(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGroupStyle";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "71ca300b-b89e-4184-b0df-a9e95447de8d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Panel: *const fn(self: *anyopaque, _r: **ItemsPanelTemplate) callconv(.winapi) HRESULT,
        put_Panel: *const fn(self: *anyopaque, value: *ItemsPanelTemplate) callconv(.winapi) HRESULT,
        get_ContainerStyle: *const fn(self: *anyopaque, _r: **Style) callconv(.winapi) HRESULT,
        put_ContainerStyle: *const fn(self: *anyopaque, value: *Style) callconv(.winapi) HRESULT,
        get_ContainerStyleSelector: *const fn(self: *anyopaque, _r: **StyleSelector) callconv(.winapi) HRESULT,
        put_ContainerStyleSelector: *const fn(self: *anyopaque, value: *StyleSelector) callconv(.winapi) HRESULT,
        get_HeaderTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_HeaderTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_HeaderTemplateSelector: *const fn(self: *anyopaque, _r: **DataTemplateSelector) callconv(.winapi) HRESULT,
        put_HeaderTemplateSelector: *const fn(self: *anyopaque, value: *DataTemplateSelector) callconv(.winapi) HRESULT,
        get_HidesIfEmpty: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_HidesIfEmpty: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IGroupStyle2 = extern struct {
    vtable: *const VTable,
    pub fn getHeaderContainerStyle(self: *@This()) core.HResult!*Style {
        var _r: *Style = undefined;
        const _c = self.vtable.get_HeaderContainerStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderContainerStyle(self: *@This(), value: *Style) core.HResult!void {
        const _c = self.vtable.put_HeaderContainerStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGroupStyle2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "69f90679-3a11-4fe7-b4df-2a0139d4018b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HeaderContainerStyle: *const fn(self: *anyopaque, _r: **Style) callconv(.winapi) HRESULT,
        put_HeaderContainerStyle: *const fn(self: *anyopaque, value: *Style) callconv(.winapi) HRESULT,
    };
};
pub const IGroupStyleFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*GroupStyle {
        var _r: *GroupStyle = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGroupStyleFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "56ff664f-e2d7-4f49-803d-c727cdf9372d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **GroupStyle) callconv(.winapi) HRESULT,
    };
};
pub const IGroupStyleSelector = extern struct {
    vtable: *const VTable,
    pub fn SelectGroupStyle(self: *@This(), group: *IInspectable, level: u32) core.HResult!*GroupStyle {
        var _r: *GroupStyle = undefined;
        const _c = self.vtable.SelectGroupStyle(@ptrCast(self), group, level, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGroupStyleSelector";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6dda119e-9a74-478f-a339-5bb52de6c51e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        SelectGroupStyle: *const fn(self: *anyopaque, group: *IInspectable, level: u32, _r: **GroupStyle) callconv(.winapi) HRESULT,
    };
};
pub const IGroupStyleSelectorFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*GroupStyleSelector {
        var _r: *GroupStyleSelector = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGroupStyleSelectorFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "bf570d33-b2f6-481f-a450-c80c291fb22d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **GroupStyleSelector) callconv(.winapi) HRESULT,
    };
};
pub const IGroupStyleSelectorOverrides = extern struct {
    vtable: *const VTable,
    pub fn SelectGroupStyleCore(self: *@This(), group: *IInspectable, level: u32) core.HResult!*GroupStyle {
        var _r: *GroupStyle = undefined;
        const _c = self.vtable.SelectGroupStyleCore(@ptrCast(self), group, level, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IGroupStyleSelectorOverrides";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f691cab2-77ad-4d3d-a51c-8ef9c3836456";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        SelectGroupStyleCore: *const fn(self: *anyopaque, group: *IInspectable, level: u32, _r: **GroupStyle) callconv(.winapi) HRESULT,
    };
};
pub const IHandwritingPanelClosedEventArgs = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IHandwritingPanelClosedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4fb91c73-192d-4dd2-a1a2-80ed01125876";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IHandwritingPanelOpenedEventArgs = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IHandwritingPanelOpenedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "fc15b16d-9f15-47b0-b97a-94a68cc61345";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IHandwritingView = extern struct {
    vtable: *const VTable,
    pub fn getPlacementTarget(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_PlacementTarget(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPlacementTarget(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_PlacementTarget(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPlacementAlignment(self: *@This()) core.HResult!HandwritingPanelPlacementAlignment {
        var _r: HandwritingPanelPlacementAlignment = undefined;
        const _c = self.vtable.get_PlacementAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPlacementAlignment(self: *@This(), value: HandwritingPanelPlacementAlignment) core.HResult!void {
        const _c = self.vtable.put_PlacementAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsOpen(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsOpen(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getAreCandidatesEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_AreCandidatesEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putAreCandidatesEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_AreCandidatesEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addOpened(self: *@This(), handler: *TypedEventHandler(HandwritingView,HandwritingPanelOpenedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Opened(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeOpened(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Opened(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addClosed(self: *@This(), handler: *TypedEventHandler(HandwritingView,HandwritingPanelClosedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Closed(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeClosed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Closed(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn TryClose(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.TryClose(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn TryOpen(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.TryOpen(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IHandwritingView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c44204a7-31e0-44bc-a38b-4bee64ecd99f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PlacementTarget: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_PlacementTarget: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
        get_PlacementAlignment: *const fn(self: *anyopaque, _r: *HandwritingPanelPlacementAlignment) callconv(.winapi) HRESULT,
        put_PlacementAlignment: *const fn(self: *anyopaque, value: HandwritingPanelPlacementAlignment) callconv(.winapi) HRESULT,
        get_IsOpen: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_AreCandidatesEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_AreCandidatesEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        add_Opened: *const fn(self: *anyopaque, handler: *TypedEventHandler(HandwritingView,HandwritingPanelOpenedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Opened: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_Closed: *const fn(self: *anyopaque, handler: *TypedEventHandler(HandwritingView,HandwritingPanelClosedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Closed: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        TryClose: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        TryOpen: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
    };
};
pub const IHandwritingView2 = extern struct {
    vtable: *const VTable,
    pub fn getIsSwitchToKeyboardEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsSwitchToKeyboardEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsSwitchToKeyboardEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsSwitchToKeyboardEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsCommandBarOpen(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsCommandBarOpen(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsCommandBarOpen(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsCommandBarOpen(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getInputDeviceTypes(self: *@This()) core.HResult!CoreInputDeviceTypes {
        var _r: CoreInputDeviceTypes = undefined;
        const _c = self.vtable.get_InputDeviceTypes(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putInputDeviceTypes(self: *@This(), value: CoreInputDeviceTypes) core.HResult!void {
        const _c = self.vtable.put_InputDeviceTypes(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addCandidatesChanged(self: *@This(), handler: *TypedEventHandler(HandwritingView,HandwritingViewCandidatesChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_CandidatesChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeCandidatesChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_CandidatesChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addTextSubmitted(self: *@This(), handler: *TypedEventHandler(HandwritingView,HandwritingViewTextSubmittedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_TextSubmitted(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeTextSubmitted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_TextSubmitted(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn GetCandidates(self: *@This(), candidatesSessionId: u32) core.HResult!*IVectorView(HSTRING) {
        var _r: *IVectorView(HSTRING) = undefined;
        const _c = self.vtable.GetCandidates(@ptrCast(self), candidatesSessionId, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SelectCandidate(self: *@This(), candidatesSessionId: u32, selectedCandidateIndex: u32) core.HResult!void {
        const _c = self.vtable.SelectCandidate(@ptrCast(self), candidatesSessionId, selectedCandidateIndex);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IHandwritingView2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4bcf991b-0de1-5c9e-8970-37b9878fe171";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsSwitchToKeyboardEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsSwitchToKeyboardEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsCommandBarOpen: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsCommandBarOpen: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_InputDeviceTypes: *const fn(self: *anyopaque, _r: *CoreInputDeviceTypes) callconv(.winapi) HRESULT,
        put_InputDeviceTypes: *const fn(self: *anyopaque, value: CoreInputDeviceTypes) callconv(.winapi) HRESULT,
        add_CandidatesChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(HandwritingView,HandwritingViewCandidatesChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_CandidatesChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_TextSubmitted: *const fn(self: *anyopaque, handler: *TypedEventHandler(HandwritingView,HandwritingViewTextSubmittedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_TextSubmitted: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        GetCandidates: *const fn(self: *anyopaque, candidatesSessionId: u32, _r: **IVectorView(HSTRING)) callconv(.winapi) HRESULT,
        SelectCandidate: *const fn(self: *anyopaque, candidatesSessionId: u32, selectedCandidateIndex: u32) callconv(.winapi) HRESULT,
    };
};
pub const IHandwritingViewCandidatesChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getCandidatesSessionId(self: *@This()) core.HResult!u32 {
        var _r: u32 = undefined;
        const _c = self.vtable.get_CandidatesSessionId(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IHandwritingViewCandidatesChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6f5f63d8-56b1-56c5-a416-c19c16bf7884";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CandidatesSessionId: *const fn(self: *anyopaque, _r: *u32) callconv(.winapi) HRESULT,
    };
};
pub const IHandwritingViewFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*HandwritingView {
        var _r: *HandwritingView = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IHandwritingViewFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e00c873f-0012-475c-890c-97ae308642de";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **HandwritingView) callconv(.winapi) HRESULT,
    };
};
pub const IHandwritingViewStatics = extern struct {
    vtable: *const VTable,
    pub fn getPlacementTargetProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlacementTargetProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPlacementAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlacementAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsOpenProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsOpenProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getAreCandidatesEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AreCandidatesEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IHandwritingViewStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "bb7ceed0-cc5f-4004-b8c8-142e195f0618";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PlacementTargetProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PlacementAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsOpenProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_AreCandidatesEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IHandwritingViewStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getIsSwitchToKeyboardEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsSwitchToKeyboardEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsCommandBarOpenProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsCommandBarOpenProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IHandwritingViewStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "2cd052e4-d703-5183-a1be-7e285df978d9";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsSwitchToKeyboardEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsCommandBarOpenProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IHandwritingViewTextSubmittedEventArgs = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IHandwritingViewTextSubmittedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "55ac0f47-f5e4-55da-b8a3-d418b7564291";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IHub = extern struct {
    vtable: *const VTable,
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Header(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Header(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_HeaderTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_HeaderTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOrientation(self: *@This()) core.HResult!Orientation {
        var _r: Orientation = undefined;
        const _c = self.vtable.get_Orientation(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOrientation(self: *@This(), value: Orientation) core.HResult!void {
        const _c = self.vtable.put_Orientation(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDefaultSectionIndex(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_DefaultSectionIndex(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDefaultSectionIndex(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_DefaultSectionIndex(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSections(self: *@This()) core.HResult!*IVector(HubSection) {
        var _r: *IVector(HubSection) = undefined;
        const _c = self.vtable.get_Sections(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSectionsInView(self: *@This()) core.HResult!*IVector(HubSection) {
        var _r: *IVector(HubSection) = undefined;
        const _c = self.vtable.get_SectionsInView(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSectionHeaders(self: *@This()) core.HResult!*IObservableVector(IInspectable) {
        var _r: *IObservableVector(IInspectable) = undefined;
        const _c = self.vtable.get_SectionHeaders(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addSectionHeaderClick(self: *@This(), handler: *HubSectionHeaderClickEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_SectionHeaderClick(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeSectionHeaderClick(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_SectionHeaderClick(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addSectionsInViewChanged(self: *@This(), handler: *SectionsInViewChangedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_SectionsInViewChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeSectionsInViewChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_SectionsInViewChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn ScrollToSection(self: *@This(), section: *HubSection) core.HResult!void {
        const _c = self.vtable.ScrollToSection(@ptrCast(self), section);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IHub";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ae692e82-7314-4f51-ab11-2af1ed4a19f8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Header: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Header: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_HeaderTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_HeaderTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_Orientation: *const fn(self: *anyopaque, _r: *Orientation) callconv(.winapi) HRESULT,
        put_Orientation: *const fn(self: *anyopaque, value: Orientation) callconv(.winapi) HRESULT,
        get_DefaultSectionIndex: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_DefaultSectionIndex: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_Sections: *const fn(self: *anyopaque, _r: **IVector(HubSection)) callconv(.winapi) HRESULT,
        get_SectionsInView: *const fn(self: *anyopaque, _r: **IVector(HubSection)) callconv(.winapi) HRESULT,
        get_SectionHeaders: *const fn(self: *anyopaque, _r: **IObservableVector(IInspectable)) callconv(.winapi) HRESULT,
        add_SectionHeaderClick: *const fn(self: *anyopaque, handler: *HubSectionHeaderClickEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_SectionHeaderClick: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_SectionsInViewChanged: *const fn(self: *anyopaque, handler: *SectionsInViewChangedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_SectionsInViewChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        ScrollToSection: *const fn(self: *anyopaque, section: *HubSection) callconv(.winapi) HRESULT,
    };
};
pub const IHubFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*Hub {
        var _r: *Hub = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IHubFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "dca6b2ba-c6f5-4961-9953-c51873db5424";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **Hub) callconv(.winapi) HRESULT,
    };
};
pub const IHubSection = extern struct {
    vtable: *const VTable,
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Header(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Header(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_HeaderTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_HeaderTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getContentTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_ContentTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putContentTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_ContentTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsHeaderInteractive(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsHeaderInteractive(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsHeaderInteractive(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsHeaderInteractive(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IHubSection";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a4e66cb7-7fdd-4fe0-ab49-c246639dccf9";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Header: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Header: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_HeaderTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_HeaderTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_ContentTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_ContentTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_IsHeaderInteractive: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsHeaderInteractive: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IHubSectionFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*HubSection {
        var _r: *HubSection = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IHubSectionFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "fff55fa2-ece4-4bba-aa3b-9804aef47883";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **HubSection) callconv(.winapi) HRESULT,
    };
};
pub const IHubSectionHeaderClickEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getSection(self: *@This()) core.HResult!*HubSection {
        var _r: *HubSection = undefined;
        const _c = self.vtable.get_Section(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IHubSectionHeaderClickEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e1c5ef04-1edd-4112-aeeb-996c96400698";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Section: *const fn(self: *anyopaque, _r: **HubSection) callconv(.winapi) HRESULT,
    };
};
pub const IHubSectionStatics = extern struct {
    vtable: *const VTable,
    pub fn getHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getContentTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ContentTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsHeaderInteractiveProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsHeaderInteractiveProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IHubSectionStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "12d2d85a-ea27-42d1-998b-61e52aed842b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ContentTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsHeaderInteractiveProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IHubStatics = extern struct {
    vtable: *const VTable,
    pub fn getHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOrientationProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OrientationProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDefaultSectionIndexProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DefaultSectionIndexProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSemanticZoomOwnerProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SemanticZoomOwnerProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsActiveViewProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsActiveViewProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsZoomedInViewProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsZoomedInViewProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IHubStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0e6fa034-ad3c-4f32-b701-e24fab562028";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OrientationProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DefaultSectionIndexProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SemanticZoomOwnerProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsActiveViewProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsZoomedInViewProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IHyperlinkButton = extern struct {
    vtable: *const VTable,
    pub fn getNavigateUri(self: *@This()) core.HResult!*Uri {
        var _r: *Uri = undefined;
        const _c = self.vtable.get_NavigateUri(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putNavigateUri(self: *@This(), value: *Uri) core.HResult!void {
        const _c = self.vtable.put_NavigateUri(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IHyperlinkButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ccebaca3-3b5c-4f4c-9bfd-86887bc79772";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_NavigateUri: *const fn(self: *anyopaque, _r: **Uri) callconv(.winapi) HRESULT,
        put_NavigateUri: *const fn(self: *anyopaque, value: *Uri) callconv(.winapi) HRESULT,
    };
};
pub const IHyperlinkButtonFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*HyperlinkButton {
        var _r: *HyperlinkButton = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IHyperlinkButtonFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "43521bad-4e97-4da9-a64d-935dfd8cedf2";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **HyperlinkButton) callconv(.winapi) HRESULT,
    };
};
pub const IHyperlinkButtonStatics = extern struct {
    vtable: *const VTable,
    pub fn getNavigateUriProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_NavigateUriProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IHyperlinkButtonStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "fbaeb5c7-cdb7-4263-b7d6-3c0d2904ed98";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_NavigateUriProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IIconElement = extern struct {
    vtable: *const VTable,
    pub fn getForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_Foreground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_Foreground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IIconElement";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9af0803b-d04c-467a-bbd5-9b81f02d9a56";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Foreground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_Foreground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
    };
};
pub const IIconElementFactory = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IIconElementFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "cf37a562-0424-43c7-8bea-720fba973ef1";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IIconElementStatics = extern struct {
    vtable: *const VTable,
    pub fn getForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IIconElementStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "be19a623-77cf-472f-82ea-047801d12012";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IIconSource = extern struct {
    vtable: *const VTable,
    pub fn getForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_Foreground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_Foreground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IIconSource";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "92ec8d55-45eb-47a4-863c-91b224044f9b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Foreground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_Foreground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
    };
};
pub const IIconSourceElement = extern struct {
    vtable: *const VTable,
    pub fn getIconSource(self: *@This()) core.HResult!*IconSource {
        var _r: *IconSource = undefined;
        const _c = self.vtable.get_IconSource(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIconSource(self: *@This(), value: *IconSource) core.HResult!void {
        const _c = self.vtable.put_IconSource(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IIconSourceElement";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d7a64502-ddda-55cd-b4c9-e79abc8b0ea4";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IconSource: *const fn(self: *anyopaque, _r: **IconSource) callconv(.winapi) HRESULT,
        put_IconSource: *const fn(self: *anyopaque, value: *IconSource) callconv(.winapi) HRESULT,
    };
};
pub const IIconSourceElementFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*IconSourceElement {
        var _r: *IconSourceElement = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IIconSourceElementFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "26b59fab-2092-5b95-b59e-f27f210689e7";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **IconSourceElement) callconv(.winapi) HRESULT,
    };
};
pub const IIconSourceElementStatics = extern struct {
    vtable: *const VTable,
    pub fn getIconSourceProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IconSourceProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IIconSourceElementStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f37cfd45-f3d8-50ff-a1b8-0fba4ae61d79";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IconSourceProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IIconSourceFactory = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IIconSourceFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4d117cf1-1fd6-49d7-b483-02ec3de997d6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IIconSourceStatics = extern struct {
    vtable: *const VTable,
    pub fn getForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IIconSourceStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1d389dbe-1cd3-4f4f-83b0-55dc6387685b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IImage = extern struct {
    vtable: *const VTable,
    pub fn getSource(self: *@This()) core.HResult!*ImageSource {
        var _r: *ImageSource = undefined;
        const _c = self.vtable.get_Source(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSource(self: *@This(), value: *ImageSource) core.HResult!void {
        const _c = self.vtable.put_Source(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getStretch(self: *@This()) core.HResult!Stretch {
        var _r: Stretch = undefined;
        const _c = self.vtable.get_Stretch(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putStretch(self: *@This(), value: Stretch) core.HResult!void {
        const _c = self.vtable.put_Stretch(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getNineGrid(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_NineGrid(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putNineGrid(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_NineGrid(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPlayToSource(self: *@This()) core.HResult!*PlayToSource {
        var _r: *PlayToSource = undefined;
        const _c = self.vtable.get_PlayToSource(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addImageFailed(self: *@This(), handler: *ExceptionRoutedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ImageFailed(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeImageFailed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ImageFailed(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addImageOpened(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ImageOpened(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeImageOpened(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ImageOpened(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IImage";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "495b7402-9af3-4e50-aa90-03388f3086d2";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Source: *const fn(self: *anyopaque, _r: **ImageSource) callconv(.winapi) HRESULT,
        put_Source: *const fn(self: *anyopaque, value: *ImageSource) callconv(.winapi) HRESULT,
        get_Stretch: *const fn(self: *anyopaque, _r: *Stretch) callconv(.winapi) HRESULT,
        put_Stretch: *const fn(self: *anyopaque, value: Stretch) callconv(.winapi) HRESULT,
        get_NineGrid: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_NineGrid: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
        get_PlayToSource: *const fn(self: *anyopaque, _r: **PlayToSource) callconv(.winapi) HRESULT,
        add_ImageFailed: *const fn(self: *anyopaque, handler: *ExceptionRoutedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ImageFailed: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_ImageOpened: *const fn(self: *anyopaque, handler: *RoutedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ImageOpened: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IImage2 = extern struct {
    vtable: *const VTable,
    pub fn GetAsCastingSource(self: *@This()) core.HResult!*CastingSource {
        var _r: *CastingSource = undefined;
        const _c = self.vtable.GetAsCastingSource(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IImage2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f445119e-881f-48bb-873a-64417ca4f002";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        GetAsCastingSource: *const fn(self: *anyopaque, _r: **CastingSource) callconv(.winapi) HRESULT,
    };
};
pub const IImage3 = extern struct {
    vtable: *const VTable,
    pub fn GetAlphaMask(self: *@This()) core.HResult!*CompositionBrush {
        var _r: *CompositionBrush = undefined;
        const _c = self.vtable.GetAlphaMask(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IImage3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "06ebe792-47c2-4d92-a488-8cd685d06aca";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        GetAlphaMask: *const fn(self: *anyopaque, _r: **CompositionBrush) callconv(.winapi) HRESULT,
    };
};
pub const IImageStatics = extern struct {
    vtable: *const VTable,
    pub fn getSourceProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SourceProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getStretchProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_StretchProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getNineGridProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_NineGridProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPlayToSourceProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlayToSourceProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IImageStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "89903772-c336-43d1-9d51-c3bbd5d5d691";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SourceProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_StretchProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_NineGridProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PlayToSourceProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IInkCanvas = extern struct {
    vtable: *const VTable,
    pub fn getInkPresenter(self: *@This()) core.HResult!*InkPresenter {
        var _r: *InkPresenter = undefined;
        const _c = self.vtable.get_InkPresenter(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkCanvas";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "29443c28-8e48-4fc8-a473-35b0ba12acea";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_InkPresenter: *const fn(self: *anyopaque, _r: **InkPresenter) callconv(.winapi) HRESULT,
    };
};
pub const IInkCanvasFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkCanvas {
        var _r: *InkCanvas = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkCanvasFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "924ac2de-ab04-48f0-9653-e0f2da4dbf1a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **InkCanvas) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbar = extern struct {
    vtable: *const VTable,
    pub fn getInitialControls(self: *@This()) core.HResult!InkToolbarInitialControls {
        var _r: InkToolbarInitialControls = undefined;
        const _c = self.vtable.get_InitialControls(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putInitialControls(self: *@This(), value: InkToolbarInitialControls) core.HResult!void {
        const _c = self.vtable.put_InitialControls(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getChildren(self: *@This()) core.HResult!*DependencyObjectCollection {
        var _r: *DependencyObjectCollection = undefined;
        const _c = self.vtable.get_Children(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getActiveTool(self: *@This()) core.HResult!*InkToolbarToolButton {
        var _r: *InkToolbarToolButton = undefined;
        const _c = self.vtable.get_ActiveTool(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putActiveTool(self: *@This(), value: *InkToolbarToolButton) core.HResult!void {
        const _c = self.vtable.put_ActiveTool(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getInkDrawingAttributes(self: *@This()) core.HResult!*InkDrawingAttributes {
        var _r: *InkDrawingAttributes = undefined;
        const _c = self.vtable.get_InkDrawingAttributes(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsRulerButtonChecked(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsRulerButtonChecked(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsRulerButtonChecked(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsRulerButtonChecked(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTargetInkCanvas(self: *@This()) core.HResult!*InkCanvas {
        var _r: *InkCanvas = undefined;
        const _c = self.vtable.get_TargetInkCanvas(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTargetInkCanvas(self: *@This(), value: *InkCanvas) core.HResult!void {
        const _c = self.vtable.put_TargetInkCanvas(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addActiveToolChanged(self: *@This(), handler: *TypedEventHandler(InkToolbar,IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ActiveToolChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeActiveToolChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ActiveToolChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addInkDrawingAttributesChanged(self: *@This(), handler: *TypedEventHandler(InkToolbar,IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_InkDrawingAttributesChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeInkDrawingAttributesChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_InkDrawingAttributesChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addEraseAllClicked(self: *@This(), handler: *TypedEventHandler(InkToolbar,IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_EraseAllClicked(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeEraseAllClicked(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_EraseAllClicked(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addIsRulerButtonCheckedChanged(self: *@This(), handler: *TypedEventHandler(InkToolbar,IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_IsRulerButtonCheckedChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeIsRulerButtonCheckedChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_IsRulerButtonCheckedChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn GetToolButton(self: *@This(), tool: InkToolbarTool) core.HResult!*InkToolbarToolButton {
        var _r: *InkToolbarToolButton = undefined;
        const _c = self.vtable.GetToolButton(@ptrCast(self), tool, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetToggleButton(self: *@This(), tool: InkToolbarToggle) core.HResult!*InkToolbarToggleButton {
        var _r: *InkToolbarToggleButton = undefined;
        const _c = self.vtable.GetToggleButton(@ptrCast(self), tool, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbar";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3ddd0cca-51f0-486f-a03e-4ee13dc12bcb";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_InitialControls: *const fn(self: *anyopaque, _r: *InkToolbarInitialControls) callconv(.winapi) HRESULT,
        put_InitialControls: *const fn(self: *anyopaque, value: InkToolbarInitialControls) callconv(.winapi) HRESULT,
        get_Children: *const fn(self: *anyopaque, _r: **DependencyObjectCollection) callconv(.winapi) HRESULT,
        get_ActiveTool: *const fn(self: *anyopaque, _r: **InkToolbarToolButton) callconv(.winapi) HRESULT,
        put_ActiveTool: *const fn(self: *anyopaque, value: *InkToolbarToolButton) callconv(.winapi) HRESULT,
        get_InkDrawingAttributes: *const fn(self: *anyopaque, _r: **InkDrawingAttributes) callconv(.winapi) HRESULT,
        get_IsRulerButtonChecked: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsRulerButtonChecked: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_TargetInkCanvas: *const fn(self: *anyopaque, _r: **InkCanvas) callconv(.winapi) HRESULT,
        put_TargetInkCanvas: *const fn(self: *anyopaque, value: *InkCanvas) callconv(.winapi) HRESULT,
        add_ActiveToolChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(InkToolbar,IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ActiveToolChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_InkDrawingAttributesChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(InkToolbar,IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_InkDrawingAttributesChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_EraseAllClicked: *const fn(self: *anyopaque, handler: *TypedEventHandler(InkToolbar,IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_EraseAllClicked: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_IsRulerButtonCheckedChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(InkToolbar,IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_IsRulerButtonCheckedChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        GetToolButton: *const fn(self: *anyopaque, tool: InkToolbarTool, _r: **InkToolbarToolButton) callconv(.winapi) HRESULT,
        GetToggleButton: *const fn(self: *anyopaque, tool: InkToolbarToggle, _r: **InkToolbarToggleButton) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbar2 = extern struct {
    vtable: *const VTable,
    pub fn getIsStencilButtonChecked(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsStencilButtonChecked(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsStencilButtonChecked(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsStencilButtonChecked(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getButtonFlyoutPlacement(self: *@This()) core.HResult!InkToolbarButtonFlyoutPlacement {
        var _r: InkToolbarButtonFlyoutPlacement = undefined;
        const _c = self.vtable.get_ButtonFlyoutPlacement(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putButtonFlyoutPlacement(self: *@This(), value: InkToolbarButtonFlyoutPlacement) core.HResult!void {
        const _c = self.vtable.put_ButtonFlyoutPlacement(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOrientation(self: *@This()) core.HResult!Orientation {
        var _r: Orientation = undefined;
        const _c = self.vtable.get_Orientation(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOrientation(self: *@This(), value: Orientation) core.HResult!void {
        const _c = self.vtable.put_Orientation(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addIsStencilButtonCheckedChanged(self: *@This(), handler: *TypedEventHandler(InkToolbar,InkToolbarIsStencilButtonCheckedChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_IsStencilButtonCheckedChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeIsStencilButtonCheckedChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_IsStencilButtonCheckedChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn GetMenuButton(self: *@This(), menu: InkToolbarMenuKind) core.HResult!*InkToolbarMenuButton {
        var _r: *InkToolbarMenuButton = undefined;
        const _c = self.vtable.GetMenuButton(@ptrCast(self), menu, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbar2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "86f0c111-b484-454a-ae78-1d25a33d1c67";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsStencilButtonChecked: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsStencilButtonChecked: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_ButtonFlyoutPlacement: *const fn(self: *anyopaque, _r: *InkToolbarButtonFlyoutPlacement) callconv(.winapi) HRESULT,
        put_ButtonFlyoutPlacement: *const fn(self: *anyopaque, value: InkToolbarButtonFlyoutPlacement) callconv(.winapi) HRESULT,
        get_Orientation: *const fn(self: *anyopaque, _r: *Orientation) callconv(.winapi) HRESULT,
        put_Orientation: *const fn(self: *anyopaque, value: Orientation) callconv(.winapi) HRESULT,
        add_IsStencilButtonCheckedChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(InkToolbar,InkToolbarIsStencilButtonCheckedChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_IsStencilButtonCheckedChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        GetMenuButton: *const fn(self: *anyopaque, menu: InkToolbarMenuKind, _r: **InkToolbarMenuButton) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbar3 = extern struct {
    vtable: *const VTable,
    pub fn getTargetInkPresenter(self: *@This()) core.HResult!*InkPresenter {
        var _r: *InkPresenter = undefined;
        const _c = self.vtable.get_TargetInkPresenter(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTargetInkPresenter(self: *@This(), value: *InkPresenter) core.HResult!void {
        const _c = self.vtable.put_TargetInkPresenter(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbar3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a8a6def0-7aa8-5326-b7c4-88ae25013362";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TargetInkPresenter: *const fn(self: *anyopaque, _r: **InkPresenter) callconv(.winapi) HRESULT,
        put_TargetInkPresenter: *const fn(self: *anyopaque, value: *InkPresenter) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarBallpointPenButton = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarBallpointPenButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "158329f8-1e99-3acc-910f-9da2d872ae12";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarBallpointPenButtonFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarBallpointPenButton {
        var _r: *InkToolbarBallpointPenButton = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarBallpointPenButtonFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "2f0bd3e4-d754-4255-8ec4-00cd101296ab";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **InkToolbarBallpointPenButton) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarCustomPen = extern struct {
    vtable: *const VTable,
    pub fn CreateInkDrawingAttributes(self: *@This(), brush: *Brush, strokeWidth: f64) core.HResult!*InkDrawingAttributes {
        var _r: *InkDrawingAttributes = undefined;
        const _c = self.vtable.CreateInkDrawingAttributes(@ptrCast(self), brush, strokeWidth, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarCustomPen";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4082207b-2f3d-4e6a-8c27-fe61ef7e70eb";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInkDrawingAttributes: *const fn(self: *anyopaque, brush: *Brush, strokeWidth: f64, _r: **InkDrawingAttributes) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarCustomPenButton = extern struct {
    vtable: *const VTable,
    pub fn getCustomPen(self: *@This()) core.HResult!*InkToolbarCustomPen {
        var _r: *InkToolbarCustomPen = undefined;
        const _c = self.vtable.get_CustomPen(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCustomPen(self: *@This(), value: *InkToolbarCustomPen) core.HResult!void {
        const _c = self.vtable.put_CustomPen(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getConfigurationContent(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_ConfigurationContent(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putConfigurationContent(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_ConfigurationContent(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarCustomPenButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "46024401-2b2a-4f3c-a53c-1a045a408efa";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CustomPen: *const fn(self: *anyopaque, _r: **InkToolbarCustomPen) callconv(.winapi) HRESULT,
        put_CustomPen: *const fn(self: *anyopaque, value: *InkToolbarCustomPen) callconv(.winapi) HRESULT,
        get_ConfigurationContent: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_ConfigurationContent: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarCustomPenButtonFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarCustomPenButton {
        var _r: *InkToolbarCustomPenButton = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarCustomPenButtonFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0f2ef0ba-c8b9-4c36-8987-94d3dafede18";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **InkToolbarCustomPenButton) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarCustomPenButtonStatics = extern struct {
    vtable: *const VTable,
    pub fn getCustomPenProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CustomPenProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getConfigurationContentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ConfigurationContentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarCustomPenButtonStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "373c25f4-e555-4e85-a80d-da6b8433dbde";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CustomPenProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ConfigurationContentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarCustomPenFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarCustomPen {
        var _r: *InkToolbarCustomPen = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarCustomPenFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d214d636-f1aa-4f48-bf2c-a926caae4c60";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **InkToolbarCustomPen) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarCustomPenOverrides = extern struct {
    vtable: *const VTable,
    pub fn CreateInkDrawingAttributesCore(self: *@This(), brush: *Brush, strokeWidth: f64) core.HResult!*InkDrawingAttributes {
        var _r: *InkDrawingAttributes = undefined;
        const _c = self.vtable.CreateInkDrawingAttributesCore(@ptrCast(self), brush, strokeWidth, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarCustomPenOverrides";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9d22eb6c-1255-4256-b6bd-82c2fd273488";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInkDrawingAttributesCore: *const fn(self: *anyopaque, brush: *Brush, strokeWidth: f64, _r: **InkDrawingAttributes) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarCustomToggleButton = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarCustomToggleButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "550c4d84-4f54-4fbe-b12b-e0a50aab0d05";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarCustomToggleButtonFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarCustomToggleButton {
        var _r: *InkToolbarCustomToggleButton = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarCustomToggleButtonFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4a00374d-4cd2-4ed9-863e-83b8cf3fd2af";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **InkToolbarCustomToggleButton) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarCustomToolButton = extern struct {
    vtable: *const VTable,
    pub fn getConfigurationContent(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_ConfigurationContent(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putConfigurationContent(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_ConfigurationContent(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarCustomToolButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9f98acd7-c605-4105-be10-3943a7c0da3c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ConfigurationContent: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_ConfigurationContent: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarCustomToolButtonFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarCustomToolButton {
        var _r: *InkToolbarCustomToolButton = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarCustomToolButtonFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c295fe4e-30eb-4130-a6b6-8c85d8e26e89";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **InkToolbarCustomToolButton) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarCustomToolButtonStatics = extern struct {
    vtable: *const VTable,
    pub fn getConfigurationContentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ConfigurationContentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarCustomToolButtonStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "11fe4cb9-bbac-4314-9344-92c6693ddeaf";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ConfigurationContentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarEraserButton = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarEraserButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4cbdb92e-5f5e-4b35-a41c-16ffb0283bc0";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarEraserButton2 = extern struct {
    vtable: *const VTable,
    pub fn getIsClearAllVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsClearAllVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsClearAllVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsClearAllVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarEraserButton2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e7a59257-5ae8-436d-b2e2-93c200900ca0";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsClearAllVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsClearAllVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarEraserButtonFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarEraserButton {
        var _r: *InkToolbarEraserButton = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarEraserButtonFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "fd40611d-d1ba-4d67-af00-148036ad492c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **InkToolbarEraserButton) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarEraserButtonStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getIsClearAllVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsClearAllVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarEraserButtonStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "038a1736-c5cd-4311-83f4-38cbf07c2066";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsClearAllVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbar {
        var _r: *InkToolbar = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3947aa99-36b1-4374-ab5c-98bf07a4320b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **InkToolbar) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarFlyoutItem = extern struct {
    vtable: *const VTable,
    pub fn getKind(self: *@This()) core.HResult!InkToolbarFlyoutItemKind {
        var _r: InkToolbarFlyoutItemKind = undefined;
        const _c = self.vtable.get_Kind(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putKind(self: *@This(), value: InkToolbarFlyoutItemKind) core.HResult!void {
        const _c = self.vtable.put_Kind(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsChecked(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsChecked(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsChecked(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsChecked(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addChecked(self: *@This(), handler: *TypedEventHandler(InkToolbarFlyoutItem,IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Checked(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeChecked(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Checked(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addUnchecked(self: *@This(), handler: *TypedEventHandler(InkToolbarFlyoutItem,IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Unchecked(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeUnchecked(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Unchecked(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarFlyoutItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "92b68786-37ee-4915-9e89-e187564a889a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Kind: *const fn(self: *anyopaque, _r: *InkToolbarFlyoutItemKind) callconv(.winapi) HRESULT,
        put_Kind: *const fn(self: *anyopaque, value: InkToolbarFlyoutItemKind) callconv(.winapi) HRESULT,
        get_IsChecked: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsChecked: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        add_Checked: *const fn(self: *anyopaque, handler: *TypedEventHandler(InkToolbarFlyoutItem,IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Checked: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_Unchecked: *const fn(self: *anyopaque, handler: *TypedEventHandler(InkToolbarFlyoutItem,IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Unchecked: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarFlyoutItemFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarFlyoutItem {
        var _r: *InkToolbarFlyoutItem = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarFlyoutItemFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "352e7b93-803b-4f0e-8c72-9dfc0329329f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **InkToolbarFlyoutItem) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarFlyoutItemStatics = extern struct {
    vtable: *const VTable,
    pub fn getKindProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_KindProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsCheckedProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsCheckedProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarFlyoutItemStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1fe54b64-4063-4a5f-b89c-9f58935ee379";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_KindProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsCheckedProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarHighlighterButton = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarHighlighterButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0b3cc15b-7abf-487e-acc1-5b5048fee6d2";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarHighlighterButtonFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarHighlighterButton {
        var _r: *InkToolbarHighlighterButton = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarHighlighterButtonFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "7c334add-42ca-4943-94a4-23b5a6e55cf1";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **InkToolbarHighlighterButton) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarIsStencilButtonCheckedChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getStencilButton(self: *@This()) core.HResult!*InkToolbarStencilButton {
        var _r: *InkToolbarStencilButton = undefined;
        const _c = self.vtable.get_StencilButton(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getStencilKind(self: *@This()) core.HResult!InkToolbarStencilKind {
        var _r: InkToolbarStencilKind = undefined;
        const _c = self.vtable.get_StencilKind(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarIsStencilButtonCheckedChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "026edd26-d32b-4e28-a033-d5097662b292";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_StencilButton: *const fn(self: *anyopaque, _r: **InkToolbarStencilButton) callconv(.winapi) HRESULT,
        get_StencilKind: *const fn(self: *anyopaque, _r: *InkToolbarStencilKind) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarMenuButton = extern struct {
    vtable: *const VTable,
    pub fn getMenuKind(self: *@This()) core.HResult!InkToolbarMenuKind {
        var _r: InkToolbarMenuKind = undefined;
        const _c = self.vtable.get_MenuKind(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsExtensionGlyphShown(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsExtensionGlyphShown(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsExtensionGlyphShown(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsExtensionGlyphShown(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarMenuButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "860ecae5-7633-4ea1-a209-50392d1aebd1";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_MenuKind: *const fn(self: *anyopaque, _r: *InkToolbarMenuKind) callconv(.winapi) HRESULT,
        get_IsExtensionGlyphShown: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsExtensionGlyphShown: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarMenuButtonFactory = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarMenuButtonFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "7a463a9d-5dc7-44a7-afd0-2b685cb9a96c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarMenuButtonStatics = extern struct {
    vtable: *const VTable,
    pub fn getIsExtensionGlyphShownProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsExtensionGlyphShownProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarMenuButtonStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f03b17a6-b8b0-4a87-a961-37cd05d83137";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsExtensionGlyphShownProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarPenButton = extern struct {
    vtable: *const VTable,
    pub fn getPalette(self: *@This()) core.HResult!*IVector(Brush) {
        var _r: *IVector(Brush) = undefined;
        const _c = self.vtable.get_Palette(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPalette(self: *@This(), value: *IVector(Brush)) core.HResult!void {
        const _c = self.vtable.put_Palette(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMinStrokeWidth(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_MinStrokeWidth(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMinStrokeWidth(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_MinStrokeWidth(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMaxStrokeWidth(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_MaxStrokeWidth(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxStrokeWidth(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_MaxStrokeWidth(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectedBrush(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_SelectedBrush(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedBrushIndex(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_SelectedBrushIndex(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectedBrushIndex(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_SelectedBrushIndex(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectedStrokeWidth(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_SelectedStrokeWidth(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectedStrokeWidth(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_SelectedStrokeWidth(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarPenButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e0b80c21-b032-40ee-a2b9-507f6ccb827b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Palette: *const fn(self: *anyopaque, _r: **IVector(Brush)) callconv(.winapi) HRESULT,
        put_Palette: *const fn(self: *anyopaque, value: *IVector(Brush)) callconv(.winapi) HRESULT,
        get_MinStrokeWidth: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_MinStrokeWidth: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_MaxStrokeWidth: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_MaxStrokeWidth: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_SelectedBrush: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        get_SelectedBrushIndex: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_SelectedBrushIndex: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_SelectedStrokeWidth: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_SelectedStrokeWidth: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarPenButtonFactory = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarPenButtonFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b1463d21-59cb-4a83-92e1-692842797b2e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarPenButtonStatics = extern struct {
    vtable: *const VTable,
    pub fn getPaletteProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PaletteProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMinStrokeWidthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MinStrokeWidthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaxStrokeWidthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxStrokeWidthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedBrushProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedBrushProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedBrushIndexProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedBrushIndexProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedStrokeWidthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedStrokeWidthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarPenButtonStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b922ce42-09f0-453d-8026-44daf2753f65";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PaletteProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MinStrokeWidthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaxStrokeWidthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectedBrushProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectedBrushIndexProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectedStrokeWidthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarPenConfigurationControl = extern struct {
    vtable: *const VTable,
    pub fn getPenButton(self: *@This()) core.HResult!*InkToolbarPenButton {
        var _r: *InkToolbarPenButton = undefined;
        const _c = self.vtable.get_PenButton(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarPenConfigurationControl";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "601ae5f6-28a5-44cc-89a6-380e91a572dd";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PenButton: *const fn(self: *anyopaque, _r: **InkToolbarPenButton) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarPenConfigurationControlFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarPenConfigurationControl {
        var _r: *InkToolbarPenConfigurationControl = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarPenConfigurationControlFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "67f065ee-f5e7-46eb-9187-8d3ca3af891b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **InkToolbarPenConfigurationControl) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarPenConfigurationControlStatics = extern struct {
    vtable: *const VTable,
    pub fn getPenButtonProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PenButtonProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarPenConfigurationControlStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "48a61bef-19ce-41bb-abe0-7c8726fae75e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PenButtonProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarPencilButton = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarPencilButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5b112832-1984-4148-9f25-382b35db087f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarPencilButtonFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarPencilButton {
        var _r: *InkToolbarPencilButton = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarPencilButtonFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "db66d85f-cfd6-495f-93ab-b8566af9f8af";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **InkToolbarPencilButton) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarRulerButton = extern struct {
    vtable: *const VTable,
    pub fn getRuler(self: *@This()) core.HResult!*InkPresenterRuler {
        var _r: *InkPresenterRuler = undefined;
        const _c = self.vtable.get_Ruler(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarRulerButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4a992832-1984-4148-9f25-382b35db087f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Ruler: *const fn(self: *anyopaque, _r: **InkPresenterRuler) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarRulerButtonFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarRulerButton {
        var _r: *InkToolbarRulerButton = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarRulerButtonFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "bb26d85f-cfd6-495f-93ab-b8566af9f8af";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **InkToolbarRulerButton) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarRulerButtonStatics = extern struct {
    vtable: *const VTable,
    pub fn getRulerProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_RulerProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarRulerButtonStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "bae75f65-be30-4bee-964b-ff9e498fee37";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_RulerProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarStatics = extern struct {
    vtable: *const VTable,
    pub fn getInitialControlsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_InitialControlsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getChildrenProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ChildrenProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getActiveToolProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ActiveToolProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getInkDrawingAttributesProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_InkDrawingAttributesProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsRulerButtonCheckedProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsRulerButtonCheckedProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTargetInkCanvasProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TargetInkCanvasProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a3b493bb-cb4f-4e6b-a33d-f11e7a295efa";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_InitialControlsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ChildrenProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ActiveToolProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_InkDrawingAttributesProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsRulerButtonCheckedProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TargetInkCanvasProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getIsStencilButtonCheckedProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsStencilButtonCheckedProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getButtonFlyoutPlacementProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ButtonFlyoutPlacementProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOrientationProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OrientationProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "aac1f8f2-2c1f-4e9c-b3f3-31ff22b51c7a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsStencilButtonCheckedProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ButtonFlyoutPlacementProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OrientationProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getTargetInkPresenterProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TargetInkPresenterProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a0ee663d-b63f-516e-a0a4-0704c4544d62";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TargetInkPresenterProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarStencilButton = extern struct {
    vtable: *const VTable,
    pub fn getRuler(self: *@This()) core.HResult!*InkPresenterRuler {
        var _r: *InkPresenterRuler = undefined;
        const _c = self.vtable.get_Ruler(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getProtractor(self: *@This()) core.HResult!*InkPresenterProtractor {
        var _r: *InkPresenterProtractor = undefined;
        const _c = self.vtable.get_Protractor(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedStencil(self: *@This()) core.HResult!InkToolbarStencilKind {
        var _r: InkToolbarStencilKind = undefined;
        const _c = self.vtable.get_SelectedStencil(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectedStencil(self: *@This(), value: InkToolbarStencilKind) core.HResult!void {
        const _c = self.vtable.put_SelectedStencil(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsRulerItemVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsRulerItemVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsRulerItemVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsRulerItemVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsProtractorItemVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsProtractorItemVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsProtractorItemVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsProtractorItemVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarStencilButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "306a2616-5b40-4bf3-92b7-f1df936aeff5";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Ruler: *const fn(self: *anyopaque, _r: **InkPresenterRuler) callconv(.winapi) HRESULT,
        get_Protractor: *const fn(self: *anyopaque, _r: **InkPresenterProtractor) callconv(.winapi) HRESULT,
        get_SelectedStencil: *const fn(self: *anyopaque, _r: *InkToolbarStencilKind) callconv(.winapi) HRESULT,
        put_SelectedStencil: *const fn(self: *anyopaque, value: InkToolbarStencilKind) callconv(.winapi) HRESULT,
        get_IsRulerItemVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsRulerItemVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsProtractorItemVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsProtractorItemVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarStencilButtonFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarStencilButton {
        var _r: *InkToolbarStencilButton = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarStencilButtonFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a20701d1-8a70-4d77-89d4-1730a3a58edf";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **InkToolbarStencilButton) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarStencilButtonStatics = extern struct {
    vtable: *const VTable,
    pub fn getRulerProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_RulerProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getProtractorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ProtractorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedStencilProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedStencilProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsRulerItemVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsRulerItemVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsProtractorItemVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsProtractorItemVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarStencilButtonStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4748c07f-63e4-420d-939a-6b7243e9d124";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_RulerProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ProtractorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectedStencilProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsRulerItemVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsProtractorItemVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarToggleButton = extern struct {
    vtable: *const VTable,
    pub fn getToggleKind(self: *@This()) core.HResult!InkToolbarToggle {
        var _r: InkToolbarToggle = undefined;
        const _c = self.vtable.get_ToggleKind(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarToggleButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b4a278fa-f5f0-4b1f-beb0-0b8a29905a4a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ToggleKind: *const fn(self: *anyopaque, _r: *InkToolbarToggle) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarToggleButtonFactory = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarToggleButtonFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b2f90710-e5a1-4365-9d1a-e5b7ad8b9668";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarToolButton = extern struct {
    vtable: *const VTable,
    pub fn getToolKind(self: *@This()) core.HResult!InkToolbarTool {
        var _r: InkToolbarTool = undefined;
        const _c = self.vtable.get_ToolKind(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsExtensionGlyphShown(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsExtensionGlyphShown(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsExtensionGlyphShown(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsExtensionGlyphShown(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarToolButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5c5af41e-ccb7-4458-8064-a9849d31561b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ToolKind: *const fn(self: *anyopaque, _r: *InkToolbarTool) callconv(.winapi) HRESULT,
        get_IsExtensionGlyphShown: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsExtensionGlyphShown: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarToolButtonFactory = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarToolButtonFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6293bf4b-89fe-4ed0-a1a6-88d3eba917b2";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IInkToolbarToolButtonStatics = extern struct {
    vtable: *const VTable,
    pub fn getIsExtensionGlyphShownProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsExtensionGlyphShownProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInkToolbarToolButtonStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9e097d18-d136-4ef6-b0fd-1a78c2884a01";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsExtensionGlyphShownProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IInsertionPanel = extern struct {
    vtable: *const VTable,
    pub fn GetInsertionIndexes(self: *@This(), position: Point, first: i32, second: i32) core.HResult!void {
        const _c = self.vtable.GetInsertionIndexes(@ptrCast(self), position, first, second);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IInsertionPanel";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6b8de08f-6527-4d39-bcbf-58b01da923d7";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        GetInsertionIndexes: *const fn(self: *anyopaque, position: Point, first: i32, second: i32) callconv(.winapi) HRESULT,
    };
};
pub const IIsTextTrimmedChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IIsTextTrimmedChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "16f597cd-ebff-4fb4-8714-26147418b945";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IItemClickEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getClickedItem(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_ClickedItem(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemClickEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9c314242-f29a-494d-a3a5-d4c7b2a46852";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ClickedItem: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
    };
};
pub const IItemContainerGenerator = extern struct {
    vtable: *const VTable,
    pub fn addItemsChanged(self: *@This(), handler: *ItemsChangedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ItemsChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeItemsChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ItemsChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn ItemFromContainer(self: *@This(), container: *DependencyObject) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.ItemFromContainer(@ptrCast(self), container, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn ContainerFromItem(self: *@This(), item: *IInspectable) core.HResult!*DependencyObject {
        var _r: *DependencyObject = undefined;
        const _c = self.vtable.ContainerFromItem(@ptrCast(self), item, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn IndexFromContainer(self: *@This(), container: *DependencyObject) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.IndexFromContainer(@ptrCast(self), container, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn ContainerFromIndex(self: *@This(), index: i32) core.HResult!*DependencyObject {
        var _r: *DependencyObject = undefined;
        const _c = self.vtable.ContainerFromIndex(@ptrCast(self), index, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetItemContainerGeneratorForPanel(self: *@This(), panel: *Panel) core.HResult!*ItemContainerGenerator {
        var _r: *ItemContainerGenerator = undefined;
        const _c = self.vtable.GetItemContainerGeneratorForPanel(@ptrCast(self), panel, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn StartAt(self: *@This(), position: GeneratorPosition, direction: GeneratorDirection, allowStartAtRealizedItem: bool) core.HResult!void {
        const _c = self.vtable.StartAt(@ptrCast(self), position, direction, allowStartAtRealizedItem);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Stop(self: *@This()) core.HResult!void {
        const _c = self.vtable.Stop(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn GenerateNext(self: *@This(), isNewlyRealized: bool) core.HResult!*DependencyObject {
        var _r: *DependencyObject = undefined;
        const _c = self.vtable.GenerateNext(@ptrCast(self), isNewlyRealized, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn PrepareItemContainer(self: *@This(), container: *DependencyObject) core.HResult!void {
        const _c = self.vtable.PrepareItemContainer(@ptrCast(self), container);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn RemoveAll(self: *@This()) core.HResult!void {
        const _c = self.vtable.RemoveAll(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Remove(self: *@This(), position: GeneratorPosition, count: i32) core.HResult!void {
        const _c = self.vtable.Remove(@ptrCast(self), position, count);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn GeneratorPositionFromIndex(self: *@This(), itemIndex: i32) core.HResult!GeneratorPosition {
        var _r: GeneratorPosition = undefined;
        const _c = self.vtable.GeneratorPositionFromIndex(@ptrCast(self), itemIndex, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn IndexFromGeneratorPosition(self: *@This(), position: GeneratorPosition) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.IndexFromGeneratorPosition(@ptrCast(self), position, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn Recycle(self: *@This(), position: GeneratorPosition, count: i32) core.HResult!void {
        const _c = self.vtable.Recycle(@ptrCast(self), position, count);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemContainerGenerator";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "40765f00-83f0-4d7f-b1b8-f19de4f1d5da";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        add_ItemsChanged: *const fn(self: *anyopaque, handler: *ItemsChangedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ItemsChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        ItemFromContainer: *const fn(self: *anyopaque, container: *DependencyObject, _r: **IInspectable) callconv(.winapi) HRESULT,
        ContainerFromItem: *const fn(self: *anyopaque, item: *IInspectable, _r: **DependencyObject) callconv(.winapi) HRESULT,
        IndexFromContainer: *const fn(self: *anyopaque, container: *DependencyObject, _r: *i32) callconv(.winapi) HRESULT,
        ContainerFromIndex: *const fn(self: *anyopaque, index: i32, _r: **DependencyObject) callconv(.winapi) HRESULT,
        GetItemContainerGeneratorForPanel: *const fn(self: *anyopaque, panel: *Panel, _r: **ItemContainerGenerator) callconv(.winapi) HRESULT,
        StartAt: *const fn(self: *anyopaque, position: GeneratorPosition, direction: GeneratorDirection, allowStartAtRealizedItem: bool) callconv(.winapi) HRESULT,
        Stop: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        GenerateNext: *const fn(self: *anyopaque, isNewlyRealized: bool, _r: **DependencyObject) callconv(.winapi) HRESULT,
        PrepareItemContainer: *const fn(self: *anyopaque, container: *DependencyObject) callconv(.winapi) HRESULT,
        RemoveAll: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        Remove: *const fn(self: *anyopaque, position: GeneratorPosition, count: i32) callconv(.winapi) HRESULT,
        GeneratorPositionFromIndex: *const fn(self: *anyopaque, itemIndex: i32, _r: *GeneratorPosition) callconv(.winapi) HRESULT,
        IndexFromGeneratorPosition: *const fn(self: *anyopaque, position: GeneratorPosition, _r: *i32) callconv(.winapi) HRESULT,
        Recycle: *const fn(self: *anyopaque, position: GeneratorPosition, count: i32) callconv(.winapi) HRESULT,
    };
};
pub const IItemContainerMapping = extern struct {
    vtable: *const VTable,
    pub fn ItemFromContainer(self: *@This(), container: *DependencyObject) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.ItemFromContainer(@ptrCast(self), container, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn ContainerFromItem(self: *@This(), item: *IInspectable) core.HResult!*DependencyObject {
        var _r: *DependencyObject = undefined;
        const _c = self.vtable.ContainerFromItem(@ptrCast(self), item, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn IndexFromContainer(self: *@This(), container: *DependencyObject) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.IndexFromContainer(@ptrCast(self), container, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn ContainerFromIndex(self: *@This(), index: i32) core.HResult!*DependencyObject {
        var _r: *DependencyObject = undefined;
        const _c = self.vtable.ContainerFromIndex(@ptrCast(self), index, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemContainerMapping";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "53c9f23a-f25d-446a-99b8-c7aeb839050f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        ItemFromContainer: *const fn(self: *anyopaque, container: *DependencyObject, _r: **IInspectable) callconv(.winapi) HRESULT,
        ContainerFromItem: *const fn(self: *anyopaque, item: *IInspectable, _r: **DependencyObject) callconv(.winapi) HRESULT,
        IndexFromContainer: *const fn(self: *anyopaque, container: *DependencyObject, _r: *i32) callconv(.winapi) HRESULT,
        ContainerFromIndex: *const fn(self: *anyopaque, index: i32, _r: **DependencyObject) callconv(.winapi) HRESULT,
    };
};
pub const IItemsControl = extern struct {
    vtable: *const VTable,
    pub fn getItemsSource(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_ItemsSource(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemsSource(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_ItemsSource(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getItems(self: *@This()) core.HResult!*ItemCollection {
        var _r: *ItemCollection = undefined;
        const _c = self.vtable.get_Items(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_ItemTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_ItemTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getItemTemplateSelector(self: *@This()) core.HResult!*DataTemplateSelector {
        var _r: *DataTemplateSelector = undefined;
        const _c = self.vtable.get_ItemTemplateSelector(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemTemplateSelector(self: *@This(), value: *DataTemplateSelector) core.HResult!void {
        const _c = self.vtable.put_ItemTemplateSelector(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getItemsPanel(self: *@This()) core.HResult!*ItemsPanelTemplate {
        var _r: *ItemsPanelTemplate = undefined;
        const _c = self.vtable.get_ItemsPanel(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemsPanel(self: *@This(), value: *ItemsPanelTemplate) core.HResult!void {
        const _c = self.vtable.put_ItemsPanel(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDisplayMemberPath(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_DisplayMemberPath(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDisplayMemberPath(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_DisplayMemberPath(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getItemContainerStyle(self: *@This()) core.HResult!*Style {
        var _r: *Style = undefined;
        const _c = self.vtable.get_ItemContainerStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemContainerStyle(self: *@This(), value: *Style) core.HResult!void {
        const _c = self.vtable.put_ItemContainerStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getItemContainerStyleSelector(self: *@This()) core.HResult!*StyleSelector {
        var _r: *StyleSelector = undefined;
        const _c = self.vtable.get_ItemContainerStyleSelector(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemContainerStyleSelector(self: *@This(), value: *StyleSelector) core.HResult!void {
        const _c = self.vtable.put_ItemContainerStyleSelector(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getItemContainerGenerator(self: *@This()) core.HResult!*ItemContainerGenerator {
        var _r: *ItemContainerGenerator = undefined;
        const _c = self.vtable.get_ItemContainerGenerator(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemContainerTransitions(self: *@This()) core.HResult!*TransitionCollection {
        var _r: *TransitionCollection = undefined;
        const _c = self.vtable.get_ItemContainerTransitions(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemContainerTransitions(self: *@This(), value: *TransitionCollection) core.HResult!void {
        const _c = self.vtable.put_ItemContainerTransitions(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getGroupStyle(self: *@This()) core.HResult!*IObservableVector(GroupStyle) {
        var _r: *IObservableVector(GroupStyle) = undefined;
        const _c = self.vtable.get_GroupStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getGroupStyleSelector(self: *@This()) core.HResult!*GroupStyleSelector {
        var _r: *GroupStyleSelector = undefined;
        const _c = self.vtable.get_GroupStyleSelector(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putGroupStyleSelector(self: *@This(), value: *GroupStyleSelector) core.HResult!void {
        const _c = self.vtable.put_GroupStyleSelector(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsGrouping(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsGrouping(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemsControl";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f4a91dd8-d979-4381-8652-bda0342a765e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ItemsSource: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_ItemsSource: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_Items: *const fn(self: *anyopaque, _r: **ItemCollection) callconv(.winapi) HRESULT,
        get_ItemTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_ItemTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_ItemTemplateSelector: *const fn(self: *anyopaque, _r: **DataTemplateSelector) callconv(.winapi) HRESULT,
        put_ItemTemplateSelector: *const fn(self: *anyopaque, value: *DataTemplateSelector) callconv(.winapi) HRESULT,
        get_ItemsPanel: *const fn(self: *anyopaque, _r: **ItemsPanelTemplate) callconv(.winapi) HRESULT,
        put_ItemsPanel: *const fn(self: *anyopaque, value: *ItemsPanelTemplate) callconv(.winapi) HRESULT,
        get_DisplayMemberPath: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_DisplayMemberPath: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_ItemContainerStyle: *const fn(self: *anyopaque, _r: **Style) callconv(.winapi) HRESULT,
        put_ItemContainerStyle: *const fn(self: *anyopaque, value: *Style) callconv(.winapi) HRESULT,
        get_ItemContainerStyleSelector: *const fn(self: *anyopaque, _r: **StyleSelector) callconv(.winapi) HRESULT,
        put_ItemContainerStyleSelector: *const fn(self: *anyopaque, value: *StyleSelector) callconv(.winapi) HRESULT,
        get_ItemContainerGenerator: *const fn(self: *anyopaque, _r: **ItemContainerGenerator) callconv(.winapi) HRESULT,
        get_ItemContainerTransitions: *const fn(self: *anyopaque, _r: **TransitionCollection) callconv(.winapi) HRESULT,
        put_ItemContainerTransitions: *const fn(self: *anyopaque, value: *TransitionCollection) callconv(.winapi) HRESULT,
        get_GroupStyle: *const fn(self: *anyopaque, _r: **IObservableVector(GroupStyle)) callconv(.winapi) HRESULT,
        get_GroupStyleSelector: *const fn(self: *anyopaque, _r: **GroupStyleSelector) callconv(.winapi) HRESULT,
        put_GroupStyleSelector: *const fn(self: *anyopaque, value: *GroupStyleSelector) callconv(.winapi) HRESULT,
        get_IsGrouping: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
    };
};
pub const IItemsControl2 = extern struct {
    vtable: *const VTable,
    pub fn getItemsPanelRoot(self: *@This()) core.HResult!*Panel {
        var _r: *Panel = undefined;
        const _c = self.vtable.get_ItemsPanelRoot(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemsControl2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "754c3266-0529-45e3-8748-bf747d158357";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ItemsPanelRoot: *const fn(self: *anyopaque, _r: **Panel) callconv(.winapi) HRESULT,
    };
};
pub const IItemsControl3 = extern struct {
    vtable: *const VTable,
    pub fn GroupHeaderContainerFromItemContainer(self: *@This(), itemContainer: *DependencyObject) core.HResult!*DependencyObject {
        var _r: *DependencyObject = undefined;
        const _c = self.vtable.GroupHeaderContainerFromItemContainer(@ptrCast(self), itemContainer, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemsControl3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "502b7489-aee4-4de3-a2ab-195ac20c4212";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        GroupHeaderContainerFromItemContainer: *const fn(self: *anyopaque, itemContainer: *DependencyObject, _r: **DependencyObject) callconv(.winapi) HRESULT,
    };
};
pub const IItemsControlFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ItemsControl {
        var _r: *ItemsControl = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemsControlFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f7bbc359-f8fd-471c-bcb2-2c74be8ebf8c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **ItemsControl) callconv(.winapi) HRESULT,
    };
};
pub const IItemsControlOverrides = extern struct {
    vtable: *const VTable,
    pub fn IsItemItsOwnContainerOverride(self: *@This(), item: *IInspectable) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.IsItemItsOwnContainerOverride(@ptrCast(self), item, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetContainerForItemOverride(self: *@This()) core.HResult!*DependencyObject {
        var _r: *DependencyObject = undefined;
        const _c = self.vtable.GetContainerForItemOverride(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn ClearContainerForItemOverride(self: *@This(), element: *DependencyObject, item: *IInspectable) core.HResult!void {
        const _c = self.vtable.ClearContainerForItemOverride(@ptrCast(self), element, item);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn PrepareContainerForItemOverride(self: *@This(), element: *DependencyObject, item: *IInspectable) core.HResult!void {
        const _c = self.vtable.PrepareContainerForItemOverride(@ptrCast(self), element, item);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnItemsChanged(self: *@This(), e: *IInspectable) core.HResult!void {
        const _c = self.vtable.OnItemsChanged(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnItemContainerStyleChanged(self: *@This(), oldItemContainerStyle: *Style, newItemContainerStyle: *Style) core.HResult!void {
        const _c = self.vtable.OnItemContainerStyleChanged(@ptrCast(self), oldItemContainerStyle, newItemContainerStyle);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnItemContainerStyleSelectorChanged(self: *@This(), oldItemContainerStyleSelector: *StyleSelector, newItemContainerStyleSelector: *StyleSelector) core.HResult!void {
        const _c = self.vtable.OnItemContainerStyleSelectorChanged(@ptrCast(self), oldItemContainerStyleSelector, newItemContainerStyleSelector);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnItemTemplateChanged(self: *@This(), oldItemTemplate: *DataTemplate, newItemTemplate: *DataTemplate) core.HResult!void {
        const _c = self.vtable.OnItemTemplateChanged(@ptrCast(self), oldItemTemplate, newItemTemplate);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnItemTemplateSelectorChanged(self: *@This(), oldItemTemplateSelector: *DataTemplateSelector, newItemTemplateSelector: *DataTemplateSelector) core.HResult!void {
        const _c = self.vtable.OnItemTemplateSelectorChanged(@ptrCast(self), oldItemTemplateSelector, newItemTemplateSelector);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnGroupStyleSelectorChanged(self: *@This(), oldGroupStyleSelector: *GroupStyleSelector, newGroupStyleSelector: *GroupStyleSelector) core.HResult!void {
        const _c = self.vtable.OnGroupStyleSelectorChanged(@ptrCast(self), oldGroupStyleSelector, newGroupStyleSelector);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemsControlOverrides";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c79bb41b-a084-4301-a496-72971f364ed1";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        IsItemItsOwnContainerOverride: *const fn(self: *anyopaque, item: *IInspectable, _r: *bool) callconv(.winapi) HRESULT,
        GetContainerForItemOverride: *const fn(self: *anyopaque, _r: **DependencyObject) callconv(.winapi) HRESULT,
        ClearContainerForItemOverride: *const fn(self: *anyopaque, element: *DependencyObject, item: *IInspectable) callconv(.winapi) HRESULT,
        PrepareContainerForItemOverride: *const fn(self: *anyopaque, element: *DependencyObject, item: *IInspectable) callconv(.winapi) HRESULT,
        OnItemsChanged: *const fn(self: *anyopaque, e: *IInspectable) callconv(.winapi) HRESULT,
        OnItemContainerStyleChanged: *const fn(self: *anyopaque, oldItemContainerStyle: *Style, newItemContainerStyle: *Style) callconv(.winapi) HRESULT,
        OnItemContainerStyleSelectorChanged: *const fn(self: *anyopaque, oldItemContainerStyleSelector: *StyleSelector, newItemContainerStyleSelector: *StyleSelector) callconv(.winapi) HRESULT,
        OnItemTemplateChanged: *const fn(self: *anyopaque, oldItemTemplate: *DataTemplate, newItemTemplate: *DataTemplate) callconv(.winapi) HRESULT,
        OnItemTemplateSelectorChanged: *const fn(self: *anyopaque, oldItemTemplateSelector: *DataTemplateSelector, newItemTemplateSelector: *DataTemplateSelector) callconv(.winapi) HRESULT,
        OnGroupStyleSelectorChanged: *const fn(self: *anyopaque, oldGroupStyleSelector: *GroupStyleSelector, newGroupStyleSelector: *GroupStyleSelector) callconv(.winapi) HRESULT,
    };
};
pub const IItemsControlStatics = extern struct {
    vtable: *const VTable,
    pub fn getItemsSourceProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemsSourceProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemTemplateSelectorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemTemplateSelectorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemsPanelProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemsPanelProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDisplayMemberPathProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DisplayMemberPathProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemContainerStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemContainerStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemContainerStyleSelectorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemContainerStyleSelectorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemContainerTransitionsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemContainerTransitionsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getGroupStyleSelectorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_GroupStyleSelectorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsGroupingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsGroupingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetItemsOwner(self: *@This(), element: *DependencyObject) core.HResult!*ItemsControl {
        var _r: *ItemsControl = undefined;
        const _c = self.vtable.GetItemsOwner(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn ItemsControlFromItemContainer(self: *@This(), container: *DependencyObject) core.HResult!*ItemsControl {
        var _r: *ItemsControl = undefined;
        const _c = self.vtable.ItemsControlFromItemContainer(@ptrCast(self), container, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemsControlStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "37dabd89-dcfb-45b8-9afe-874df097905e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ItemsSourceProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ItemTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ItemTemplateSelectorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ItemsPanelProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DisplayMemberPathProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ItemContainerStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ItemContainerStyleSelectorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ItemContainerTransitionsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_GroupStyleSelectorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsGroupingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetItemsOwner: *const fn(self: *anyopaque, element: *DependencyObject, _r: **ItemsControl) callconv(.winapi) HRESULT,
        ItemsControlFromItemContainer: *const fn(self: *anyopaque, container: *DependencyObject, _r: **ItemsControl) callconv(.winapi) HRESULT,
    };
};
pub const IItemsPanelTemplate = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemsPanelTemplate";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "14ead768-34b2-4b97-bf3c-e8d73230a2aa";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IItemsPickedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getAddedItems(self: *@This()) core.HResult!*IVector(IInspectable) {
        var _r: *IVector(IInspectable) = undefined;
        const _c = self.vtable.get_AddedItems(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getRemovedItems(self: *@This()) core.HResult!*IVector(IInspectable) {
        var _r: *IVector(IInspectable) = undefined;
        const _c = self.vtable.get_RemovedItems(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemsPickedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f95b9aac-a621-488e-9156-8ee31165be04";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_AddedItems: *const fn(self: *anyopaque, _r: **IVector(IInspectable)) callconv(.winapi) HRESULT,
        get_RemovedItems: *const fn(self: *anyopaque, _r: **IVector(IInspectable)) callconv(.winapi) HRESULT,
    };
};
pub const IItemsPresenter = extern struct {
    vtable: *const VTable,
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Header(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Header(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_HeaderTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_HeaderTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeaderTransitions(self: *@This()) core.HResult!*TransitionCollection {
        var _r: *TransitionCollection = undefined;
        const _c = self.vtable.get_HeaderTransitions(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderTransitions(self: *@This(), value: *TransitionCollection) core.HResult!void {
        const _c = self.vtable.put_HeaderTransitions(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPadding(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_Padding(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPadding(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_Padding(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemsPresenter";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c271569b-6dca-4e2b-8e14-c55136b02a71";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Header: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Header: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_HeaderTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_HeaderTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_HeaderTransitions: *const fn(self: *anyopaque, _r: **TransitionCollection) callconv(.winapi) HRESULT,
        put_HeaderTransitions: *const fn(self: *anyopaque, value: *TransitionCollection) callconv(.winapi) HRESULT,
        get_Padding: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_Padding: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
    };
};
pub const IItemsPresenter2 = extern struct {
    vtable: *const VTable,
    pub fn getFooter(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Footer(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFooter(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Footer(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFooterTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_FooterTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFooterTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_FooterTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFooterTransitions(self: *@This()) core.HResult!*TransitionCollection {
        var _r: *TransitionCollection = undefined;
        const _c = self.vtable.get_FooterTransitions(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFooterTransitions(self: *@This(), value: *TransitionCollection) core.HResult!void {
        const _c = self.vtable.put_FooterTransitions(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemsPresenter2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5c04aa33-1df3-4731-a4c9-da818378d63d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Footer: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Footer: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_FooterTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_FooterTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_FooterTransitions: *const fn(self: *anyopaque, _r: **TransitionCollection) callconv(.winapi) HRESULT,
        put_FooterTransitions: *const fn(self: *anyopaque, value: *TransitionCollection) callconv(.winapi) HRESULT,
    };
};
pub const IItemsPresenterStatics = extern struct {
    vtable: *const VTable,
    pub fn getHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderTransitionsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderTransitionsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPaddingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PaddingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemsPresenterStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "18de66cd-4a6c-4b2e-aa86-cb126c9a2920";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderTransitionsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PaddingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IItemsPresenterStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getFooterProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FooterProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFooterTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FooterTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFooterTransitionsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FooterTransitionsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemsPresenterStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8971632e-7867-4d66-9630-29f1c5f7403f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_FooterProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FooterTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FooterTransitionsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IItemsStackPanel = extern struct {
    vtable: *const VTable,
    pub fn getGroupPadding(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_GroupPadding(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putGroupPadding(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_GroupPadding(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOrientation(self: *@This()) core.HResult!Orientation {
        var _r: Orientation = undefined;
        const _c = self.vtable.get_Orientation(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOrientation(self: *@This(), value: Orientation) core.HResult!void {
        const _c = self.vtable.put_Orientation(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFirstCacheIndex(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_FirstCacheIndex(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFirstVisibleIndex(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_FirstVisibleIndex(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLastVisibleIndex(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_LastVisibleIndex(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLastCacheIndex(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_LastCacheIndex(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getScrollingDirection(self: *@This()) core.HResult!PanelScrollingDirection {
        var _r: PanelScrollingDirection = undefined;
        const _c = self.vtable.get_ScrollingDirection(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getGroupHeaderPlacement(self: *@This()) core.HResult!GroupHeaderPlacement {
        var _r: GroupHeaderPlacement = undefined;
        const _c = self.vtable.get_GroupHeaderPlacement(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putGroupHeaderPlacement(self: *@This(), value: GroupHeaderPlacement) core.HResult!void {
        const _c = self.vtable.put_GroupHeaderPlacement(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getItemsUpdatingScrollMode(self: *@This()) core.HResult!ItemsUpdatingScrollMode {
        var _r: ItemsUpdatingScrollMode = undefined;
        const _c = self.vtable.get_ItemsUpdatingScrollMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemsUpdatingScrollMode(self: *@This(), value: ItemsUpdatingScrollMode) core.HResult!void {
        const _c = self.vtable.put_ItemsUpdatingScrollMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCacheLength(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_CacheLength(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCacheLength(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_CacheLength(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemsStackPanel";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "df7ab79d-7ad5-4b58-9363-919af90226e6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_GroupPadding: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_GroupPadding: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
        get_Orientation: *const fn(self: *anyopaque, _r: *Orientation) callconv(.winapi) HRESULT,
        put_Orientation: *const fn(self: *anyopaque, value: Orientation) callconv(.winapi) HRESULT,
        get_FirstCacheIndex: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_FirstVisibleIndex: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_LastVisibleIndex: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_LastCacheIndex: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_ScrollingDirection: *const fn(self: *anyopaque, _r: *PanelScrollingDirection) callconv(.winapi) HRESULT,
        get_GroupHeaderPlacement: *const fn(self: *anyopaque, _r: *GroupHeaderPlacement) callconv(.winapi) HRESULT,
        put_GroupHeaderPlacement: *const fn(self: *anyopaque, value: GroupHeaderPlacement) callconv(.winapi) HRESULT,
        get_ItemsUpdatingScrollMode: *const fn(self: *anyopaque, _r: *ItemsUpdatingScrollMode) callconv(.winapi) HRESULT,
        put_ItemsUpdatingScrollMode: *const fn(self: *anyopaque, value: ItemsUpdatingScrollMode) callconv(.winapi) HRESULT,
        get_CacheLength: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_CacheLength: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
    };
};
pub const IItemsStackPanel2 = extern struct {
    vtable: *const VTable,
    pub fn getAreStickyGroupHeadersEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_AreStickyGroupHeadersEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putAreStickyGroupHeadersEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_AreStickyGroupHeadersEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemsStackPanel2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "eeeecdb0-00b4-4534-937b-56318b293e92";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_AreStickyGroupHeadersEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_AreStickyGroupHeadersEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IItemsStackPanelStatics = extern struct {
    vtable: *const VTable,
    pub fn getGroupPaddingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_GroupPaddingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOrientationProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OrientationProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getGroupHeaderPlacementProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_GroupHeaderPlacementProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCacheLengthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CacheLengthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemsStackPanelStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ca25d63f-044f-4b6b-b315-0b60e0b4f87d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_GroupPaddingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OrientationProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_GroupHeaderPlacementProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CacheLengthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IItemsStackPanelStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getAreStickyGroupHeadersEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AreStickyGroupHeadersEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemsStackPanelStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3972eb2c-384a-48bf-adfd-772e2572c504";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_AreStickyGroupHeadersEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IItemsWrapGrid = extern struct {
    vtable: *const VTable,
    pub fn getGroupPadding(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_GroupPadding(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putGroupPadding(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_GroupPadding(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOrientation(self: *@This()) core.HResult!Orientation {
        var _r: Orientation = undefined;
        const _c = self.vtable.get_Orientation(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOrientation(self: *@This(), value: Orientation) core.HResult!void {
        const _c = self.vtable.put_Orientation(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMaximumRowsOrColumns(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_MaximumRowsOrColumns(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaximumRowsOrColumns(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_MaximumRowsOrColumns(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getItemWidth(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_ItemWidth(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemWidth(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_ItemWidth(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getItemHeight(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_ItemHeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemHeight(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_ItemHeight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFirstCacheIndex(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_FirstCacheIndex(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFirstVisibleIndex(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_FirstVisibleIndex(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLastVisibleIndex(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_LastVisibleIndex(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLastCacheIndex(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_LastCacheIndex(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getScrollingDirection(self: *@This()) core.HResult!PanelScrollingDirection {
        var _r: PanelScrollingDirection = undefined;
        const _c = self.vtable.get_ScrollingDirection(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getGroupHeaderPlacement(self: *@This()) core.HResult!GroupHeaderPlacement {
        var _r: GroupHeaderPlacement = undefined;
        const _c = self.vtable.get_GroupHeaderPlacement(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putGroupHeaderPlacement(self: *@This(), value: GroupHeaderPlacement) core.HResult!void {
        const _c = self.vtable.put_GroupHeaderPlacement(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCacheLength(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_CacheLength(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCacheLength(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_CacheLength(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemsWrapGrid";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ddfe6b5f-ba88-4a7d-8a5b-e58caf0f4e2d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_GroupPadding: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_GroupPadding: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
        get_Orientation: *const fn(self: *anyopaque, _r: *Orientation) callconv(.winapi) HRESULT,
        put_Orientation: *const fn(self: *anyopaque, value: Orientation) callconv(.winapi) HRESULT,
        get_MaximumRowsOrColumns: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_MaximumRowsOrColumns: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_ItemWidth: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_ItemWidth: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_ItemHeight: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_ItemHeight: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_FirstCacheIndex: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_FirstVisibleIndex: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_LastVisibleIndex: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_LastCacheIndex: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_ScrollingDirection: *const fn(self: *anyopaque, _r: *PanelScrollingDirection) callconv(.winapi) HRESULT,
        get_GroupHeaderPlacement: *const fn(self: *anyopaque, _r: *GroupHeaderPlacement) callconv(.winapi) HRESULT,
        put_GroupHeaderPlacement: *const fn(self: *anyopaque, value: GroupHeaderPlacement) callconv(.winapi) HRESULT,
        get_CacheLength: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_CacheLength: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
    };
};
pub const IItemsWrapGrid2 = extern struct {
    vtable: *const VTable,
    pub fn getAreStickyGroupHeadersEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_AreStickyGroupHeadersEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putAreStickyGroupHeadersEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_AreStickyGroupHeadersEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemsWrapGrid2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "80c21c0f-63ec-4258-bd61-d4a6956c864a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_AreStickyGroupHeadersEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_AreStickyGroupHeadersEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IItemsWrapGridStatics = extern struct {
    vtable: *const VTable,
    pub fn getGroupPaddingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_GroupPaddingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOrientationProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OrientationProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaximumRowsOrColumnsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaximumRowsOrColumnsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemWidthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemWidthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemHeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemHeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getGroupHeaderPlacementProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_GroupHeaderPlacementProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCacheLengthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CacheLengthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemsWrapGridStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4ec5427d-24a0-449a-b763-3077ba0f2dd5";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_GroupPaddingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OrientationProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaximumRowsOrColumnsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ItemWidthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ItemHeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_GroupHeaderPlacementProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CacheLengthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IItemsWrapGridStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getAreStickyGroupHeadersEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AreStickyGroupHeadersEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IItemsWrapGridStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "2e27d3f7-feaa-478d-bfd1-29338adc5a03";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_AreStickyGroupHeadersEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IListBox = extern struct {
    vtable: *const VTable,
    pub fn getSelectedItems(self: *@This()) core.HResult!*IVector(IInspectable) {
        var _r: *IVector(IInspectable) = undefined;
        const _c = self.vtable.get_SelectedItems(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionMode(self: *@This()) core.HResult!SelectionMode {
        var _r: SelectionMode = undefined;
        const _c = self.vtable.get_SelectionMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectionMode(self: *@This(), value: SelectionMode) core.HResult!void {
        const _c = self.vtable.put_SelectionMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn ScrollIntoView(self: *@This(), item: *IInspectable) core.HResult!void {
        const _c = self.vtable.ScrollIntoView(@ptrCast(self), item);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn SelectAll(self: *@This()) core.HResult!void {
        const _c = self.vtable.SelectAll(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListBox";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e9f3b9ff-8e91-4ecf-a707-c927f694f881";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectedItems: *const fn(self: *anyopaque, _r: **IVector(IInspectable)) callconv(.winapi) HRESULT,
        get_SelectionMode: *const fn(self: *anyopaque, _r: *SelectionMode) callconv(.winapi) HRESULT,
        put_SelectionMode: *const fn(self: *anyopaque, value: SelectionMode) callconv(.winapi) HRESULT,
        ScrollIntoView: *const fn(self: *anyopaque, item: *IInspectable) callconv(.winapi) HRESULT,
        SelectAll: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
    };
};
pub const IListBox2 = extern struct {
    vtable: *const VTable,
    pub fn getSingleSelectionFollowsFocus(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_SingleSelectionFollowsFocus(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSingleSelectionFollowsFocus(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_SingleSelectionFollowsFocus(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListBox2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "70572aba-8ad1-4085-9350-deee359294e3";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SingleSelectionFollowsFocus: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_SingleSelectionFollowsFocus: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IListBoxFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ListBox {
        var _r: *ListBox = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListBoxFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "60cdfda2-2f44-444b-9c94-b8c9fda46f59";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **ListBox) callconv(.winapi) HRESULT,
    };
};
pub const IListBoxItem = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListBoxItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "43c13323-6edf-4e4b-b6b2-3a93eec41d95";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IListBoxItemFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ListBoxItem {
        var _r: *ListBoxItem = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListBoxItemFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4398b8d4-a3de-402c-b23d-190384b27ca8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **ListBoxItem) callconv(.winapi) HRESULT,
    };
};
pub const IListBoxStatics = extern struct {
    vtable: *const VTable,
    pub fn getSelectionModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectionModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListBoxStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6d3f7f73-706a-4e53-a9aa-c9a53c9cdd70";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectionModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IListBoxStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getSingleSelectionFollowsFocusProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SingleSelectionFollowsFocusProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListBoxStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0089adeb-b709-4c8d-b1ed-4a7d97ee7716";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SingleSelectionFollowsFocusProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IListPickerFlyout = extern struct {
    vtable: *const VTable,
    pub fn getItemsSource(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_ItemsSource(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemsSource(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_ItemsSource(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getItemTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_ItemTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_ItemTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDisplayMemberPath(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_DisplayMemberPath(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDisplayMemberPath(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_DisplayMemberPath(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectionMode(self: *@This()) core.HResult!ListPickerFlyoutSelectionMode {
        var _r: ListPickerFlyoutSelectionMode = undefined;
        const _c = self.vtable.get_SelectionMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectionMode(self: *@This(), value: ListPickerFlyoutSelectionMode) core.HResult!void {
        const _c = self.vtable.put_SelectionMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectedIndex(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_SelectedIndex(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectedIndex(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_SelectedIndex(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectedItem(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_SelectedItem(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectedItem(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_SelectedItem(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectedValue(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_SelectedValue(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectedValue(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_SelectedValue(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectedValuePath(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_SelectedValuePath(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectedValuePath(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_SelectedValuePath(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectedItems(self: *@This()) core.HResult!*IVector(IInspectable) {
        var _r: *IVector(IInspectable) = undefined;
        const _c = self.vtable.get_SelectedItems(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addItemsPicked(self: *@This(), handler: *TypedEventHandler(ListPickerFlyout,ItemsPickedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ItemsPicked(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeItemsPicked(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ItemsPicked(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn ShowAtAsync(self: *@This(), target: *FrameworkElement) core.HResult!*IAsyncOperation(IVectorView(IInspectable)) {
        var _r: *IAsyncOperation(IVectorView(IInspectable)) = undefined;
        const _c = self.vtable.ShowAtAsync(@ptrCast(self), target, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListPickerFlyout";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0f0cb9d7-e5f3-45e6-9063-ff7bbb193c47";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ItemsSource: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_ItemsSource: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_ItemTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_ItemTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_DisplayMemberPath: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_DisplayMemberPath: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_SelectionMode: *const fn(self: *anyopaque, _r: *ListPickerFlyoutSelectionMode) callconv(.winapi) HRESULT,
        put_SelectionMode: *const fn(self: *anyopaque, value: ListPickerFlyoutSelectionMode) callconv(.winapi) HRESULT,
        get_SelectedIndex: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_SelectedIndex: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_SelectedItem: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_SelectedItem: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_SelectedValue: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_SelectedValue: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_SelectedValuePath: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_SelectedValuePath: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_SelectedItems: *const fn(self: *anyopaque, _r: **IVector(IInspectable)) callconv(.winapi) HRESULT,
        add_ItemsPicked: *const fn(self: *anyopaque, handler: *TypedEventHandler(ListPickerFlyout,ItemsPickedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ItemsPicked: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        ShowAtAsync: *const fn(self: *anyopaque, target: *FrameworkElement, _r: **IAsyncOperation(IVectorView(IInspectable))) callconv(.winapi) HRESULT,
    };
};
pub const IListPickerFlyoutPresenter = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListPickerFlyoutPresenter";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "68155fb3-883e-417a-80d0-e2fd88410084";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IListPickerFlyoutStatics = extern struct {
    vtable: *const VTable,
    pub fn getItemsSourceProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemsSourceProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDisplayMemberPathProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DisplayMemberPathProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectionModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedIndexProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedIndexProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedItemProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedItemProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedValueProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedValueProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedValuePathProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedValuePathProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListPickerFlyoutStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "fee25b97-8b96-4602-81d2-82fd8e0f7ea8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ItemsSourceProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ItemTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DisplayMemberPathProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectionModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectedIndexProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectedItemProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectedValueProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectedValuePathProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IListView = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f6ce8c6d-fe96-41ad-a64a-c2b81c4af7f8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IListViewBase = extern struct {
    vtable: *const VTable,
    pub fn getSelectedItems(self: *@This()) core.HResult!*IVector(IInspectable) {
        var _r: *IVector(IInspectable) = undefined;
        const _c = self.vtable.get_SelectedItems(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionMode(self: *@This()) core.HResult!ListViewSelectionMode {
        var _r: ListViewSelectionMode = undefined;
        const _c = self.vtable.get_SelectionMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectionMode(self: *@This(), value: ListViewSelectionMode) core.HResult!void {
        const _c = self.vtable.put_SelectionMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsSwipeEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsSwipeEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsSwipeEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsSwipeEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCanDragItems(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_CanDragItems(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCanDragItems(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_CanDragItems(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCanReorderItems(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_CanReorderItems(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCanReorderItems(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_CanReorderItems(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsItemClickEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsItemClickEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsItemClickEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsItemClickEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDataFetchSize(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_DataFetchSize(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDataFetchSize(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_DataFetchSize(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIncrementalLoadingThreshold(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_IncrementalLoadingThreshold(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIncrementalLoadingThreshold(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_IncrementalLoadingThreshold(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIncrementalLoadingTrigger(self: *@This()) core.HResult!IncrementalLoadingTrigger {
        var _r: IncrementalLoadingTrigger = undefined;
        const _c = self.vtable.get_IncrementalLoadingTrigger(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIncrementalLoadingTrigger(self: *@This(), value: IncrementalLoadingTrigger) core.HResult!void {
        const _c = self.vtable.put_IncrementalLoadingTrigger(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addItemClick(self: *@This(), handler: *ItemClickEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ItemClick(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeItemClick(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ItemClick(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addDragItemsStarting(self: *@This(), handler: *DragItemsStartingEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_DragItemsStarting(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeDragItemsStarting(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_DragItemsStarting(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn ScrollIntoView(self: *@This(), item: *IInspectable) core.HResult!void {
        const _c = self.vtable.ScrollIntoView(@ptrCast(self), item);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn SelectAll(self: *@This()) core.HResult!void {
        const _c = self.vtable.SelectAll(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn LoadMoreItemsAsync(self: *@This()) core.HResult!*IAsyncOperation(LoadMoreItemsResult) {
        var _r: *IAsyncOperation(LoadMoreItemsResult) = undefined;
        const _c = self.vtable.LoadMoreItemsAsync(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn ScrollIntoViewWithAlignment(self: *@This(), item: *IInspectable, alignment: ScrollIntoViewAlignment) core.HResult!void {
        const _c = self.vtable.ScrollIntoViewWithAlignment(@ptrCast(self), item, alignment);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Header(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Header(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_HeaderTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_HeaderTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeaderTransitions(self: *@This()) core.HResult!*TransitionCollection {
        var _r: *TransitionCollection = undefined;
        const _c = self.vtable.get_HeaderTransitions(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderTransitions(self: *@This(), value: *TransitionCollection) core.HResult!void {
        const _c = self.vtable.put_HeaderTransitions(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListViewBase";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3d0813ba-6890-4537-bfe5-796d9458edd6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectedItems: *const fn(self: *anyopaque, _r: **IVector(IInspectable)) callconv(.winapi) HRESULT,
        get_SelectionMode: *const fn(self: *anyopaque, _r: *ListViewSelectionMode) callconv(.winapi) HRESULT,
        put_SelectionMode: *const fn(self: *anyopaque, value: ListViewSelectionMode) callconv(.winapi) HRESULT,
        get_IsSwipeEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsSwipeEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_CanDragItems: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_CanDragItems: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_CanReorderItems: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_CanReorderItems: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsItemClickEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsItemClickEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_DataFetchSize: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_DataFetchSize: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_IncrementalLoadingThreshold: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_IncrementalLoadingThreshold: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_IncrementalLoadingTrigger: *const fn(self: *anyopaque, _r: *IncrementalLoadingTrigger) callconv(.winapi) HRESULT,
        put_IncrementalLoadingTrigger: *const fn(self: *anyopaque, value: IncrementalLoadingTrigger) callconv(.winapi) HRESULT,
        add_ItemClick: *const fn(self: *anyopaque, handler: *ItemClickEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ItemClick: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_DragItemsStarting: *const fn(self: *anyopaque, handler: *DragItemsStartingEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_DragItemsStarting: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        ScrollIntoView: *const fn(self: *anyopaque, item: *IInspectable) callconv(.winapi) HRESULT,
        SelectAll: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        LoadMoreItemsAsync: *const fn(self: *anyopaque, _r: **IAsyncOperation(LoadMoreItemsResult)) callconv(.winapi) HRESULT,
        ScrollIntoViewWithAlignment: *const fn(self: *anyopaque, item: *IInspectable, alignment: ScrollIntoViewAlignment) callconv(.winapi) HRESULT,
        get_Header: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Header: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_HeaderTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_HeaderTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_HeaderTransitions: *const fn(self: *anyopaque, _r: **TransitionCollection) callconv(.winapi) HRESULT,
        put_HeaderTransitions: *const fn(self: *anyopaque, value: *TransitionCollection) callconv(.winapi) HRESULT,
    };
};
pub const IListViewBase2 = extern struct {
    vtable: *const VTable,
    pub fn getShowsScrollingPlaceholders(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_ShowsScrollingPlaceholders(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putShowsScrollingPlaceholders(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_ShowsScrollingPlaceholders(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addContainerContentChanging(self: *@This(), handler: *TypedEventHandler(ListViewBase,ContainerContentChangingEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ContainerContentChanging(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeContainerContentChanging(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ContainerContentChanging(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn SetDesiredContainerUpdateDuration(self: *@This(), duration: TimeSpan) core.HResult!void {
        const _c = self.vtable.SetDesiredContainerUpdateDuration(@ptrCast(self), duration);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFooter(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Footer(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFooter(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Footer(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFooterTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_FooterTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFooterTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_FooterTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFooterTransitions(self: *@This()) core.HResult!*TransitionCollection {
        var _r: *TransitionCollection = undefined;
        const _c = self.vtable.get_FooterTransitions(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFooterTransitions(self: *@This(), value: *TransitionCollection) core.HResult!void {
        const _c = self.vtable.put_FooterTransitions(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListViewBase2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d1c2a4f7-78a3-4491-86e0-2ddebc007ac5";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ShowsScrollingPlaceholders: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_ShowsScrollingPlaceholders: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        add_ContainerContentChanging: *const fn(self: *anyopaque, handler: *TypedEventHandler(ListViewBase,ContainerContentChangingEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ContainerContentChanging: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        SetDesiredContainerUpdateDuration: *const fn(self: *anyopaque, duration: TimeSpan) callconv(.winapi) HRESULT,
        get_Footer: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Footer: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_FooterTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_FooterTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_FooterTransitions: *const fn(self: *anyopaque, _r: **TransitionCollection) callconv(.winapi) HRESULT,
        put_FooterTransitions: *const fn(self: *anyopaque, value: *TransitionCollection) callconv(.winapi) HRESULT,
    };
};
pub const IListViewBase3 = extern struct {
    vtable: *const VTable,
    pub fn getReorderMode(self: *@This()) core.HResult!ListViewReorderMode {
        var _r: ListViewReorderMode = undefined;
        const _c = self.vtable.get_ReorderMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putReorderMode(self: *@This(), value: ListViewReorderMode) core.HResult!void {
        const _c = self.vtable.put_ReorderMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListViewBase3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b364c035-0a13-406f-a3fb-f30e7ddca94c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ReorderMode: *const fn(self: *anyopaque, _r: *ListViewReorderMode) callconv(.winapi) HRESULT,
        put_ReorderMode: *const fn(self: *anyopaque, value: ListViewReorderMode) callconv(.winapi) HRESULT,
    };
};
pub const IListViewBase4 = extern struct {
    vtable: *const VTable,
    pub fn getSelectedRanges(self: *@This()) core.HResult!*IVectorView(ItemIndexRange) {
        var _r: *IVectorView(ItemIndexRange) = undefined;
        const _c = self.vtable.get_SelectedRanges(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsMultiSelectCheckBoxEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsMultiSelectCheckBoxEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsMultiSelectCheckBoxEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsMultiSelectCheckBoxEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addDragItemsCompleted(self: *@This(), handler: *TypedEventHandler(ListViewBase,DragItemsCompletedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_DragItemsCompleted(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeDragItemsCompleted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_DragItemsCompleted(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addChoosingItemContainer(self: *@This(), handler: *TypedEventHandler(ListViewBase,ChoosingItemContainerEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ChoosingItemContainer(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeChoosingItemContainer(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ChoosingItemContainer(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addChoosingGroupHeaderContainer(self: *@This(), handler: *TypedEventHandler(ListViewBase,ChoosingGroupHeaderContainerEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ChoosingGroupHeaderContainer(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeChoosingGroupHeaderContainer(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ChoosingGroupHeaderContainer(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn SelectRange(self: *@This(), itemIndexRange: *ItemIndexRange) core.HResult!void {
        const _c = self.vtable.SelectRange(@ptrCast(self), itemIndexRange);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn DeselectRange(self: *@This(), itemIndexRange: *ItemIndexRange) core.HResult!void {
        const _c = self.vtable.DeselectRange(@ptrCast(self), itemIndexRange);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListViewBase4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "18b7792b-11dc-4eb6-a7bc-741adb3eeb79";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectedRanges: *const fn(self: *anyopaque, _r: **IVectorView(ItemIndexRange)) callconv(.winapi) HRESULT,
        get_IsMultiSelectCheckBoxEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsMultiSelectCheckBoxEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        add_DragItemsCompleted: *const fn(self: *anyopaque, handler: *TypedEventHandler(ListViewBase,DragItemsCompletedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_DragItemsCompleted: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_ChoosingItemContainer: *const fn(self: *anyopaque, handler: *TypedEventHandler(ListViewBase,ChoosingItemContainerEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ChoosingItemContainer: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_ChoosingGroupHeaderContainer: *const fn(self: *anyopaque, handler: *TypedEventHandler(ListViewBase,ChoosingGroupHeaderContainerEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ChoosingGroupHeaderContainer: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        SelectRange: *const fn(self: *anyopaque, itemIndexRange: *ItemIndexRange) callconv(.winapi) HRESULT,
        DeselectRange: *const fn(self: *anyopaque, itemIndexRange: *ItemIndexRange) callconv(.winapi) HRESULT,
    };
};
pub const IListViewBase5 = extern struct {
    vtable: *const VTable,
    pub fn getSingleSelectionFollowsFocus(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_SingleSelectionFollowsFocus(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSingleSelectionFollowsFocus(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_SingleSelectionFollowsFocus(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn IsDragSource(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.IsDragSource(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListViewBase5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1a9c6e99-1719-4b80-b335-628331a07019";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SingleSelectionFollowsFocus: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_SingleSelectionFollowsFocus: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        IsDragSource: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
    };
};
pub const IListViewBase6 = extern struct {
    vtable: *const VTable,
    pub fn TryStartConnectedAnimationAsync(self: *@This(), animation: *ConnectedAnimation, item: *IInspectable, elementName: HSTRING) core.HResult!*IAsyncOperation(bool) {
        var _r: *IAsyncOperation(bool) = undefined;
        const _c = self.vtable.TryStartConnectedAnimationAsync(@ptrCast(self), animation, item, elementName, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn PrepareConnectedAnimation(self: *@This(), key: HSTRING, item: *IInspectable, elementName: HSTRING) core.HResult!*ConnectedAnimation {
        var _r: *ConnectedAnimation = undefined;
        const _c = self.vtable.PrepareConnectedAnimation(@ptrCast(self), key, item, elementName, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListViewBase6";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f8a42637-965b-483b-94e5-e5c9fef0e352";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        TryStartConnectedAnimationAsync: *const fn(self: *anyopaque, animation: *ConnectedAnimation, item: *IInspectable, elementName: HSTRING, _r: **IAsyncOperation(bool)) callconv(.winapi) HRESULT,
        PrepareConnectedAnimation: *const fn(self: *anyopaque, key: HSTRING, item: *IInspectable, elementName: HSTRING, _r: **ConnectedAnimation) callconv(.winapi) HRESULT,
    };
};
pub const IListViewBaseFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ListViewBase {
        var _r: *ListViewBase = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListViewBaseFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e67e6c7f-150f-46d0-a6ac-c5002bd9ca53";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **ListViewBase) callconv(.winapi) HRESULT,
    };
};
pub const IListViewBaseHeaderItem = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListViewBaseHeaderItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6d0ded27-0d19-4091-8917-ce7c85c1e630";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IListViewBaseHeaderItemFactory = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListViewBaseHeaderItemFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3872a6a1-ea19-455f-9df7-147cc41d329c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IListViewBaseStatics = extern struct {
    vtable: *const VTable,
    pub fn getSelectionModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectionModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsSwipeEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsSwipeEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCanDragItemsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CanDragItemsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCanReorderItemsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CanReorderItemsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsItemClickEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsItemClickEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDataFetchSizeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DataFetchSizeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIncrementalLoadingThresholdProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IncrementalLoadingThresholdProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIncrementalLoadingTriggerProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IncrementalLoadingTriggerProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSemanticZoomOwnerProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SemanticZoomOwnerProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsActiveViewProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsActiveViewProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsZoomedInViewProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsZoomedInViewProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderTransitionsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderTransitionsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListViewBaseStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8532b8f7-3e16-455b-89a8-c1346223f6d3";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectionModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsSwipeEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CanDragItemsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CanReorderItemsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsItemClickEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DataFetchSizeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IncrementalLoadingThresholdProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IncrementalLoadingTriggerProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SemanticZoomOwnerProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsActiveViewProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsZoomedInViewProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderTransitionsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IListViewBaseStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getShowsScrollingPlaceholdersProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ShowsScrollingPlaceholdersProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFooterProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FooterProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFooterTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FooterTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFooterTransitionsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FooterTransitionsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListViewBaseStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "821c00c8-78cc-411f-9f2e-a55758227f3e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ShowsScrollingPlaceholdersProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FooterProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FooterTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FooterTransitionsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IListViewBaseStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getReorderModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ReorderModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListViewBaseStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3b539091-31c6-4d0c-90af-5dc1d6ae9c05";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ReorderModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IListViewBaseStatics4 = extern struct {
    vtable: *const VTable,
    pub fn getIsMultiSelectCheckBoxEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsMultiSelectCheckBoxEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListViewBaseStatics4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ad13258b-fbd0-4f18-8bf8-9b8613951c22";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsMultiSelectCheckBoxEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IListViewBaseStatics5 = extern struct {
    vtable: *const VTable,
    pub fn getSingleSelectionFollowsFocusProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SingleSelectionFollowsFocusProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListViewBaseStatics5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "40346fcf-0476-4259-895f-a6569738620f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SingleSelectionFollowsFocusProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IListViewFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ListView {
        var _r: *ListView = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListViewFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "bdff696d-3f22-41f9-97a6-883134a76113";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **ListView) callconv(.winapi) HRESULT,
    };
};
pub const IListViewHeaderItem = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListViewHeaderItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1b61baeb-e196-4b3b-a5f9-1ed636f3f79b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IListViewHeaderItemFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ListViewHeaderItem {
        var _r: *ListViewHeaderItem = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListViewHeaderItemFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "68d2c96a-96b0-4f08-a7a5-f1086720a0fa";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **ListViewHeaderItem) callconv(.winapi) HRESULT,
    };
};
pub const IListViewItem = extern struct {
    vtable: *const VTable,
    pub fn getTemplateSettings(self: *@This()) core.HResult!*ListViewItemTemplateSettings {
        var _r: *ListViewItemTemplateSettings = undefined;
        const _c = self.vtable.get_TemplateSettings(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListViewItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b7bb4305-3dd9-43de-a8c0-c472f085bc11";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TemplateSettings: *const fn(self: *anyopaque, _r: **ListViewItemTemplateSettings) callconv(.winapi) HRESULT,
    };
};
pub const IListViewItemFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ListViewItem {
        var _r: *ListViewItem = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListViewItemFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f431073d-9cac-42a2-82df-0f4490bc4e2e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **ListViewItem) callconv(.winapi) HRESULT,
    };
};
pub const IListViewPersistenceHelper = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListViewPersistenceHelper";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "05bde8a6-2191-4b4b-8c22-9b25676e806e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IListViewPersistenceHelperStatics = extern struct {
    vtable: *const VTable,
    pub fn GetRelativeScrollPosition(self: *@This(), listViewBase: *ListViewBase, itemToKeyHandler: *ListViewItemToKeyHandler) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.GetRelativeScrollPosition(@ptrCast(self), listViewBase, itemToKeyHandler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetRelativeScrollPositionAsync(self: *@This(), listViewBase: *ListViewBase, relativeScrollPosition: HSTRING, keyToItemHandler: *ListViewKeyToItemHandler) core.HResult!*IAsyncAction {
        var _r: *IAsyncAction = undefined;
        const _c = self.vtable.SetRelativeScrollPositionAsync(@ptrCast(self), listViewBase, relativeScrollPosition, keyToItemHandler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IListViewPersistenceHelperStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6d0c2b08-bb9b-44f9-8063-5c3f9c21884b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        GetRelativeScrollPosition: *const fn(self: *anyopaque, listViewBase: *ListViewBase, itemToKeyHandler: *ListViewItemToKeyHandler, _r: *HSTRING) callconv(.winapi) HRESULT,
        SetRelativeScrollPositionAsync: *const fn(self: *anyopaque, listViewBase: *ListViewBase, relativeScrollPosition: HSTRING, keyToItemHandler: *ListViewKeyToItemHandler, _r: **IAsyncAction) callconv(.winapi) HRESULT,
    };
};
pub const IMediaElement = extern struct {
    vtable: *const VTable,
    pub fn getPosterSource(self: *@This()) core.HResult!*ImageSource {
        var _r: *ImageSource = undefined;
        const _c = self.vtable.get_PosterSource(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPosterSource(self: *@This(), value: *ImageSource) core.HResult!void {
        const _c = self.vtable.put_PosterSource(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSource(self: *@This()) core.HResult!*Uri {
        var _r: *Uri = undefined;
        const _c = self.vtable.get_Source(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSource(self: *@This(), value: *Uri) core.HResult!void {
        const _c = self.vtable.put_Source(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsMuted(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsMuted(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsMuted(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsMuted(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsAudioOnly(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsAudioOnly(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getAutoPlay(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_AutoPlay(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putAutoPlay(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_AutoPlay(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getVolume(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_Volume(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putVolume(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_Volume(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBalance(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_Balance(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBalance(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_Balance(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getNaturalVideoHeight(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_NaturalVideoHeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getNaturalVideoWidth(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_NaturalVideoWidth(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getNaturalDuration(self: *@This()) core.HResult!Duration {
        var _r: Duration = undefined;
        const _c = self.vtable.get_NaturalDuration(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPosition(self: *@This()) core.HResult!TimeSpan {
        var _r: TimeSpan = undefined;
        const _c = self.vtable.get_Position(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPosition(self: *@This(), value: TimeSpan) core.HResult!void {
        const _c = self.vtable.put_Position(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDownloadProgress(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_DownloadProgress(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBufferingProgress(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_BufferingProgress(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDownloadProgressOffset(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_DownloadProgressOffset(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCurrentState(self: *@This()) core.HResult!MediaElementState {
        var _r: MediaElementState = undefined;
        const _c = self.vtable.get_CurrentState(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMarkers(self: *@This()) core.HResult!*TimelineMarkerCollection {
        var _r: *TimelineMarkerCollection = undefined;
        const _c = self.vtable.get_Markers(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCanSeek(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_CanSeek(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCanPause(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_CanPause(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getAudioStreamCount(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_AudioStreamCount(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getAudioStreamIndex(self: *@This()) core.HResult!*IReference(i32) {
        var _r: *IReference(i32) = undefined;
        const _c = self.vtable.get_AudioStreamIndex(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putAudioStreamIndex(self: *@This(), value: *IReference(i32)) core.HResult!void {
        const _c = self.vtable.put_AudioStreamIndex(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPlaybackRate(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_PlaybackRate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPlaybackRate(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_PlaybackRate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsLooping(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsLooping(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsLooping(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsLooping(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPlayToSource(self: *@This()) core.HResult!*PlayToSource {
        var _r: *PlayToSource = undefined;
        const _c = self.vtable.get_PlayToSource(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDefaultPlaybackRate(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_DefaultPlaybackRate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDefaultPlaybackRate(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_DefaultPlaybackRate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAspectRatioWidth(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_AspectRatioWidth(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getAspectRatioHeight(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_AspectRatioHeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getRealTimePlayback(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_RealTimePlayback(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putRealTimePlayback(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_RealTimePlayback(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAudioCategory(self: *@This()) core.HResult!AudioCategory {
        var _r: AudioCategory = undefined;
        const _c = self.vtable.get_AudioCategory(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putAudioCategory(self: *@This(), value: AudioCategory) core.HResult!void {
        const _c = self.vtable.put_AudioCategory(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAudioDeviceType(self: *@This()) core.HResult!AudioDeviceType {
        var _r: AudioDeviceType = undefined;
        const _c = self.vtable.get_AudioDeviceType(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putAudioDeviceType(self: *@This(), value: AudioDeviceType) core.HResult!void {
        const _c = self.vtable.put_AudioDeviceType(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getProtectionManager(self: *@This()) core.HResult!*MediaProtectionManager {
        var _r: *MediaProtectionManager = undefined;
        const _c = self.vtable.get_ProtectionManager(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putProtectionManager(self: *@This(), value: *MediaProtectionManager) core.HResult!void {
        const _c = self.vtable.put_ProtectionManager(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getStereo3DVideoPackingMode(self: *@This()) core.HResult!Stereo3DVideoPackingMode {
        var _r: Stereo3DVideoPackingMode = undefined;
        const _c = self.vtable.get_Stereo3DVideoPackingMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putStereo3DVideoPackingMode(self: *@This(), value: Stereo3DVideoPackingMode) core.HResult!void {
        const _c = self.vtable.put_Stereo3DVideoPackingMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getStereo3DVideoRenderMode(self: *@This()) core.HResult!Stereo3DVideoRenderMode {
        var _r: Stereo3DVideoRenderMode = undefined;
        const _c = self.vtable.get_Stereo3DVideoRenderMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putStereo3DVideoRenderMode(self: *@This(), value: Stereo3DVideoRenderMode) core.HResult!void {
        const _c = self.vtable.put_Stereo3DVideoRenderMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsStereo3DVideo(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsStereo3DVideo(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addMediaOpened(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_MediaOpened(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeMediaOpened(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_MediaOpened(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addMediaEnded(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_MediaEnded(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeMediaEnded(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_MediaEnded(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addMediaFailed(self: *@This(), handler: *ExceptionRoutedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_MediaFailed(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeMediaFailed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_MediaFailed(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addDownloadProgressChanged(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_DownloadProgressChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeDownloadProgressChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_DownloadProgressChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addBufferingProgressChanged(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_BufferingProgressChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeBufferingProgressChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_BufferingProgressChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addCurrentStateChanged(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_CurrentStateChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeCurrentStateChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_CurrentStateChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addMarkerReached(self: *@This(), handler: *TimelineMarkerRoutedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_MarkerReached(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeMarkerReached(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_MarkerReached(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addRateChanged(self: *@This(), handler: *RateChangedRoutedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_RateChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeRateChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_RateChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addVolumeChanged(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_VolumeChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeVolumeChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_VolumeChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addSeekCompleted(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_SeekCompleted(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeSeekCompleted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_SeekCompleted(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Stop(self: *@This()) core.HResult!void {
        const _c = self.vtable.Stop(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Play(self: *@This()) core.HResult!void {
        const _c = self.vtable.Play(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Pause(self: *@This()) core.HResult!void {
        const _c = self.vtable.Pause(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn CanPlayType(self: *@This(), ty: HSTRING) core.HResult!MediaCanPlayResponse {
        var _r: MediaCanPlayResponse = undefined;
        const _c = self.vtable.CanPlayType(@ptrCast(self), ty, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetSource(self: *@This(), stream: *IRandomAccessStream, mimeType: HSTRING) core.HResult!void {
        const _c = self.vtable.SetSource(@ptrCast(self), stream, mimeType);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn GetAudioStreamLanguage(self: *@This(), index: *IReference(i32)) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.GetAudioStreamLanguage(@ptrCast(self), index, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn AddAudioEffect(self: *@This(), effectID: HSTRING, effectOptional: bool, effectConfiguration: *IPropertySet) core.HResult!void {
        const _c = self.vtable.AddAudioEffect(@ptrCast(self), effectID, effectOptional, effectConfiguration);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn AddVideoEffect(self: *@This(), effectID: HSTRING, effectOptional: bool, effectConfiguration: *IPropertySet) core.HResult!void {
        const _c = self.vtable.AddVideoEffect(@ptrCast(self), effectID, effectOptional, effectConfiguration);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn RemoveAllEffects(self: *@This()) core.HResult!void {
        const _c = self.vtable.RemoveAllEffects(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getActualStereo3DVideoPackingMode(self: *@This()) core.HResult!Stereo3DVideoPackingMode {
        var _r: Stereo3DVideoPackingMode = undefined;
        const _c = self.vtable.get_ActualStereo3DVideoPackingMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMediaElement";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a38ed2cf-13de-4299-ade2-ae18f74ed353";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PosterSource: *const fn(self: *anyopaque, _r: **ImageSource) callconv(.winapi) HRESULT,
        put_PosterSource: *const fn(self: *anyopaque, value: *ImageSource) callconv(.winapi) HRESULT,
        get_Source: *const fn(self: *anyopaque, _r: **Uri) callconv(.winapi) HRESULT,
        put_Source: *const fn(self: *anyopaque, value: *Uri) callconv(.winapi) HRESULT,
        get_IsMuted: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsMuted: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsAudioOnly: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_AutoPlay: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_AutoPlay: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_Volume: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_Volume: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_Balance: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_Balance: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_NaturalVideoHeight: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_NaturalVideoWidth: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_NaturalDuration: *const fn(self: *anyopaque, _r: *Duration) callconv(.winapi) HRESULT,
        get_Position: *const fn(self: *anyopaque, _r: *TimeSpan) callconv(.winapi) HRESULT,
        put_Position: *const fn(self: *anyopaque, value: TimeSpan) callconv(.winapi) HRESULT,
        get_DownloadProgress: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        get_BufferingProgress: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        get_DownloadProgressOffset: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        get_CurrentState: *const fn(self: *anyopaque, _r: *MediaElementState) callconv(.winapi) HRESULT,
        get_Markers: *const fn(self: *anyopaque, _r: **TimelineMarkerCollection) callconv(.winapi) HRESULT,
        get_CanSeek: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_CanPause: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_AudioStreamCount: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_AudioStreamIndex: *const fn(self: *anyopaque, _r: **IReference(i32)) callconv(.winapi) HRESULT,
        put_AudioStreamIndex: *const fn(self: *anyopaque, value: *IReference(i32)) callconv(.winapi) HRESULT,
        get_PlaybackRate: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_PlaybackRate: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_IsLooping: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsLooping: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_PlayToSource: *const fn(self: *anyopaque, _r: **PlayToSource) callconv(.winapi) HRESULT,
        get_DefaultPlaybackRate: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_DefaultPlaybackRate: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_AspectRatioWidth: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_AspectRatioHeight: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_RealTimePlayback: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_RealTimePlayback: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_AudioCategory: *const fn(self: *anyopaque, _r: *AudioCategory) callconv(.winapi) HRESULT,
        put_AudioCategory: *const fn(self: *anyopaque, value: AudioCategory) callconv(.winapi) HRESULT,
        get_AudioDeviceType: *const fn(self: *anyopaque, _r: *AudioDeviceType) callconv(.winapi) HRESULT,
        put_AudioDeviceType: *const fn(self: *anyopaque, value: AudioDeviceType) callconv(.winapi) HRESULT,
        get_ProtectionManager: *const fn(self: *anyopaque, _r: **MediaProtectionManager) callconv(.winapi) HRESULT,
        put_ProtectionManager: *const fn(self: *anyopaque, value: *MediaProtectionManager) callconv(.winapi) HRESULT,
        get_Stereo3DVideoPackingMode: *const fn(self: *anyopaque, _r: *Stereo3DVideoPackingMode) callconv(.winapi) HRESULT,
        put_Stereo3DVideoPackingMode: *const fn(self: *anyopaque, value: Stereo3DVideoPackingMode) callconv(.winapi) HRESULT,
        get_Stereo3DVideoRenderMode: *const fn(self: *anyopaque, _r: *Stereo3DVideoRenderMode) callconv(.winapi) HRESULT,
        put_Stereo3DVideoRenderMode: *const fn(self: *anyopaque, value: Stereo3DVideoRenderMode) callconv(.winapi) HRESULT,
        get_IsStereo3DVideo: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        add_MediaOpened: *const fn(self: *anyopaque, handler: *RoutedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_MediaOpened: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_MediaEnded: *const fn(self: *anyopaque, handler: *RoutedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_MediaEnded: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_MediaFailed: *const fn(self: *anyopaque, handler: *ExceptionRoutedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_MediaFailed: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_DownloadProgressChanged: *const fn(self: *anyopaque, handler: *RoutedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_DownloadProgressChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_BufferingProgressChanged: *const fn(self: *anyopaque, handler: *RoutedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_BufferingProgressChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_CurrentStateChanged: *const fn(self: *anyopaque, handler: *RoutedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_CurrentStateChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_MarkerReached: *const fn(self: *anyopaque, handler: *TimelineMarkerRoutedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_MarkerReached: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_RateChanged: *const fn(self: *anyopaque, handler: *RateChangedRoutedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_RateChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_VolumeChanged: *const fn(self: *anyopaque, handler: *RoutedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_VolumeChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_SeekCompleted: *const fn(self: *anyopaque, handler: *RoutedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_SeekCompleted: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        Stop: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        Play: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        Pause: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        CanPlayType: *const fn(self: *anyopaque, ty: HSTRING, _r: *MediaCanPlayResponse) callconv(.winapi) HRESULT,
        SetSource: *const fn(self: *anyopaque, stream: *IRandomAccessStream, mimeType: HSTRING) callconv(.winapi) HRESULT,
        GetAudioStreamLanguage: *const fn(self: *anyopaque, index: *IReference(i32), _r: *HSTRING) callconv(.winapi) HRESULT,
        AddAudioEffect: *const fn(self: *anyopaque, effectID: HSTRING, effectOptional: bool, effectConfiguration: *IPropertySet) callconv(.winapi) HRESULT,
        AddVideoEffect: *const fn(self: *anyopaque, effectID: HSTRING, effectOptional: bool, effectConfiguration: *IPropertySet) callconv(.winapi) HRESULT,
        RemoveAllEffects: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        get_ActualStereo3DVideoPackingMode: *const fn(self: *anyopaque, _r: *Stereo3DVideoPackingMode) callconv(.winapi) HRESULT,
    };
};
pub const IMediaElement2 = extern struct {
    vtable: *const VTable,
    pub fn getAreTransportControlsEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_AreTransportControlsEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putAreTransportControlsEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_AreTransportControlsEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getStretch(self: *@This()) core.HResult!Stretch {
        var _r: Stretch = undefined;
        const _c = self.vtable.get_Stretch(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putStretch(self: *@This(), value: Stretch) core.HResult!void {
        const _c = self.vtable.put_Stretch(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsFullWindow(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsFullWindow(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsFullWindow(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsFullWindow(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn SetMediaStreamSource(self: *@This(), source: *IMediaSource) core.HResult!void {
        const _c = self.vtable.SetMediaStreamSource(@ptrCast(self), source);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPlayToPreferredSourceUri(self: *@This()) core.HResult!*Uri {
        var _r: *Uri = undefined;
        const _c = self.vtable.get_PlayToPreferredSourceUri(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPlayToPreferredSourceUri(self: *@This(), value: *Uri) core.HResult!void {
        const _c = self.vtable.put_PlayToPreferredSourceUri(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMediaElement2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "fd53da65-b186-4654-bfdb-180ed26cad07";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_AreTransportControlsEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_AreTransportControlsEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_Stretch: *const fn(self: *anyopaque, _r: *Stretch) callconv(.winapi) HRESULT,
        put_Stretch: *const fn(self: *anyopaque, value: Stretch) callconv(.winapi) HRESULT,
        get_IsFullWindow: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsFullWindow: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        SetMediaStreamSource: *const fn(self: *anyopaque, source: *IMediaSource) callconv(.winapi) HRESULT,
        get_PlayToPreferredSourceUri: *const fn(self: *anyopaque, _r: **Uri) callconv(.winapi) HRESULT,
        put_PlayToPreferredSourceUri: *const fn(self: *anyopaque, value: *Uri) callconv(.winapi) HRESULT,
    };
};
pub const IMediaElement3 = extern struct {
    vtable: *const VTable,
    pub fn getTransportControls(self: *@This()) core.HResult!*MediaTransportControls {
        var _r: *MediaTransportControls = undefined;
        const _c = self.vtable.get_TransportControls(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTransportControls(self: *@This(), value: *MediaTransportControls) core.HResult!void {
        const _c = self.vtable.put_TransportControls(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addPartialMediaFailureDetected(self: *@This(), handler: *TypedEventHandler(MediaElement,PartialMediaFailureDetectedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_PartialMediaFailureDetected(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removePartialMediaFailureDetected(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_PartialMediaFailureDetected(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn SetPlaybackSource(self: *@This(), source: *IMediaPlaybackSource) core.HResult!void {
        const _c = self.vtable.SetPlaybackSource(@ptrCast(self), source);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn GetAsCastingSource(self: *@This()) core.HResult!*CastingSource {
        var _r: *CastingSource = undefined;
        const _c = self.vtable.GetAsCastingSource(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMediaElement3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "479f6f13-0fdb-4ed8-928a-4d39169c3cd2";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TransportControls: *const fn(self: *anyopaque, _r: **MediaTransportControls) callconv(.winapi) HRESULT,
        put_TransportControls: *const fn(self: *anyopaque, value: *MediaTransportControls) callconv(.winapi) HRESULT,
        add_PartialMediaFailureDetected: *const fn(self: *anyopaque, handler: *TypedEventHandler(MediaElement,PartialMediaFailureDetectedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_PartialMediaFailureDetected: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        SetPlaybackSource: *const fn(self: *anyopaque, source: *IMediaPlaybackSource) callconv(.winapi) HRESULT,
        GetAsCastingSource: *const fn(self: *anyopaque, _r: **CastingSource) callconv(.winapi) HRESULT,
    };
};
pub const IMediaElementStatics = extern struct {
    vtable: *const VTable,
    pub fn getPosterSourceProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PosterSourceProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSourceProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SourceProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsMutedProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsMutedProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsAudioOnlyProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsAudioOnlyProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getAutoPlayProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AutoPlayProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getVolumeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_VolumeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBalanceProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BalanceProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getNaturalVideoHeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_NaturalVideoHeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getNaturalVideoWidthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_NaturalVideoWidthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getNaturalDurationProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_NaturalDurationProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPositionProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PositionProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDownloadProgressProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DownloadProgressProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBufferingProgressProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BufferingProgressProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDownloadProgressOffsetProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DownloadProgressOffsetProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCurrentStateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CurrentStateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCanSeekProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CanSeekProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCanPauseProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CanPauseProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getAudioStreamCountProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AudioStreamCountProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getAudioStreamIndexProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AudioStreamIndexProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPlaybackRateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlaybackRateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsLoopingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsLoopingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPlayToSourceProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlayToSourceProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDefaultPlaybackRateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DefaultPlaybackRateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getAspectRatioWidthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AspectRatioWidthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getAspectRatioHeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AspectRatioHeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getRealTimePlaybackProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_RealTimePlaybackProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getAudioCategoryProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AudioCategoryProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getAudioDeviceTypeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AudioDeviceTypeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getProtectionManagerProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ProtectionManagerProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getStereo3DVideoPackingModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_Stereo3DVideoPackingModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getStereo3DVideoRenderModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_Stereo3DVideoRenderModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsStereo3DVideoProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsStereo3DVideoProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getActualStereo3DVideoPackingModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ActualStereo3DVideoPackingModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMediaElementStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "dccd2cb9-7568-4682-a72a-8ddf2a2665ca";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PosterSourceProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SourceProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsMutedProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsAudioOnlyProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_AutoPlayProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_VolumeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BalanceProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_NaturalVideoHeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_NaturalVideoWidthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_NaturalDurationProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PositionProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DownloadProgressProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BufferingProgressProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DownloadProgressOffsetProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CurrentStateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CanSeekProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CanPauseProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_AudioStreamCountProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_AudioStreamIndexProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PlaybackRateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsLoopingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PlayToSourceProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DefaultPlaybackRateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_AspectRatioWidthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_AspectRatioHeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_RealTimePlaybackProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_AudioCategoryProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_AudioDeviceTypeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ProtectionManagerProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_Stereo3DVideoPackingModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_Stereo3DVideoRenderModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsStereo3DVideoProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ActualStereo3DVideoPackingModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IMediaElementStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getAreTransportControlsEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AreTransportControlsEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getStretchProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_StretchProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsFullWindowProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsFullWindowProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPlayToPreferredSourceUriProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlayToPreferredSourceUriProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMediaElementStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9ee7f826-f154-4dc6-8014-a6eba987f847";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_AreTransportControlsEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_StretchProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsFullWindowProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PlayToPreferredSourceUriProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IMediaPlayerElement = extern struct {
    vtable: *const VTable,
    pub fn getSource(self: *@This()) core.HResult!*IMediaPlaybackSource {
        var _r: *IMediaPlaybackSource = undefined;
        const _c = self.vtable.get_Source(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSource(self: *@This(), value: *IMediaPlaybackSource) core.HResult!void {
        const _c = self.vtable.put_Source(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTransportControls(self: *@This()) core.HResult!*MediaTransportControls {
        var _r: *MediaTransportControls = undefined;
        const _c = self.vtable.get_TransportControls(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTransportControls(self: *@This(), value: *MediaTransportControls) core.HResult!void {
        const _c = self.vtable.put_TransportControls(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAreTransportControlsEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_AreTransportControlsEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putAreTransportControlsEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_AreTransportControlsEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPosterSource(self: *@This()) core.HResult!*ImageSource {
        var _r: *ImageSource = undefined;
        const _c = self.vtable.get_PosterSource(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPosterSource(self: *@This(), value: *ImageSource) core.HResult!void {
        const _c = self.vtable.put_PosterSource(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getStretch(self: *@This()) core.HResult!Stretch {
        var _r: Stretch = undefined;
        const _c = self.vtable.get_Stretch(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putStretch(self: *@This(), value: Stretch) core.HResult!void {
        const _c = self.vtable.put_Stretch(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAutoPlay(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_AutoPlay(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putAutoPlay(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_AutoPlay(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsFullWindow(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsFullWindow(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsFullWindow(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsFullWindow(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMediaPlayer(self: *@This()) core.HResult!*MediaPlayer {
        var _r: *MediaPlayer = undefined;
        const _c = self.vtable.get_MediaPlayer(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetMediaPlayer(self: *@This(), mediaPlayer: *MediaPlayer) core.HResult!void {
        const _c = self.vtable.SetMediaPlayer(@ptrCast(self), mediaPlayer);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMediaPlayerElement";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3b4ca526-2e25-4598-bc71-d491f8e8de39";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Source: *const fn(self: *anyopaque, _r: **IMediaPlaybackSource) callconv(.winapi) HRESULT,
        put_Source: *const fn(self: *anyopaque, value: *IMediaPlaybackSource) callconv(.winapi) HRESULT,
        get_TransportControls: *const fn(self: *anyopaque, _r: **MediaTransportControls) callconv(.winapi) HRESULT,
        put_TransportControls: *const fn(self: *anyopaque, value: *MediaTransportControls) callconv(.winapi) HRESULT,
        get_AreTransportControlsEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_AreTransportControlsEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_PosterSource: *const fn(self: *anyopaque, _r: **ImageSource) callconv(.winapi) HRESULT,
        put_PosterSource: *const fn(self: *anyopaque, value: *ImageSource) callconv(.winapi) HRESULT,
        get_Stretch: *const fn(self: *anyopaque, _r: *Stretch) callconv(.winapi) HRESULT,
        put_Stretch: *const fn(self: *anyopaque, value: Stretch) callconv(.winapi) HRESULT,
        get_AutoPlay: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_AutoPlay: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsFullWindow: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsFullWindow: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_MediaPlayer: *const fn(self: *anyopaque, _r: **MediaPlayer) callconv(.winapi) HRESULT,
        SetMediaPlayer: *const fn(self: *anyopaque, mediaPlayer: *MediaPlayer) callconv(.winapi) HRESULT,
    };
};
pub const IMediaPlayerElementFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*MediaPlayerElement {
        var _r: *MediaPlayerElement = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMediaPlayerElementFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "77e525c3-eb17-4b8d-889d-1ea8abdbd4ef";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **MediaPlayerElement) callconv(.winapi) HRESULT,
    };
};
pub const IMediaPlayerElementStatics = extern struct {
    vtable: *const VTable,
    pub fn getSourceProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SourceProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getAreTransportControlsEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AreTransportControlsEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPosterSourceProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PosterSourceProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getStretchProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_StretchProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getAutoPlayProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AutoPlayProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsFullWindowProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsFullWindowProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMediaPlayerProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MediaPlayerProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMediaPlayerElementStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1e7c4020-ac57-42dd-ad1c-3ebc2d7f08ba";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SourceProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_AreTransportControlsEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PosterSourceProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_StretchProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_AutoPlayProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsFullWindowProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MediaPlayerProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IMediaPlayerPresenter = extern struct {
    vtable: *const VTable,
    pub fn getMediaPlayer(self: *@This()) core.HResult!*MediaPlayer {
        var _r: *MediaPlayer = undefined;
        const _c = self.vtable.get_MediaPlayer(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMediaPlayer(self: *@This(), value: *MediaPlayer) core.HResult!void {
        const _c = self.vtable.put_MediaPlayer(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getStretch(self: *@This()) core.HResult!Stretch {
        var _r: Stretch = undefined;
        const _c = self.vtable.get_Stretch(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putStretch(self: *@This(), value: Stretch) core.HResult!void {
        const _c = self.vtable.put_Stretch(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsFullWindow(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsFullWindow(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsFullWindow(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsFullWindow(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMediaPlayerPresenter";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "77a92326-0c5b-41fc-bf49-15f6c3524b6b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_MediaPlayer: *const fn(self: *anyopaque, _r: **MediaPlayer) callconv(.winapi) HRESULT,
        put_MediaPlayer: *const fn(self: *anyopaque, value: *MediaPlayer) callconv(.winapi) HRESULT,
        get_Stretch: *const fn(self: *anyopaque, _r: *Stretch) callconv(.winapi) HRESULT,
        put_Stretch: *const fn(self: *anyopaque, value: Stretch) callconv(.winapi) HRESULT,
        get_IsFullWindow: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsFullWindow: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IMediaPlayerPresenterFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*MediaPlayerPresenter {
        var _r: *MediaPlayerPresenter = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMediaPlayerPresenterFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e6766fb7-d96f-4b95-b33c-59e81cb1e9ba";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **MediaPlayerPresenter) callconv(.winapi) HRESULT,
    };
};
pub const IMediaPlayerPresenterStatics = extern struct {
    vtable: *const VTable,
    pub fn getMediaPlayerProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MediaPlayerProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getStretchProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_StretchProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsFullWindowProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsFullWindowProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMediaPlayerPresenterStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "84d774fe-ead4-4957-b42b-223158ca0de7";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_MediaPlayerProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_StretchProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsFullWindowProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IMediaTransportControls = extern struct {
    vtable: *const VTable,
    pub fn getIsFullWindowButtonVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsFullWindowButtonVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsFullWindowButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsFullWindowButtonVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsFullWindowEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsFullWindowEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsFullWindowEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsFullWindowEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsZoomButtonVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsZoomButtonVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsZoomButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsZoomButtonVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsZoomEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsZoomEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsZoomEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsZoomEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsFastForwardButtonVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsFastForwardButtonVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsFastForwardButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsFastForwardButtonVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsFastForwardEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsFastForwardEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsFastForwardEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsFastForwardEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsFastRewindButtonVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsFastRewindButtonVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsFastRewindButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsFastRewindButtonVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsFastRewindEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsFastRewindEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsFastRewindEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsFastRewindEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsStopButtonVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsStopButtonVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsStopButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsStopButtonVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsStopEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsStopEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsStopEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsStopEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsVolumeButtonVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsVolumeButtonVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsVolumeButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsVolumeButtonVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsVolumeEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsVolumeEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsVolumeEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsVolumeEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsPlaybackRateButtonVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsPlaybackRateButtonVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsPlaybackRateButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsPlaybackRateButtonVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsPlaybackRateEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsPlaybackRateEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsPlaybackRateEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsPlaybackRateEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsSeekBarVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsSeekBarVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsSeekBarVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsSeekBarVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsSeekEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsSeekEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsSeekEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsSeekEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsCompact(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsCompact(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsCompact(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsCompact(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMediaTransportControls";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d6f69e7d-0825-49a9-9fce-5586d8694f0c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsFullWindowButtonVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsFullWindowButtonVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsFullWindowEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsFullWindowEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsZoomButtonVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsZoomButtonVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsZoomEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsZoomEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsFastForwardButtonVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsFastForwardButtonVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsFastForwardEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsFastForwardEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsFastRewindButtonVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsFastRewindButtonVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsFastRewindEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsFastRewindEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsStopButtonVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsStopButtonVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsStopEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsStopEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsVolumeButtonVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsVolumeButtonVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsVolumeEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsVolumeEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsPlaybackRateButtonVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsPlaybackRateButtonVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsPlaybackRateEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsPlaybackRateEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsSeekBarVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsSeekBarVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsSeekEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsSeekEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsCompact: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsCompact: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IMediaTransportControls2 = extern struct {
    vtable: *const VTable,
    pub fn getIsSkipForwardButtonVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsSkipForwardButtonVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsSkipForwardButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsSkipForwardButtonVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsSkipForwardEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsSkipForwardEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsSkipForwardEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsSkipForwardEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsSkipBackwardButtonVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsSkipBackwardButtonVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsSkipBackwardButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsSkipBackwardButtonVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsSkipBackwardEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsSkipBackwardEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsSkipBackwardEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsSkipBackwardEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsNextTrackButtonVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsNextTrackButtonVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsNextTrackButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsNextTrackButtonVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsPreviousTrackButtonVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsPreviousTrackButtonVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsPreviousTrackButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsPreviousTrackButtonVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFastPlayFallbackBehaviour(self: *@This()) core.HResult!FastPlayFallbackBehaviour {
        var _r: FastPlayFallbackBehaviour = undefined;
        const _c = self.vtable.get_FastPlayFallbackBehaviour(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFastPlayFallbackBehaviour(self: *@This(), value: FastPlayFallbackBehaviour) core.HResult!void {
        const _c = self.vtable.put_FastPlayFallbackBehaviour(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addThumbnailRequested(self: *@This(), handler: *TypedEventHandler(MediaTransportControls,MediaTransportControlsThumbnailRequestedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ThumbnailRequested(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeThumbnailRequested(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ThumbnailRequested(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMediaTransportControls2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "2b89efec-1bea-451e-8bcd-cfe2d9423262";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsSkipForwardButtonVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsSkipForwardButtonVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsSkipForwardEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsSkipForwardEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsSkipBackwardButtonVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsSkipBackwardButtonVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsSkipBackwardEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsSkipBackwardEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsNextTrackButtonVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsNextTrackButtonVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsPreviousTrackButtonVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsPreviousTrackButtonVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_FastPlayFallbackBehaviour: *const fn(self: *anyopaque, _r: *FastPlayFallbackBehaviour) callconv(.winapi) HRESULT,
        put_FastPlayFallbackBehaviour: *const fn(self: *anyopaque, value: FastPlayFallbackBehaviour) callconv(.winapi) HRESULT,
        add_ThumbnailRequested: *const fn(self: *anyopaque, handler: *TypedEventHandler(MediaTransportControls,MediaTransportControlsThumbnailRequestedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ThumbnailRequested: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IMediaTransportControls3 = extern struct {
    vtable: *const VTable,
    pub fn getShowAndHideAutomatically(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_ShowAndHideAutomatically(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putShowAndHideAutomatically(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_ShowAndHideAutomatically(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsRepeatEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsRepeatEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsRepeatEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsRepeatEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsRepeatButtonVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsRepeatButtonVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsRepeatButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsRepeatButtonVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Show(self: *@This()) core.HResult!void {
        const _c = self.vtable.Show(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Hide(self: *@This()) core.HResult!void {
        const _c = self.vtable.Hide(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMediaTransportControls3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5086430e-0940-11e7-93ae-92361f002671";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ShowAndHideAutomatically: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_ShowAndHideAutomatically: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsRepeatEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsRepeatEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsRepeatButtonVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsRepeatButtonVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        Show: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        Hide: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
    };
};
pub const IMediaTransportControls4 = extern struct {
    vtable: *const VTable,
    pub fn getIsCompactOverlayButtonVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsCompactOverlayButtonVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsCompactOverlayButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsCompactOverlayButtonVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsCompactOverlayEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsCompactOverlayEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsCompactOverlayEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsCompactOverlayEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMediaTransportControls4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0fb17c58-9f23-11e7-abc4-cec278b6b50a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsCompactOverlayButtonVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsCompactOverlayButtonVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsCompactOverlayEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsCompactOverlayEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IMediaTransportControlsFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*MediaTransportControls {
        var _r: *MediaTransportControls = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMediaTransportControlsFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1da2015a-a8e4-4c1b-88c9-0b183ecc62e3";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **MediaTransportControls) callconv(.winapi) HRESULT,
    };
};
pub const IMediaTransportControlsHelper = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMediaTransportControlsHelper";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3d41d509-ff44-4420-807e-8f7a2e2c4251";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IMediaTransportControlsHelperStatics = extern struct {
    vtable: *const VTable,
    pub fn getDropoutOrderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DropoutOrderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetDropoutOrder(self: *@This(), element: *UIElement) core.HResult!*IReference(i32) {
        var _r: *IReference(i32) = undefined;
        const _c = self.vtable.GetDropoutOrder(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetDropoutOrder(self: *@This(), element: *UIElement, value: *IReference(i32)) core.HResult!void {
        const _c = self.vtable.SetDropoutOrder(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMediaTransportControlsHelperStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5a772047-a9a1-4625-9270-7f49875d4394";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_DropoutOrderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetDropoutOrder: *const fn(self: *anyopaque, element: *UIElement, _r: **IReference(i32)) callconv(.winapi) HRESULT,
        SetDropoutOrder: *const fn(self: *anyopaque, element: *UIElement, value: *IReference(i32)) callconv(.winapi) HRESULT,
    };
};
pub const IMediaTransportControlsStatics = extern struct {
    vtable: *const VTable,
    pub fn getIsFullWindowButtonVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsFullWindowButtonVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsFullWindowEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsFullWindowEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsZoomButtonVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsZoomButtonVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsZoomEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsZoomEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsFastForwardButtonVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsFastForwardButtonVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsFastForwardEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsFastForwardEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsFastRewindButtonVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsFastRewindButtonVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsFastRewindEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsFastRewindEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsStopButtonVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsStopButtonVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsStopEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsStopEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsVolumeButtonVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsVolumeButtonVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsVolumeEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsVolumeEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsPlaybackRateButtonVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsPlaybackRateButtonVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsPlaybackRateEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsPlaybackRateEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsSeekBarVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsSeekBarVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsSeekEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsSeekEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsCompactProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsCompactProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMediaTransportControlsStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "590ea907-d2ef-4c1a-9429-b4b15d64fd56";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsFullWindowButtonVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsFullWindowEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsZoomButtonVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsZoomEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsFastForwardButtonVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsFastForwardEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsFastRewindButtonVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsFastRewindEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsStopButtonVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsStopEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsVolumeButtonVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsVolumeEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsPlaybackRateButtonVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsPlaybackRateEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsSeekBarVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsSeekEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsCompactProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IMediaTransportControlsStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getIsSkipForwardButtonVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsSkipForwardButtonVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsSkipForwardEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsSkipForwardEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsSkipBackwardButtonVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsSkipBackwardButtonVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsSkipBackwardEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsSkipBackwardEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsNextTrackButtonVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsNextTrackButtonVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsPreviousTrackButtonVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsPreviousTrackButtonVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFastPlayFallbackBehaviourProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FastPlayFallbackBehaviourProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMediaTransportControlsStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1728cfdc-561f-4386-a7f8-090d95f68d96";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsSkipForwardButtonVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsSkipForwardEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsSkipBackwardButtonVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsSkipBackwardEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsNextTrackButtonVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsPreviousTrackButtonVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FastPlayFallbackBehaviourProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IMediaTransportControlsStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getShowAndHideAutomaticallyProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ShowAndHideAutomaticallyProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsRepeatEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsRepeatEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsRepeatButtonVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsRepeatButtonVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMediaTransportControlsStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5fe05542-0940-11e7-93ae-92361f002671";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ShowAndHideAutomaticallyProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsRepeatEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsRepeatButtonVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IMediaTransportControlsStatics4 = extern struct {
    vtable: *const VTable,
    pub fn getIsCompactOverlayButtonVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsCompactOverlayButtonVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsCompactOverlayEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsCompactOverlayEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMediaTransportControlsStatics4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0fb18144-9f23-11e7-abc4-cec278b6b50a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsCompactOverlayButtonVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsCompactOverlayEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IMenuBar = extern struct {
    vtable: *const VTable,
    pub fn getItems(self: *@This()) core.HResult!*IVector(MenuBarItem) {
        var _r: *IVector(MenuBarItem) = undefined;
        const _c = self.vtable.get_Items(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuBar";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c8f67b0c-0e76-5af2-bade-785049c80a41";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Items: *const fn(self: *anyopaque, _r: **IVector(MenuBarItem)) callconv(.winapi) HRESULT,
    };
};
pub const IMenuBarFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*MenuBar {
        var _r: *MenuBar = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuBarFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "dc619e50-72ba-513f-80aa-ddd093825dde";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **MenuBar) callconv(.winapi) HRESULT,
    };
};
pub const IMenuBarItem = extern struct {
    vtable: *const VTable,
    pub fn getTitle(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Title(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTitle(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_Title(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getItems(self: *@This()) core.HResult!*IVector(MenuFlyoutItemBase) {
        var _r: *IVector(MenuFlyoutItemBase) = undefined;
        const _c = self.vtable.get_Items(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuBarItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "bf643b4c-8125-5b53-a454-06e896a5acee";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Title: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_Title: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_Items: *const fn(self: *anyopaque, _r: **IVector(MenuFlyoutItemBase)) callconv(.winapi) HRESULT,
    };
};
pub const IMenuBarItemFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*MenuBarItem {
        var _r: *MenuBarItem = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuBarItemFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ecf86f62-c394-50e2-a568-17af8cf26874";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **MenuBarItem) callconv(.winapi) HRESULT,
    };
};
pub const IMenuBarItemFlyout = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuBarItemFlyout";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ed00d2d8-b686-55fe-8dbb-f04a640e42ef";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IMenuBarItemFlyoutFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*MenuBarItemFlyout {
        var _r: *MenuBarItemFlyout = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuBarItemFlyoutFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1d24f9bd-bd19-5d95-b573-711f649fcbe9";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **MenuBarItemFlyout) callconv(.winapi) HRESULT,
    };
};
pub const IMenuBarItemStatics = extern struct {
    vtable: *const VTable,
    pub fn getTitleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TitleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuBarItemStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "60a9e3fb-b405-50d0-bb78-d396a34da267";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TitleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ItemsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IMenuBarStatics = extern struct {
    vtable: *const VTable,
    pub fn getItemsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuBarStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "bed31c25-7db8-51cc-9706-1d79327daf93";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ItemsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyout = extern struct {
    vtable: *const VTable,
    pub fn getItems(self: *@This()) core.HResult!*IVector(MenuFlyoutItemBase) {
        var _r: *IVector(MenuFlyoutItemBase) = undefined;
        const _c = self.vtable.get_Items(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMenuFlyoutPresenterStyle(self: *@This()) core.HResult!*Style {
        var _r: *Style = undefined;
        const _c = self.vtable.get_MenuFlyoutPresenterStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMenuFlyoutPresenterStyle(self: *@This(), value: *Style) core.HResult!void {
        const _c = self.vtable.put_MenuFlyoutPresenterStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyout";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ad3210f1-985b-4171-bbba-67bcc729649b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Items: *const fn(self: *anyopaque, _r: **IVector(MenuFlyoutItemBase)) callconv(.winapi) HRESULT,
        get_MenuFlyoutPresenterStyle: *const fn(self: *anyopaque, _r: **Style) callconv(.winapi) HRESULT,
        put_MenuFlyoutPresenterStyle: *const fn(self: *anyopaque, value: *Style) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyout2 = extern struct {
    vtable: *const VTable,
    pub fn ShowAt(self: *@This(), targetElement: *UIElement, point: Point) core.HResult!void {
        const _c = self.vtable.ShowAt(@ptrCast(self), targetElement, point);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyout2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "507c7bad-d9d1-4c05-9d4b-cda8de9ab242";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        ShowAt: *const fn(self: *anyopaque, targetElement: *UIElement, point: Point) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyoutFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*MenuFlyout {
        var _r: *MenuFlyout = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyoutFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "644533ab-bbb9-499b-9ff3-30d40e2c56d8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **MenuFlyout) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyoutItem = extern struct {
    vtable: *const VTable,
    pub fn getText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Text(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putText(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_Text(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCommand(self: *@This()) core.HResult!*ICommand {
        var _r: *ICommand = undefined;
        const _c = self.vtable.get_Command(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCommand(self: *@This(), value: *ICommand) core.HResult!void {
        const _c = self.vtable.put_Command(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCommandParameter(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_CommandParameter(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCommandParameter(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_CommandParameter(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addClick(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Click(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeClick(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Click(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyoutItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "160775cf-b598-44af-a488-c3ce2af6d3f0";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Text: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_Text: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_Command: *const fn(self: *anyopaque, _r: **ICommand) callconv(.winapi) HRESULT,
        put_Command: *const fn(self: *anyopaque, value: *ICommand) callconv(.winapi) HRESULT,
        get_CommandParameter: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_CommandParameter: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        add_Click: *const fn(self: *anyopaque, handler: *RoutedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Click: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyoutItem2 = extern struct {
    vtable: *const VTable,
    pub fn getIcon(self: *@This()) core.HResult!*IconElement {
        var _r: *IconElement = undefined;
        const _c = self.vtable.get_Icon(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIcon(self: *@This(), value: *IconElement) core.HResult!void {
        const _c = self.vtable.put_Icon(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyoutItem2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0ae266eb-028c-4423-a8e3-989fd9dd7126";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Icon: *const fn(self: *anyopaque, _r: **IconElement) callconv(.winapi) HRESULT,
        put_Icon: *const fn(self: *anyopaque, value: *IconElement) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyoutItem3 = extern struct {
    vtable: *const VTable,
    pub fn getKeyboardAcceleratorTextOverride(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_KeyboardAcceleratorTextOverride(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putKeyboardAcceleratorTextOverride(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_KeyboardAcceleratorTextOverride(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*MenuFlyoutItemTemplateSettings {
        var _r: *MenuFlyoutItemTemplateSettings = undefined;
        const _c = self.vtable.get_TemplateSettings(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyoutItem3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9727b2e3-b2b6-49dc-8c22-e0138b941559";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_KeyboardAcceleratorTextOverride: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_KeyboardAcceleratorTextOverride: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_TemplateSettings: *const fn(self: *anyopaque, _r: **MenuFlyoutItemTemplateSettings) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyoutItemBase = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyoutItemBase";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f9b56047-8da6-4730-9208-144125c6b396";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyoutItemBaseFactory = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyoutItemBaseFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "83e6dbad-fc67-41d5-8797-60acd1ceb1d9";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyoutItemFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*MenuFlyoutItem {
        var _r: *MenuFlyoutItem = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyoutItemFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c5aa39e2-44f3-455e-9c5b-62bb6afce3ad";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **MenuFlyoutItem) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyoutItemStatics = extern struct {
    vtable: *const VTable,
    pub fn getTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCommandProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CommandProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCommandParameterProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CommandParameterProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyoutItemStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4950b424-a43a-41f7-aa3a-9ce9619747d5";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CommandProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CommandParameterProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyoutItemStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getIconProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IconProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyoutItemStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "aca4f564-1790-4601-916e-5ae1f01f4bd6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IconProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyoutItemStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getKeyboardAcceleratorTextOverrideProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_KeyboardAcceleratorTextOverrideProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyoutItemStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d83fd7c3-0aeb-4ef3-8270-8b9b95f2b298";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_KeyboardAcceleratorTextOverrideProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyoutPresenter = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyoutPresenter";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "906e0304-254e-413f-b219-c7b97f003752";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyoutPresenter2 = extern struct {
    vtable: *const VTable,
    pub fn getTemplateSettings(self: *@This()) core.HResult!*MenuFlyoutPresenterTemplateSettings {
        var _r: *MenuFlyoutPresenterTemplateSettings = undefined;
        const _c = self.vtable.get_TemplateSettings(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyoutPresenter2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "895894df-5a9f-4a1f-85ec-6f3c1b6dcb89";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TemplateSettings: *const fn(self: *anyopaque, _r: **MenuFlyoutPresenterTemplateSettings) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyoutPresenter3 = extern struct {
    vtable: *const VTable,
    pub fn getIsDefaultShadowEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsDefaultShadowEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsDefaultShadowEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsDefaultShadowEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyoutPresenter3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6afd4e16-aee0-584a-9849-edaa323a484f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsDefaultShadowEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsDefaultShadowEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyoutPresenterFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*MenuFlyoutPresenter {
        var _r: *MenuFlyoutPresenter = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyoutPresenterFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b88b5091-101c-41f8-aac1-1b105c14fb99";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **MenuFlyoutPresenter) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyoutPresenterStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getIsDefaultShadowEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsDefaultShadowEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyoutPresenterStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3772a818-825a-520c-80ae-4d39a2d59ab5";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsDefaultShadowEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyoutSeparator = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyoutSeparator";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "71fa2b7d-0b51-4950-a1a4-bbc42eac4c12";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyoutSeparatorFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*MenuFlyoutSeparator {
        var _r: *MenuFlyoutSeparator = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyoutSeparatorFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c159dcc8-b437-44e0-b24b-5720aea1dbac";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **MenuFlyoutSeparator) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyoutStatics = extern struct {
    vtable: *const VTable,
    pub fn getMenuFlyoutPresenterStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MenuFlyoutPresenterStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyoutStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3dbefba1-9522-4045-9e58-c99b13aab9b9";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_MenuFlyoutPresenterStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyoutSubItem = extern struct {
    vtable: *const VTable,
    pub fn getItems(self: *@This()) core.HResult!*IVector(MenuFlyoutItemBase) {
        var _r: *IVector(MenuFlyoutItemBase) = undefined;
        const _c = self.vtable.get_Items(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Text(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putText(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_Text(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyoutSubItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e5386550-fe2c-43e2-a73f-62168f619973";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Items: *const fn(self: *anyopaque, _r: **IVector(MenuFlyoutItemBase)) callconv(.winapi) HRESULT,
        get_Text: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_Text: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyoutSubItem2 = extern struct {
    vtable: *const VTable,
    pub fn getIcon(self: *@This()) core.HResult!*IconElement {
        var _r: *IconElement = undefined;
        const _c = self.vtable.get_Icon(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIcon(self: *@This(), value: *IconElement) core.HResult!void {
        const _c = self.vtable.put_Icon(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyoutSubItem2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ac935626-190a-4de2-8d71-7cc4747da580";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Icon: *const fn(self: *anyopaque, _r: **IconElement) callconv(.winapi) HRESULT,
        put_Icon: *const fn(self: *anyopaque, value: *IconElement) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyoutSubItemStatics = extern struct {
    vtable: *const VTable,
    pub fn getTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyoutSubItemStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ddb27a36-1874-4aef-837d-6fec9da4e681";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IMenuFlyoutSubItemStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getIconProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IconProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IMenuFlyoutSubItemStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ac14d09b-3e93-4785-94ef-fdb23baba965";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IconProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const INavigate = extern struct {
    vtable: *const VTable,
    pub fn Navigate(self: *@This(), sourcePageType: TypeName) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.Navigate(@ptrCast(self), sourcePageType, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigate";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "bf2195a9-f4ea-4336-977c-f8fcf78b0d9e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        Navigate: *const fn(self: *anyopaque, sourcePageType: TypeName, _r: *bool) callconv(.winapi) HRESULT,
    };
};
pub const INavigationView = extern struct {
    vtable: *const VTable,
    pub fn getIsPaneOpen(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsPaneOpen(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsPaneOpen(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsPaneOpen(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCompactModeThresholdWidth(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_CompactModeThresholdWidth(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCompactModeThresholdWidth(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_CompactModeThresholdWidth(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getExpandedModeThresholdWidth(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_ExpandedModeThresholdWidth(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putExpandedModeThresholdWidth(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_ExpandedModeThresholdWidth(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPaneFooter(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_PaneFooter(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPaneFooter(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_PaneFooter(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Header(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Header(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_HeaderTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_HeaderTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDisplayMode(self: *@This()) core.HResult!NavigationViewDisplayMode {
        var _r: NavigationViewDisplayMode = undefined;
        const _c = self.vtable.get_DisplayMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsSettingsVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsSettingsVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsSettingsVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsSettingsVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsPaneToggleButtonVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsPaneToggleButtonVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsPaneToggleButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsPaneToggleButtonVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAlwaysShowHeader(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_AlwaysShowHeader(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putAlwaysShowHeader(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_AlwaysShowHeader(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCompactPaneLength(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_CompactPaneLength(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCompactPaneLength(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_CompactPaneLength(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOpenPaneLength(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_OpenPaneLength(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOpenPaneLength(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_OpenPaneLength(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPaneToggleButtonStyle(self: *@This()) core.HResult!*Style {
        var _r: *Style = undefined;
        const _c = self.vtable.get_PaneToggleButtonStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPaneToggleButtonStyle(self: *@This(), value: *Style) core.HResult!void {
        const _c = self.vtable.put_PaneToggleButtonStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectedItem(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_SelectedItem(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectedItem(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_SelectedItem(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMenuItems(self: *@This()) core.HResult!*IVector(IInspectable) {
        var _r: *IVector(IInspectable) = undefined;
        const _c = self.vtable.get_MenuItems(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMenuItemsSource(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_MenuItemsSource(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMenuItemsSource(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_MenuItemsSource(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSettingsItem(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_SettingsItem(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getAutoSuggestBox(self: *@This()) core.HResult!*AutoSuggestBox {
        var _r: *AutoSuggestBox = undefined;
        const _c = self.vtable.get_AutoSuggestBox(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putAutoSuggestBox(self: *@This(), value: *AutoSuggestBox) core.HResult!void {
        const _c = self.vtable.put_AutoSuggestBox(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMenuItemTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_MenuItemTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMenuItemTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_MenuItemTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMenuItemTemplateSelector(self: *@This()) core.HResult!*DataTemplateSelector {
        var _r: *DataTemplateSelector = undefined;
        const _c = self.vtable.get_MenuItemTemplateSelector(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMenuItemTemplateSelector(self: *@This(), value: *DataTemplateSelector) core.HResult!void {
        const _c = self.vtable.put_MenuItemTemplateSelector(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMenuItemContainerStyle(self: *@This()) core.HResult!*Style {
        var _r: *Style = undefined;
        const _c = self.vtable.get_MenuItemContainerStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMenuItemContainerStyle(self: *@This(), value: *Style) core.HResult!void {
        const _c = self.vtable.put_MenuItemContainerStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMenuItemContainerStyleSelector(self: *@This()) core.HResult!*StyleSelector {
        var _r: *StyleSelector = undefined;
        const _c = self.vtable.get_MenuItemContainerStyleSelector(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMenuItemContainerStyleSelector(self: *@This(), value: *StyleSelector) core.HResult!void {
        const _c = self.vtable.put_MenuItemContainerStyleSelector(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn MenuItemFromContainer(self: *@This(), container: *DependencyObject) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.MenuItemFromContainer(@ptrCast(self), container, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn ContainerFromMenuItem(self: *@This(), item: *IInspectable) core.HResult!*DependencyObject {
        var _r: *DependencyObject = undefined;
        const _c = self.vtable.ContainerFromMenuItem(@ptrCast(self), item, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addSelectionChanged(self: *@This(), handler: *TypedEventHandler(NavigationView,NavigationViewSelectionChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_SelectionChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeSelectionChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_SelectionChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addItemInvoked(self: *@This(), handler: *TypedEventHandler(NavigationView,NavigationViewItemInvokedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ItemInvoked(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeItemInvoked(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ItemInvoked(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addDisplayModeChanged(self: *@This(), handler: *TypedEventHandler(NavigationView,NavigationViewDisplayModeChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_DisplayModeChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeDisplayModeChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_DisplayModeChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f209ce15-391a-42ca-9fc6-f79da65aca32";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsPaneOpen: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsPaneOpen: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_CompactModeThresholdWidth: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_CompactModeThresholdWidth: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_ExpandedModeThresholdWidth: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_ExpandedModeThresholdWidth: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_PaneFooter: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_PaneFooter: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
        get_Header: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Header: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_HeaderTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_HeaderTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_DisplayMode: *const fn(self: *anyopaque, _r: *NavigationViewDisplayMode) callconv(.winapi) HRESULT,
        get_IsSettingsVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsSettingsVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsPaneToggleButtonVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsPaneToggleButtonVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_AlwaysShowHeader: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_AlwaysShowHeader: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_CompactPaneLength: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_CompactPaneLength: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_OpenPaneLength: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_OpenPaneLength: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_PaneToggleButtonStyle: *const fn(self: *anyopaque, _r: **Style) callconv(.winapi) HRESULT,
        put_PaneToggleButtonStyle: *const fn(self: *anyopaque, value: *Style) callconv(.winapi) HRESULT,
        get_SelectedItem: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_SelectedItem: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_MenuItems: *const fn(self: *anyopaque, _r: **IVector(IInspectable)) callconv(.winapi) HRESULT,
        get_MenuItemsSource: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_MenuItemsSource: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_SettingsItem: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        get_AutoSuggestBox: *const fn(self: *anyopaque, _r: **AutoSuggestBox) callconv(.winapi) HRESULT,
        put_AutoSuggestBox: *const fn(self: *anyopaque, value: *AutoSuggestBox) callconv(.winapi) HRESULT,
        get_MenuItemTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_MenuItemTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_MenuItemTemplateSelector: *const fn(self: *anyopaque, _r: **DataTemplateSelector) callconv(.winapi) HRESULT,
        put_MenuItemTemplateSelector: *const fn(self: *anyopaque, value: *DataTemplateSelector) callconv(.winapi) HRESULT,
        get_MenuItemContainerStyle: *const fn(self: *anyopaque, _r: **Style) callconv(.winapi) HRESULT,
        put_MenuItemContainerStyle: *const fn(self: *anyopaque, value: *Style) callconv(.winapi) HRESULT,
        get_MenuItemContainerStyleSelector: *const fn(self: *anyopaque, _r: **StyleSelector) callconv(.winapi) HRESULT,
        put_MenuItemContainerStyleSelector: *const fn(self: *anyopaque, value: *StyleSelector) callconv(.winapi) HRESULT,
        MenuItemFromContainer: *const fn(self: *anyopaque, container: *DependencyObject, _r: **IInspectable) callconv(.winapi) HRESULT,
        ContainerFromMenuItem: *const fn(self: *anyopaque, item: *IInspectable, _r: **DependencyObject) callconv(.winapi) HRESULT,
        add_SelectionChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(NavigationView,NavigationViewSelectionChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_SelectionChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_ItemInvoked: *const fn(self: *anyopaque, handler: *TypedEventHandler(NavigationView,NavigationViewItemInvokedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ItemInvoked: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_DisplayModeChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(NavigationView,NavigationViewDisplayModeChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_DisplayModeChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const INavigationView2 = extern struct {
    vtable: *const VTable,
    pub fn getIsBackButtonVisible(self: *@This()) core.HResult!NavigationViewBackButtonVisible {
        var _r: NavigationViewBackButtonVisible = undefined;
        const _c = self.vtable.get_IsBackButtonVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsBackButtonVisible(self: *@This(), value: NavigationViewBackButtonVisible) core.HResult!void {
        const _c = self.vtable.put_IsBackButtonVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsBackEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsBackEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsBackEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsBackEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPaneTitle(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_PaneTitle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPaneTitle(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_PaneTitle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addBackRequested(self: *@This(), handler: *TypedEventHandler(NavigationView,NavigationViewBackRequestedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_BackRequested(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeBackRequested(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_BackRequested(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addPaneClosed(self: *@This(), handler: *TypedEventHandler(NavigationView,IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_PaneClosed(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removePaneClosed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_PaneClosed(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addPaneClosing(self: *@This(), handler: *TypedEventHandler(NavigationView,NavigationViewPaneClosingEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_PaneClosing(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removePaneClosing(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_PaneClosing(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addPaneOpened(self: *@This(), handler: *TypedEventHandler(NavigationView,IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_PaneOpened(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removePaneOpened(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_PaneOpened(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addPaneOpening(self: *@This(), handler: *TypedEventHandler(NavigationView,IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_PaneOpening(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removePaneOpening(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_PaneOpening(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationView2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "2be49737-7c13-4c44-86c3-8b25e697a80e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsBackButtonVisible: *const fn(self: *anyopaque, _r: *NavigationViewBackButtonVisible) callconv(.winapi) HRESULT,
        put_IsBackButtonVisible: *const fn(self: *anyopaque, value: NavigationViewBackButtonVisible) callconv(.winapi) HRESULT,
        get_IsBackEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsBackEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_PaneTitle: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_PaneTitle: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        add_BackRequested: *const fn(self: *anyopaque, handler: *TypedEventHandler(NavigationView,NavigationViewBackRequestedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_BackRequested: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_PaneClosed: *const fn(self: *anyopaque, handler: *TypedEventHandler(NavigationView,IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_PaneClosed: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_PaneClosing: *const fn(self: *anyopaque, handler: *TypedEventHandler(NavigationView,NavigationViewPaneClosingEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_PaneClosing: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_PaneOpened: *const fn(self: *anyopaque, handler: *TypedEventHandler(NavigationView,IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_PaneOpened: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_PaneOpening: *const fn(self: *anyopaque, handler: *TypedEventHandler(NavigationView,IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_PaneOpening: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const INavigationView3 = extern struct {
    vtable: *const VTable,
    pub fn getPaneDisplayMode(self: *@This()) core.HResult!NavigationViewPaneDisplayMode {
        var _r: NavigationViewPaneDisplayMode = undefined;
        const _c = self.vtable.get_PaneDisplayMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPaneDisplayMode(self: *@This(), value: NavigationViewPaneDisplayMode) core.HResult!void {
        const _c = self.vtable.put_PaneDisplayMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPaneHeader(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_PaneHeader(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPaneHeader(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_PaneHeader(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPaneCustomContent(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_PaneCustomContent(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPaneCustomContent(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_PaneCustomContent(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getContentOverlay(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_ContentOverlay(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putContentOverlay(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_ContentOverlay(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsPaneVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsPaneVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsPaneVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsPaneVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectionFollowsFocus(self: *@This()) core.HResult!NavigationViewSelectionFollowsFocus {
        var _r: NavigationViewSelectionFollowsFocus = undefined;
        const _c = self.vtable.get_SelectionFollowsFocus(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectionFollowsFocus(self: *@This(), value: NavigationViewSelectionFollowsFocus) core.HResult!void {
        const _c = self.vtable.put_SelectionFollowsFocus(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*NavigationViewTemplateSettings {
        var _r: *NavigationViewTemplateSettings = undefined;
        const _c = self.vtable.get_TemplateSettings(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getShoulderNavigationEnabled(self: *@This()) core.HResult!NavigationViewShoulderNavigationEnabled {
        var _r: NavigationViewShoulderNavigationEnabled = undefined;
        const _c = self.vtable.get_ShoulderNavigationEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putShoulderNavigationEnabled(self: *@This(), value: NavigationViewShoulderNavigationEnabled) core.HResult!void {
        const _c = self.vtable.put_ShoulderNavigationEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOverflowLabelMode(self: *@This()) core.HResult!NavigationViewOverflowLabelMode {
        var _r: NavigationViewOverflowLabelMode = undefined;
        const _c = self.vtable.get_OverflowLabelMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOverflowLabelMode(self: *@This(), value: NavigationViewOverflowLabelMode) core.HResult!void {
        const _c = self.vtable.put_OverflowLabelMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationView3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8fdfab66-9bbc-5fa3-9043-a02bb4f8ef37";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PaneDisplayMode: *const fn(self: *anyopaque, _r: *NavigationViewPaneDisplayMode) callconv(.winapi) HRESULT,
        put_PaneDisplayMode: *const fn(self: *anyopaque, value: NavigationViewPaneDisplayMode) callconv(.winapi) HRESULT,
        get_PaneHeader: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_PaneHeader: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
        get_PaneCustomContent: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_PaneCustomContent: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
        get_ContentOverlay: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_ContentOverlay: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
        get_IsPaneVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsPaneVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_SelectionFollowsFocus: *const fn(self: *anyopaque, _r: *NavigationViewSelectionFollowsFocus) callconv(.winapi) HRESULT,
        put_SelectionFollowsFocus: *const fn(self: *anyopaque, value: NavigationViewSelectionFollowsFocus) callconv(.winapi) HRESULT,
        get_TemplateSettings: *const fn(self: *anyopaque, _r: **NavigationViewTemplateSettings) callconv(.winapi) HRESULT,
        get_ShoulderNavigationEnabled: *const fn(self: *anyopaque, _r: *NavigationViewShoulderNavigationEnabled) callconv(.winapi) HRESULT,
        put_ShoulderNavigationEnabled: *const fn(self: *anyopaque, value: NavigationViewShoulderNavigationEnabled) callconv(.winapi) HRESULT,
        get_OverflowLabelMode: *const fn(self: *anyopaque, _r: *NavigationViewOverflowLabelMode) callconv(.winapi) HRESULT,
        put_OverflowLabelMode: *const fn(self: *anyopaque, value: NavigationViewOverflowLabelMode) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewBackRequestedEventArgs = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewBackRequestedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "446700e1-9a9d-4500-a71d-25c15809b879";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewDisplayModeChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getDisplayMode(self: *@This()) core.HResult!NavigationViewDisplayMode {
        var _r: NavigationViewDisplayMode = undefined;
        const _c = self.vtable.get_DisplayMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewDisplayModeChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b7c1ad35-5544-40c1-9b33-acfe1d6c8094";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_DisplayMode: *const fn(self: *anyopaque, _r: *NavigationViewDisplayMode) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*NavigationView {
        var _r: *NavigationView = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e50687c1-b7c2-4975-ad7a-5f4fe6a514c9";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **NavigationView) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewItem = extern struct {
    vtable: *const VTable,
    pub fn getIcon(self: *@This()) core.HResult!*IconElement {
        var _r: *IconElement = undefined;
        const _c = self.vtable.get_Icon(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIcon(self: *@This(), value: *IconElement) core.HResult!void {
        const _c = self.vtable.put_Icon(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCompactPaneLength(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_CompactPaneLength(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8614be0f-b7b6-4851-960a-f5e3f69f624a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Icon: *const fn(self: *anyopaque, _r: **IconElement) callconv(.winapi) HRESULT,
        put_Icon: *const fn(self: *anyopaque, value: *IconElement) callconv(.winapi) HRESULT,
        get_CompactPaneLength: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewItem2 = extern struct {
    vtable: *const VTable,
    pub fn getSelectsOnInvoked(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_SelectsOnInvoked(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectsOnInvoked(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_SelectsOnInvoked(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewItem2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ee488ef9-ea9c-5e04-b26c-83bf9655342f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectsOnInvoked: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_SelectsOnInvoked: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewItemBase = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewItemBase";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "edf04eb1-37d1-471f-8570-3829ee5b2bc6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewItemBaseFactory = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewItemBaseFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "eb014cef-7890-4ebb-8245-02e8510f321d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewItemFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*NavigationViewItem {
        var _r: *NavigationViewItem = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewItemFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "973bdb4a-7e08-4f76-923c-f12bd685e86e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **NavigationViewItem) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewItemHeader = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewItemHeader";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e21df22c-da4a-4e74-9ffc-b163bd7adacd";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewItemHeaderFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*NavigationViewItemHeader {
        var _r: *NavigationViewItemHeader = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewItemHeaderFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f3105988-7768-45d3-8bb0-6ded9e43a98b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **NavigationViewItemHeader) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewItemInvokedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getInvokedItem(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_InvokedItem(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsSettingsInvoked(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsSettingsInvoked(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "29496822-55d2-49fa-964b-f1dbafef85c4";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_InvokedItem: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        get_IsSettingsInvoked: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewItemInvokedEventArgs2 = extern struct {
    vtable: *const VTable,
    pub fn getInvokedItemContainer(self: *@This()) core.HResult!*NavigationViewItemBase {
        var _r: *NavigationViewItemBase = undefined;
        const _c = self.vtable.get_InvokedItemContainer(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getRecommendedNavigationTransitionInfo(self: *@This()) core.HResult!*NavigationTransitionInfo {
        var _r: *NavigationTransitionInfo = undefined;
        const _c = self.vtable.get_RecommendedNavigationTransitionInfo(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b568f2dd-515e-5770-a466-bd5f43fb6442";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_InvokedItemContainer: *const fn(self: *anyopaque, _r: **NavigationViewItemBase) callconv(.winapi) HRESULT,
        get_RecommendedNavigationTransitionInfo: *const fn(self: *anyopaque, _r: **NavigationTransitionInfo) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewItemSeparator = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewItemSeparator";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "de62c951-bb9b-471e-83e3-af4791e7096a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewItemSeparatorFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*NavigationViewItemSeparator {
        var _r: *NavigationViewItemSeparator = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewItemSeparatorFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "71cf3a66-db86-49e0-8154-5fd356aedec0";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **NavigationViewItemSeparator) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewItemStatics = extern struct {
    vtable: *const VTable,
    pub fn getIconProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IconProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCompactPaneLengthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CompactPaneLengthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewItemStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "803c0081-fda5-4b90-aace-3f2306dbe5c4";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IconProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CompactPaneLengthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewItemStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getSelectsOnInvokedProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectsOnInvokedProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewItemStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f4f2f77c-54b4-541d-b747-3a96e9ff3d55";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectsOnInvokedProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewList = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewList";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4f726f85-5ce0-48cd-8ef2-1a29458a3404";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewListFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*NavigationViewList {
        var _r: *NavigationViewList = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewListFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "faee9541-c3bf-47bf-b904-6155f4df6b4f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **NavigationViewList) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewPaneClosingEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getCancel(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_Cancel(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCancel(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_Cancel(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewPaneClosingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "955575ba-75f5-432d-b49b-60e47552d5ee";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Cancel: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_Cancel: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewSelectionChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getSelectedItem(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_SelectedItem(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsSettingsSelected(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsSettingsSelected(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewSelectionChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5aa509a0-3a5e-4f54-896c-98b85f819508";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectedItem: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        get_IsSettingsSelected: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewSelectionChangedEventArgs2 = extern struct {
    vtable: *const VTable,
    pub fn getSelectedItemContainer(self: *@This()) core.HResult!*NavigationViewItemBase {
        var _r: *NavigationViewItemBase = undefined;
        const _c = self.vtable.get_SelectedItemContainer(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getRecommendedNavigationTransitionInfo(self: *@This()) core.HResult!*NavigationTransitionInfo {
        var _r: *NavigationTransitionInfo = undefined;
        const _c = self.vtable.get_RecommendedNavigationTransitionInfo(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewSelectionChangedEventArgs2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "fd5af806-d10a-5e8b-973f-3b8fda944625";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectedItemContainer: *const fn(self: *anyopaque, _r: **NavigationViewItemBase) callconv(.winapi) HRESULT,
        get_RecommendedNavigationTransitionInfo: *const fn(self: *anyopaque, _r: **NavigationTransitionInfo) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewStatics = extern struct {
    vtable: *const VTable,
    pub fn getIsPaneOpenProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsPaneOpenProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCompactModeThresholdWidthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CompactModeThresholdWidthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getExpandedModeThresholdWidthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ExpandedModeThresholdWidthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPaneFooterProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PaneFooterProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDisplayModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DisplayModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsSettingsVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsSettingsVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsPaneToggleButtonVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsPaneToggleButtonVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getAlwaysShowHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AlwaysShowHeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCompactPaneLengthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CompactPaneLengthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOpenPaneLengthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OpenPaneLengthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPaneToggleButtonStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PaneToggleButtonStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMenuItemsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MenuItemsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMenuItemsSourceProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MenuItemsSourceProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedItemProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedItemProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSettingsItemProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SettingsItemProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getAutoSuggestBoxProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AutoSuggestBoxProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMenuItemTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MenuItemTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMenuItemTemplateSelectorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MenuItemTemplateSelectorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMenuItemContainerStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MenuItemContainerStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMenuItemContainerStyleSelectorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MenuItemContainerStyleSelectorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "363a86c7-72da-4420-b871-15d9d0d45756";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsPaneOpenProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CompactModeThresholdWidthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ExpandedModeThresholdWidthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PaneFooterProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DisplayModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsSettingsVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsPaneToggleButtonVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_AlwaysShowHeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CompactPaneLengthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OpenPaneLengthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PaneToggleButtonStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MenuItemsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MenuItemsSourceProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectedItemProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SettingsItemProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_AutoSuggestBoxProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MenuItemTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MenuItemTemplateSelectorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MenuItemContainerStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MenuItemContainerStyleSelectorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getIsBackButtonVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsBackButtonVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsBackEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsBackEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPaneTitleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PaneTitleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8cc50d74-1a42-4852-ab5a-6dc82f28a4ba";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsBackButtonVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsBackEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PaneTitleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getPaneDisplayModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PaneDisplayModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPaneHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PaneHeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPaneCustomContentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PaneCustomContentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getContentOverlayProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ContentOverlayProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsPaneVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsPaneVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionFollowsFocusProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectionFollowsFocusProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTemplateSettingsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TemplateSettingsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getShoulderNavigationEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ShoulderNavigationEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOverflowLabelModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OverflowLabelModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9b6b69b7-f746-5550-91e1-ee0c9a85c05e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PaneDisplayModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PaneHeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PaneCustomContentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ContentOverlayProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsPaneVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectionFollowsFocusProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TemplateSettingsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ShoulderNavigationEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OverflowLabelModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewTemplateSettings = extern struct {
    vtable: *const VTable,
    pub fn getTopPadding(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_TopPadding(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOverflowButtonVisibility(self: *@This()) core.HResult!Visibility {
        var _r: Visibility = undefined;
        const _c = self.vtable.get_OverflowButtonVisibility(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPaneToggleButtonVisibility(self: *@This()) core.HResult!Visibility {
        var _r: Visibility = undefined;
        const _c = self.vtable.get_PaneToggleButtonVisibility(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBackButtonVisibility(self: *@This()) core.HResult!Visibility {
        var _r: Visibility = undefined;
        const _c = self.vtable.get_BackButtonVisibility(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTopPaneVisibility(self: *@This()) core.HResult!Visibility {
        var _r: Visibility = undefined;
        const _c = self.vtable.get_TopPaneVisibility(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLeftPaneVisibility(self: *@This()) core.HResult!Visibility {
        var _r: Visibility = undefined;
        const _c = self.vtable.get_LeftPaneVisibility(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSingleSelectionFollowsFocus(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_SingleSelectionFollowsFocus(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewTemplateSettings";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "2956cbc4-0528-55d5-b2d1-eae807aea6da";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TopPadding: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        get_OverflowButtonVisibility: *const fn(self: *anyopaque, _r: *Visibility) callconv(.winapi) HRESULT,
        get_PaneToggleButtonVisibility: *const fn(self: *anyopaque, _r: *Visibility) callconv(.winapi) HRESULT,
        get_BackButtonVisibility: *const fn(self: *anyopaque, _r: *Visibility) callconv(.winapi) HRESULT,
        get_TopPaneVisibility: *const fn(self: *anyopaque, _r: *Visibility) callconv(.winapi) HRESULT,
        get_LeftPaneVisibility: *const fn(self: *anyopaque, _r: *Visibility) callconv(.winapi) HRESULT,
        get_SingleSelectionFollowsFocus: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewTemplateSettingsFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*NavigationViewTemplateSettings {
        var _r: *NavigationViewTemplateSettings = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewTemplateSettingsFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "28a6a351-64bc-5b60-8f74-e9ee908a240e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **NavigationViewTemplateSettings) callconv(.winapi) HRESULT,
    };
};
pub const INavigationViewTemplateSettingsStatics = extern struct {
    vtable: *const VTable,
    pub fn getTopPaddingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TopPaddingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOverflowButtonVisibilityProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OverflowButtonVisibilityProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPaneToggleButtonVisibilityProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PaneToggleButtonVisibilityProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBackButtonVisibilityProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BackButtonVisibilityProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTopPaneVisibilityProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TopPaneVisibilityProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLeftPaneVisibilityProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LeftPaneVisibilityProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSingleSelectionFollowsFocusProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SingleSelectionFollowsFocusProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INavigationViewTemplateSettingsStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "2c885e59-f7b9-5078-aeb6-8d7a03c05d02";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TopPaddingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OverflowButtonVisibilityProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PaneToggleButtonVisibilityProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BackButtonVisibilityProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TopPaneVisibilityProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_LeftPaneVisibilityProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SingleSelectionFollowsFocusProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const INotifyEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getValue(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Value(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INotifyEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "af0e05f7-c4b7-44c5-b09d-5cb7052b3a97";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Value: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
    };
};
pub const INotifyEventArgs2 = extern struct {
    vtable: *const VTable,
    pub fn getCallingUri(self: *@This()) core.HResult!*Uri {
        var _r: *Uri = undefined;
        const _c = self.vtable.get_CallingUri(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.INotifyEventArgs2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0d140f56-1dce-4fcd-85bc-5a5572273b9c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CallingUri: *const fn(self: *anyopaque, _r: **Uri) callconv(.winapi) HRESULT,
    };
};
pub const IPage = extern struct {
    vtable: *const VTable,
    pub fn getFrame(self: *@This()) core.HResult!*Frame {
        var _r: *Frame = undefined;
        const _c = self.vtable.get_Frame(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getNavigationCacheMode(self: *@This()) core.HResult!NavigationCacheMode {
        var _r: NavigationCacheMode = undefined;
        const _c = self.vtable.get_NavigationCacheMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putNavigationCacheMode(self: *@This(), value: NavigationCacheMode) core.HResult!void {
        const _c = self.vtable.put_NavigationCacheMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTopAppBar(self: *@This()) core.HResult!*AppBar {
        var _r: *AppBar = undefined;
        const _c = self.vtable.get_TopAppBar(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTopAppBar(self: *@This(), value: *AppBar) core.HResult!void {
        const _c = self.vtable.put_TopAppBar(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBottomAppBar(self: *@This()) core.HResult!*AppBar {
        var _r: *AppBar = undefined;
        const _c = self.vtable.get_BottomAppBar(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBottomAppBar(self: *@This(), value: *AppBar) core.HResult!void {
        const _c = self.vtable.put_BottomAppBar(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPage";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c4b27075-e641-453e-824d-012fc7cf95cf";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Frame: *const fn(self: *anyopaque, _r: **Frame) callconv(.winapi) HRESULT,
        get_NavigationCacheMode: *const fn(self: *anyopaque, _r: *NavigationCacheMode) callconv(.winapi) HRESULT,
        put_NavigationCacheMode: *const fn(self: *anyopaque, value: NavigationCacheMode) callconv(.winapi) HRESULT,
        get_TopAppBar: *const fn(self: *anyopaque, _r: **AppBar) callconv(.winapi) HRESULT,
        put_TopAppBar: *const fn(self: *anyopaque, value: *AppBar) callconv(.winapi) HRESULT,
        get_BottomAppBar: *const fn(self: *anyopaque, _r: **AppBar) callconv(.winapi) HRESULT,
        put_BottomAppBar: *const fn(self: *anyopaque, value: *AppBar) callconv(.winapi) HRESULT,
    };
};
pub const IPageFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*Page {
        var _r: *Page = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPageFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "dfa149ac-1849-445e-937c-40a9590cc076";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **Page) callconv(.winapi) HRESULT,
    };
};
pub const IPageOverrides = extern struct {
    vtable: *const VTable,
    pub fn OnNavigatedFrom(self: *@This(), e: *NavigationEventArgs) core.HResult!void {
        const _c = self.vtable.OnNavigatedFrom(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnNavigatedTo(self: *@This(), e: *NavigationEventArgs) core.HResult!void {
        const _c = self.vtable.OnNavigatedTo(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnNavigatingFrom(self: *@This(), e: *NavigatingCancelEventArgs) core.HResult!void {
        const _c = self.vtable.OnNavigatingFrom(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPageOverrides";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "230b9cb8-3419-4306-aabe-4a8e680d3627";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        OnNavigatedFrom: *const fn(self: *anyopaque, e: *NavigationEventArgs) callconv(.winapi) HRESULT,
        OnNavigatedTo: *const fn(self: *anyopaque, e: *NavigationEventArgs) callconv(.winapi) HRESULT,
        OnNavigatingFrom: *const fn(self: *anyopaque, e: *NavigatingCancelEventArgs) callconv(.winapi) HRESULT,
    };
};
pub const IPageStatics = extern struct {
    vtable: *const VTable,
    pub fn getFrameProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FrameProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTopAppBarProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TopAppBarProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBottomAppBarProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BottomAppBarProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPageStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "376dde71-f725-46dd-8d80-eeeaf7da74e5";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_FrameProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TopAppBarProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BottomAppBarProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IPanel = extern struct {
    vtable: *const VTable,
    pub fn getChildren(self: *@This()) core.HResult!*UIElementCollection {
        var _r: *UIElementCollection = undefined;
        const _c = self.vtable.get_Children(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBackground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_Background(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBackground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_Background(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsItemsHost(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsItemsHost(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getChildrenTransitions(self: *@This()) core.HResult!*TransitionCollection {
        var _r: *TransitionCollection = undefined;
        const _c = self.vtable.get_ChildrenTransitions(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putChildrenTransitions(self: *@This(), value: *TransitionCollection) core.HResult!void {
        const _c = self.vtable.put_ChildrenTransitions(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPanel";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a50a4bbd-8361-469c-90da-e9a40c7474df";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Children: *const fn(self: *anyopaque, _r: **UIElementCollection) callconv(.winapi) HRESULT,
        get_Background: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_Background: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_IsItemsHost: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_ChildrenTransitions: *const fn(self: *anyopaque, _r: **TransitionCollection) callconv(.winapi) HRESULT,
        put_ChildrenTransitions: *const fn(self: *anyopaque, value: *TransitionCollection) callconv(.winapi) HRESULT,
    };
};
pub const IPanel2 = extern struct {
    vtable: *const VTable,
    pub fn getBackgroundTransition(self: *@This()) core.HResult!*BrushTransition {
        var _r: *BrushTransition = undefined;
        const _c = self.vtable.get_BackgroundTransition(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBackgroundTransition(self: *@This(), value: *BrushTransition) core.HResult!void {
        const _c = self.vtable.put_BackgroundTransition(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPanel2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "709133c7-38f3-5083-a4bb-06a548a1d231";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BackgroundTransition: *const fn(self: *anyopaque, _r: **BrushTransition) callconv(.winapi) HRESULT,
        put_BackgroundTransition: *const fn(self: *anyopaque, value: *BrushTransition) callconv(.winapi) HRESULT,
    };
};
pub const IPanelFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*Panel {
        var _r: *Panel = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPanelFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "eee68111-c7cc-433f-95cd-d630c34302dd";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **Panel) callconv(.winapi) HRESULT,
    };
};
pub const IPanelStatics = extern struct {
    vtable: *const VTable,
    pub fn getBackgroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BackgroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsItemsHostProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsItemsHostProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getChildrenTransitionsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ChildrenTransitionsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPanelStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f23d6b5d-8330-47a6-a046-25f509b25232";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BackgroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsItemsHostProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ChildrenTransitionsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IParallaxView = extern struct {
    vtable: *const VTable,
    pub fn getChild(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_Child(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putChild(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_Child(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHorizontalShift(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_HorizontalShift(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHorizontalShift(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_HorizontalShift(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHorizontalSourceEndOffset(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_HorizontalSourceEndOffset(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHorizontalSourceEndOffset(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_HorizontalSourceEndOffset(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHorizontalSourceOffsetKind(self: *@This()) core.HResult!ParallaxSourceOffsetKind {
        var _r: ParallaxSourceOffsetKind = undefined;
        const _c = self.vtable.get_HorizontalSourceOffsetKind(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHorizontalSourceOffsetKind(self: *@This(), value: ParallaxSourceOffsetKind) core.HResult!void {
        const _c = self.vtable.put_HorizontalSourceOffsetKind(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHorizontalSourceStartOffset(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_HorizontalSourceStartOffset(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHorizontalSourceStartOffset(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_HorizontalSourceStartOffset(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsHorizontalShiftClamped(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsHorizontalShiftClamped(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsHorizontalShiftClamped(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsHorizontalShiftClamped(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsVerticalShiftClamped(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsVerticalShiftClamped(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsVerticalShiftClamped(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsVerticalShiftClamped(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMaxHorizontalShiftRatio(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_MaxHorizontalShiftRatio(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxHorizontalShiftRatio(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_MaxHorizontalShiftRatio(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMaxVerticalShiftRatio(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_MaxVerticalShiftRatio(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxVerticalShiftRatio(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_MaxVerticalShiftRatio(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSource(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_Source(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSource(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_Source(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getVerticalShift(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_VerticalShift(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putVerticalShift(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_VerticalShift(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getVerticalSourceEndOffset(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_VerticalSourceEndOffset(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putVerticalSourceEndOffset(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_VerticalSourceEndOffset(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getVerticalSourceOffsetKind(self: *@This()) core.HResult!ParallaxSourceOffsetKind {
        var _r: ParallaxSourceOffsetKind = undefined;
        const _c = self.vtable.get_VerticalSourceOffsetKind(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putVerticalSourceOffsetKind(self: *@This(), value: ParallaxSourceOffsetKind) core.HResult!void {
        const _c = self.vtable.put_VerticalSourceOffsetKind(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getVerticalSourceStartOffset(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_VerticalSourceStartOffset(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putVerticalSourceStartOffset(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_VerticalSourceStartOffset(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn RefreshAutomaticHorizontalOffsets(self: *@This()) core.HResult!void {
        const _c = self.vtable.RefreshAutomaticHorizontalOffsets(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn RefreshAutomaticVerticalOffsets(self: *@This()) core.HResult!void {
        const _c = self.vtable.RefreshAutomaticVerticalOffsets(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IParallaxView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6b84fcd4-4083-5b4b-bc40-d9204e19b41a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Child: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_Child: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
        get_HorizontalShift: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_HorizontalShift: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_HorizontalSourceEndOffset: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_HorizontalSourceEndOffset: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_HorizontalSourceOffsetKind: *const fn(self: *anyopaque, _r: *ParallaxSourceOffsetKind) callconv(.winapi) HRESULT,
        put_HorizontalSourceOffsetKind: *const fn(self: *anyopaque, value: ParallaxSourceOffsetKind) callconv(.winapi) HRESULT,
        get_HorizontalSourceStartOffset: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_HorizontalSourceStartOffset: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_IsHorizontalShiftClamped: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsHorizontalShiftClamped: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsVerticalShiftClamped: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsVerticalShiftClamped: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_MaxHorizontalShiftRatio: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_MaxHorizontalShiftRatio: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_MaxVerticalShiftRatio: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_MaxVerticalShiftRatio: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_Source: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_Source: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
        get_VerticalShift: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_VerticalShift: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_VerticalSourceEndOffset: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_VerticalSourceEndOffset: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_VerticalSourceOffsetKind: *const fn(self: *anyopaque, _r: *ParallaxSourceOffsetKind) callconv(.winapi) HRESULT,
        put_VerticalSourceOffsetKind: *const fn(self: *anyopaque, value: ParallaxSourceOffsetKind) callconv(.winapi) HRESULT,
        get_VerticalSourceStartOffset: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_VerticalSourceStartOffset: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        RefreshAutomaticHorizontalOffsets: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        RefreshAutomaticVerticalOffsets: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
    };
};
pub const IParallaxViewFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ParallaxView {
        var _r: *ParallaxView = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IParallaxViewFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e4eb9642-3e8e-5a26-94f2-9121d121b916";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **ParallaxView) callconv(.winapi) HRESULT,
    };
};
pub const IParallaxViewStatics = extern struct {
    vtable: *const VTable,
    pub fn getChildProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ChildProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHorizontalSourceEndOffsetProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HorizontalSourceEndOffsetProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHorizontalSourceOffsetKindProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HorizontalSourceOffsetKindProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHorizontalSourceStartOffsetProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HorizontalSourceStartOffsetProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaxHorizontalShiftRatioProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxHorizontalShiftRatioProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHorizontalShiftProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HorizontalShiftProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsHorizontalShiftClampedProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsHorizontalShiftClampedProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsVerticalShiftClampedProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsVerticalShiftClampedProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSourceProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SourceProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getVerticalSourceEndOffsetProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_VerticalSourceEndOffsetProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getVerticalSourceOffsetKindProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_VerticalSourceOffsetKindProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getVerticalSourceStartOffsetProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_VerticalSourceStartOffsetProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaxVerticalShiftRatioProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxVerticalShiftRatioProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getVerticalShiftProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_VerticalShiftProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IParallaxViewStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8836e49c-0e0e-57d8-9395-f0a9a0d1bb28";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ChildProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HorizontalSourceEndOffsetProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HorizontalSourceOffsetKindProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HorizontalSourceStartOffsetProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaxHorizontalShiftRatioProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HorizontalShiftProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsHorizontalShiftClampedProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsVerticalShiftClampedProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SourceProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_VerticalSourceEndOffsetProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_VerticalSourceOffsetKindProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_VerticalSourceStartOffsetProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaxVerticalShiftRatioProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_VerticalShiftProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IPasswordBox = extern struct {
    vtable: *const VTable,
    pub fn getPassword(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Password(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPassword(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_Password(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPasswordChar(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_PasswordChar(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPasswordChar(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_PasswordChar(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsPasswordRevealButtonEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsPasswordRevealButtonEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsPasswordRevealButtonEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsPasswordRevealButtonEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMaxLength(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_MaxLength(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxLength(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_MaxLength(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addPasswordChanged(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_PasswordChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removePasswordChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_PasswordChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addContextMenuOpening(self: *@This(), handler: *ContextMenuOpeningEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ContextMenuOpening(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeContextMenuOpening(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ContextMenuOpening(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn SelectAll(self: *@This()) core.HResult!void {
        const _c = self.vtable.SelectAll(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPasswordBox";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "02b9aa11-0b47-4e7d-ad91-3a4168ed230d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Password: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_Password: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_PasswordChar: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_PasswordChar: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_IsPasswordRevealButtonEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsPasswordRevealButtonEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_MaxLength: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_MaxLength: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        add_PasswordChanged: *const fn(self: *anyopaque, handler: *RoutedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_PasswordChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_ContextMenuOpening: *const fn(self: *anyopaque, handler: *ContextMenuOpeningEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ContextMenuOpening: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        SelectAll: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
    };
};
pub const IPasswordBox2 = extern struct {
    vtable: *const VTable,
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Header(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Header(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_HeaderTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_HeaderTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPlaceholderText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_PlaceholderText(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPlaceholderText(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_PlaceholderText(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectionHighlightColor(self: *@This()) core.HResult!*SolidColorBrush {
        var _r: *SolidColorBrush = undefined;
        const _c = self.vtable.get_SelectionHighlightColor(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectionHighlightColor(self: *@This(), value: *SolidColorBrush) core.HResult!void {
        const _c = self.vtable.put_SelectionHighlightColor(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPreventKeyboardDisplayOnProgrammaticFocus(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_PreventKeyboardDisplayOnProgrammaticFocus(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPreventKeyboardDisplayOnProgrammaticFocus(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_PreventKeyboardDisplayOnProgrammaticFocus(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addPaste(self: *@This(), handler: *TextControlPasteEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Paste(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removePaste(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Paste(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPasswordBox2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5ed738df-212f-4aeb-b5b8-2c219aec3c0c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Header: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Header: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_HeaderTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_HeaderTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_PlaceholderText: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_PlaceholderText: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_SelectionHighlightColor: *const fn(self: *anyopaque, _r: **SolidColorBrush) callconv(.winapi) HRESULT,
        put_SelectionHighlightColor: *const fn(self: *anyopaque, value: *SolidColorBrush) callconv(.winapi) HRESULT,
        get_PreventKeyboardDisplayOnProgrammaticFocus: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_PreventKeyboardDisplayOnProgrammaticFocus: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        add_Paste: *const fn(self: *anyopaque, handler: *TextControlPasteEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Paste: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IPasswordBox3 = extern struct {
    vtable: *const VTable,
    pub fn getPasswordRevealMode(self: *@This()) core.HResult!PasswordRevealMode {
        var _r: PasswordRevealMode = undefined;
        const _c = self.vtable.get_PasswordRevealMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPasswordRevealMode(self: *@This(), value: PasswordRevealMode) core.HResult!void {
        const _c = self.vtable.put_PasswordRevealMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextReadingOrder(self: *@This()) core.HResult!TextReadingOrder {
        var _r: TextReadingOrder = undefined;
        const _c = self.vtable.get_TextReadingOrder(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextReadingOrder(self: *@This(), value: TextReadingOrder) core.HResult!void {
        const _c = self.vtable.put_TextReadingOrder(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getInputScope(self: *@This()) core.HResult!*InputScope {
        var _r: *InputScope = undefined;
        const _c = self.vtable.get_InputScope(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putInputScope(self: *@This(), value: *InputScope) core.HResult!void {
        const _c = self.vtable.put_InputScope(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPasswordBox3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6024d9d1-56b7-41f0-9558-3934c14244d6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PasswordRevealMode: *const fn(self: *anyopaque, _r: *PasswordRevealMode) callconv(.winapi) HRESULT,
        put_PasswordRevealMode: *const fn(self: *anyopaque, value: PasswordRevealMode) callconv(.winapi) HRESULT,
        get_TextReadingOrder: *const fn(self: *anyopaque, _r: *TextReadingOrder) callconv(.winapi) HRESULT,
        put_TextReadingOrder: *const fn(self: *anyopaque, value: TextReadingOrder) callconv(.winapi) HRESULT,
        get_InputScope: *const fn(self: *anyopaque, _r: **InputScope) callconv(.winapi) HRESULT,
        put_InputScope: *const fn(self: *anyopaque, value: *InputScope) callconv(.winapi) HRESULT,
    };
};
pub const IPasswordBox4 = extern struct {
    vtable: *const VTable,
    pub fn addPasswordChanging(self: *@This(), handler: *TypedEventHandler(PasswordBox,PasswordBoxPasswordChangingEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_PasswordChanging(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removePasswordChanging(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_PasswordChanging(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPasswordBox4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "569f4343-8e6c-44bf-808d-0e03964ed32f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        add_PasswordChanging: *const fn(self: *anyopaque, handler: *TypedEventHandler(PasswordBox,PasswordBoxPasswordChangingEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_PasswordChanging: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IPasswordBox5 = extern struct {
    vtable: *const VTable,
    pub fn getCanPasteClipboardContent(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_CanPasteClipboardContent(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionFlyout(self: *@This()) core.HResult!*FlyoutBase {
        var _r: *FlyoutBase = undefined;
        const _c = self.vtable.get_SelectionFlyout(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectionFlyout(self: *@This(), value: *FlyoutBase) core.HResult!void {
        const _c = self.vtable.put_SelectionFlyout(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDescription(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Description(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDescription(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Description(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn PasteFromClipboard(self: *@This()) core.HResult!void {
        const _c = self.vtable.PasteFromClipboard(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPasswordBox5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f96c2753-e1d4-5142-86c2-7318bfbbc705";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CanPasteClipboardContent: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_SelectionFlyout: *const fn(self: *anyopaque, _r: **FlyoutBase) callconv(.winapi) HRESULT,
        put_SelectionFlyout: *const fn(self: *anyopaque, value: *FlyoutBase) callconv(.winapi) HRESULT,
        get_Description: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Description: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        PasteFromClipboard: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
    };
};
pub const IPasswordBoxPasswordChangingEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getIsContentChanging(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsContentChanging(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPasswordBoxPasswordChangingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "142eda22-3552-4ab8-81a6-a48620ee9c53";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsContentChanging: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
    };
};
pub const IPasswordBoxStatics = extern struct {
    vtable: *const VTable,
    pub fn getPasswordProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PasswordProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPasswordCharProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PasswordCharProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsPasswordRevealButtonEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsPasswordRevealButtonEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaxLengthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxLengthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPasswordBoxStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5ee67563-2d74-4ace-bd79-fcab61a7d77b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PasswordProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PasswordCharProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsPasswordRevealButtonEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaxLengthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IPasswordBoxStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPlaceholderTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlaceholderTextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionHighlightColorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectionHighlightColorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPreventKeyboardDisplayOnProgrammaticFocusProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PreventKeyboardDisplayOnProgrammaticFocusProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPasswordBoxStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "fc57935f-98fa-4066-b785-fa725ecde232";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PlaceholderTextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectionHighlightColorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PreventKeyboardDisplayOnProgrammaticFocusProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IPasswordBoxStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getPasswordRevealModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PasswordRevealModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextReadingOrderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextReadingOrderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getInputScopeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_InputScopeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPasswordBoxStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a2cdd319-ad6a-4352-b590-f696ffcb8e3f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PasswordRevealModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextReadingOrderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_InputScopeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IPasswordBoxStatics5 = extern struct {
    vtable: *const VTable,
    pub fn getCanPasteClipboardContentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CanPasteClipboardContentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionFlyoutProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectionFlyoutProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDescriptionProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DescriptionProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPasswordBoxStatics5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4bdac1ac-6b42-55f3-bfa4-65c7235078d6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CanPasteClipboardContentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectionFlyoutProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DescriptionProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IPathIcon = extern struct {
    vtable: *const VTable,
    pub fn getData(self: *@This()) core.HResult!*Geometry {
        var _r: *Geometry = undefined;
        const _c = self.vtable.get_Data(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putData(self: *@This(), value: *Geometry) core.HResult!void {
        const _c = self.vtable.put_Data(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPathIcon";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "214c62db-c366-4a0e-b9ad-dcf168d7ec0c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Data: *const fn(self: *anyopaque, _r: **Geometry) callconv(.winapi) HRESULT,
        put_Data: *const fn(self: *anyopaque, value: *Geometry) callconv(.winapi) HRESULT,
    };
};
pub const IPathIconFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*PathIcon {
        var _r: *PathIcon = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPathIconFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "af9d9652-9c5d-4a37-9e1a-044abeef792b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **PathIcon) callconv(.winapi) HRESULT,
    };
};
pub const IPathIconSource = extern struct {
    vtable: *const VTable,
    pub fn getData(self: *@This()) core.HResult!*Geometry {
        var _r: *Geometry = undefined;
        const _c = self.vtable.get_Data(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putData(self: *@This(), value: *Geometry) core.HResult!void {
        const _c = self.vtable.put_Data(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPathIconSource";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1f47010e-b305-4863-8b7a-15d08d633c7a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Data: *const fn(self: *anyopaque, _r: **Geometry) callconv(.winapi) HRESULT,
        put_Data: *const fn(self: *anyopaque, value: *Geometry) callconv(.winapi) HRESULT,
    };
};
pub const IPathIconSourceFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*PathIconSource {
        var _r: *PathIconSource = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPathIconSourceFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8f7f85b9-5247-4f3b-833f-e384bf7e9c84";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **PathIconSource) callconv(.winapi) HRESULT,
    };
};
pub const IPathIconSourceStatics = extern struct {
    vtable: *const VTable,
    pub fn getDataProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DataProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPathIconSourceStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "df7027d5-3682-43ff-80f0-afa256b2fdc3";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_DataProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IPathIconStatics = extern struct {
    vtable: *const VTable,
    pub fn getDataProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DataProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPathIconStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "77b75db8-fb15-491a-b6e3-7dbba911bafe";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_DataProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IPersonPicture = extern struct {
    vtable: *const VTable,
    pub fn getBadgeNumber(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_BadgeNumber(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBadgeNumber(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_BadgeNumber(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBadgeGlyph(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_BadgeGlyph(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBadgeGlyph(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_BadgeGlyph(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBadgeImageSource(self: *@This()) core.HResult!*ImageSource {
        var _r: *ImageSource = undefined;
        const _c = self.vtable.get_BadgeImageSource(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBadgeImageSource(self: *@This(), value: *ImageSource) core.HResult!void {
        const _c = self.vtable.put_BadgeImageSource(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBadgeText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_BadgeText(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBadgeText(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_BadgeText(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsGroup(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsGroup(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsGroup(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsGroup(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getContact(self: *@This()) core.HResult!*Contact {
        var _r: *Contact = undefined;
        const _c = self.vtable.get_Contact(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putContact(self: *@This(), value: *Contact) core.HResult!void {
        const _c = self.vtable.put_Contact(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDisplayName(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_DisplayName(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDisplayName(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_DisplayName(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getInitials(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Initials(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putInitials(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_Initials(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPreferSmallImage(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_PreferSmallImage(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPreferSmallImage(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_PreferSmallImage(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getProfilePicture(self: *@This()) core.HResult!*ImageSource {
        var _r: *ImageSource = undefined;
        const _c = self.vtable.get_ProfilePicture(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putProfilePicture(self: *@This(), value: *ImageSource) core.HResult!void {
        const _c = self.vtable.put_ProfilePicture(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPersonPicture";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6c230b6d-0d75-4059-91bc-7b174d1d7315";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BadgeNumber: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_BadgeNumber: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_BadgeGlyph: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_BadgeGlyph: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_BadgeImageSource: *const fn(self: *anyopaque, _r: **ImageSource) callconv(.winapi) HRESULT,
        put_BadgeImageSource: *const fn(self: *anyopaque, value: *ImageSource) callconv(.winapi) HRESULT,
        get_BadgeText: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_BadgeText: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_IsGroup: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsGroup: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_Contact: *const fn(self: *anyopaque, _r: **Contact) callconv(.winapi) HRESULT,
        put_Contact: *const fn(self: *anyopaque, value: *Contact) callconv(.winapi) HRESULT,
        get_DisplayName: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_DisplayName: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_Initials: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_Initials: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_PreferSmallImage: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_PreferSmallImage: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_ProfilePicture: *const fn(self: *anyopaque, _r: **ImageSource) callconv(.winapi) HRESULT,
        put_ProfilePicture: *const fn(self: *anyopaque, value: *ImageSource) callconv(.winapi) HRESULT,
    };
};
pub const IPersonPictureFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*PersonPicture {
        var _r: *PersonPicture = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPersonPictureFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4f18330d-0416-4b92-bfd3-bf5780b46ab2";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **PersonPicture) callconv(.winapi) HRESULT,
    };
};
pub const IPersonPictureStatics = extern struct {
    vtable: *const VTable,
    pub fn getBadgeNumberProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BadgeNumberProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBadgeGlyphProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BadgeGlyphProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBadgeImageSourceProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BadgeImageSourceProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBadgeTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BadgeTextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsGroupProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsGroupProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getContactProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ContactProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDisplayNameProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DisplayNameProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getInitialsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_InitialsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPreferSmallImageProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PreferSmallImageProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getProfilePictureProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ProfilePictureProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPersonPictureStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "dbec0982-3c10-4639-9614-aa5b7cdc32ca";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BadgeNumberProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BadgeGlyphProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BadgeImageSourceProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BadgeTextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsGroupProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ContactProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DisplayNameProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_InitialsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PreferSmallImageProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ProfilePictureProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IPickerConfirmedEventArgs = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPickerConfirmedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "447a9b51-1e23-4779-992b-986849713941";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IPickerFlyout = extern struct {
    vtable: *const VTable,
    pub fn getContent(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_Content(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putContent(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_Content(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getConfirmationButtonsVisible(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_ConfirmationButtonsVisible(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putConfirmationButtonsVisible(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_ConfirmationButtonsVisible(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addConfirmed(self: *@This(), handler: *TypedEventHandler(PickerFlyout,PickerConfirmedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Confirmed(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeConfirmed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Confirmed(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn ShowAtAsync(self: *@This(), target: *FrameworkElement) core.HResult!*IAsyncOperation(bool) {
        var _r: *IAsyncOperation(bool) = undefined;
        const _c = self.vtable.ShowAtAsync(@ptrCast(self), target, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPickerFlyout";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a336ffdb-08d9-43e6-944e-f2e5c7cee630";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Content: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_Content: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
        get_ConfirmationButtonsVisible: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_ConfirmationButtonsVisible: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        add_Confirmed: *const fn(self: *anyopaque, handler: *TypedEventHandler(PickerFlyout,PickerConfirmedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Confirmed: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        ShowAtAsync: *const fn(self: *anyopaque, target: *FrameworkElement, _r: **IAsyncOperation(bool)) callconv(.winapi) HRESULT,
    };
};
pub const IPickerFlyoutPresenter = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPickerFlyoutPresenter";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5884c978-6b27-4b38-a9ae-677c2994652e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IPickerFlyoutStatics = extern struct {
    vtable: *const VTable,
    pub fn getContentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ContentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getConfirmationButtonsVisibleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ConfirmationButtonsVisibleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPickerFlyoutStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "af18a436-f38a-4abd-b933-6286c115b07f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ContentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ConfirmationButtonsVisibleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IPivot = extern struct {
    vtable: *const VTable,
    pub fn getTitle(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Title(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTitle(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Title(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTitleTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_TitleTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTitleTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_TitleTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_HeaderTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_HeaderTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectedIndex(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_SelectedIndex(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectedIndex(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_SelectedIndex(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectedItem(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_SelectedItem(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectedItem(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_SelectedItem(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsLocked(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsLocked(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsLocked(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsLocked(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addSelectionChanged(self: *@This(), handler: *SelectionChangedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_SelectionChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeSelectionChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_SelectionChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addPivotItemLoading(self: *@This(), handler: *TypedEventHandler(Pivot,PivotItemEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_PivotItemLoading(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removePivotItemLoading(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_PivotItemLoading(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addPivotItemLoaded(self: *@This(), handler: *TypedEventHandler(Pivot,PivotItemEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_PivotItemLoaded(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removePivotItemLoaded(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_PivotItemLoaded(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addPivotItemUnloading(self: *@This(), handler: *TypedEventHandler(Pivot,PivotItemEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_PivotItemUnloading(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removePivotItemUnloading(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_PivotItemUnloading(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addPivotItemUnloaded(self: *@This(), handler: *TypedEventHandler(Pivot,PivotItemEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_PivotItemUnloaded(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removePivotItemUnloaded(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_PivotItemUnloaded(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPivot";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "103e9b13-3400-4a16-90b9-6912bf06974e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Title: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Title: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_TitleTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_TitleTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_HeaderTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_HeaderTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_SelectedIndex: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_SelectedIndex: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_SelectedItem: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_SelectedItem: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_IsLocked: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsLocked: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        add_SelectionChanged: *const fn(self: *anyopaque, handler: *SelectionChangedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_SelectionChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_PivotItemLoading: *const fn(self: *anyopaque, handler: *TypedEventHandler(Pivot,PivotItemEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_PivotItemLoading: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_PivotItemLoaded: *const fn(self: *anyopaque, handler: *TypedEventHandler(Pivot,PivotItemEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_PivotItemLoaded: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_PivotItemUnloading: *const fn(self: *anyopaque, handler: *TypedEventHandler(Pivot,PivotItemEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_PivotItemUnloading: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_PivotItemUnloaded: *const fn(self: *anyopaque, handler: *TypedEventHandler(Pivot,PivotItemEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_PivotItemUnloaded: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IPivot2 = extern struct {
    vtable: *const VTable,
    pub fn getLeftHeader(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_LeftHeader(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putLeftHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_LeftHeader(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getLeftHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_LeftHeaderTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putLeftHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_LeftHeaderTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getRightHeader(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_RightHeader(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putRightHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_RightHeader(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getRightHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_RightHeaderTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putRightHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_RightHeaderTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPivot2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8b8a8660-1a55-411c-a82d-18991c3f0d6f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LeftHeader: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_LeftHeader: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_LeftHeaderTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_LeftHeaderTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_RightHeader: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_RightHeader: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_RightHeaderTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_RightHeaderTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
    };
};
pub const IPivot3 = extern struct {
    vtable: *const VTable,
    pub fn getHeaderFocusVisualPlacement(self: *@This()) core.HResult!PivotHeaderFocusVisualPlacement {
        var _r: PivotHeaderFocusVisualPlacement = undefined;
        const _c = self.vtable.get_HeaderFocusVisualPlacement(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderFocusVisualPlacement(self: *@This(), value: PivotHeaderFocusVisualPlacement) core.HResult!void {
        const _c = self.vtable.put_HeaderFocusVisualPlacement(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsHeaderItemsCarouselEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsHeaderItemsCarouselEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsHeaderItemsCarouselEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsHeaderItemsCarouselEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPivot3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "95bcbf96-f0da-4089-8c65-e8b81354c766";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HeaderFocusVisualPlacement: *const fn(self: *anyopaque, _r: *PivotHeaderFocusVisualPlacement) callconv(.winapi) HRESULT,
        put_HeaderFocusVisualPlacement: *const fn(self: *anyopaque, value: PivotHeaderFocusVisualPlacement) callconv(.winapi) HRESULT,
        get_IsHeaderItemsCarouselEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsHeaderItemsCarouselEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IPivotFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*Pivot {
        var _r: *Pivot = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPivotFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1b0a818e-2529-4762-ba44-9abc68c3ceca";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **Pivot) callconv(.winapi) HRESULT,
    };
};
pub const IPivotItem = extern struct {
    vtable: *const VTable,
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Header(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Header(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPivotItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a4764371-a502-47a3-915e-4aa096daf87f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Header: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Header: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
    };
};
pub const IPivotItemEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getItem(self: *@This()) core.HResult!*PivotItem {
        var _r: *PivotItem = undefined;
        const _c = self.vtable.get_Item(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItem(self: *@This(), value: *PivotItem) core.HResult!void {
        const _c = self.vtable.put_Item(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPivotItemEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1a6f7254-1ed5-4bc5-a060-655530bca6ba";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Item: *const fn(self: *anyopaque, _r: **PivotItem) callconv(.winapi) HRESULT,
        put_Item: *const fn(self: *anyopaque, value: *PivotItem) callconv(.winapi) HRESULT,
    };
};
pub const IPivotItemFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*PivotItem {
        var _r: *PivotItem = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPivotItemFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0dced981-636e-4a34-8a3f-8ee018639285";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **PivotItem) callconv(.winapi) HRESULT,
    };
};
pub const IPivotItemStatics = extern struct {
    vtable: *const VTable,
    pub fn getHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPivotItemStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e147ad0c-488b-4a6e-becd-a5dbd9941754";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IPivotStatics = extern struct {
    vtable: *const VTable,
    pub fn getTitleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TitleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTitleTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TitleTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedIndexProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedIndexProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedItemProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedItemProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsLockedProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsLockedProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSlideInAnimationGroupProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SlideInAnimationGroupProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetSlideInAnimationGroup(self: *@This(), element: *FrameworkElement) core.HResult!PivotSlideInAnimationGroup {
        var _r: PivotSlideInAnimationGroup = undefined;
        const _c = self.vtable.GetSlideInAnimationGroup(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetSlideInAnimationGroup(self: *@This(), element: *FrameworkElement, value: PivotSlideInAnimationGroup) core.HResult!void {
        const _c = self.vtable.SetSlideInAnimationGroup(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPivotStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ee22c7f4-c15d-4ff3-8a94-f50dfdfbe899";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TitleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TitleTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectedIndexProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectedItemProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsLockedProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SlideInAnimationGroupProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetSlideInAnimationGroup: *const fn(self: *anyopaque, element: *FrameworkElement, _r: *PivotSlideInAnimationGroup) callconv(.winapi) HRESULT,
        SetSlideInAnimationGroup: *const fn(self: *anyopaque, element: *FrameworkElement, value: PivotSlideInAnimationGroup) callconv(.winapi) HRESULT,
    };
};
pub const IPivotStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getLeftHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LeftHeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLeftHeaderTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LeftHeaderTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getRightHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_RightHeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getRightHeaderTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_RightHeaderTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPivotStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d7518add-be75-4023-8deb-c6513c3192a3";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LeftHeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_LeftHeaderTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_RightHeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_RightHeaderTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IPivotStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getHeaderFocusVisualPlacementProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderFocusVisualPlacementProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsHeaderItemsCarouselEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsHeaderItemsCarouselEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IPivotStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "78b6274e-6616-4600-a039-922a5d09330b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HeaderFocusVisualPlacementProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsHeaderItemsCarouselEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IProgressBar = extern struct {
    vtable: *const VTable,
    pub fn getIsIndeterminate(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsIndeterminate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsIndeterminate(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsIndeterminate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getShowError(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_ShowError(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putShowError(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_ShowError(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getShowPaused(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_ShowPaused(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putShowPaused(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_ShowPaused(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*ProgressBarTemplateSettings {
        var _r: *ProgressBarTemplateSettings = undefined;
        const _c = self.vtable.get_TemplateSettings(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IProgressBar";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ae752c89-0067-4963-bf4c-29db0c4a507e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsIndeterminate: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsIndeterminate: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_ShowError: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_ShowError: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_ShowPaused: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_ShowPaused: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_TemplateSettings: *const fn(self: *anyopaque, _r: **ProgressBarTemplateSettings) callconv(.winapi) HRESULT,
    };
};
pub const IProgressBarFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ProgressBar {
        var _r: *ProgressBar = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IProgressBarFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "da9a8c11-1591-400b-a993-0f1c5cc12f3b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **ProgressBar) callconv(.winapi) HRESULT,
    };
};
pub const IProgressBarStatics = extern struct {
    vtable: *const VTable,
    pub fn getIsIndeterminateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsIndeterminateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getShowErrorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ShowErrorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getShowPausedProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ShowPausedProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IProgressBarStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "7a129fda-5837-4e26-b3b4-e1c092cebbec";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsIndeterminateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ShowErrorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ShowPausedProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IProgressRing = extern struct {
    vtable: *const VTable,
    pub fn getIsActive(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsActive(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsActive(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsActive(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*ProgressRingTemplateSettings {
        var _r: *ProgressRingTemplateSettings = undefined;
        const _c = self.vtable.get_TemplateSettings(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IProgressRing";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6da5e49e-6e9d-425c-bd7c-02173e39763f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsActive: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsActive: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_TemplateSettings: *const fn(self: *anyopaque, _r: **ProgressRingTemplateSettings) callconv(.winapi) HRESULT,
    };
};
pub const IProgressRingStatics = extern struct {
    vtable: *const VTable,
    pub fn getIsActiveProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsActiveProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IProgressRingStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e8b62507-4e2c-47d5-a54a-c6c48a5e6989";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsActiveProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRadioButton = extern struct {
    vtable: *const VTable,
    pub fn getGroupName(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_GroupName(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putGroupName(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_GroupName(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRadioButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "325c44e0-9a03-4bf3-abd6-6fbb46c9a486";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_GroupName: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_GroupName: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
    };
};
pub const IRadioButtonFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*RadioButton {
        var _r: *RadioButton = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRadioButtonFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f1d04933-34e1-4a5c-b2ae-ca3b1c0b20de";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **RadioButton) callconv(.winapi) HRESULT,
    };
};
pub const IRadioButtonStatics = extern struct {
    vtable: *const VTable,
    pub fn getGroupNameProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_GroupNameProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRadioButtonStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6b149293-f50f-4bd8-b0ac-5c162f33a208";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_GroupNameProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRatingControl = extern struct {
    vtable: *const VTable,
    pub fn getCaption(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Caption(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCaption(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_Caption(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getInitialSetValue(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_InitialSetValue(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putInitialSetValue(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_InitialSetValue(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsClearEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsClearEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsClearEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsClearEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsReadOnly(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsReadOnly(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsReadOnly(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsReadOnly(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMaxRating(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_MaxRating(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxRating(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_MaxRating(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPlaceholderValue(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_PlaceholderValue(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPlaceholderValue(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_PlaceholderValue(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getItemInfo(self: *@This()) core.HResult!*RatingItemInfo {
        var _r: *RatingItemInfo = undefined;
        const _c = self.vtable.get_ItemInfo(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemInfo(self: *@This(), value: *RatingItemInfo) core.HResult!void {
        const _c = self.vtable.put_ItemInfo(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getValue(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_Value(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putValue(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_Value(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addValueChanged(self: *@This(), handler: *TypedEventHandler(RatingControl,IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ValueChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeValueChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ValueChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRatingControl";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a7d91ca7-e5cf-4963-a24e-9673fe5ffdd5";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Caption: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_Caption: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_InitialSetValue: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_InitialSetValue: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_IsClearEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsClearEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsReadOnly: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsReadOnly: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_MaxRating: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_MaxRating: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_PlaceholderValue: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_PlaceholderValue: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_ItemInfo: *const fn(self: *anyopaque, _r: **RatingItemInfo) callconv(.winapi) HRESULT,
        put_ItemInfo: *const fn(self: *anyopaque, value: *RatingItemInfo) callconv(.winapi) HRESULT,
        get_Value: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_Value: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        add_ValueChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(RatingControl,IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ValueChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IRatingControlFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*RatingControl {
        var _r: *RatingControl = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRatingControlFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "18d81716-c542-4ccb-b347-5e62c5db782e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **RatingControl) callconv(.winapi) HRESULT,
    };
};
pub const IRatingControlStatics = extern struct {
    vtable: *const VTable,
    pub fn getCaptionProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CaptionProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getInitialSetValueProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_InitialSetValueProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsClearEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsClearEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsReadOnlyProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsReadOnlyProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaxRatingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxRatingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPlaceholderValueProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlaceholderValueProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemInfoProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemInfoProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getValueProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ValueProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRatingControlStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d062d399-ad85-4c1c-b2c4-35dd4432275e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CaptionProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_InitialSetValueProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsClearEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsReadOnlyProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaxRatingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PlaceholderValueProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ItemInfoProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ValueProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRatingItemFontInfo = extern struct {
    vtable: *const VTable,
    pub fn getDisabledGlyph(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_DisabledGlyph(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDisabledGlyph(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_DisabledGlyph(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getGlyph(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Glyph(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putGlyph(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_Glyph(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPointerOverGlyph(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_PointerOverGlyph(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPointerOverGlyph(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_PointerOverGlyph(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPointerOverPlaceholderGlyph(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_PointerOverPlaceholderGlyph(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPointerOverPlaceholderGlyph(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_PointerOverPlaceholderGlyph(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPlaceholderGlyph(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_PlaceholderGlyph(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPlaceholderGlyph(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_PlaceholderGlyph(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getUnsetGlyph(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_UnsetGlyph(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putUnsetGlyph(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_UnsetGlyph(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRatingItemFontInfo";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "054723e9-7989-4d5c-9d01-a7eb876f1071";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_DisabledGlyph: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_DisabledGlyph: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_Glyph: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_Glyph: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_PointerOverGlyph: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_PointerOverGlyph: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_PointerOverPlaceholderGlyph: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_PointerOverPlaceholderGlyph: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_PlaceholderGlyph: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_PlaceholderGlyph: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_UnsetGlyph: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_UnsetGlyph: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
    };
};
pub const IRatingItemFontInfoFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*RatingItemFontInfo {
        var _r: *RatingItemFontInfo = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRatingItemFontInfoFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9603fe56-9e9f-40b5-bae1-4481bb73bcd3";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **RatingItemFontInfo) callconv(.winapi) HRESULT,
    };
};
pub const IRatingItemFontInfoStatics = extern struct {
    vtable: *const VTable,
    pub fn getDisabledGlyphProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DisabledGlyphProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getGlyphProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_GlyphProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPlaceholderGlyphProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlaceholderGlyphProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPointerOverGlyphProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PointerOverGlyphProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPointerOverPlaceholderGlyphProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PointerOverPlaceholderGlyphProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getUnsetGlyphProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_UnsetGlyphProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRatingItemFontInfoStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "fb214f01-6434-4eeb-82ff-7ce5d40bf510";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_DisabledGlyphProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_GlyphProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PlaceholderGlyphProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PointerOverGlyphProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PointerOverPlaceholderGlyphProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_UnsetGlyphProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRatingItemImageInfo = extern struct {
    vtable: *const VTable,
    pub fn getDisabledImage(self: *@This()) core.HResult!*ImageSource {
        var _r: *ImageSource = undefined;
        const _c = self.vtable.get_DisabledImage(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDisabledImage(self: *@This(), value: *ImageSource) core.HResult!void {
        const _c = self.vtable.put_DisabledImage(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getImage(self: *@This()) core.HResult!*ImageSource {
        var _r: *ImageSource = undefined;
        const _c = self.vtable.get_Image(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putImage(self: *@This(), value: *ImageSource) core.HResult!void {
        const _c = self.vtable.put_Image(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPlaceholderImage(self: *@This()) core.HResult!*ImageSource {
        var _r: *ImageSource = undefined;
        const _c = self.vtable.get_PlaceholderImage(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPlaceholderImage(self: *@This(), value: *ImageSource) core.HResult!void {
        const _c = self.vtable.put_PlaceholderImage(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPointerOverImage(self: *@This()) core.HResult!*ImageSource {
        var _r: *ImageSource = undefined;
        const _c = self.vtable.get_PointerOverImage(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPointerOverImage(self: *@This(), value: *ImageSource) core.HResult!void {
        const _c = self.vtable.put_PointerOverImage(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPointerOverPlaceholderImage(self: *@This()) core.HResult!*ImageSource {
        var _r: *ImageSource = undefined;
        const _c = self.vtable.get_PointerOverPlaceholderImage(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPointerOverPlaceholderImage(self: *@This(), value: *ImageSource) core.HResult!void {
        const _c = self.vtable.put_PointerOverPlaceholderImage(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getUnsetImage(self: *@This()) core.HResult!*ImageSource {
        var _r: *ImageSource = undefined;
        const _c = self.vtable.get_UnsetImage(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putUnsetImage(self: *@This(), value: *ImageSource) core.HResult!void {
        const _c = self.vtable.put_UnsetImage(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRatingItemImageInfo";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "25240e8c-e0d2-490e-b8f8-96c8ee0512b9";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_DisabledImage: *const fn(self: *anyopaque, _r: **ImageSource) callconv(.winapi) HRESULT,
        put_DisabledImage: *const fn(self: *anyopaque, value: *ImageSource) callconv(.winapi) HRESULT,
        get_Image: *const fn(self: *anyopaque, _r: **ImageSource) callconv(.winapi) HRESULT,
        put_Image: *const fn(self: *anyopaque, value: *ImageSource) callconv(.winapi) HRESULT,
        get_PlaceholderImage: *const fn(self: *anyopaque, _r: **ImageSource) callconv(.winapi) HRESULT,
        put_PlaceholderImage: *const fn(self: *anyopaque, value: *ImageSource) callconv(.winapi) HRESULT,
        get_PointerOverImage: *const fn(self: *anyopaque, _r: **ImageSource) callconv(.winapi) HRESULT,
        put_PointerOverImage: *const fn(self: *anyopaque, value: *ImageSource) callconv(.winapi) HRESULT,
        get_PointerOverPlaceholderImage: *const fn(self: *anyopaque, _r: **ImageSource) callconv(.winapi) HRESULT,
        put_PointerOverPlaceholderImage: *const fn(self: *anyopaque, value: *ImageSource) callconv(.winapi) HRESULT,
        get_UnsetImage: *const fn(self: *anyopaque, _r: **ImageSource) callconv(.winapi) HRESULT,
        put_UnsetImage: *const fn(self: *anyopaque, value: *ImageSource) callconv(.winapi) HRESULT,
    };
};
pub const IRatingItemImageInfoFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*RatingItemImageInfo {
        var _r: *RatingItemImageInfo = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRatingItemImageInfoFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "269e03f2-da79-4787-9f4a-24a6fa56cde2";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **RatingItemImageInfo) callconv(.winapi) HRESULT,
    };
};
pub const IRatingItemImageInfoStatics = extern struct {
    vtable: *const VTable,
    pub fn getDisabledImageProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DisabledImageProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getImageProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ImageProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPlaceholderImageProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlaceholderImageProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPointerOverImageProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PointerOverImageProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPointerOverPlaceholderImageProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PointerOverPlaceholderImageProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getUnsetImageProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_UnsetImageProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRatingItemImageInfoStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8438486b-4b1c-4123-ba0b-73484d68c338";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_DisabledImageProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ImageProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PlaceholderImageProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PointerOverImageProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PointerOverPlaceholderImageProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_UnsetImageProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRatingItemInfo = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRatingItemInfo";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9ccbe6a2-591e-47a0-a318-6a1f7947da2d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IRatingItemInfoFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*RatingItemInfo {
        var _r: *RatingItemInfo = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRatingItemInfoFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b0fd43d6-cfec-43c8-9ac5-0b0d5e25d862";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **RatingItemInfo) callconv(.winapi) HRESULT,
    };
};
pub const IRefreshContainer = extern struct {
    vtable: *const VTable,
    pub fn getVisualizer(self: *@This()) core.HResult!*RefreshVisualizer {
        var _r: *RefreshVisualizer = undefined;
        const _c = self.vtable.get_Visualizer(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putVisualizer(self: *@This(), value: *RefreshVisualizer) core.HResult!void {
        const _c = self.vtable.put_Visualizer(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPullDirection(self: *@This()) core.HResult!RefreshPullDirection {
        var _r: RefreshPullDirection = undefined;
        const _c = self.vtable.get_PullDirection(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPullDirection(self: *@This(), value: RefreshPullDirection) core.HResult!void {
        const _c = self.vtable.put_PullDirection(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addRefreshRequested(self: *@This(), handler: *TypedEventHandler(RefreshContainer,RefreshRequestedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_RefreshRequested(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeRefreshRequested(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_RefreshRequested(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn RequestRefresh(self: *@This()) core.HResult!void {
        const _c = self.vtable.RequestRefresh(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRefreshContainer";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "535dc413-b1d5-43c1-b057-8658ce1e0ba2";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Visualizer: *const fn(self: *anyopaque, _r: **RefreshVisualizer) callconv(.winapi) HRESULT,
        put_Visualizer: *const fn(self: *anyopaque, value: *RefreshVisualizer) callconv(.winapi) HRESULT,
        get_PullDirection: *const fn(self: *anyopaque, _r: *RefreshPullDirection) callconv(.winapi) HRESULT,
        put_PullDirection: *const fn(self: *anyopaque, value: RefreshPullDirection) callconv(.winapi) HRESULT,
        add_RefreshRequested: *const fn(self: *anyopaque, handler: *TypedEventHandler(RefreshContainer,RefreshRequestedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_RefreshRequested: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        RequestRefresh: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
    };
};
pub const IRefreshContainerFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*RefreshContainer {
        var _r: *RefreshContainer = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRefreshContainerFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0a04777f-089e-4239-baeb-c4641484c37e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **RefreshContainer) callconv(.winapi) HRESULT,
    };
};
pub const IRefreshContainerStatics = extern struct {
    vtable: *const VTable,
    pub fn getVisualizerProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_VisualizerProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPullDirectionProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PullDirectionProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRefreshContainerStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a20af5a5-7015-475d-9de3-81a0479dda38";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_VisualizerProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PullDirectionProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRefreshInteractionRatioChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getInteractionRatio(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_InteractionRatio(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRefreshInteractionRatioChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d7e47820-dc47-4b8e-bb27-7f0a83f29a07";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_InteractionRatio: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
    };
};
pub const IRefreshRequestedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn GetDeferral(self: *@This()) core.HResult!*Deferral {
        var _r: *Deferral = undefined;
        const _c = self.vtable.GetDeferral(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRefreshRequestedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1b089f43-cfcf-4ac6-b31f-8dab6eefdd93";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        GetDeferral: *const fn(self: *anyopaque, _r: **Deferral) callconv(.winapi) HRESULT,
    };
};
pub const IRefreshStateChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getOldState(self: *@This()) core.HResult!RefreshVisualizerState {
        var _r: RefreshVisualizerState = undefined;
        const _c = self.vtable.get_OldState(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getNewState(self: *@This()) core.HResult!RefreshVisualizerState {
        var _r: RefreshVisualizerState = undefined;
        const _c = self.vtable.get_NewState(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRefreshStateChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "bb6c901e-21fe-4109-af80-73ec661b678a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_OldState: *const fn(self: *anyopaque, _r: *RefreshVisualizerState) callconv(.winapi) HRESULT,
        get_NewState: *const fn(self: *anyopaque, _r: *RefreshVisualizerState) callconv(.winapi) HRESULT,
    };
};
pub const IRefreshVisualizer = extern struct {
    vtable: *const VTable,
    pub fn RequestRefresh(self: *@This()) core.HResult!void {
        const _c = self.vtable.RequestRefresh(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOrientation(self: *@This()) core.HResult!RefreshVisualizerOrientation {
        var _r: RefreshVisualizerOrientation = undefined;
        const _c = self.vtable.get_Orientation(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOrientation(self: *@This(), value: RefreshVisualizerOrientation) core.HResult!void {
        const _c = self.vtable.put_Orientation(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getContent(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_Content(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putContent(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_Content(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getState(self: *@This()) core.HResult!RefreshVisualizerState {
        var _r: RefreshVisualizerState = undefined;
        const _c = self.vtable.get_State(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addRefreshRequested(self: *@This(), handler: *TypedEventHandler(RefreshVisualizer,RefreshRequestedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_RefreshRequested(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeRefreshRequested(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_RefreshRequested(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addRefreshStateChanged(self: *@This(), handler: *TypedEventHandler(RefreshVisualizer,RefreshStateChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_RefreshStateChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeRefreshStateChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_RefreshStateChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRefreshVisualizer";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c0e30122-f3eb-4baa-a11f-c3f87342cbf4";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        RequestRefresh: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        get_Orientation: *const fn(self: *anyopaque, _r: *RefreshVisualizerOrientation) callconv(.winapi) HRESULT,
        put_Orientation: *const fn(self: *anyopaque, value: RefreshVisualizerOrientation) callconv(.winapi) HRESULT,
        get_Content: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_Content: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
        get_State: *const fn(self: *anyopaque, _r: *RefreshVisualizerState) callconv(.winapi) HRESULT,
        add_RefreshRequested: *const fn(self: *anyopaque, handler: *TypedEventHandler(RefreshVisualizer,RefreshRequestedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_RefreshRequested: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_RefreshStateChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(RefreshVisualizer,RefreshStateChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_RefreshStateChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IRefreshVisualizerFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*RefreshVisualizer {
        var _r: *RefreshVisualizer = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRefreshVisualizerFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6f5c6132-6e09-4c10-824a-127d36672715";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **RefreshVisualizer) callconv(.winapi) HRESULT,
    };
};
pub const IRefreshVisualizerStatics = extern struct {
    vtable: *const VTable,
    pub fn getInfoProviderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_InfoProviderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOrientationProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OrientationProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getContentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ContentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getStateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_StateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRefreshVisualizerStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "afea56af-362a-4015-b155-733a1f869831";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_InfoProviderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OrientationProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ContentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_StateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRelativePanel = extern struct {
    vtable: *const VTable,
    pub fn getBorderBrush(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_BorderBrush(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_BorderBrush(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBorderThickness(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_BorderThickness(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBorderThickness(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_BorderThickness(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCornerRadius(self: *@This()) core.HResult!CornerRadius {
        var _r: CornerRadius = undefined;
        const _c = self.vtable.get_CornerRadius(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCornerRadius(self: *@This(), value: CornerRadius) core.HResult!void {
        const _c = self.vtable.put_CornerRadius(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPadding(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_Padding(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPadding(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_Padding(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRelativePanel";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "2eabfaeb-b35a-4035-acea-3c4a3730683f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BorderBrush: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_BorderBrush: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_BorderThickness: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_BorderThickness: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
        get_CornerRadius: *const fn(self: *anyopaque, _r: *CornerRadius) callconv(.winapi) HRESULT,
        put_CornerRadius: *const fn(self: *anyopaque, value: CornerRadius) callconv(.winapi) HRESULT,
        get_Padding: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_Padding: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
    };
};
pub const IRelativePanel2 = extern struct {
    vtable: *const VTable,
    pub fn getBackgroundSizing(self: *@This()) core.HResult!BackgroundSizing {
        var _r: BackgroundSizing = undefined;
        const _c = self.vtable.get_BackgroundSizing(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBackgroundSizing(self: *@This(), value: BackgroundSizing) core.HResult!void {
        const _c = self.vtable.put_BackgroundSizing(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRelativePanel2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c09bd88c-1e82-53b3-8c01-7d0432f5f7db";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BackgroundSizing: *const fn(self: *anyopaque, _r: *BackgroundSizing) callconv(.winapi) HRESULT,
        put_BackgroundSizing: *const fn(self: *anyopaque, value: BackgroundSizing) callconv(.winapi) HRESULT,
    };
};
pub const IRelativePanelFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*RelativePanel {
        var _r: *RelativePanel = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRelativePanelFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8460193c-361b-44ba-a17e-b84c9dcdc772";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **RelativePanel) callconv(.winapi) HRESULT,
    };
};
pub const IRelativePanelStatics = extern struct {
    vtable: *const VTable,
    pub fn getLeftOfProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LeftOfProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetLeftOf(self: *@This(), element: *UIElement) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.GetLeftOf(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetLeftOf(self: *@This(), element: *UIElement, value: *IInspectable) core.HResult!void {
        const _c = self.vtable.SetLeftOf(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAboveProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AboveProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetAbove(self: *@This(), element: *UIElement) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.GetAbove(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetAbove(self: *@This(), element: *UIElement, value: *IInspectable) core.HResult!void {
        const _c = self.vtable.SetAbove(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getRightOfProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_RightOfProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetRightOf(self: *@This(), element: *UIElement) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.GetRightOf(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetRightOf(self: *@This(), element: *UIElement, value: *IInspectable) core.HResult!void {
        const _c = self.vtable.SetRightOf(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBelowProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BelowProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetBelow(self: *@This(), element: *UIElement) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.GetBelow(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetBelow(self: *@This(), element: *UIElement, value: *IInspectable) core.HResult!void {
        const _c = self.vtable.SetBelow(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAlignHorizontalCenterWithProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AlignHorizontalCenterWithProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetAlignHorizontalCenterWith(self: *@This(), element: *UIElement) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.GetAlignHorizontalCenterWith(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetAlignHorizontalCenterWith(self: *@This(), element: *UIElement, value: *IInspectable) core.HResult!void {
        const _c = self.vtable.SetAlignHorizontalCenterWith(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAlignVerticalCenterWithProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AlignVerticalCenterWithProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetAlignVerticalCenterWith(self: *@This(), element: *UIElement) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.GetAlignVerticalCenterWith(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetAlignVerticalCenterWith(self: *@This(), element: *UIElement, value: *IInspectable) core.HResult!void {
        const _c = self.vtable.SetAlignVerticalCenterWith(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAlignLeftWithProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AlignLeftWithProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetAlignLeftWith(self: *@This(), element: *UIElement) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.GetAlignLeftWith(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetAlignLeftWith(self: *@This(), element: *UIElement, value: *IInspectable) core.HResult!void {
        const _c = self.vtable.SetAlignLeftWith(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAlignTopWithProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AlignTopWithProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetAlignTopWith(self: *@This(), element: *UIElement) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.GetAlignTopWith(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetAlignTopWith(self: *@This(), element: *UIElement, value: *IInspectable) core.HResult!void {
        const _c = self.vtable.SetAlignTopWith(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAlignRightWithProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AlignRightWithProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetAlignRightWith(self: *@This(), element: *UIElement) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.GetAlignRightWith(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetAlignRightWith(self: *@This(), element: *UIElement, value: *IInspectable) core.HResult!void {
        const _c = self.vtable.SetAlignRightWith(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAlignBottomWithProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AlignBottomWithProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetAlignBottomWith(self: *@This(), element: *UIElement) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.GetAlignBottomWith(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetAlignBottomWith(self: *@This(), element: *UIElement, value: *IInspectable) core.HResult!void {
        const _c = self.vtable.SetAlignBottomWith(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAlignLeftWithPanelProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AlignLeftWithPanelProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetAlignLeftWithPanel(self: *@This(), element: *UIElement) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.GetAlignLeftWithPanel(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetAlignLeftWithPanel(self: *@This(), element: *UIElement, value: bool) core.HResult!void {
        const _c = self.vtable.SetAlignLeftWithPanel(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAlignTopWithPanelProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AlignTopWithPanelProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetAlignTopWithPanel(self: *@This(), element: *UIElement) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.GetAlignTopWithPanel(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetAlignTopWithPanel(self: *@This(), element: *UIElement, value: bool) core.HResult!void {
        const _c = self.vtable.SetAlignTopWithPanel(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAlignRightWithPanelProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AlignRightWithPanelProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetAlignRightWithPanel(self: *@This(), element: *UIElement) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.GetAlignRightWithPanel(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetAlignRightWithPanel(self: *@This(), element: *UIElement, value: bool) core.HResult!void {
        const _c = self.vtable.SetAlignRightWithPanel(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAlignBottomWithPanelProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AlignBottomWithPanelProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetAlignBottomWithPanel(self: *@This(), element: *UIElement) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.GetAlignBottomWithPanel(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetAlignBottomWithPanel(self: *@This(), element: *UIElement, value: bool) core.HResult!void {
        const _c = self.vtable.SetAlignBottomWithPanel(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAlignHorizontalCenterWithPanelProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AlignHorizontalCenterWithPanelProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetAlignHorizontalCenterWithPanel(self: *@This(), element: *UIElement) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.GetAlignHorizontalCenterWithPanel(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetAlignHorizontalCenterWithPanel(self: *@This(), element: *UIElement, value: bool) core.HResult!void {
        const _c = self.vtable.SetAlignHorizontalCenterWithPanel(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAlignVerticalCenterWithPanelProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AlignVerticalCenterWithPanelProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetAlignVerticalCenterWithPanel(self: *@This(), element: *UIElement) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.GetAlignVerticalCenterWithPanel(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetAlignVerticalCenterWithPanel(self: *@This(), element: *UIElement, value: bool) core.HResult!void {
        const _c = self.vtable.SetAlignVerticalCenterWithPanel(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBorderBrushProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BorderBrushProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBorderThicknessProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BorderThicknessProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCornerRadiusProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CornerRadiusProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPaddingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PaddingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRelativePanelStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "15903c27-f18c-4c35-8e19-6a7459d907b6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LeftOfProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetLeftOf: *const fn(self: *anyopaque, element: *UIElement, _r: **IInspectable) callconv(.winapi) HRESULT,
        SetLeftOf: *const fn(self: *anyopaque, element: *UIElement, value: *IInspectable) callconv(.winapi) HRESULT,
        get_AboveProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetAbove: *const fn(self: *anyopaque, element: *UIElement, _r: **IInspectable) callconv(.winapi) HRESULT,
        SetAbove: *const fn(self: *anyopaque, element: *UIElement, value: *IInspectable) callconv(.winapi) HRESULT,
        get_RightOfProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetRightOf: *const fn(self: *anyopaque, element: *UIElement, _r: **IInspectable) callconv(.winapi) HRESULT,
        SetRightOf: *const fn(self: *anyopaque, element: *UIElement, value: *IInspectable) callconv(.winapi) HRESULT,
        get_BelowProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetBelow: *const fn(self: *anyopaque, element: *UIElement, _r: **IInspectable) callconv(.winapi) HRESULT,
        SetBelow: *const fn(self: *anyopaque, element: *UIElement, value: *IInspectable) callconv(.winapi) HRESULT,
        get_AlignHorizontalCenterWithProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetAlignHorizontalCenterWith: *const fn(self: *anyopaque, element: *UIElement, _r: **IInspectable) callconv(.winapi) HRESULT,
        SetAlignHorizontalCenterWith: *const fn(self: *anyopaque, element: *UIElement, value: *IInspectable) callconv(.winapi) HRESULT,
        get_AlignVerticalCenterWithProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetAlignVerticalCenterWith: *const fn(self: *anyopaque, element: *UIElement, _r: **IInspectable) callconv(.winapi) HRESULT,
        SetAlignVerticalCenterWith: *const fn(self: *anyopaque, element: *UIElement, value: *IInspectable) callconv(.winapi) HRESULT,
        get_AlignLeftWithProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetAlignLeftWith: *const fn(self: *anyopaque, element: *UIElement, _r: **IInspectable) callconv(.winapi) HRESULT,
        SetAlignLeftWith: *const fn(self: *anyopaque, element: *UIElement, value: *IInspectable) callconv(.winapi) HRESULT,
        get_AlignTopWithProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetAlignTopWith: *const fn(self: *anyopaque, element: *UIElement, _r: **IInspectable) callconv(.winapi) HRESULT,
        SetAlignTopWith: *const fn(self: *anyopaque, element: *UIElement, value: *IInspectable) callconv(.winapi) HRESULT,
        get_AlignRightWithProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetAlignRightWith: *const fn(self: *anyopaque, element: *UIElement, _r: **IInspectable) callconv(.winapi) HRESULT,
        SetAlignRightWith: *const fn(self: *anyopaque, element: *UIElement, value: *IInspectable) callconv(.winapi) HRESULT,
        get_AlignBottomWithProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetAlignBottomWith: *const fn(self: *anyopaque, element: *UIElement, _r: **IInspectable) callconv(.winapi) HRESULT,
        SetAlignBottomWith: *const fn(self: *anyopaque, element: *UIElement, value: *IInspectable) callconv(.winapi) HRESULT,
        get_AlignLeftWithPanelProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetAlignLeftWithPanel: *const fn(self: *anyopaque, element: *UIElement, _r: *bool) callconv(.winapi) HRESULT,
        SetAlignLeftWithPanel: *const fn(self: *anyopaque, element: *UIElement, value: bool) callconv(.winapi) HRESULT,
        get_AlignTopWithPanelProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetAlignTopWithPanel: *const fn(self: *anyopaque, element: *UIElement, _r: *bool) callconv(.winapi) HRESULT,
        SetAlignTopWithPanel: *const fn(self: *anyopaque, element: *UIElement, value: bool) callconv(.winapi) HRESULT,
        get_AlignRightWithPanelProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetAlignRightWithPanel: *const fn(self: *anyopaque, element: *UIElement, _r: *bool) callconv(.winapi) HRESULT,
        SetAlignRightWithPanel: *const fn(self: *anyopaque, element: *UIElement, value: bool) callconv(.winapi) HRESULT,
        get_AlignBottomWithPanelProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetAlignBottomWithPanel: *const fn(self: *anyopaque, element: *UIElement, _r: *bool) callconv(.winapi) HRESULT,
        SetAlignBottomWithPanel: *const fn(self: *anyopaque, element: *UIElement, value: bool) callconv(.winapi) HRESULT,
        get_AlignHorizontalCenterWithPanelProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetAlignHorizontalCenterWithPanel: *const fn(self: *anyopaque, element: *UIElement, _r: *bool) callconv(.winapi) HRESULT,
        SetAlignHorizontalCenterWithPanel: *const fn(self: *anyopaque, element: *UIElement, value: bool) callconv(.winapi) HRESULT,
        get_AlignVerticalCenterWithPanelProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetAlignVerticalCenterWithPanel: *const fn(self: *anyopaque, element: *UIElement, _r: *bool) callconv(.winapi) HRESULT,
        SetAlignVerticalCenterWithPanel: *const fn(self: *anyopaque, element: *UIElement, value: bool) callconv(.winapi) HRESULT,
        get_BorderBrushProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BorderThicknessProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CornerRadiusProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PaddingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRelativePanelStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getBackgroundSizingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BackgroundSizingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRelativePanelStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8d6b3444-5fbc-5d8b-8b46-22176f21fa8e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BackgroundSizingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRichEditBox = extern struct {
    vtable: *const VTable,
    pub fn getIsReadOnly(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsReadOnly(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsReadOnly(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsReadOnly(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAcceptsReturn(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_AcceptsReturn(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putAcceptsReturn(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_AcceptsReturn(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextAlignment(self: *@This()) core.HResult!TextAlignment {
        var _r: TextAlignment = undefined;
        const _c = self.vtable.get_TextAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextAlignment(self: *@This(), value: TextAlignment) core.HResult!void {
        const _c = self.vtable.put_TextAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextWrapping(self: *@This()) core.HResult!TextWrapping {
        var _r: TextWrapping = undefined;
        const _c = self.vtable.get_TextWrapping(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextWrapping(self: *@This(), value: TextWrapping) core.HResult!void {
        const _c = self.vtable.put_TextWrapping(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsSpellCheckEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsSpellCheckEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsSpellCheckEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsSpellCheckEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsTextPredictionEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsTextPredictionEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsTextPredictionEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsTextPredictionEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDocument(self: *@This()) core.HResult!*ITextDocument {
        var _r: *ITextDocument = undefined;
        const _c = self.vtable.get_Document(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getInputScope(self: *@This()) core.HResult!*InputScope {
        var _r: *InputScope = undefined;
        const _c = self.vtable.get_InputScope(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putInputScope(self: *@This(), value: *InputScope) core.HResult!void {
        const _c = self.vtable.put_InputScope(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addTextChanged(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_TextChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeTextChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_TextChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addSelectionChanged(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_SelectionChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeSelectionChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_SelectionChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addContextMenuOpening(self: *@This(), handler: *ContextMenuOpeningEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ContextMenuOpening(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeContextMenuOpening(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ContextMenuOpening(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichEditBox";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "90a57a40-80b6-4fce-b1ec-e3c616284b6a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsReadOnly: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsReadOnly: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_AcceptsReturn: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_AcceptsReturn: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_TextAlignment: *const fn(self: *anyopaque, _r: *TextAlignment) callconv(.winapi) HRESULT,
        put_TextAlignment: *const fn(self: *anyopaque, value: TextAlignment) callconv(.winapi) HRESULT,
        get_TextWrapping: *const fn(self: *anyopaque, _r: *TextWrapping) callconv(.winapi) HRESULT,
        put_TextWrapping: *const fn(self: *anyopaque, value: TextWrapping) callconv(.winapi) HRESULT,
        get_IsSpellCheckEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsSpellCheckEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsTextPredictionEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsTextPredictionEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_Document: *const fn(self: *anyopaque, _r: **ITextDocument) callconv(.winapi) HRESULT,
        get_InputScope: *const fn(self: *anyopaque, _r: **InputScope) callconv(.winapi) HRESULT,
        put_InputScope: *const fn(self: *anyopaque, value: *InputScope) callconv(.winapi) HRESULT,
        add_TextChanged: *const fn(self: *anyopaque, handler: *RoutedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_TextChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_SelectionChanged: *const fn(self: *anyopaque, handler: *RoutedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_SelectionChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_ContextMenuOpening: *const fn(self: *anyopaque, handler: *ContextMenuOpeningEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ContextMenuOpening: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IRichEditBox2 = extern struct {
    vtable: *const VTable,
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Header(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Header(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_HeaderTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_HeaderTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPlaceholderText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_PlaceholderText(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPlaceholderText(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_PlaceholderText(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectionHighlightColor(self: *@This()) core.HResult!*SolidColorBrush {
        var _r: *SolidColorBrush = undefined;
        const _c = self.vtable.get_SelectionHighlightColor(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectionHighlightColor(self: *@This(), value: *SolidColorBrush) core.HResult!void {
        const _c = self.vtable.put_SelectionHighlightColor(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPreventKeyboardDisplayOnProgrammaticFocus(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_PreventKeyboardDisplayOnProgrammaticFocus(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPreventKeyboardDisplayOnProgrammaticFocus(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_PreventKeyboardDisplayOnProgrammaticFocus(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsColorFontEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsColorFontEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsColorFontEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsColorFontEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addPaste(self: *@This(), handler: *TextControlPasteEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Paste(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removePaste(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Paste(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichEditBox2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "bbea6ead-e805-47a4-bbe7-47e59b8f74a7";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Header: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Header: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_HeaderTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_HeaderTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_PlaceholderText: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_PlaceholderText: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_SelectionHighlightColor: *const fn(self: *anyopaque, _r: **SolidColorBrush) callconv(.winapi) HRESULT,
        put_SelectionHighlightColor: *const fn(self: *anyopaque, value: *SolidColorBrush) callconv(.winapi) HRESULT,
        get_PreventKeyboardDisplayOnProgrammaticFocus: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_PreventKeyboardDisplayOnProgrammaticFocus: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsColorFontEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsColorFontEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        add_Paste: *const fn(self: *anyopaque, handler: *TextControlPasteEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Paste: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IRichEditBox3 = extern struct {
    vtable: *const VTable,
    pub fn addTextCompositionStarted(self: *@This(), handler: *TypedEventHandler(RichEditBox,TextCompositionStartedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_TextCompositionStarted(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeTextCompositionStarted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_TextCompositionStarted(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addTextCompositionChanged(self: *@This(), handler: *TypedEventHandler(RichEditBox,TextCompositionChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_TextCompositionChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeTextCompositionChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_TextCompositionChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addTextCompositionEnded(self: *@This(), handler: *TypedEventHandler(RichEditBox,TextCompositionEndedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_TextCompositionEnded(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeTextCompositionEnded(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_TextCompositionEnded(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextReadingOrder(self: *@This()) core.HResult!TextReadingOrder {
        var _r: TextReadingOrder = undefined;
        const _c = self.vtable.get_TextReadingOrder(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextReadingOrder(self: *@This(), value: TextReadingOrder) core.HResult!void {
        const _c = self.vtable.put_TextReadingOrder(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDesiredCandidateWindowAlignment(self: *@This()) core.HResult!CandidateWindowAlignment {
        var _r: CandidateWindowAlignment = undefined;
        const _c = self.vtable.get_DesiredCandidateWindowAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDesiredCandidateWindowAlignment(self: *@This(), value: CandidateWindowAlignment) core.HResult!void {
        const _c = self.vtable.put_DesiredCandidateWindowAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addCandidateWindowBoundsChanged(self: *@This(), handler: *TypedEventHandler(RichEditBox,CandidateWindowBoundsChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_CandidateWindowBoundsChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeCandidateWindowBoundsChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_CandidateWindowBoundsChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addTextChanging(self: *@This(), handler: *TypedEventHandler(RichEditBox,RichEditBoxTextChangingEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_TextChanging(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeTextChanging(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_TextChanging(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichEditBox3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6b17a462-fbb6-4fff-9991-9399cb9c0b90";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        add_TextCompositionStarted: *const fn(self: *anyopaque, handler: *TypedEventHandler(RichEditBox,TextCompositionStartedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_TextCompositionStarted: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_TextCompositionChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(RichEditBox,TextCompositionChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_TextCompositionChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_TextCompositionEnded: *const fn(self: *anyopaque, handler: *TypedEventHandler(RichEditBox,TextCompositionEndedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_TextCompositionEnded: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        get_TextReadingOrder: *const fn(self: *anyopaque, _r: *TextReadingOrder) callconv(.winapi) HRESULT,
        put_TextReadingOrder: *const fn(self: *anyopaque, value: TextReadingOrder) callconv(.winapi) HRESULT,
        get_DesiredCandidateWindowAlignment: *const fn(self: *anyopaque, _r: *CandidateWindowAlignment) callconv(.winapi) HRESULT,
        put_DesiredCandidateWindowAlignment: *const fn(self: *anyopaque, value: CandidateWindowAlignment) callconv(.winapi) HRESULT,
        add_CandidateWindowBoundsChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(RichEditBox,CandidateWindowBoundsChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_CandidateWindowBoundsChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_TextChanging: *const fn(self: *anyopaque, handler: *TypedEventHandler(RichEditBox,RichEditBoxTextChangingEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_TextChanging: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IRichEditBox4 = extern struct {
    vtable: *const VTable,
    pub fn GetLinguisticAlternativesAsync(self: *@This()) core.HResult!*IAsyncOperation(IVectorView(HSTRING)) {
        var _r: *IAsyncOperation(IVectorView(HSTRING)) = undefined;
        const _c = self.vtable.GetLinguisticAlternativesAsync(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getClipboardCopyFormat(self: *@This()) core.HResult!RichEditClipboardFormat {
        var _r: RichEditClipboardFormat = undefined;
        const _c = self.vtable.get_ClipboardCopyFormat(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putClipboardCopyFormat(self: *@This(), value: RichEditClipboardFormat) core.HResult!void {
        const _c = self.vtable.put_ClipboardCopyFormat(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichEditBox4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5caa8d35-c838-4bad-a07c-204183bb751f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        GetLinguisticAlternativesAsync: *const fn(self: *anyopaque, _r: **IAsyncOperation(IVectorView(HSTRING))) callconv(.winapi) HRESULT,
        get_ClipboardCopyFormat: *const fn(self: *anyopaque, _r: *RichEditClipboardFormat) callconv(.winapi) HRESULT,
        put_ClipboardCopyFormat: *const fn(self: *anyopaque, value: RichEditClipboardFormat) callconv(.winapi) HRESULT,
    };
};
pub const IRichEditBox5 = extern struct {
    vtable: *const VTable,
    pub fn getSelectionHighlightColorWhenNotFocused(self: *@This()) core.HResult!*SolidColorBrush {
        var _r: *SolidColorBrush = undefined;
        const _c = self.vtable.get_SelectionHighlightColorWhenNotFocused(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectionHighlightColorWhenNotFocused(self: *@This(), value: *SolidColorBrush) core.HResult!void {
        const _c = self.vtable.put_SelectionHighlightColorWhenNotFocused(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMaxLength(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_MaxLength(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxLength(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_MaxLength(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichEditBox5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a66d9cea-6391-4f3b-9fd3-1fd01f49f327";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectionHighlightColorWhenNotFocused: *const fn(self: *anyopaque, _r: **SolidColorBrush) callconv(.winapi) HRESULT,
        put_SelectionHighlightColorWhenNotFocused: *const fn(self: *anyopaque, value: *SolidColorBrush) callconv(.winapi) HRESULT,
        get_MaxLength: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_MaxLength: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
    };
};
pub const IRichEditBox6 = extern struct {
    vtable: *const VTable,
    pub fn getHorizontalTextAlignment(self: *@This()) core.HResult!TextAlignment {
        var _r: TextAlignment = undefined;
        const _c = self.vtable.get_HorizontalTextAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHorizontalTextAlignment(self: *@This(), value: TextAlignment) core.HResult!void {
        const _c = self.vtable.put_HorizontalTextAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCharacterCasing(self: *@This()) core.HResult!CharacterCasing {
        var _r: CharacterCasing = undefined;
        const _c = self.vtable.get_CharacterCasing(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCharacterCasing(self: *@This(), value: CharacterCasing) core.HResult!void {
        const _c = self.vtable.put_CharacterCasing(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDisabledFormattingAccelerators(self: *@This()) core.HResult!DisabledFormattingAccelerators {
        var _r: DisabledFormattingAccelerators = undefined;
        const _c = self.vtable.get_DisabledFormattingAccelerators(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDisabledFormattingAccelerators(self: *@This(), value: DisabledFormattingAccelerators) core.HResult!void {
        const _c = self.vtable.put_DisabledFormattingAccelerators(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addCopyingToClipboard(self: *@This(), handler: *TypedEventHandler(RichEditBox,TextControlCopyingToClipboardEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_CopyingToClipboard(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeCopyingToClipboard(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_CopyingToClipboard(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addCuttingToClipboard(self: *@This(), handler: *TypedEventHandler(RichEditBox,TextControlCuttingToClipboardEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_CuttingToClipboard(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeCuttingToClipboard(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_CuttingToClipboard(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichEditBox6";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0c89d500-e8d8-4eae-8804-33649205d7d2";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HorizontalTextAlignment: *const fn(self: *anyopaque, _r: *TextAlignment) callconv(.winapi) HRESULT,
        put_HorizontalTextAlignment: *const fn(self: *anyopaque, value: TextAlignment) callconv(.winapi) HRESULT,
        get_CharacterCasing: *const fn(self: *anyopaque, _r: *CharacterCasing) callconv(.winapi) HRESULT,
        put_CharacterCasing: *const fn(self: *anyopaque, value: CharacterCasing) callconv(.winapi) HRESULT,
        get_DisabledFormattingAccelerators: *const fn(self: *anyopaque, _r: *DisabledFormattingAccelerators) callconv(.winapi) HRESULT,
        put_DisabledFormattingAccelerators: *const fn(self: *anyopaque, value: DisabledFormattingAccelerators) callconv(.winapi) HRESULT,
        add_CopyingToClipboard: *const fn(self: *anyopaque, handler: *TypedEventHandler(RichEditBox,TextControlCopyingToClipboardEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_CopyingToClipboard: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_CuttingToClipboard: *const fn(self: *anyopaque, handler: *TypedEventHandler(RichEditBox,TextControlCuttingToClipboardEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_CuttingToClipboard: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IRichEditBox7 = extern struct {
    vtable: *const VTable,
    pub fn getContentLinkForegroundColor(self: *@This()) core.HResult!*SolidColorBrush {
        var _r: *SolidColorBrush = undefined;
        const _c = self.vtable.get_ContentLinkForegroundColor(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putContentLinkForegroundColor(self: *@This(), value: *SolidColorBrush) core.HResult!void {
        const _c = self.vtable.put_ContentLinkForegroundColor(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getContentLinkBackgroundColor(self: *@This()) core.HResult!*SolidColorBrush {
        var _r: *SolidColorBrush = undefined;
        const _c = self.vtable.get_ContentLinkBackgroundColor(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putContentLinkBackgroundColor(self: *@This(), value: *SolidColorBrush) core.HResult!void {
        const _c = self.vtable.put_ContentLinkBackgroundColor(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getContentLinkProviders(self: *@This()) core.HResult!*ContentLinkProviderCollection {
        var _r: *ContentLinkProviderCollection = undefined;
        const _c = self.vtable.get_ContentLinkProviders(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putContentLinkProviders(self: *@This(), value: *ContentLinkProviderCollection) core.HResult!void {
        const _c = self.vtable.put_ContentLinkProviders(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHandwritingView(self: *@This()) core.HResult!*HandwritingView {
        var _r: *HandwritingView = undefined;
        const _c = self.vtable.get_HandwritingView(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHandwritingView(self: *@This(), value: *HandwritingView) core.HResult!void {
        const _c = self.vtable.put_HandwritingView(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsHandwritingViewEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsHandwritingViewEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsHandwritingViewEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsHandwritingViewEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addContentLinkChanged(self: *@This(), handler: *TypedEventHandler(RichEditBox,ContentLinkChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ContentLinkChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeContentLinkChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ContentLinkChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addContentLinkInvoked(self: *@This(), handler: *TypedEventHandler(RichEditBox,ContentLinkInvokedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ContentLinkInvoked(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeContentLinkInvoked(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ContentLinkInvoked(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichEditBox7";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "980c93ea-241f-4f6a-a539-9d185c8cf18a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ContentLinkForegroundColor: *const fn(self: *anyopaque, _r: **SolidColorBrush) callconv(.winapi) HRESULT,
        put_ContentLinkForegroundColor: *const fn(self: *anyopaque, value: *SolidColorBrush) callconv(.winapi) HRESULT,
        get_ContentLinkBackgroundColor: *const fn(self: *anyopaque, _r: **SolidColorBrush) callconv(.winapi) HRESULT,
        put_ContentLinkBackgroundColor: *const fn(self: *anyopaque, value: *SolidColorBrush) callconv(.winapi) HRESULT,
        get_ContentLinkProviders: *const fn(self: *anyopaque, _r: **ContentLinkProviderCollection) callconv(.winapi) HRESULT,
        put_ContentLinkProviders: *const fn(self: *anyopaque, value: *ContentLinkProviderCollection) callconv(.winapi) HRESULT,
        get_HandwritingView: *const fn(self: *anyopaque, _r: **HandwritingView) callconv(.winapi) HRESULT,
        put_HandwritingView: *const fn(self: *anyopaque, value: *HandwritingView) callconv(.winapi) HRESULT,
        get_IsHandwritingViewEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsHandwritingViewEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        add_ContentLinkChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(RichEditBox,ContentLinkChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ContentLinkChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_ContentLinkInvoked: *const fn(self: *anyopaque, handler: *TypedEventHandler(RichEditBox,ContentLinkInvokedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ContentLinkInvoked: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IRichEditBox8 = extern struct {
    vtable: *const VTable,
    pub fn getTextDocument(self: *@This()) core.HResult!*RichEditTextDocument {
        var _r: *RichEditTextDocument = undefined;
        const _c = self.vtable.get_TextDocument(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionFlyout(self: *@This()) core.HResult!*FlyoutBase {
        var _r: *FlyoutBase = undefined;
        const _c = self.vtable.get_SelectionFlyout(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectionFlyout(self: *@This(), value: *FlyoutBase) core.HResult!void {
        const _c = self.vtable.put_SelectionFlyout(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getProofingMenuFlyout(self: *@This()) core.HResult!*FlyoutBase {
        var _r: *FlyoutBase = undefined;
        const _c = self.vtable.get_ProofingMenuFlyout(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDescription(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Description(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDescription(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Description(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addSelectionChanging(self: *@This(), handler: *TypedEventHandler(RichEditBox,RichEditBoxSelectionChangingEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_SelectionChanging(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeSelectionChanging(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_SelectionChanging(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichEditBox8";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a098e0b8-18e2-513e-9d8d-4e9703410c03";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TextDocument: *const fn(self: *anyopaque, _r: **RichEditTextDocument) callconv(.winapi) HRESULT,
        get_SelectionFlyout: *const fn(self: *anyopaque, _r: **FlyoutBase) callconv(.winapi) HRESULT,
        put_SelectionFlyout: *const fn(self: *anyopaque, value: *FlyoutBase) callconv(.winapi) HRESULT,
        get_ProofingMenuFlyout: *const fn(self: *anyopaque, _r: **FlyoutBase) callconv(.winapi) HRESULT,
        get_Description: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Description: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        add_SelectionChanging: *const fn(self: *anyopaque, handler: *TypedEventHandler(RichEditBox,RichEditBoxSelectionChangingEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_SelectionChanging: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IRichEditBoxFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*RichEditBox {
        var _r: *RichEditBox = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichEditBoxFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "61a1df62-2806-41ed-88ed-ae21f47ab422";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **RichEditBox) callconv(.winapi) HRESULT,
    };
};
pub const IRichEditBoxSelectionChangingEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getSelectionStart(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_SelectionStart(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionLength(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_SelectionLength(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCancel(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_Cancel(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCancel(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_Cancel(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichEditBoxSelectionChangingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "90e0035c-e8b8-5c33-9896-4e989d65829c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectionStart: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_SelectionLength: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_Cancel: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_Cancel: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IRichEditBoxStatics = extern struct {
    vtable: *const VTable,
    pub fn getIsReadOnlyProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsReadOnlyProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getAcceptsReturnProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AcceptsReturnProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextWrappingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextWrappingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsSpellCheckEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsSpellCheckEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsTextPredictionEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsTextPredictionEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getInputScopeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_InputScopeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichEditBoxStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f5e03a74-88ea-479b-9a05-37089ff30ede";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsReadOnlyProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_AcceptsReturnProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextWrappingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsSpellCheckEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsTextPredictionEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_InputScopeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRichEditBoxStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPlaceholderTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlaceholderTextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionHighlightColorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectionHighlightColorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPreventKeyboardDisplayOnProgrammaticFocusProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PreventKeyboardDisplayOnProgrammaticFocusProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsColorFontEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsColorFontEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichEditBoxStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e3eb26de-2748-420b-b1fc-ce95b6e85eec";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PlaceholderTextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectionHighlightColorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PreventKeyboardDisplayOnProgrammaticFocusProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsColorFontEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRichEditBoxStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getDesiredCandidateWindowAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DesiredCandidateWindowAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextReadingOrderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextReadingOrderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichEditBoxStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6d17eec5-1fb3-4c8b-aa23-f5e15d6ab64e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_DesiredCandidateWindowAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextReadingOrderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRichEditBoxStatics4 = extern struct {
    vtable: *const VTable,
    pub fn getClipboardCopyFormatProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ClipboardCopyFormatProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichEditBoxStatics4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f5d54fd7-7796-42a5-a5e5-2cd211ee8176";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ClipboardCopyFormatProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRichEditBoxStatics5 = extern struct {
    vtable: *const VTable,
    pub fn getSelectionHighlightColorWhenNotFocusedProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectionHighlightColorWhenNotFocusedProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaxLengthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxLengthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichEditBoxStatics5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4b5c4568-43d5-43e6-bbb9-cb4e6250f45a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectionHighlightColorWhenNotFocusedProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaxLengthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRichEditBoxStatics6 = extern struct {
    vtable: *const VTable,
    pub fn getHorizontalTextAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HorizontalTextAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCharacterCasingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CharacterCasingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDisabledFormattingAcceleratorsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DisabledFormattingAcceleratorsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichEditBoxStatics6";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "fe40e287-82ed-4f7e-92ba-66f67bc1ff44";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HorizontalTextAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CharacterCasingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DisabledFormattingAcceleratorsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRichEditBoxStatics7 = extern struct {
    vtable: *const VTable,
    pub fn getContentLinkForegroundColorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ContentLinkForegroundColorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getContentLinkBackgroundColorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ContentLinkBackgroundColorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getContentLinkProvidersProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ContentLinkProvidersProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHandwritingViewProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HandwritingViewProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsHandwritingViewEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsHandwritingViewEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichEditBoxStatics7";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "59fa898f-f861-43da-a7ce-4b9c21d835f9";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ContentLinkForegroundColorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ContentLinkBackgroundColorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ContentLinkProvidersProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HandwritingViewProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsHandwritingViewEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRichEditBoxStatics8 = extern struct {
    vtable: *const VTable,
    pub fn getSelectionFlyoutProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectionFlyoutProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getProofingMenuFlyoutProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ProofingMenuFlyoutProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDescriptionProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DescriptionProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichEditBoxStatics8";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "58045172-106b-56a9-a8e4-4b74bf347d4e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectionFlyoutProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ProofingMenuFlyoutProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DescriptionProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRichEditBoxTextChangingEventArgs = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichEditBoxTextChangingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "54065018-2813-4922-9f8e-b6bbafd995d8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IRichEditBoxTextChangingEventArgs2 = extern struct {
    vtable: *const VTable,
    pub fn getIsContentChanging(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsContentChanging(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichEditBoxTextChangingEventArgs2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "395b0db5-636e-413e-9eb4-fc22ebfa3628";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsContentChanging: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
    };
};
pub const IRichTextBlock = extern struct {
    vtable: *const VTable,
    pub fn getFontSize(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_FontSize(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontSize(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_FontSize(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontFamily(self: *@This()) core.HResult!*FontFamily {
        var _r: *FontFamily = undefined;
        const _c = self.vtable.get_FontFamily(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontFamily(self: *@This(), value: *FontFamily) core.HResult!void {
        const _c = self.vtable.put_FontFamily(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontWeight(self: *@This()) core.HResult!FontWeight {
        var _r: FontWeight = undefined;
        const _c = self.vtable.get_FontWeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontWeight(self: *@This(), value: FontWeight) core.HResult!void {
        const _c = self.vtable.put_FontWeight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontStyle(self: *@This()) core.HResult!FontStyle {
        var _r: FontStyle = undefined;
        const _c = self.vtable.get_FontStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontStyle(self: *@This(), value: FontStyle) core.HResult!void {
        const _c = self.vtable.put_FontStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontStretch(self: *@This()) core.HResult!FontStretch {
        var _r: FontStretch = undefined;
        const _c = self.vtable.get_FontStretch(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontStretch(self: *@This(), value: FontStretch) core.HResult!void {
        const _c = self.vtable.put_FontStretch(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_Foreground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_Foreground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextWrapping(self: *@This()) core.HResult!TextWrapping {
        var _r: TextWrapping = undefined;
        const _c = self.vtable.get_TextWrapping(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextWrapping(self: *@This(), value: TextWrapping) core.HResult!void {
        const _c = self.vtable.put_TextWrapping(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextTrimming(self: *@This()) core.HResult!TextTrimming {
        var _r: TextTrimming = undefined;
        const _c = self.vtable.get_TextTrimming(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextTrimming(self: *@This(), value: TextTrimming) core.HResult!void {
        const _c = self.vtable.put_TextTrimming(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextAlignment(self: *@This()) core.HResult!TextAlignment {
        var _r: TextAlignment = undefined;
        const _c = self.vtable.get_TextAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextAlignment(self: *@This(), value: TextAlignment) core.HResult!void {
        const _c = self.vtable.put_TextAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBlocks(self: *@This()) core.HResult!*BlockCollection {
        var _r: *BlockCollection = undefined;
        const _c = self.vtable.get_Blocks(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPadding(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_Padding(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPadding(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_Padding(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getLineHeight(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_LineHeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putLineHeight(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_LineHeight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getLineStackingStrategy(self: *@This()) core.HResult!LineStackingStrategy {
        var _r: LineStackingStrategy = undefined;
        const _c = self.vtable.get_LineStackingStrategy(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putLineStackingStrategy(self: *@This(), value: LineStackingStrategy) core.HResult!void {
        const _c = self.vtable.put_LineStackingStrategy(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCharacterSpacing(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_CharacterSpacing(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCharacterSpacing(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_CharacterSpacing(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOverflowContentTarget(self: *@This()) core.HResult!*RichTextBlockOverflow {
        var _r: *RichTextBlockOverflow = undefined;
        const _c = self.vtable.get_OverflowContentTarget(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOverflowContentTarget(self: *@This(), value: *RichTextBlockOverflow) core.HResult!void {
        const _c = self.vtable.put_OverflowContentTarget(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsTextSelectionEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsTextSelectionEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsTextSelectionEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsTextSelectionEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHasOverflowContent(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_HasOverflowContent(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_SelectedText(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getContentStart(self: *@This()) core.HResult!*TextPointer {
        var _r: *TextPointer = undefined;
        const _c = self.vtable.get_ContentStart(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getContentEnd(self: *@This()) core.HResult!*TextPointer {
        var _r: *TextPointer = undefined;
        const _c = self.vtable.get_ContentEnd(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionStart(self: *@This()) core.HResult!*TextPointer {
        var _r: *TextPointer = undefined;
        const _c = self.vtable.get_SelectionStart(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionEnd(self: *@This()) core.HResult!*TextPointer {
        var _r: *TextPointer = undefined;
        const _c = self.vtable.get_SelectionEnd(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBaselineOffset(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_BaselineOffset(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addSelectionChanged(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_SelectionChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeSelectionChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_SelectionChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addContextMenuOpening(self: *@This(), handler: *ContextMenuOpeningEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ContextMenuOpening(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeContextMenuOpening(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ContextMenuOpening(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn SelectAll(self: *@This()) core.HResult!void {
        const _c = self.vtable.SelectAll(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Select(self: *@This(), start: *TextPointer, end: *TextPointer) core.HResult!void {
        const _c = self.vtable.Select(@ptrCast(self), start, end);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn GetPositionFromPoint(self: *@This(), point: Point) core.HResult!*TextPointer {
        var _r: *TextPointer = undefined;
        const _c = self.vtable.GetPositionFromPoint(@ptrCast(self), point, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn Focus(self: *@This(), value: FocusState) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.Focus(@ptrCast(self), value, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextIndent(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_TextIndent(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextIndent(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_TextIndent(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichTextBlock";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e5fff9e2-b968-49e7-97d4-8cca2ac3ae7c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_FontSize: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_FontSize: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_FontFamily: *const fn(self: *anyopaque, _r: **FontFamily) callconv(.winapi) HRESULT,
        put_FontFamily: *const fn(self: *anyopaque, value: *FontFamily) callconv(.winapi) HRESULT,
        get_FontWeight: *const fn(self: *anyopaque, _r: *FontWeight) callconv(.winapi) HRESULT,
        put_FontWeight: *const fn(self: *anyopaque, value: FontWeight) callconv(.winapi) HRESULT,
        get_FontStyle: *const fn(self: *anyopaque, _r: *FontStyle) callconv(.winapi) HRESULT,
        put_FontStyle: *const fn(self: *anyopaque, value: FontStyle) callconv(.winapi) HRESULT,
        get_FontStretch: *const fn(self: *anyopaque, _r: *FontStretch) callconv(.winapi) HRESULT,
        put_FontStretch: *const fn(self: *anyopaque, value: FontStretch) callconv(.winapi) HRESULT,
        get_Foreground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_Foreground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_TextWrapping: *const fn(self: *anyopaque, _r: *TextWrapping) callconv(.winapi) HRESULT,
        put_TextWrapping: *const fn(self: *anyopaque, value: TextWrapping) callconv(.winapi) HRESULT,
        get_TextTrimming: *const fn(self: *anyopaque, _r: *TextTrimming) callconv(.winapi) HRESULT,
        put_TextTrimming: *const fn(self: *anyopaque, value: TextTrimming) callconv(.winapi) HRESULT,
        get_TextAlignment: *const fn(self: *anyopaque, _r: *TextAlignment) callconv(.winapi) HRESULT,
        put_TextAlignment: *const fn(self: *anyopaque, value: TextAlignment) callconv(.winapi) HRESULT,
        get_Blocks: *const fn(self: *anyopaque, _r: **BlockCollection) callconv(.winapi) HRESULT,
        get_Padding: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_Padding: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
        get_LineHeight: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_LineHeight: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_LineStackingStrategy: *const fn(self: *anyopaque, _r: *LineStackingStrategy) callconv(.winapi) HRESULT,
        put_LineStackingStrategy: *const fn(self: *anyopaque, value: LineStackingStrategy) callconv(.winapi) HRESULT,
        get_CharacterSpacing: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_CharacterSpacing: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_OverflowContentTarget: *const fn(self: *anyopaque, _r: **RichTextBlockOverflow) callconv(.winapi) HRESULT,
        put_OverflowContentTarget: *const fn(self: *anyopaque, value: *RichTextBlockOverflow) callconv(.winapi) HRESULT,
        get_IsTextSelectionEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsTextSelectionEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_HasOverflowContent: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_SelectedText: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        get_ContentStart: *const fn(self: *anyopaque, _r: **TextPointer) callconv(.winapi) HRESULT,
        get_ContentEnd: *const fn(self: *anyopaque, _r: **TextPointer) callconv(.winapi) HRESULT,
        get_SelectionStart: *const fn(self: *anyopaque, _r: **TextPointer) callconv(.winapi) HRESULT,
        get_SelectionEnd: *const fn(self: *anyopaque, _r: **TextPointer) callconv(.winapi) HRESULT,
        get_BaselineOffset: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        add_SelectionChanged: *const fn(self: *anyopaque, handler: *RoutedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_SelectionChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_ContextMenuOpening: *const fn(self: *anyopaque, handler: *ContextMenuOpeningEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ContextMenuOpening: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        SelectAll: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        Select: *const fn(self: *anyopaque, start: *TextPointer, end: *TextPointer) callconv(.winapi) HRESULT,
        GetPositionFromPoint: *const fn(self: *anyopaque, point: Point, _r: **TextPointer) callconv(.winapi) HRESULT,
        Focus: *const fn(self: *anyopaque, value: FocusState, _r: *bool) callconv(.winapi) HRESULT,
        get_TextIndent: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_TextIndent: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
    };
};
pub const IRichTextBlock2 = extern struct {
    vtable: *const VTable,
    pub fn getMaxLines(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_MaxLines(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxLines(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_MaxLines(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextLineBounds(self: *@This()) core.HResult!TextLineBounds {
        var _r: TextLineBounds = undefined;
        const _c = self.vtable.get_TextLineBounds(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextLineBounds(self: *@This(), value: TextLineBounds) core.HResult!void {
        const _c = self.vtable.put_TextLineBounds(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectionHighlightColor(self: *@This()) core.HResult!*SolidColorBrush {
        var _r: *SolidColorBrush = undefined;
        const _c = self.vtable.get_SelectionHighlightColor(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectionHighlightColor(self: *@This(), value: *SolidColorBrush) core.HResult!void {
        const _c = self.vtable.put_SelectionHighlightColor(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOpticalMarginAlignment(self: *@This()) core.HResult!OpticalMarginAlignment {
        var _r: OpticalMarginAlignment = undefined;
        const _c = self.vtable.get_OpticalMarginAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOpticalMarginAlignment(self: *@This(), value: OpticalMarginAlignment) core.HResult!void {
        const _c = self.vtable.put_OpticalMarginAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsColorFontEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsColorFontEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsColorFontEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsColorFontEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextReadingOrder(self: *@This()) core.HResult!TextReadingOrder {
        var _r: TextReadingOrder = undefined;
        const _c = self.vtable.get_TextReadingOrder(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextReadingOrder(self: *@This(), value: TextReadingOrder) core.HResult!void {
        const _c = self.vtable.put_TextReadingOrder(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichTextBlock2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3f209013-03e7-4508-964a-91aedab3d11e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_MaxLines: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_MaxLines: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_TextLineBounds: *const fn(self: *anyopaque, _r: *TextLineBounds) callconv(.winapi) HRESULT,
        put_TextLineBounds: *const fn(self: *anyopaque, value: TextLineBounds) callconv(.winapi) HRESULT,
        get_SelectionHighlightColor: *const fn(self: *anyopaque, _r: **SolidColorBrush) callconv(.winapi) HRESULT,
        put_SelectionHighlightColor: *const fn(self: *anyopaque, value: *SolidColorBrush) callconv(.winapi) HRESULT,
        get_OpticalMarginAlignment: *const fn(self: *anyopaque, _r: *OpticalMarginAlignment) callconv(.winapi) HRESULT,
        put_OpticalMarginAlignment: *const fn(self: *anyopaque, value: OpticalMarginAlignment) callconv(.winapi) HRESULT,
        get_IsColorFontEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsColorFontEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_TextReadingOrder: *const fn(self: *anyopaque, _r: *TextReadingOrder) callconv(.winapi) HRESULT,
        put_TextReadingOrder: *const fn(self: *anyopaque, value: TextReadingOrder) callconv(.winapi) HRESULT,
    };
};
pub const IRichTextBlock3 = extern struct {
    vtable: *const VTable,
    pub fn getIsTextScaleFactorEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsTextScaleFactorEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsTextScaleFactorEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsTextScaleFactorEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichTextBlock3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "7d39ae83-8918-4613-b007-7c898ba2950e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsTextScaleFactorEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsTextScaleFactorEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IRichTextBlock4 = extern struct {
    vtable: *const VTable,
    pub fn getTextDecorations(self: *@This()) core.HResult!TextDecorations {
        var _r: TextDecorations = undefined;
        const _c = self.vtable.get_TextDecorations(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextDecorations(self: *@This(), value: TextDecorations) core.HResult!void {
        const _c = self.vtable.put_TextDecorations(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichTextBlock4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3577c1ea-24fd-4f50-bbe4-3fb654ea58c5";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TextDecorations: *const fn(self: *anyopaque, _r: *TextDecorations) callconv(.winapi) HRESULT,
        put_TextDecorations: *const fn(self: *anyopaque, value: TextDecorations) callconv(.winapi) HRESULT,
    };
};
pub const IRichTextBlock5 = extern struct {
    vtable: *const VTable,
    pub fn getIsTextTrimmed(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsTextTrimmed(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHorizontalTextAlignment(self: *@This()) core.HResult!TextAlignment {
        var _r: TextAlignment = undefined;
        const _c = self.vtable.get_HorizontalTextAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHorizontalTextAlignment(self: *@This(), value: TextAlignment) core.HResult!void {
        const _c = self.vtable.put_HorizontalTextAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextHighlighters(self: *@This()) core.HResult!*IVector(TextHighlighter) {
        var _r: *IVector(TextHighlighter) = undefined;
        const _c = self.vtable.get_TextHighlighters(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addIsTextTrimmedChanged(self: *@This(), handler: *TypedEventHandler(RichTextBlock,IsTextTrimmedChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_IsTextTrimmedChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeIsTextTrimmedChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_IsTextTrimmedChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichTextBlock5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9c7dc0c6-7a9f-45b6-8818-822c549ba094";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsTextTrimmed: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_HorizontalTextAlignment: *const fn(self: *anyopaque, _r: *TextAlignment) callconv(.winapi) HRESULT,
        put_HorizontalTextAlignment: *const fn(self: *anyopaque, value: TextAlignment) callconv(.winapi) HRESULT,
        get_TextHighlighters: *const fn(self: *anyopaque, _r: **IVector(TextHighlighter)) callconv(.winapi) HRESULT,
        add_IsTextTrimmedChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(RichTextBlock,IsTextTrimmedChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_IsTextTrimmedChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IRichTextBlock6 = extern struct {
    vtable: *const VTable,
    pub fn getSelectionFlyout(self: *@This()) core.HResult!*FlyoutBase {
        var _r: *FlyoutBase = undefined;
        const _c = self.vtable.get_SelectionFlyout(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectionFlyout(self: *@This(), value: *FlyoutBase) core.HResult!void {
        const _c = self.vtable.put_SelectionFlyout(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn CopySelectionToClipboard(self: *@This()) core.HResult!void {
        const _c = self.vtable.CopySelectionToClipboard(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichTextBlock6";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ae9010cd-e899-526e-927e-88e0eed693c8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectionFlyout: *const fn(self: *anyopaque, _r: **FlyoutBase) callconv(.winapi) HRESULT,
        put_SelectionFlyout: *const fn(self: *anyopaque, value: *FlyoutBase) callconv(.winapi) HRESULT,
        CopySelectionToClipboard: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
    };
};
pub const IRichTextBlockOverflow = extern struct {
    vtable: *const VTable,
    pub fn getOverflowContentTarget(self: *@This()) core.HResult!*RichTextBlockOverflow {
        var _r: *RichTextBlockOverflow = undefined;
        const _c = self.vtable.get_OverflowContentTarget(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOverflowContentTarget(self: *@This(), value: *RichTextBlockOverflow) core.HResult!void {
        const _c = self.vtable.put_OverflowContentTarget(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPadding(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_Padding(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPadding(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_Padding(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getContentSource(self: *@This()) core.HResult!*RichTextBlock {
        var _r: *RichTextBlock = undefined;
        const _c = self.vtable.get_ContentSource(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHasOverflowContent(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_HasOverflowContent(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getContentStart(self: *@This()) core.HResult!*TextPointer {
        var _r: *TextPointer = undefined;
        const _c = self.vtable.get_ContentStart(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getContentEnd(self: *@This()) core.HResult!*TextPointer {
        var _r: *TextPointer = undefined;
        const _c = self.vtable.get_ContentEnd(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBaselineOffset(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_BaselineOffset(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetPositionFromPoint(self: *@This(), point: Point) core.HResult!*TextPointer {
        var _r: *TextPointer = undefined;
        const _c = self.vtable.GetPositionFromPoint(@ptrCast(self), point, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn Focus(self: *@This(), value: FocusState) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.Focus(@ptrCast(self), value, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichTextBlockOverflow";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4f93749b-dac3-4a42-9cbb-99f0de37c071";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_OverflowContentTarget: *const fn(self: *anyopaque, _r: **RichTextBlockOverflow) callconv(.winapi) HRESULT,
        put_OverflowContentTarget: *const fn(self: *anyopaque, value: *RichTextBlockOverflow) callconv(.winapi) HRESULT,
        get_Padding: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_Padding: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
        get_ContentSource: *const fn(self: *anyopaque, _r: **RichTextBlock) callconv(.winapi) HRESULT,
        get_HasOverflowContent: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_ContentStart: *const fn(self: *anyopaque, _r: **TextPointer) callconv(.winapi) HRESULT,
        get_ContentEnd: *const fn(self: *anyopaque, _r: **TextPointer) callconv(.winapi) HRESULT,
        get_BaselineOffset: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        GetPositionFromPoint: *const fn(self: *anyopaque, point: Point, _r: **TextPointer) callconv(.winapi) HRESULT,
        Focus: *const fn(self: *anyopaque, value: FocusState, _r: *bool) callconv(.winapi) HRESULT,
    };
};
pub const IRichTextBlockOverflow2 = extern struct {
    vtable: *const VTable,
    pub fn getMaxLines(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_MaxLines(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxLines(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_MaxLines(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichTextBlockOverflow2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8742624e-a882-4826-b929-4d5c3905b9a1";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_MaxLines: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_MaxLines: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
    };
};
pub const IRichTextBlockOverflow3 = extern struct {
    vtable: *const VTable,
    pub fn getIsTextTrimmed(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsTextTrimmed(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addIsTextTrimmedChanged(self: *@This(), handler: *TypedEventHandler(RichTextBlockOverflow,IsTextTrimmedChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_IsTextTrimmedChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeIsTextTrimmedChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_IsTextTrimmedChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichTextBlockOverflow3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "7f69587b-5c7f-4b5f-bdbc-fb95c90e10de";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsTextTrimmed: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        add_IsTextTrimmedChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(RichTextBlockOverflow,IsTextTrimmedChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_IsTextTrimmedChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IRichTextBlockOverflowStatics = extern struct {
    vtable: *const VTable,
    pub fn getOverflowContentTargetProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OverflowContentTargetProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPaddingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PaddingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHasOverflowContentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HasOverflowContentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichTextBlockOverflowStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "041ac2f7-4f2b-43c3-a122-3fea9ca9dc87";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_OverflowContentTargetProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PaddingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HasOverflowContentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRichTextBlockOverflowStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getMaxLinesProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxLinesProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichTextBlockOverflowStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b5ebed4c-f8c4-4a3a-907f-e53e78279fa3";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_MaxLinesProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRichTextBlockOverflowStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getIsTextTrimmedProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsTextTrimmedProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichTextBlockOverflowStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d1d4a705-eb0b-4ecb-b9b7-e65d03087c8e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsTextTrimmedProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRichTextBlockStatics = extern struct {
    vtable: *const VTable,
    pub fn getFontSizeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontSizeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontFamilyProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontFamilyProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontWeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontWeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontStretchProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontStretchProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextWrappingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextWrappingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextTrimmingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextTrimmingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPaddingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PaddingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLineHeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LineHeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLineStackingStrategyProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LineStackingStrategyProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCharacterSpacingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CharacterSpacingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOverflowContentTargetProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OverflowContentTargetProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsTextSelectionEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsTextSelectionEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHasOverflowContentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HasOverflowContentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedTextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextIndentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextIndentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichTextBlockStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "492d883c-adea-433c-be1c-208a164262be";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_FontSizeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontFamilyProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontWeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontStretchProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextWrappingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextTrimmingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PaddingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_LineHeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_LineStackingStrategyProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CharacterSpacingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OverflowContentTargetProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsTextSelectionEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HasOverflowContentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectedTextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextIndentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRichTextBlockStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getMaxLinesProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxLinesProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextLineBoundsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextLineBoundsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionHighlightColorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectionHighlightColorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOpticalMarginAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OpticalMarginAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsColorFontEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsColorFontEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextReadingOrderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextReadingOrderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichTextBlockStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0d6131e1-af29-48ce-8aaf-74ecc28bfbb0";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_MaxLinesProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextLineBoundsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectionHighlightColorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OpticalMarginAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsColorFontEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextReadingOrderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRichTextBlockStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getIsTextScaleFactorEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsTextScaleFactorEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichTextBlockStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "073f7ef4-ca2b-4b49-a59a-31d8fa743332";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsTextScaleFactorEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRichTextBlockStatics4 = extern struct {
    vtable: *const VTable,
    pub fn getTextDecorationsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextDecorationsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichTextBlockStatics4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "80155bc4-6d96-4b08-ad57-13db0f046412";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TextDecorationsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRichTextBlockStatics5 = extern struct {
    vtable: *const VTable,
    pub fn getIsTextTrimmedProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsTextTrimmedProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHorizontalTextAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HorizontalTextAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichTextBlockStatics5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ac9283a1-4f25-4280-8868-3eeee82821e8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsTextTrimmedProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HorizontalTextAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRichTextBlockStatics6 = extern struct {
    vtable: *const VTable,
    pub fn getSelectionFlyoutProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectionFlyoutProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRichTextBlockStatics6";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "073057e7-91c5-5857-be7c-e72621239786";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectionFlyoutProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IRowDefinition = extern struct {
    vtable: *const VTable,
    pub fn getHeight(self: *@This()) core.HResult!GridLength {
        var _r: GridLength = undefined;
        const _c = self.vtable.get_Height(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeight(self: *@This(), value: GridLength) core.HResult!void {
        const _c = self.vtable.put_Height(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMaxHeight(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_MaxHeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxHeight(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_MaxHeight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMinHeight(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_MinHeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMinHeight(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_MinHeight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getActualHeight(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_ActualHeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRowDefinition";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4abae829-d80c-4a5e-a48c-f8b3d3b6533d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Height: *const fn(self: *anyopaque, _r: *GridLength) callconv(.winapi) HRESULT,
        put_Height: *const fn(self: *anyopaque, value: GridLength) callconv(.winapi) HRESULT,
        get_MaxHeight: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_MaxHeight: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_MinHeight: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_MinHeight: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_ActualHeight: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
    };
};
pub const IRowDefinitionStatics = extern struct {
    vtable: *const VTable,
    pub fn getHeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaxHeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxHeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMinHeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MinHeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IRowDefinitionStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5adf3fe5-2056-4724-94d6-e4812b022ec8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaxHeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MinHeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IScrollAnchorProvider = extern struct {
    vtable: *const VTable,
    pub fn getCurrentAnchor(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_CurrentAnchor(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn RegisterAnchorCandidate(self: *@This(), element: *UIElement) core.HResult!void {
        const _c = self.vtable.RegisterAnchorCandidate(@ptrCast(self), element);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn UnregisterAnchorCandidate(self: *@This(), element: *UIElement) core.HResult!void {
        const _c = self.vtable.UnregisterAnchorCandidate(@ptrCast(self), element);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IScrollAnchorProvider";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6ae99a0f-478c-5440-b2c6-ead4378ef8e4";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CurrentAnchor: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        RegisterAnchorCandidate: *const fn(self: *anyopaque, element: *UIElement) callconv(.winapi) HRESULT,
        UnregisterAnchorCandidate: *const fn(self: *anyopaque, element: *UIElement) callconv(.winapi) HRESULT,
    };
};
pub const IScrollContentPresenter = extern struct {
    vtable: *const VTable,
    pub fn getCanVerticallyScroll(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_CanVerticallyScroll(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCanVerticallyScroll(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_CanVerticallyScroll(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCanHorizontallyScroll(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_CanHorizontallyScroll(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCanHorizontallyScroll(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_CanHorizontallyScroll(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getExtentWidth(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_ExtentWidth(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getExtentHeight(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_ExtentHeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getViewportWidth(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_ViewportWidth(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getViewportHeight(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_ViewportHeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHorizontalOffset(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_HorizontalOffset(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getVerticalOffset(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_VerticalOffset(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getScrollOwner(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_ScrollOwner(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putScrollOwner(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_ScrollOwner(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn LineUp(self: *@This()) core.HResult!void {
        const _c = self.vtable.LineUp(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn LineDown(self: *@This()) core.HResult!void {
        const _c = self.vtable.LineDown(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn LineLeft(self: *@This()) core.HResult!void {
        const _c = self.vtable.LineLeft(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn LineRight(self: *@This()) core.HResult!void {
        const _c = self.vtable.LineRight(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn PageUp(self: *@This()) core.HResult!void {
        const _c = self.vtable.PageUp(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn PageDown(self: *@This()) core.HResult!void {
        const _c = self.vtable.PageDown(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn PageLeft(self: *@This()) core.HResult!void {
        const _c = self.vtable.PageLeft(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn PageRight(self: *@This()) core.HResult!void {
        const _c = self.vtable.PageRight(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn MouseWheelUp(self: *@This()) core.HResult!void {
        const _c = self.vtable.MouseWheelUp(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn MouseWheelDown(self: *@This()) core.HResult!void {
        const _c = self.vtable.MouseWheelDown(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn MouseWheelLeft(self: *@This()) core.HResult!void {
        const _c = self.vtable.MouseWheelLeft(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn MouseWheelRight(self: *@This()) core.HResult!void {
        const _c = self.vtable.MouseWheelRight(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn SetHorizontalOffset(self: *@This(), offset: f64) core.HResult!void {
        const _c = self.vtable.SetHorizontalOffset(@ptrCast(self), offset);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn SetVerticalOffset(self: *@This(), offset: f64) core.HResult!void {
        const _c = self.vtable.SetVerticalOffset(@ptrCast(self), offset);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn MakeVisible(self: *@This(), visual: *UIElement, rectangle: Rect) core.HResult!Rect {
        var _r: Rect = undefined;
        const _c = self.vtable.MakeVisible(@ptrCast(self), visual, rectangle, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IScrollContentPresenter";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5712ee2b-0eeb-46d3-aa31-5f6801b8de20";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CanVerticallyScroll: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_CanVerticallyScroll: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_CanHorizontallyScroll: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_CanHorizontallyScroll: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_ExtentWidth: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        get_ExtentHeight: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        get_ViewportWidth: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        get_ViewportHeight: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        get_HorizontalOffset: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        get_VerticalOffset: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        get_ScrollOwner: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_ScrollOwner: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        LineUp: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        LineDown: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        LineLeft: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        LineRight: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        PageUp: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        PageDown: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        PageLeft: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        PageRight: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        MouseWheelUp: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        MouseWheelDown: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        MouseWheelLeft: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        MouseWheelRight: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        SetHorizontalOffset: *const fn(self: *anyopaque, offset: f64) callconv(.winapi) HRESULT,
        SetVerticalOffset: *const fn(self: *anyopaque, offset: f64) callconv(.winapi) HRESULT,
        MakeVisible: *const fn(self: *anyopaque, visual: *UIElement, rectangle: Rect, _r: *Rect) callconv(.winapi) HRESULT,
    };
};
pub const IScrollContentPresenter2 = extern struct {
    vtable: *const VTable,
    pub fn getCanContentRenderOutsideBounds(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_CanContentRenderOutsideBounds(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCanContentRenderOutsideBounds(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_CanContentRenderOutsideBounds(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSizesContentToTemplatedParent(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_SizesContentToTemplatedParent(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSizesContentToTemplatedParent(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_SizesContentToTemplatedParent(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IScrollContentPresenter2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5f9f2737-2318-5999-8a62-c3ed3c0e98b6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CanContentRenderOutsideBounds: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_CanContentRenderOutsideBounds: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_SizesContentToTemplatedParent: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_SizesContentToTemplatedParent: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IScrollContentPresenterStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getCanContentRenderOutsideBoundsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CanContentRenderOutsideBoundsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSizesContentToTemplatedParentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SizesContentToTemplatedParentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IScrollContentPresenterStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e172ff1a-c676-524b-8f20-96152149d05e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CanContentRenderOutsideBoundsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SizesContentToTemplatedParentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IScrollViewer = extern struct {
    vtable: *const VTable,
    pub fn getHorizontalScrollBarVisibility(self: *@This()) core.HResult!ScrollBarVisibility {
        var _r: ScrollBarVisibility = undefined;
        const _c = self.vtable.get_HorizontalScrollBarVisibility(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHorizontalScrollBarVisibility(self: *@This(), value: ScrollBarVisibility) core.HResult!void {
        const _c = self.vtable.put_HorizontalScrollBarVisibility(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getVerticalScrollBarVisibility(self: *@This()) core.HResult!ScrollBarVisibility {
        var _r: ScrollBarVisibility = undefined;
        const _c = self.vtable.get_VerticalScrollBarVisibility(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putVerticalScrollBarVisibility(self: *@This(), value: ScrollBarVisibility) core.HResult!void {
        const _c = self.vtable.put_VerticalScrollBarVisibility(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsHorizontalRailEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsHorizontalRailEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsHorizontalRailEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsHorizontalRailEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsVerticalRailEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsVerticalRailEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsVerticalRailEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsVerticalRailEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsHorizontalScrollChainingEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsHorizontalScrollChainingEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsHorizontalScrollChainingEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsHorizontalScrollChainingEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsVerticalScrollChainingEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsVerticalScrollChainingEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsVerticalScrollChainingEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsVerticalScrollChainingEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsZoomChainingEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsZoomChainingEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsZoomChainingEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsZoomChainingEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsScrollInertiaEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsScrollInertiaEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsScrollInertiaEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsScrollInertiaEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsZoomInertiaEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsZoomInertiaEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsZoomInertiaEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsZoomInertiaEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHorizontalScrollMode(self: *@This()) core.HResult!ScrollMode {
        var _r: ScrollMode = undefined;
        const _c = self.vtable.get_HorizontalScrollMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHorizontalScrollMode(self: *@This(), value: ScrollMode) core.HResult!void {
        const _c = self.vtable.put_HorizontalScrollMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getVerticalScrollMode(self: *@This()) core.HResult!ScrollMode {
        var _r: ScrollMode = undefined;
        const _c = self.vtable.get_VerticalScrollMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putVerticalScrollMode(self: *@This(), value: ScrollMode) core.HResult!void {
        const _c = self.vtable.put_VerticalScrollMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getZoomMode(self: *@This()) core.HResult!ZoomMode {
        var _r: ZoomMode = undefined;
        const _c = self.vtable.get_ZoomMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putZoomMode(self: *@This(), value: ZoomMode) core.HResult!void {
        const _c = self.vtable.put_ZoomMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHorizontalSnapPointsAlignment(self: *@This()) core.HResult!SnapPointsAlignment {
        var _r: SnapPointsAlignment = undefined;
        const _c = self.vtable.get_HorizontalSnapPointsAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHorizontalSnapPointsAlignment(self: *@This(), value: SnapPointsAlignment) core.HResult!void {
        const _c = self.vtable.put_HorizontalSnapPointsAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getVerticalSnapPointsAlignment(self: *@This()) core.HResult!SnapPointsAlignment {
        var _r: SnapPointsAlignment = undefined;
        const _c = self.vtable.get_VerticalSnapPointsAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putVerticalSnapPointsAlignment(self: *@This(), value: SnapPointsAlignment) core.HResult!void {
        const _c = self.vtable.put_VerticalSnapPointsAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHorizontalSnapPointsType(self: *@This()) core.HResult!SnapPointsType {
        var _r: SnapPointsType = undefined;
        const _c = self.vtable.get_HorizontalSnapPointsType(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHorizontalSnapPointsType(self: *@This(), value: SnapPointsType) core.HResult!void {
        const _c = self.vtable.put_HorizontalSnapPointsType(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getVerticalSnapPointsType(self: *@This()) core.HResult!SnapPointsType {
        var _r: SnapPointsType = undefined;
        const _c = self.vtable.get_VerticalSnapPointsType(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putVerticalSnapPointsType(self: *@This(), value: SnapPointsType) core.HResult!void {
        const _c = self.vtable.put_VerticalSnapPointsType(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getZoomSnapPointsType(self: *@This()) core.HResult!SnapPointsType {
        var _r: SnapPointsType = undefined;
        const _c = self.vtable.get_ZoomSnapPointsType(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putZoomSnapPointsType(self: *@This(), value: SnapPointsType) core.HResult!void {
        const _c = self.vtable.put_ZoomSnapPointsType(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHorizontalOffset(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_HorizontalOffset(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getViewportWidth(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_ViewportWidth(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getScrollableWidth(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_ScrollableWidth(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getComputedHorizontalScrollBarVisibility(self: *@This()) core.HResult!Visibility {
        var _r: Visibility = undefined;
        const _c = self.vtable.get_ComputedHorizontalScrollBarVisibility(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getExtentWidth(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_ExtentWidth(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getVerticalOffset(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_VerticalOffset(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getViewportHeight(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_ViewportHeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getScrollableHeight(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_ScrollableHeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getComputedVerticalScrollBarVisibility(self: *@This()) core.HResult!Visibility {
        var _r: Visibility = undefined;
        const _c = self.vtable.get_ComputedVerticalScrollBarVisibility(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getExtentHeight(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_ExtentHeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMinZoomFactor(self: *@This()) core.HResult!f32 {
        var _r: f32 = undefined;
        const _c = self.vtable.get_MinZoomFactor(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMinZoomFactor(self: *@This(), value: f32) core.HResult!void {
        const _c = self.vtable.put_MinZoomFactor(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMaxZoomFactor(self: *@This()) core.HResult!f32 {
        var _r: f32 = undefined;
        const _c = self.vtable.get_MaxZoomFactor(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxZoomFactor(self: *@This(), value: f32) core.HResult!void {
        const _c = self.vtable.put_MaxZoomFactor(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getZoomFactor(self: *@This()) core.HResult!f32 {
        var _r: f32 = undefined;
        const _c = self.vtable.get_ZoomFactor(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getZoomSnapPoints(self: *@This()) core.HResult!*IVector(f32) {
        var _r: *IVector(f32) = undefined;
        const _c = self.vtable.get_ZoomSnapPoints(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addViewChanged(self: *@This(), handler: *EventHandler(ScrollViewerViewChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ViewChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeViewChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ViewChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn ScrollToHorizontalOffset(self: *@This(), offset: f64) core.HResult!void {
        const _c = self.vtable.ScrollToHorizontalOffset(@ptrCast(self), offset);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn ScrollToVerticalOffset(self: *@This(), offset: f64) core.HResult!void {
        const _c = self.vtable.ScrollToVerticalOffset(@ptrCast(self), offset);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn ZoomToFactor(self: *@This(), factor: f32) core.HResult!void {
        const _c = self.vtable.ZoomToFactor(@ptrCast(self), factor);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn InvalidateScrollInfo(self: *@This()) core.HResult!void {
        const _c = self.vtable.InvalidateScrollInfo(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsDeferredScrollingEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsDeferredScrollingEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsDeferredScrollingEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsDeferredScrollingEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBringIntoViewOnFocusChange(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_BringIntoViewOnFocusChange(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBringIntoViewOnFocusChange(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_BringIntoViewOnFocusChange(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IScrollViewer";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "64e9be00-4dc1-493d-abe7-cbd3c577490d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HorizontalScrollBarVisibility: *const fn(self: *anyopaque, _r: *ScrollBarVisibility) callconv(.winapi) HRESULT,
        put_HorizontalScrollBarVisibility: *const fn(self: *anyopaque, value: ScrollBarVisibility) callconv(.winapi) HRESULT,
        get_VerticalScrollBarVisibility: *const fn(self: *anyopaque, _r: *ScrollBarVisibility) callconv(.winapi) HRESULT,
        put_VerticalScrollBarVisibility: *const fn(self: *anyopaque, value: ScrollBarVisibility) callconv(.winapi) HRESULT,
        get_IsHorizontalRailEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsHorizontalRailEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsVerticalRailEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsVerticalRailEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsHorizontalScrollChainingEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsHorizontalScrollChainingEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsVerticalScrollChainingEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsVerticalScrollChainingEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsZoomChainingEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsZoomChainingEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsScrollInertiaEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsScrollInertiaEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsZoomInertiaEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsZoomInertiaEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_HorizontalScrollMode: *const fn(self: *anyopaque, _r: *ScrollMode) callconv(.winapi) HRESULT,
        put_HorizontalScrollMode: *const fn(self: *anyopaque, value: ScrollMode) callconv(.winapi) HRESULT,
        get_VerticalScrollMode: *const fn(self: *anyopaque, _r: *ScrollMode) callconv(.winapi) HRESULT,
        put_VerticalScrollMode: *const fn(self: *anyopaque, value: ScrollMode) callconv(.winapi) HRESULT,
        get_ZoomMode: *const fn(self: *anyopaque, _r: *ZoomMode) callconv(.winapi) HRESULT,
        put_ZoomMode: *const fn(self: *anyopaque, value: ZoomMode) callconv(.winapi) HRESULT,
        get_HorizontalSnapPointsAlignment: *const fn(self: *anyopaque, _r: *SnapPointsAlignment) callconv(.winapi) HRESULT,
        put_HorizontalSnapPointsAlignment: *const fn(self: *anyopaque, value: SnapPointsAlignment) callconv(.winapi) HRESULT,
        get_VerticalSnapPointsAlignment: *const fn(self: *anyopaque, _r: *SnapPointsAlignment) callconv(.winapi) HRESULT,
        put_VerticalSnapPointsAlignment: *const fn(self: *anyopaque, value: SnapPointsAlignment) callconv(.winapi) HRESULT,
        get_HorizontalSnapPointsType: *const fn(self: *anyopaque, _r: *SnapPointsType) callconv(.winapi) HRESULT,
        put_HorizontalSnapPointsType: *const fn(self: *anyopaque, value: SnapPointsType) callconv(.winapi) HRESULT,
        get_VerticalSnapPointsType: *const fn(self: *anyopaque, _r: *SnapPointsType) callconv(.winapi) HRESULT,
        put_VerticalSnapPointsType: *const fn(self: *anyopaque, value: SnapPointsType) callconv(.winapi) HRESULT,
        get_ZoomSnapPointsType: *const fn(self: *anyopaque, _r: *SnapPointsType) callconv(.winapi) HRESULT,
        put_ZoomSnapPointsType: *const fn(self: *anyopaque, value: SnapPointsType) callconv(.winapi) HRESULT,
        get_HorizontalOffset: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        get_ViewportWidth: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        get_ScrollableWidth: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        get_ComputedHorizontalScrollBarVisibility: *const fn(self: *anyopaque, _r: *Visibility) callconv(.winapi) HRESULT,
        get_ExtentWidth: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        get_VerticalOffset: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        get_ViewportHeight: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        get_ScrollableHeight: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        get_ComputedVerticalScrollBarVisibility: *const fn(self: *anyopaque, _r: *Visibility) callconv(.winapi) HRESULT,
        get_ExtentHeight: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        get_MinZoomFactor: *const fn(self: *anyopaque, _r: *f32) callconv(.winapi) HRESULT,
        put_MinZoomFactor: *const fn(self: *anyopaque, value: f32) callconv(.winapi) HRESULT,
        get_MaxZoomFactor: *const fn(self: *anyopaque, _r: *f32) callconv(.winapi) HRESULT,
        put_MaxZoomFactor: *const fn(self: *anyopaque, value: f32) callconv(.winapi) HRESULT,
        get_ZoomFactor: *const fn(self: *anyopaque, _r: *f32) callconv(.winapi) HRESULT,
        get_ZoomSnapPoints: *const fn(self: *anyopaque, _r: **IVector(f32)) callconv(.winapi) HRESULT,
        add_ViewChanged: *const fn(self: *anyopaque, handler: *EventHandler(ScrollViewerViewChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ViewChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        ScrollToHorizontalOffset: *const fn(self: *anyopaque, offset: f64) callconv(.winapi) HRESULT,
        ScrollToVerticalOffset: *const fn(self: *anyopaque, offset: f64) callconv(.winapi) HRESULT,
        ZoomToFactor: *const fn(self: *anyopaque, factor: f32) callconv(.winapi) HRESULT,
        InvalidateScrollInfo: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        get_IsDeferredScrollingEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsDeferredScrollingEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_BringIntoViewOnFocusChange: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_BringIntoViewOnFocusChange: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IScrollViewer2 = extern struct {
    vtable: *const VTable,
    pub fn getTopLeftHeader(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_TopLeftHeader(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTopLeftHeader(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_TopLeftHeader(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getLeftHeader(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_LeftHeader(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putLeftHeader(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_LeftHeader(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTopHeader(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_TopHeader(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTopHeader(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_TopHeader(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addViewChanging(self: *@This(), handler: *EventHandler(ScrollViewerViewChangingEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ViewChanging(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeViewChanging(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ViewChanging(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn ChangeView(self: *@This(), horizontalOffset: *IReference(f64), verticalOffset: *IReference(f64), zoomFactor: *IReference(f32)) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.ChangeView(@ptrCast(self), horizontalOffset, verticalOffset, zoomFactor, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn ChangeViewWithDisableAnimation(self: *@This(), horizontalOffset: *IReference(f64), verticalOffset: *IReference(f64), zoomFactor: *IReference(f32), disableAnimation: bool) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.ChangeViewWithDisableAnimation(@ptrCast(self), horizontalOffset, verticalOffset, zoomFactor, disableAnimation, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IScrollViewer2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "64e9be10-4dd1-494d-abf7-cbd3c577491d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TopLeftHeader: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_TopLeftHeader: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
        get_LeftHeader: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_LeftHeader: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
        get_TopHeader: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_TopHeader: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
        add_ViewChanging: *const fn(self: *anyopaque, handler: *EventHandler(ScrollViewerViewChangingEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ViewChanging: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        ChangeView: *const fn(self: *anyopaque, horizontalOffset: *IReference(f64), verticalOffset: *IReference(f64), zoomFactor: *IReference(f32), _r: *bool) callconv(.winapi) HRESULT,
        ChangeViewWithDisableAnimation: *const fn(self: *anyopaque, horizontalOffset: *IReference(f64), verticalOffset: *IReference(f64), zoomFactor: *IReference(f32), disableAnimation: bool, _r: *bool) callconv(.winapi) HRESULT,
    };
};
pub const IScrollViewer3 = extern struct {
    vtable: *const VTable,
    pub fn addDirectManipulationStarted(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_DirectManipulationStarted(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeDirectManipulationStarted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_DirectManipulationStarted(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addDirectManipulationCompleted(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_DirectManipulationCompleted(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeDirectManipulationCompleted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_DirectManipulationCompleted(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IScrollViewer3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "74e9be21-5de2-595e-bc08-dbd3c577492c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        add_DirectManipulationStarted: *const fn(self: *anyopaque, handler: *EventHandler(IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_DirectManipulationStarted: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_DirectManipulationCompleted: *const fn(self: *anyopaque, handler: *EventHandler(IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_DirectManipulationCompleted: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IScrollViewer4 = extern struct {
    vtable: *const VTable,
    pub fn getReduceViewportForCoreInputViewOcclusions(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_ReduceViewportForCoreInputViewOcclusions(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putReduceViewportForCoreInputViewOcclusions(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_ReduceViewportForCoreInputViewOcclusions(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHorizontalAnchorRatio(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_HorizontalAnchorRatio(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHorizontalAnchorRatio(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_HorizontalAnchorRatio(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getVerticalAnchorRatio(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_VerticalAnchorRatio(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putVerticalAnchorRatio(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_VerticalAnchorRatio(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCanContentRenderOutsideBounds(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_CanContentRenderOutsideBounds(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCanContentRenderOutsideBounds(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_CanContentRenderOutsideBounds(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addAnchorRequested(self: *@This(), handler: *TypedEventHandler(ScrollViewer,AnchorRequestedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_AnchorRequested(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeAnchorRequested(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_AnchorRequested(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IScrollViewer4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "786fb0c4-50a9-5a45-8a92-7bf372e19098";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ReduceViewportForCoreInputViewOcclusions: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_ReduceViewportForCoreInputViewOcclusions: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_HorizontalAnchorRatio: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_HorizontalAnchorRatio: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_VerticalAnchorRatio: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_VerticalAnchorRatio: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_CanContentRenderOutsideBounds: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_CanContentRenderOutsideBounds: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        add_AnchorRequested: *const fn(self: *anyopaque, handler: *TypedEventHandler(ScrollViewer,AnchorRequestedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_AnchorRequested: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IScrollViewerStatics = extern struct {
    vtable: *const VTable,
    pub fn getHorizontalSnapPointsAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HorizontalSnapPointsAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getVerticalSnapPointsAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_VerticalSnapPointsAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHorizontalSnapPointsTypeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HorizontalSnapPointsTypeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getVerticalSnapPointsTypeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_VerticalSnapPointsTypeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getZoomSnapPointsTypeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ZoomSnapPointsTypeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHorizontalOffsetProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HorizontalOffsetProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getViewportWidthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ViewportWidthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getScrollableWidthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ScrollableWidthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getComputedHorizontalScrollBarVisibilityProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ComputedHorizontalScrollBarVisibilityProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getExtentWidthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ExtentWidthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getVerticalOffsetProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_VerticalOffsetProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getViewportHeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ViewportHeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getScrollableHeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ScrollableHeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getComputedVerticalScrollBarVisibilityProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ComputedVerticalScrollBarVisibilityProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getExtentHeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ExtentHeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMinZoomFactorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MinZoomFactorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaxZoomFactorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxZoomFactorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getZoomFactorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ZoomFactorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getZoomSnapPointsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ZoomSnapPointsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHorizontalScrollBarVisibilityProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HorizontalScrollBarVisibilityProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetHorizontalScrollBarVisibility(self: *@This(), element: *DependencyObject) core.HResult!ScrollBarVisibility {
        var _r: ScrollBarVisibility = undefined;
        const _c = self.vtable.GetHorizontalScrollBarVisibility(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetHorizontalScrollBarVisibility(self: *@This(), element: *DependencyObject, horizontalScrollBarVisibility: ScrollBarVisibility) core.HResult!void {
        const _c = self.vtable.SetHorizontalScrollBarVisibility(@ptrCast(self), element, horizontalScrollBarVisibility);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getVerticalScrollBarVisibilityProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_VerticalScrollBarVisibilityProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetVerticalScrollBarVisibility(self: *@This(), element: *DependencyObject) core.HResult!ScrollBarVisibility {
        var _r: ScrollBarVisibility = undefined;
        const _c = self.vtable.GetVerticalScrollBarVisibility(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetVerticalScrollBarVisibility(self: *@This(), element: *DependencyObject, verticalScrollBarVisibility: ScrollBarVisibility) core.HResult!void {
        const _c = self.vtable.SetVerticalScrollBarVisibility(@ptrCast(self), element, verticalScrollBarVisibility);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsHorizontalRailEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsHorizontalRailEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetIsHorizontalRailEnabled(self: *@This(), element: *DependencyObject) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.GetIsHorizontalRailEnabled(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetIsHorizontalRailEnabled(self: *@This(), element: *DependencyObject, isHorizontalRailEnabled: bool) core.HResult!void {
        const _c = self.vtable.SetIsHorizontalRailEnabled(@ptrCast(self), element, isHorizontalRailEnabled);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsVerticalRailEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsVerticalRailEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetIsVerticalRailEnabled(self: *@This(), element: *DependencyObject) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.GetIsVerticalRailEnabled(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetIsVerticalRailEnabled(self: *@This(), element: *DependencyObject, isVerticalRailEnabled: bool) core.HResult!void {
        const _c = self.vtable.SetIsVerticalRailEnabled(@ptrCast(self), element, isVerticalRailEnabled);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsHorizontalScrollChainingEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsHorizontalScrollChainingEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetIsHorizontalScrollChainingEnabled(self: *@This(), element: *DependencyObject) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.GetIsHorizontalScrollChainingEnabled(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetIsHorizontalScrollChainingEnabled(self: *@This(), element: *DependencyObject, isHorizontalScrollChainingEnabled: bool) core.HResult!void {
        const _c = self.vtable.SetIsHorizontalScrollChainingEnabled(@ptrCast(self), element, isHorizontalScrollChainingEnabled);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsVerticalScrollChainingEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsVerticalScrollChainingEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetIsVerticalScrollChainingEnabled(self: *@This(), element: *DependencyObject) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.GetIsVerticalScrollChainingEnabled(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetIsVerticalScrollChainingEnabled(self: *@This(), element: *DependencyObject, isVerticalScrollChainingEnabled: bool) core.HResult!void {
        const _c = self.vtable.SetIsVerticalScrollChainingEnabled(@ptrCast(self), element, isVerticalScrollChainingEnabled);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsZoomChainingEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsZoomChainingEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetIsZoomChainingEnabled(self: *@This(), element: *DependencyObject) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.GetIsZoomChainingEnabled(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetIsZoomChainingEnabled(self: *@This(), element: *DependencyObject, isZoomChainingEnabled: bool) core.HResult!void {
        const _c = self.vtable.SetIsZoomChainingEnabled(@ptrCast(self), element, isZoomChainingEnabled);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsScrollInertiaEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsScrollInertiaEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetIsScrollInertiaEnabled(self: *@This(), element: *DependencyObject) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.GetIsScrollInertiaEnabled(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetIsScrollInertiaEnabled(self: *@This(), element: *DependencyObject, isScrollInertiaEnabled: bool) core.HResult!void {
        const _c = self.vtable.SetIsScrollInertiaEnabled(@ptrCast(self), element, isScrollInertiaEnabled);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsZoomInertiaEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsZoomInertiaEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetIsZoomInertiaEnabled(self: *@This(), element: *DependencyObject) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.GetIsZoomInertiaEnabled(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetIsZoomInertiaEnabled(self: *@This(), element: *DependencyObject, isZoomInertiaEnabled: bool) core.HResult!void {
        const _c = self.vtable.SetIsZoomInertiaEnabled(@ptrCast(self), element, isZoomInertiaEnabled);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHorizontalScrollModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HorizontalScrollModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetHorizontalScrollMode(self: *@This(), element: *DependencyObject) core.HResult!ScrollMode {
        var _r: ScrollMode = undefined;
        const _c = self.vtable.GetHorizontalScrollMode(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetHorizontalScrollMode(self: *@This(), element: *DependencyObject, horizontalScrollMode: ScrollMode) core.HResult!void {
        const _c = self.vtable.SetHorizontalScrollMode(@ptrCast(self), element, horizontalScrollMode);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getVerticalScrollModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_VerticalScrollModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetVerticalScrollMode(self: *@This(), element: *DependencyObject) core.HResult!ScrollMode {
        var _r: ScrollMode = undefined;
        const _c = self.vtable.GetVerticalScrollMode(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetVerticalScrollMode(self: *@This(), element: *DependencyObject, verticalScrollMode: ScrollMode) core.HResult!void {
        const _c = self.vtable.SetVerticalScrollMode(@ptrCast(self), element, verticalScrollMode);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getZoomModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ZoomModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetZoomMode(self: *@This(), element: *DependencyObject) core.HResult!ZoomMode {
        var _r: ZoomMode = undefined;
        const _c = self.vtable.GetZoomMode(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetZoomMode(self: *@This(), element: *DependencyObject, zoomMode: ZoomMode) core.HResult!void {
        const _c = self.vtable.SetZoomMode(@ptrCast(self), element, zoomMode);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsDeferredScrollingEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsDeferredScrollingEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetIsDeferredScrollingEnabled(self: *@This(), element: *DependencyObject) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.GetIsDeferredScrollingEnabled(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetIsDeferredScrollingEnabled(self: *@This(), element: *DependencyObject, isDeferredScrollingEnabled: bool) core.HResult!void {
        const _c = self.vtable.SetIsDeferredScrollingEnabled(@ptrCast(self), element, isDeferredScrollingEnabled);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBringIntoViewOnFocusChangeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BringIntoViewOnFocusChangeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetBringIntoViewOnFocusChange(self: *@This(), element: *DependencyObject) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.GetBringIntoViewOnFocusChange(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetBringIntoViewOnFocusChange(self: *@This(), element: *DependencyObject, bringIntoViewOnFocusChange: bool) core.HResult!void {
        const _c = self.vtable.SetBringIntoViewOnFocusChange(@ptrCast(self), element, bringIntoViewOnFocusChange);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IScrollViewerStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "33d1299d-8d6e-4290-bf22-905cccd04d31";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HorizontalSnapPointsAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_VerticalSnapPointsAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HorizontalSnapPointsTypeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_VerticalSnapPointsTypeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ZoomSnapPointsTypeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HorizontalOffsetProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ViewportWidthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ScrollableWidthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ComputedHorizontalScrollBarVisibilityProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ExtentWidthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_VerticalOffsetProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ViewportHeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ScrollableHeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ComputedVerticalScrollBarVisibilityProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ExtentHeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MinZoomFactorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaxZoomFactorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ZoomFactorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ZoomSnapPointsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HorizontalScrollBarVisibilityProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetHorizontalScrollBarVisibility: *const fn(self: *anyopaque, element: *DependencyObject, _r: *ScrollBarVisibility) callconv(.winapi) HRESULT,
        SetHorizontalScrollBarVisibility: *const fn(self: *anyopaque, element: *DependencyObject, horizontalScrollBarVisibility: ScrollBarVisibility) callconv(.winapi) HRESULT,
        get_VerticalScrollBarVisibilityProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetVerticalScrollBarVisibility: *const fn(self: *anyopaque, element: *DependencyObject, _r: *ScrollBarVisibility) callconv(.winapi) HRESULT,
        SetVerticalScrollBarVisibility: *const fn(self: *anyopaque, element: *DependencyObject, verticalScrollBarVisibility: ScrollBarVisibility) callconv(.winapi) HRESULT,
        get_IsHorizontalRailEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetIsHorizontalRailEnabled: *const fn(self: *anyopaque, element: *DependencyObject, _r: *bool) callconv(.winapi) HRESULT,
        SetIsHorizontalRailEnabled: *const fn(self: *anyopaque, element: *DependencyObject, isHorizontalRailEnabled: bool) callconv(.winapi) HRESULT,
        get_IsVerticalRailEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetIsVerticalRailEnabled: *const fn(self: *anyopaque, element: *DependencyObject, _r: *bool) callconv(.winapi) HRESULT,
        SetIsVerticalRailEnabled: *const fn(self: *anyopaque, element: *DependencyObject, isVerticalRailEnabled: bool) callconv(.winapi) HRESULT,
        get_IsHorizontalScrollChainingEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetIsHorizontalScrollChainingEnabled: *const fn(self: *anyopaque, element: *DependencyObject, _r: *bool) callconv(.winapi) HRESULT,
        SetIsHorizontalScrollChainingEnabled: *const fn(self: *anyopaque, element: *DependencyObject, isHorizontalScrollChainingEnabled: bool) callconv(.winapi) HRESULT,
        get_IsVerticalScrollChainingEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetIsVerticalScrollChainingEnabled: *const fn(self: *anyopaque, element: *DependencyObject, _r: *bool) callconv(.winapi) HRESULT,
        SetIsVerticalScrollChainingEnabled: *const fn(self: *anyopaque, element: *DependencyObject, isVerticalScrollChainingEnabled: bool) callconv(.winapi) HRESULT,
        get_IsZoomChainingEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetIsZoomChainingEnabled: *const fn(self: *anyopaque, element: *DependencyObject, _r: *bool) callconv(.winapi) HRESULT,
        SetIsZoomChainingEnabled: *const fn(self: *anyopaque, element: *DependencyObject, isZoomChainingEnabled: bool) callconv(.winapi) HRESULT,
        get_IsScrollInertiaEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetIsScrollInertiaEnabled: *const fn(self: *anyopaque, element: *DependencyObject, _r: *bool) callconv(.winapi) HRESULT,
        SetIsScrollInertiaEnabled: *const fn(self: *anyopaque, element: *DependencyObject, isScrollInertiaEnabled: bool) callconv(.winapi) HRESULT,
        get_IsZoomInertiaEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetIsZoomInertiaEnabled: *const fn(self: *anyopaque, element: *DependencyObject, _r: *bool) callconv(.winapi) HRESULT,
        SetIsZoomInertiaEnabled: *const fn(self: *anyopaque, element: *DependencyObject, isZoomInertiaEnabled: bool) callconv(.winapi) HRESULT,
        get_HorizontalScrollModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetHorizontalScrollMode: *const fn(self: *anyopaque, element: *DependencyObject, _r: *ScrollMode) callconv(.winapi) HRESULT,
        SetHorizontalScrollMode: *const fn(self: *anyopaque, element: *DependencyObject, horizontalScrollMode: ScrollMode) callconv(.winapi) HRESULT,
        get_VerticalScrollModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetVerticalScrollMode: *const fn(self: *anyopaque, element: *DependencyObject, _r: *ScrollMode) callconv(.winapi) HRESULT,
        SetVerticalScrollMode: *const fn(self: *anyopaque, element: *DependencyObject, verticalScrollMode: ScrollMode) callconv(.winapi) HRESULT,
        get_ZoomModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetZoomMode: *const fn(self: *anyopaque, element: *DependencyObject, _r: *ZoomMode) callconv(.winapi) HRESULT,
        SetZoomMode: *const fn(self: *anyopaque, element: *DependencyObject, zoomMode: ZoomMode) callconv(.winapi) HRESULT,
        get_IsDeferredScrollingEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetIsDeferredScrollingEnabled: *const fn(self: *anyopaque, element: *DependencyObject, _r: *bool) callconv(.winapi) HRESULT,
        SetIsDeferredScrollingEnabled: *const fn(self: *anyopaque, element: *DependencyObject, isDeferredScrollingEnabled: bool) callconv(.winapi) HRESULT,
        get_BringIntoViewOnFocusChangeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetBringIntoViewOnFocusChange: *const fn(self: *anyopaque, element: *DependencyObject, _r: *bool) callconv(.winapi) HRESULT,
        SetBringIntoViewOnFocusChange: *const fn(self: *anyopaque, element: *DependencyObject, bringIntoViewOnFocusChange: bool) callconv(.winapi) HRESULT,
    };
};
pub const IScrollViewerStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getTopLeftHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TopLeftHeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLeftHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LeftHeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTopHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TopHeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IScrollViewerStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "33d129ad-8d7e-42a0-bf32-905cccd04d41";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TopLeftHeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_LeftHeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TopHeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IScrollViewerStatics4 = extern struct {
    vtable: *const VTable,
    pub fn getReduceViewportForCoreInputViewOcclusionsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ReduceViewportForCoreInputViewOcclusionsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHorizontalAnchorRatioProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HorizontalAnchorRatioProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getVerticalAnchorRatioProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_VerticalAnchorRatioProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCanContentRenderOutsideBoundsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CanContentRenderOutsideBoundsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetCanContentRenderOutsideBounds(self: *@This(), element: *DependencyObject) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.GetCanContentRenderOutsideBounds(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetCanContentRenderOutsideBounds(self: *@This(), element: *DependencyObject, canContentRenderOutsideBounds: bool) core.HResult!void {
        const _c = self.vtable.SetCanContentRenderOutsideBounds(@ptrCast(self), element, canContentRenderOutsideBounds);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IScrollViewerStatics4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "220cf7cc-4f46-59f1-af9b-67fa8eb33d01";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ReduceViewportForCoreInputViewOcclusionsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HorizontalAnchorRatioProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_VerticalAnchorRatioProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CanContentRenderOutsideBoundsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetCanContentRenderOutsideBounds: *const fn(self: *anyopaque, element: *DependencyObject, _r: *bool) callconv(.winapi) HRESULT,
        SetCanContentRenderOutsideBounds: *const fn(self: *anyopaque, element: *DependencyObject, canContentRenderOutsideBounds: bool) callconv(.winapi) HRESULT,
    };
};
pub const IScrollViewerView = extern struct {
    vtable: *const VTable,
    pub fn getHorizontalOffset(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_HorizontalOffset(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getVerticalOffset(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_VerticalOffset(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getZoomFactor(self: *@This()) core.HResult!f32 {
        var _r: f32 = undefined;
        const _c = self.vtable.get_ZoomFactor(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IScrollViewerView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "64e9be01-4dc2-493e-abe8-cbd3c577490e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HorizontalOffset: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        get_VerticalOffset: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        get_ZoomFactor: *const fn(self: *anyopaque, _r: *f32) callconv(.winapi) HRESULT,
    };
};
pub const IScrollViewerViewChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getIsIntermediate(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsIntermediate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IScrollViewerViewChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4dd04f7e-7a11-4b2e-9933-577df39252b6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsIntermediate: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
    };
};
pub const IScrollViewerViewChangingEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getNextView(self: *@This()) core.HResult!*ScrollViewerView {
        var _r: *ScrollViewerView = undefined;
        const _c = self.vtable.get_NextView(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFinalView(self: *@This()) core.HResult!*ScrollViewerView {
        var _r: *ScrollViewerView = undefined;
        const _c = self.vtable.get_FinalView(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsInertial(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsInertial(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IScrollViewerViewChangingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4dd04f7f-7a11-4b2e-9933-577df39252b6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_NextView: *const fn(self: *anyopaque, _r: **ScrollViewerView) callconv(.winapi) HRESULT,
        get_FinalView: *const fn(self: *anyopaque, _r: **ScrollViewerView) callconv(.winapi) HRESULT,
        get_IsInertial: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
    };
};
pub const ISearchBox = extern struct {
    vtable: *const VTable,
    pub fn getSearchHistoryEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_SearchHistoryEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSearchHistoryEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_SearchHistoryEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSearchHistoryContext(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_SearchHistoryContext(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSearchHistoryContext(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_SearchHistoryContext(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPlaceholderText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_PlaceholderText(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPlaceholderText(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_PlaceholderText(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getQueryText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_QueryText(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putQueryText(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_QueryText(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFocusOnKeyboardInput(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_FocusOnKeyboardInput(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFocusOnKeyboardInput(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_FocusOnKeyboardInput(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getChooseSuggestionOnEnter(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_ChooseSuggestionOnEnter(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putChooseSuggestionOnEnter(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_ChooseSuggestionOnEnter(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addQueryChanged(self: *@This(), handler: *TypedEventHandler(SearchBox,SearchBoxQueryChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_QueryChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeQueryChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_QueryChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addSuggestionsRequested(self: *@This(), handler: *TypedEventHandler(SearchBox,SearchBoxSuggestionsRequestedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_SuggestionsRequested(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeSuggestionsRequested(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_SuggestionsRequested(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addQuerySubmitted(self: *@This(), handler: *TypedEventHandler(SearchBox,SearchBoxQuerySubmittedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_QuerySubmitted(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeQuerySubmitted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_QuerySubmitted(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addResultSuggestionChosen(self: *@This(), handler: *TypedEventHandler(SearchBox,SearchBoxResultSuggestionChosenEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ResultSuggestionChosen(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeResultSuggestionChosen(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ResultSuggestionChosen(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addPrepareForFocusOnKeyboardInput(self: *@This(), handler: *TypedEventHandler(SearchBox,RoutedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_PrepareForFocusOnKeyboardInput(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removePrepareForFocusOnKeyboardInput(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_PrepareForFocusOnKeyboardInput(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn SetLocalContentSuggestionSettings(self: *@This(), settings: *LocalContentSuggestionSettings) core.HResult!void {
        const _c = self.vtable.SetLocalContentSuggestionSettings(@ptrCast(self), settings);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISearchBox";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f89ecc5a-99ba-4bd4-966c-f11fa443d13c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SearchHistoryEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_SearchHistoryEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_SearchHistoryContext: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_SearchHistoryContext: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_PlaceholderText: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_PlaceholderText: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_QueryText: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_QueryText: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_FocusOnKeyboardInput: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_FocusOnKeyboardInput: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_ChooseSuggestionOnEnter: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_ChooseSuggestionOnEnter: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        add_QueryChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(SearchBox,SearchBoxQueryChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_QueryChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_SuggestionsRequested: *const fn(self: *anyopaque, handler: *TypedEventHandler(SearchBox,SearchBoxSuggestionsRequestedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_SuggestionsRequested: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_QuerySubmitted: *const fn(self: *anyopaque, handler: *TypedEventHandler(SearchBox,SearchBoxQuerySubmittedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_QuerySubmitted: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_ResultSuggestionChosen: *const fn(self: *anyopaque, handler: *TypedEventHandler(SearchBox,SearchBoxResultSuggestionChosenEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ResultSuggestionChosen: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_PrepareForFocusOnKeyboardInput: *const fn(self: *anyopaque, handler: *TypedEventHandler(SearchBox,RoutedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_PrepareForFocusOnKeyboardInput: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        SetLocalContentSuggestionSettings: *const fn(self: *anyopaque, settings: *LocalContentSuggestionSettings) callconv(.winapi) HRESULT,
    };
};
pub const ISearchBoxFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SearchBox {
        var _r: *SearchBox = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISearchBoxFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "cd743f6d-8685-46b4-9ddd-202f6941b701";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **SearchBox) callconv(.winapi) HRESULT,
    };
};
pub const ISearchBoxQueryChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getQueryText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_QueryText(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLanguage(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Language(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLinguisticDetails(self: *@This()) core.HResult!*SearchQueryLinguisticDetails {
        var _r: *SearchQueryLinguisticDetails = undefined;
        const _c = self.vtable.get_LinguisticDetails(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISearchBoxQueryChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a9a70f8f-0cb0-4bd2-9998-2fb57ad5e731";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_QueryText: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        get_Language: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        get_LinguisticDetails: *const fn(self: *anyopaque, _r: **SearchQueryLinguisticDetails) callconv(.winapi) HRESULT,
    };
};
pub const ISearchBoxQuerySubmittedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getQueryText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_QueryText(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLanguage(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Language(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLinguisticDetails(self: *@This()) core.HResult!*SearchQueryLinguisticDetails {
        var _r: *SearchQueryLinguisticDetails = undefined;
        const _c = self.vtable.get_LinguisticDetails(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getKeyModifiers(self: *@This()) core.HResult!VirtualKeyModifiers {
        var _r: VirtualKeyModifiers = undefined;
        const _c = self.vtable.get_KeyModifiers(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISearchBoxQuerySubmittedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "126e90fd-3c4e-4ccb-9aef-4705d19fe548";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_QueryText: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        get_Language: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        get_LinguisticDetails: *const fn(self: *anyopaque, _r: **SearchQueryLinguisticDetails) callconv(.winapi) HRESULT,
        get_KeyModifiers: *const fn(self: *anyopaque, _r: *VirtualKeyModifiers) callconv(.winapi) HRESULT,
    };
};
pub const ISearchBoxResultSuggestionChosenEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getTag(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Tag(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getKeyModifiers(self: *@This()) core.HResult!VirtualKeyModifiers {
        var _r: VirtualKeyModifiers = undefined;
        const _c = self.vtable.get_KeyModifiers(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISearchBoxResultSuggestionChosenEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "18918c23-e4c3-4662-a03b-d054ffd0f905";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Tag: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        get_KeyModifiers: *const fn(self: *anyopaque, _r: *VirtualKeyModifiers) callconv(.winapi) HRESULT,
    };
};
pub const ISearchBoxStatics = extern struct {
    vtable: *const VTable,
    pub fn getSearchHistoryEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SearchHistoryEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSearchHistoryContextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SearchHistoryContextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPlaceholderTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlaceholderTextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getQueryTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_QueryTextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFocusOnKeyboardInputProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FocusOnKeyboardInputProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getChooseSuggestionOnEnterProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ChooseSuggestionOnEnterProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISearchBoxStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b123634f-6871-48cd-92df-4cff22459082";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SearchHistoryEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SearchHistoryContextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PlaceholderTextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_QueryTextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FocusOnKeyboardInputProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ChooseSuggestionOnEnterProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ISearchBoxSuggestionsRequestedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getQueryText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_QueryText(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLanguage(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Language(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLinguisticDetails(self: *@This()) core.HResult!*SearchQueryLinguisticDetails {
        var _r: *SearchQueryLinguisticDetails = undefined;
        const _c = self.vtable.get_LinguisticDetails(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getRequest(self: *@This()) core.HResult!*SearchSuggestionsRequest {
        var _r: *SearchSuggestionsRequest = undefined;
        const _c = self.vtable.get_Request(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISearchBoxSuggestionsRequestedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "da15170e-e566-48cb-bd11-fe4b0f30a44d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_QueryText: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        get_Language: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        get_LinguisticDetails: *const fn(self: *anyopaque, _r: **SearchQueryLinguisticDetails) callconv(.winapi) HRESULT,
        get_Request: *const fn(self: *anyopaque, _r: **SearchSuggestionsRequest) callconv(.winapi) HRESULT,
    };
};
pub const ISectionsInViewChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getAddedSections(self: *@This()) core.HResult!*IVector(HubSection) {
        var _r: *IVector(HubSection) = undefined;
        const _c = self.vtable.get_AddedSections(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getRemovedSections(self: *@This()) core.HResult!*IVector(HubSection) {
        var _r: *IVector(HubSection) = undefined;
        const _c = self.vtable.get_RemovedSections(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISectionsInViewChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "dd49ee6b-d165-430f-a37d-b807064f85e1";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_AddedSections: *const fn(self: *anyopaque, _r: **IVector(HubSection)) callconv(.winapi) HRESULT,
        get_RemovedSections: *const fn(self: *anyopaque, _r: **IVector(HubSection)) callconv(.winapi) HRESULT,
    };
};
pub const ISectionsInViewChangedEventArgsFactory = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISectionsInViewChangedEventArgsFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "557f5244-92f8-4150-b730-e6346e8f50d1";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const ISelectionChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getAddedItems(self: *@This()) core.HResult!*IVector(IInspectable) {
        var _r: *IVector(IInspectable) = undefined;
        const _c = self.vtable.get_AddedItems(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getRemovedItems(self: *@This()) core.HResult!*IVector(IInspectable) {
        var _r: *IVector(IInspectable) = undefined;
        const _c = self.vtable.get_RemovedItems(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISelectionChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c972d2dc-b609-4758-851e-a799c21de97d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_AddedItems: *const fn(self: *anyopaque, _r: **IVector(IInspectable)) callconv(.winapi) HRESULT,
        get_RemovedItems: *const fn(self: *anyopaque, _r: **IVector(IInspectable)) callconv(.winapi) HRESULT,
    };
};
pub const ISelectionChangedEventArgsFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstanceWithRemovedItemsAndAddedItems(self: *@This(), removedItems: *IVector(IInspectable), addedItems: *IVector(IInspectable), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SelectionChangedEventArgs {
        var _r: *SelectionChangedEventArgs = undefined;
        const _c = self.vtable.CreateInstanceWithRemovedItemsAndAddedItems(@ptrCast(self), removedItems, addedItems, baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISelectionChangedEventArgsFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "11a8b6b5-2830-4517-84cd-5524c8b88b45";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstanceWithRemovedItemsAndAddedItems: *const fn(self: *anyopaque, removedItems: *IVector(IInspectable), addedItems: *IVector(IInspectable), baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **SelectionChangedEventArgs) callconv(.winapi) HRESULT,
    };
};
pub const ISemanticZoom = extern struct {
    vtable: *const VTable,
    pub fn getZoomedInView(self: *@This()) core.HResult!*ISemanticZoomInformation {
        var _r: *ISemanticZoomInformation = undefined;
        const _c = self.vtable.get_ZoomedInView(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putZoomedInView(self: *@This(), value: *ISemanticZoomInformation) core.HResult!void {
        const _c = self.vtable.put_ZoomedInView(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getZoomedOutView(self: *@This()) core.HResult!*ISemanticZoomInformation {
        var _r: *ISemanticZoomInformation = undefined;
        const _c = self.vtable.get_ZoomedOutView(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putZoomedOutView(self: *@This(), value: *ISemanticZoomInformation) core.HResult!void {
        const _c = self.vtable.put_ZoomedOutView(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsZoomedInViewActive(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsZoomedInViewActive(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsZoomedInViewActive(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsZoomedInViewActive(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCanChangeViews(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_CanChangeViews(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCanChangeViews(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_CanChangeViews(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addViewChangeStarted(self: *@This(), handler: *SemanticZoomViewChangedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ViewChangeStarted(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeViewChangeStarted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ViewChangeStarted(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addViewChangeCompleted(self: *@This(), handler: *SemanticZoomViewChangedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ViewChangeCompleted(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeViewChangeCompleted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ViewChangeCompleted(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn ToggleActiveView(self: *@This()) core.HResult!void {
        const _c = self.vtable.ToggleActiveView(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsZoomOutButtonEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsZoomOutButtonEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsZoomOutButtonEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsZoomOutButtonEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISemanticZoom";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "019fff21-ece6-4fbc-bf40-8938d4813e27";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ZoomedInView: *const fn(self: *anyopaque, _r: **ISemanticZoomInformation) callconv(.winapi) HRESULT,
        put_ZoomedInView: *const fn(self: *anyopaque, value: *ISemanticZoomInformation) callconv(.winapi) HRESULT,
        get_ZoomedOutView: *const fn(self: *anyopaque, _r: **ISemanticZoomInformation) callconv(.winapi) HRESULT,
        put_ZoomedOutView: *const fn(self: *anyopaque, value: *ISemanticZoomInformation) callconv(.winapi) HRESULT,
        get_IsZoomedInViewActive: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsZoomedInViewActive: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_CanChangeViews: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_CanChangeViews: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        add_ViewChangeStarted: *const fn(self: *anyopaque, handler: *SemanticZoomViewChangedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ViewChangeStarted: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_ViewChangeCompleted: *const fn(self: *anyopaque, handler: *SemanticZoomViewChangedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ViewChangeCompleted: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        ToggleActiveView: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        get_IsZoomOutButtonEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsZoomOutButtonEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const ISemanticZoomInformation = extern struct {
    vtable: *const VTable,
    pub fn getSemanticZoomOwner(self: *@This()) core.HResult!*SemanticZoom {
        var _r: *SemanticZoom = undefined;
        const _c = self.vtable.get_SemanticZoomOwner(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSemanticZoomOwner(self: *@This(), value: *SemanticZoom) core.HResult!void {
        const _c = self.vtable.put_SemanticZoomOwner(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsActiveView(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsActiveView(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsActiveView(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsActiveView(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsZoomedInView(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsZoomedInView(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsZoomedInView(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsZoomedInView(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn InitializeViewChange(self: *@This()) core.HResult!void {
        const _c = self.vtable.InitializeViewChange(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn CompleteViewChange(self: *@This()) core.HResult!void {
        const _c = self.vtable.CompleteViewChange(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn MakeVisible(self: *@This(), item: *SemanticZoomLocation) core.HResult!void {
        const _c = self.vtable.MakeVisible(@ptrCast(self), item);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn StartViewChangeFrom(self: *@This(), source: *SemanticZoomLocation, destination: *SemanticZoomLocation) core.HResult!void {
        const _c = self.vtable.StartViewChangeFrom(@ptrCast(self), source, destination);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn StartViewChangeTo(self: *@This(), source: *SemanticZoomLocation, destination: *SemanticZoomLocation) core.HResult!void {
        const _c = self.vtable.StartViewChangeTo(@ptrCast(self), source, destination);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn CompleteViewChangeFrom(self: *@This(), source: *SemanticZoomLocation, destination: *SemanticZoomLocation) core.HResult!void {
        const _c = self.vtable.CompleteViewChangeFrom(@ptrCast(self), source, destination);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn CompleteViewChangeTo(self: *@This(), source: *SemanticZoomLocation, destination: *SemanticZoomLocation) core.HResult!void {
        const _c = self.vtable.CompleteViewChangeTo(@ptrCast(self), source, destination);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISemanticZoomInformation";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a76a3b63-229b-4dc5-aa11-9d922fbf8a98";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SemanticZoomOwner: *const fn(self: *anyopaque, _r: **SemanticZoom) callconv(.winapi) HRESULT,
        put_SemanticZoomOwner: *const fn(self: *anyopaque, value: *SemanticZoom) callconv(.winapi) HRESULT,
        get_IsActiveView: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsActiveView: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsZoomedInView: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsZoomedInView: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        InitializeViewChange: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        CompleteViewChange: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        MakeVisible: *const fn(self: *anyopaque, item: *SemanticZoomLocation) callconv(.winapi) HRESULT,
        StartViewChangeFrom: *const fn(self: *anyopaque, source: *SemanticZoomLocation, destination: *SemanticZoomLocation) callconv(.winapi) HRESULT,
        StartViewChangeTo: *const fn(self: *anyopaque, source: *SemanticZoomLocation, destination: *SemanticZoomLocation) callconv(.winapi) HRESULT,
        CompleteViewChangeFrom: *const fn(self: *anyopaque, source: *SemanticZoomLocation, destination: *SemanticZoomLocation) callconv(.winapi) HRESULT,
        CompleteViewChangeTo: *const fn(self: *anyopaque, source: *SemanticZoomLocation, destination: *SemanticZoomLocation) callconv(.winapi) HRESULT,
    };
};
pub const ISemanticZoomLocation = extern struct {
    vtable: *const VTable,
    pub fn getItem(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Item(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItem(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Item(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBounds(self: *@This()) core.HResult!Rect {
        var _r: Rect = undefined;
        const _c = self.vtable.get_Bounds(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBounds(self: *@This(), value: Rect) core.HResult!void {
        const _c = self.vtable.put_Bounds(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISemanticZoomLocation";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "42011736-e3c2-496b-bc4e-d750d4375b9a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Item: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Item: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_Bounds: *const fn(self: *anyopaque, _r: *Rect) callconv(.winapi) HRESULT,
        put_Bounds: *const fn(self: *anyopaque, value: Rect) callconv(.winapi) HRESULT,
    };
};
pub const ISemanticZoomStatics = extern struct {
    vtable: *const VTable,
    pub fn getZoomedInViewProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ZoomedInViewProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getZoomedOutViewProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ZoomedOutViewProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsZoomedInViewActiveProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsZoomedInViewActiveProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCanChangeViewsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CanChangeViewsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsZoomOutButtonEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsZoomOutButtonEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISemanticZoomStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8ef17ef2-9898-4666-b285-3ed38a07910e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ZoomedInViewProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ZoomedOutViewProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsZoomedInViewActiveProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CanChangeViewsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsZoomOutButtonEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ISemanticZoomViewChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getIsSourceZoomedInView(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsSourceZoomedInView(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsSourceZoomedInView(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsSourceZoomedInView(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSourceItem(self: *@This()) core.HResult!*SemanticZoomLocation {
        var _r: *SemanticZoomLocation = undefined;
        const _c = self.vtable.get_SourceItem(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSourceItem(self: *@This(), value: *SemanticZoomLocation) core.HResult!void {
        const _c = self.vtable.put_SourceItem(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDestinationItem(self: *@This()) core.HResult!*SemanticZoomLocation {
        var _r: *SemanticZoomLocation = undefined;
        const _c = self.vtable.get_DestinationItem(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDestinationItem(self: *@This(), value: *SemanticZoomLocation) core.HResult!void {
        const _c = self.vtable.put_DestinationItem(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISemanticZoomViewChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "47dfc068-b569-4b19-842d-8e6cf90989af";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsSourceZoomedInView: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsSourceZoomedInView: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_SourceItem: *const fn(self: *anyopaque, _r: **SemanticZoomLocation) callconv(.winapi) HRESULT,
        put_SourceItem: *const fn(self: *anyopaque, value: *SemanticZoomLocation) callconv(.winapi) HRESULT,
        get_DestinationItem: *const fn(self: *anyopaque, _r: **SemanticZoomLocation) callconv(.winapi) HRESULT,
        put_DestinationItem: *const fn(self: *anyopaque, value: *SemanticZoomLocation) callconv(.winapi) HRESULT,
    };
};
pub const ISettingsFlyout = extern struct {
    vtable: *const VTable,
    pub fn getTitle(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Title(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTitle(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_Title(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeaderBackground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_HeaderBackground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderBackground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_HeaderBackground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeaderForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_HeaderForeground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_HeaderForeground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIconSource(self: *@This()) core.HResult!*ImageSource {
        var _r: *ImageSource = undefined;
        const _c = self.vtable.get_IconSource(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIconSource(self: *@This(), value: *ImageSource) core.HResult!void {
        const _c = self.vtable.put_IconSource(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*SettingsFlyoutTemplateSettings {
        var _r: *SettingsFlyoutTemplateSettings = undefined;
        const _c = self.vtable.get_TemplateSettings(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addBackClick(self: *@This(), handler: *BackClickEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_BackClick(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeBackClick(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_BackClick(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Show(self: *@This()) core.HResult!void {
        const _c = self.vtable.Show(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn ShowIndependent(self: *@This()) core.HResult!void {
        const _c = self.vtable.ShowIndependent(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Hide(self: *@This()) core.HResult!void {
        const _c = self.vtable.Hide(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISettingsFlyout";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "830ba82b-c55b-4e32-a51c-5791e024c8af";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Title: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_Title: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_HeaderBackground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_HeaderBackground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_HeaderForeground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_HeaderForeground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_IconSource: *const fn(self: *anyopaque, _r: **ImageSource) callconv(.winapi) HRESULT,
        put_IconSource: *const fn(self: *anyopaque, value: *ImageSource) callconv(.winapi) HRESULT,
        get_TemplateSettings: *const fn(self: *anyopaque, _r: **SettingsFlyoutTemplateSettings) callconv(.winapi) HRESULT,
        add_BackClick: *const fn(self: *anyopaque, handler: *BackClickEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_BackClick: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        Show: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        ShowIndependent: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        Hide: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
    };
};
pub const ISettingsFlyoutFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SettingsFlyout {
        var _r: *SettingsFlyout = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISettingsFlyoutFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "480c7011-57aa-4db6-b6fd-ec676f6d414e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **SettingsFlyout) callconv(.winapi) HRESULT,
    };
};
pub const ISettingsFlyoutStatics = extern struct {
    vtable: *const VTable,
    pub fn getTitleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TitleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderBackgroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderBackgroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIconSourceProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IconSourceProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISettingsFlyoutStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d0e3b535-9157-4be4-a42a-f591698846ac";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TitleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderBackgroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IconSourceProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ISlider = extern struct {
    vtable: *const VTable,
    pub fn getIntermediateValue(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_IntermediateValue(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIntermediateValue(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_IntermediateValue(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getStepFrequency(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_StepFrequency(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putStepFrequency(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_StepFrequency(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSnapsTo(self: *@This()) core.HResult!SliderSnapsTo {
        var _r: SliderSnapsTo = undefined;
        const _c = self.vtable.get_SnapsTo(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSnapsTo(self: *@This(), value: SliderSnapsTo) core.HResult!void {
        const _c = self.vtable.put_SnapsTo(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTickFrequency(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_TickFrequency(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTickFrequency(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_TickFrequency(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTickPlacement(self: *@This()) core.HResult!TickPlacement {
        var _r: TickPlacement = undefined;
        const _c = self.vtable.get_TickPlacement(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTickPlacement(self: *@This(), value: TickPlacement) core.HResult!void {
        const _c = self.vtable.put_TickPlacement(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOrientation(self: *@This()) core.HResult!Orientation {
        var _r: Orientation = undefined;
        const _c = self.vtable.get_Orientation(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOrientation(self: *@This(), value: Orientation) core.HResult!void {
        const _c = self.vtable.put_Orientation(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsDirectionReversed(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsDirectionReversed(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsDirectionReversed(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsDirectionReversed(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsThumbToolTipEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsThumbToolTipEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsThumbToolTipEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsThumbToolTipEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getThumbToolTipValueConverter(self: *@This()) core.HResult!*IValueConverter {
        var _r: *IValueConverter = undefined;
        const _c = self.vtable.get_ThumbToolTipValueConverter(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putThumbToolTipValueConverter(self: *@This(), value: *IValueConverter) core.HResult!void {
        const _c = self.vtable.put_ThumbToolTipValueConverter(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISlider";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "89572027-4c48-4700-8076-497ba73d9c18";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IntermediateValue: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_IntermediateValue: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_StepFrequency: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_StepFrequency: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_SnapsTo: *const fn(self: *anyopaque, _r: *SliderSnapsTo) callconv(.winapi) HRESULT,
        put_SnapsTo: *const fn(self: *anyopaque, value: SliderSnapsTo) callconv(.winapi) HRESULT,
        get_TickFrequency: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_TickFrequency: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_TickPlacement: *const fn(self: *anyopaque, _r: *TickPlacement) callconv(.winapi) HRESULT,
        put_TickPlacement: *const fn(self: *anyopaque, value: TickPlacement) callconv(.winapi) HRESULT,
        get_Orientation: *const fn(self: *anyopaque, _r: *Orientation) callconv(.winapi) HRESULT,
        put_Orientation: *const fn(self: *anyopaque, value: Orientation) callconv(.winapi) HRESULT,
        get_IsDirectionReversed: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsDirectionReversed: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsThumbToolTipEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsThumbToolTipEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_ThumbToolTipValueConverter: *const fn(self: *anyopaque, _r: **IValueConverter) callconv(.winapi) HRESULT,
        put_ThumbToolTipValueConverter: *const fn(self: *anyopaque, value: *IValueConverter) callconv(.winapi) HRESULT,
    };
};
pub const ISlider2 = extern struct {
    vtable: *const VTable,
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Header(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Header(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_HeaderTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_HeaderTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISlider2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "40a3c50e-87d6-4d2f-b1cf-b279cc996f26";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Header: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Header: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_HeaderTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_HeaderTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
    };
};
pub const ISliderFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*Slider {
        var _r: *Slider = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISliderFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "03a67b37-c7bf-437c-848f-8cb5b753eab4";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **Slider) callconv(.winapi) HRESULT,
    };
};
pub const ISliderStatics = extern struct {
    vtable: *const VTable,
    pub fn getIntermediateValueProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IntermediateValueProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getStepFrequencyProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_StepFrequencyProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSnapsToProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SnapsToProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTickFrequencyProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TickFrequencyProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTickPlacementProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TickPlacementProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOrientationProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OrientationProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsDirectionReversedProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsDirectionReversedProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsThumbToolTipEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsThumbToolTipEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getThumbToolTipValueConverterProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ThumbToolTipValueConverterProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISliderStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8a4363d7-7fdf-4d30-98fe-ce78c05b31cf";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IntermediateValueProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_StepFrequencyProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SnapsToProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TickFrequencyProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TickPlacementProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OrientationProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsDirectionReversedProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsThumbToolTipEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ThumbToolTipValueConverterProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ISliderStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISliderStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "00e7935d-79a5-4759-96a6-29e0a94add33";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ISplitButton = extern struct {
    vtable: *const VTable,
    pub fn getFlyout(self: *@This()) core.HResult!*FlyoutBase {
        var _r: *FlyoutBase = undefined;
        const _c = self.vtable.get_Flyout(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFlyout(self: *@This(), value: *FlyoutBase) core.HResult!void {
        const _c = self.vtable.put_Flyout(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCommand(self: *@This()) core.HResult!*ICommand {
        var _r: *ICommand = undefined;
        const _c = self.vtable.get_Command(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCommand(self: *@This(), value: *ICommand) core.HResult!void {
        const _c = self.vtable.put_Command(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCommandParameter(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_CommandParameter(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCommandParameter(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_CommandParameter(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addClick(self: *@This(), handler: *TypedEventHandler(SplitButton,SplitButtonClickEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Click(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeClick(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Click(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISplitButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "58bbb066-c2ea-5499-8150-40faa75f6bb5";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Flyout: *const fn(self: *anyopaque, _r: **FlyoutBase) callconv(.winapi) HRESULT,
        put_Flyout: *const fn(self: *anyopaque, value: *FlyoutBase) callconv(.winapi) HRESULT,
        get_Command: *const fn(self: *anyopaque, _r: **ICommand) callconv(.winapi) HRESULT,
        put_Command: *const fn(self: *anyopaque, value: *ICommand) callconv(.winapi) HRESULT,
        get_CommandParameter: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_CommandParameter: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        add_Click: *const fn(self: *anyopaque, handler: *TypedEventHandler(SplitButton,SplitButtonClickEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Click: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const ISplitButtonAutomationPeer = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISplitButtonAutomationPeer";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c46a58b8-3828-5c36-aa13-f79f02c12f34";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const ISplitButtonAutomationPeerFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), owner: *SplitButton, baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SplitButtonAutomationPeer {
        var _r: *SplitButtonAutomationPeer = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), owner, baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISplitButtonAutomationPeerFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d63a2534-77dc-5361-8422-4ad8750f45f4";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, owner: *SplitButton, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **SplitButtonAutomationPeer) callconv(.winapi) HRESULT,
    };
};
pub const ISplitButtonClickEventArgs = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISplitButtonClickEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c227c2ca-26f4-5960-98d5-919149d1b525";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const ISplitButtonFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SplitButton {
        var _r: *SplitButton = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISplitButtonFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3201c32f-4d55-589d-97dd-617fa3642137";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **SplitButton) callconv(.winapi) HRESULT,
    };
};
pub const ISplitButtonStatics = extern struct {
    vtable: *const VTable,
    pub fn getFlyoutProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FlyoutProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCommandProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CommandProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCommandParameterProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CommandParameterProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISplitButtonStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8df07a81-0b1f-5ea9-be42-152ab9a4bc5e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_FlyoutProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CommandProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CommandParameterProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ISplitView = extern struct {
    vtable: *const VTable,
    pub fn getContent(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_Content(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putContent(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_Content(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPane(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_Pane(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPane(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_Pane(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsPaneOpen(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsPaneOpen(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsPaneOpen(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsPaneOpen(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOpenPaneLength(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_OpenPaneLength(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOpenPaneLength(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_OpenPaneLength(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCompactPaneLength(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_CompactPaneLength(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCompactPaneLength(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_CompactPaneLength(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPanePlacement(self: *@This()) core.HResult!SplitViewPanePlacement {
        var _r: SplitViewPanePlacement = undefined;
        const _c = self.vtable.get_PanePlacement(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPanePlacement(self: *@This(), value: SplitViewPanePlacement) core.HResult!void {
        const _c = self.vtable.put_PanePlacement(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDisplayMode(self: *@This()) core.HResult!SplitViewDisplayMode {
        var _r: SplitViewDisplayMode = undefined;
        const _c = self.vtable.get_DisplayMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDisplayMode(self: *@This(), value: SplitViewDisplayMode) core.HResult!void {
        const _c = self.vtable.put_DisplayMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*SplitViewTemplateSettings {
        var _r: *SplitViewTemplateSettings = undefined;
        const _c = self.vtable.get_TemplateSettings(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPaneBackground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_PaneBackground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPaneBackground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_PaneBackground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addPaneClosing(self: *@This(), handler: *TypedEventHandler(SplitView,SplitViewPaneClosingEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_PaneClosing(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removePaneClosing(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_PaneClosing(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addPaneClosed(self: *@This(), handler: *TypedEventHandler(SplitView,IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_PaneClosed(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removePaneClosed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_PaneClosed(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISplitView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "97222f31-3844-429e-939c-1673155322a1";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Content: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_Content: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
        get_Pane: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_Pane: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
        get_IsPaneOpen: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsPaneOpen: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_OpenPaneLength: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_OpenPaneLength: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_CompactPaneLength: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_CompactPaneLength: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_PanePlacement: *const fn(self: *anyopaque, _r: *SplitViewPanePlacement) callconv(.winapi) HRESULT,
        put_PanePlacement: *const fn(self: *anyopaque, value: SplitViewPanePlacement) callconv(.winapi) HRESULT,
        get_DisplayMode: *const fn(self: *anyopaque, _r: *SplitViewDisplayMode) callconv(.winapi) HRESULT,
        put_DisplayMode: *const fn(self: *anyopaque, value: SplitViewDisplayMode) callconv(.winapi) HRESULT,
        get_TemplateSettings: *const fn(self: *anyopaque, _r: **SplitViewTemplateSettings) callconv(.winapi) HRESULT,
        get_PaneBackground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_PaneBackground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        add_PaneClosing: *const fn(self: *anyopaque, handler: *TypedEventHandler(SplitView,SplitViewPaneClosingEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_PaneClosing: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_PaneClosed: *const fn(self: *anyopaque, handler: *TypedEventHandler(SplitView,IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_PaneClosed: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const ISplitView2 = extern struct {
    vtable: *const VTable,
    pub fn getLightDismissOverlayMode(self: *@This()) core.HResult!LightDismissOverlayMode {
        var _r: LightDismissOverlayMode = undefined;
        const _c = self.vtable.get_LightDismissOverlayMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putLightDismissOverlayMode(self: *@This(), value: LightDismissOverlayMode) core.HResult!void {
        const _c = self.vtable.put_LightDismissOverlayMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISplitView2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5ea7dc10-cc83-409a-82f9-3e91d6d7084f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LightDismissOverlayMode: *const fn(self: *anyopaque, _r: *LightDismissOverlayMode) callconv(.winapi) HRESULT,
        put_LightDismissOverlayMode: *const fn(self: *anyopaque, value: LightDismissOverlayMode) callconv(.winapi) HRESULT,
    };
};
pub const ISplitView3 = extern struct {
    vtable: *const VTable,
    pub fn addPaneOpening(self: *@This(), handler: *TypedEventHandler(SplitView,IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_PaneOpening(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removePaneOpening(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_PaneOpening(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addPaneOpened(self: *@This(), handler: *TypedEventHandler(SplitView,IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_PaneOpened(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removePaneOpened(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_PaneOpened(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISplitView3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0ea12d8d-1171-407b-96d3-5e1b470c3ec5";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        add_PaneOpening: *const fn(self: *anyopaque, handler: *TypedEventHandler(SplitView,IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_PaneOpening: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_PaneOpened: *const fn(self: *anyopaque, handler: *TypedEventHandler(SplitView,IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_PaneOpened: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const ISplitViewFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SplitView {
        var _r: *SplitView = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISplitViewFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f101773a-084e-4fb9-8442-63221b44533f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **SplitView) callconv(.winapi) HRESULT,
    };
};
pub const ISplitViewPaneClosingEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getCancel(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_Cancel(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCancel(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_Cancel(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISplitViewPaneClosingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "93cf494e-7a95-44d8-9562-1b348248da9f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Cancel: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_Cancel: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const ISplitViewStatics = extern struct {
    vtable: *const VTable,
    pub fn getContentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ContentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPaneProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PaneProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsPaneOpenProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsPaneOpenProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOpenPaneLengthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OpenPaneLengthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCompactPaneLengthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CompactPaneLengthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPanePlacementProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PanePlacementProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDisplayModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DisplayModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTemplateSettingsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TemplateSettingsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPaneBackgroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PaneBackgroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISplitViewStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "859b4f6f-44ab-4e4b-91c1-17b7056d9b5f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ContentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PaneProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsPaneOpenProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OpenPaneLengthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CompactPaneLengthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PanePlacementProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DisplayModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TemplateSettingsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PaneBackgroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ISplitViewStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getLightDismissOverlayModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LightDismissOverlayModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISplitViewStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "14b7cd7a-dfbc-422c-80a9-585871297113";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LightDismissOverlayModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IStackPanel = extern struct {
    vtable: *const VTable,
    pub fn getAreScrollSnapPointsRegular(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_AreScrollSnapPointsRegular(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putAreScrollSnapPointsRegular(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_AreScrollSnapPointsRegular(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOrientation(self: *@This()) core.HResult!Orientation {
        var _r: Orientation = undefined;
        const _c = self.vtable.get_Orientation(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOrientation(self: *@This(), value: Orientation) core.HResult!void {
        const _c = self.vtable.put_Orientation(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IStackPanel";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b8ae8fe2-d641-4fd7-80b4-7439207d2798";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_AreScrollSnapPointsRegular: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_AreScrollSnapPointsRegular: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_Orientation: *const fn(self: *anyopaque, _r: *Orientation) callconv(.winapi) HRESULT,
        put_Orientation: *const fn(self: *anyopaque, value: Orientation) callconv(.winapi) HRESULT,
    };
};
pub const IStackPanel2 = extern struct {
    vtable: *const VTable,
    pub fn getBorderBrush(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_BorderBrush(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_BorderBrush(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBorderThickness(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_BorderThickness(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBorderThickness(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_BorderThickness(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCornerRadius(self: *@This()) core.HResult!CornerRadius {
        var _r: CornerRadius = undefined;
        const _c = self.vtable.get_CornerRadius(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCornerRadius(self: *@This(), value: CornerRadius) core.HResult!void {
        const _c = self.vtable.put_CornerRadius(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPadding(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_Padding(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPadding(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_Padding(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IStackPanel2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "36f23359-040e-48f7-9a98-f2664591959c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BorderBrush: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_BorderBrush: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_BorderThickness: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_BorderThickness: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
        get_CornerRadius: *const fn(self: *anyopaque, _r: *CornerRadius) callconv(.winapi) HRESULT,
        put_CornerRadius: *const fn(self: *anyopaque, value: CornerRadius) callconv(.winapi) HRESULT,
        get_Padding: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_Padding: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
    };
};
pub const IStackPanel4 = extern struct {
    vtable: *const VTable,
    pub fn getSpacing(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_Spacing(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSpacing(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_Spacing(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IStackPanel4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "43ebf7f6-3196-412e-8a95-add002ff43f0";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Spacing: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_Spacing: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
    };
};
pub const IStackPanel5 = extern struct {
    vtable: *const VTable,
    pub fn getBackgroundSizing(self: *@This()) core.HResult!BackgroundSizing {
        var _r: BackgroundSizing = undefined;
        const _c = self.vtable.get_BackgroundSizing(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBackgroundSizing(self: *@This(), value: BackgroundSizing) core.HResult!void {
        const _c = self.vtable.put_BackgroundSizing(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IStackPanel5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f73e3117-61a8-5a01-865e-88511c04a992";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BackgroundSizing: *const fn(self: *anyopaque, _r: *BackgroundSizing) callconv(.winapi) HRESULT,
        put_BackgroundSizing: *const fn(self: *anyopaque, value: BackgroundSizing) callconv(.winapi) HRESULT,
    };
};
pub const IStackPanelFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*StackPanel {
        var _r: *StackPanel = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IStackPanelFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "63d8248a-8b34-445a-808f-b6ecd62a27d9";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **StackPanel) callconv(.winapi) HRESULT,
    };
};
pub const IStackPanelStatics = extern struct {
    vtable: *const VTable,
    pub fn getAreScrollSnapPointsRegularProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AreScrollSnapPointsRegularProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOrientationProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OrientationProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IStackPanelStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f0d0cd93-4dbc-48a7-9914-954924657771";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_AreScrollSnapPointsRegularProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OrientationProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IStackPanelStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getBorderBrushProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BorderBrushProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBorderThicknessProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BorderThicknessProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCornerRadiusProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CornerRadiusProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPaddingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PaddingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IStackPanelStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d97e6257-080d-412e-a91a-ce6e5d02aad3";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BorderBrushProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BorderThicknessProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CornerRadiusProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PaddingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IStackPanelStatics4 = extern struct {
    vtable: *const VTable,
    pub fn getSpacingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SpacingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IStackPanelStatics4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "279cdd71-067b-459f-815f-ecd85c5e4843";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SpacingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IStackPanelStatics5 = extern struct {
    vtable: *const VTable,
    pub fn getBackgroundSizingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BackgroundSizingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IStackPanelStatics5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "87287490-bff2-5347-8787-fb5aec942878";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_BackgroundSizingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IStyleSelector = extern struct {
    vtable: *const VTable,
    pub fn SelectStyle(self: *@This(), item: *IInspectable, container: *DependencyObject) core.HResult!*Style {
        var _r: *Style = undefined;
        const _c = self.vtable.SelectStyle(@ptrCast(self), item, container, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IStyleSelector";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d1113f67-d8c1-4ae4-98f0-d8504502f08b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        SelectStyle: *const fn(self: *anyopaque, item: *IInspectable, container: *DependencyObject, _r: **Style) callconv(.winapi) HRESULT,
    };
};
pub const IStyleSelectorFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*StyleSelector {
        var _r: *StyleSelector = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IStyleSelectorFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9e942ae7-3761-447f-8f97-29e39d5eb310";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **StyleSelector) callconv(.winapi) HRESULT,
    };
};
pub const IStyleSelectorOverrides = extern struct {
    vtable: *const VTable,
    pub fn SelectStyleCore(self: *@This(), item: *IInspectable, container: *DependencyObject) core.HResult!*Style {
        var _r: *Style = undefined;
        const _c = self.vtable.SelectStyleCore(@ptrCast(self), item, container, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IStyleSelectorOverrides";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "08add66d-0e2e-43a0-aeca-8faa94b9d017";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        SelectStyleCore: *const fn(self: *anyopaque, item: *IInspectable, container: *DependencyObject, _r: **Style) callconv(.winapi) HRESULT,
    };
};
pub const ISwapChainBackgroundPanel = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISwapChainBackgroundPanel";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1c59db48-8233-4c0c-bcf5-02a5fb35ae00";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const ISwapChainBackgroundPanel2 = extern struct {
    vtable: *const VTable,
    pub fn CreateCoreIndependentInputSource(self: *@This(), deviceTypes: CoreInputDeviceTypes) core.HResult!*CoreIndependentInputSource {
        var _r: *CoreIndependentInputSource = undefined;
        const _c = self.vtable.CreateCoreIndependentInputSource(@ptrCast(self), deviceTypes, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISwapChainBackgroundPanel2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "21e672f2-2592-4c38-870f-28fbcf52c095";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateCoreIndependentInputSource: *const fn(self: *anyopaque, deviceTypes: CoreInputDeviceTypes, _r: **CoreIndependentInputSource) callconv(.winapi) HRESULT,
    };
};
pub const ISwapChainBackgroundPanelFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SwapChainBackgroundPanel {
        var _r: *SwapChainBackgroundPanel = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISwapChainBackgroundPanelFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "198289d4-c89b-49b2-896c-5917bf8adcae";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **SwapChainBackgroundPanel) callconv(.winapi) HRESULT,
    };
};
pub const ISwapChainPanel = extern struct {
    vtable: *const VTable,
    pub fn getCompositionScaleX(self: *@This()) core.HResult!f32 {
        var _r: f32 = undefined;
        const _c = self.vtable.get_CompositionScaleX(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCompositionScaleY(self: *@This()) core.HResult!f32 {
        var _r: f32 = undefined;
        const _c = self.vtable.get_CompositionScaleY(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addCompositionScaleChanged(self: *@This(), handler: *TypedEventHandler(SwapChainPanel,IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_CompositionScaleChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeCompositionScaleChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_CompositionScaleChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn CreateCoreIndependentInputSource(self: *@This(), deviceTypes: CoreInputDeviceTypes) core.HResult!*CoreIndependentInputSource {
        var _r: *CoreIndependentInputSource = undefined;
        const _c = self.vtable.CreateCoreIndependentInputSource(@ptrCast(self), deviceTypes, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISwapChainPanel";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c589644f-eba8-427a-b75a-9f1f93a11ae9";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CompositionScaleX: *const fn(self: *anyopaque, _r: *f32) callconv(.winapi) HRESULT,
        get_CompositionScaleY: *const fn(self: *anyopaque, _r: *f32) callconv(.winapi) HRESULT,
        add_CompositionScaleChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(SwapChainPanel,IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_CompositionScaleChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        CreateCoreIndependentInputSource: *const fn(self: *anyopaque, deviceTypes: CoreInputDeviceTypes, _r: **CoreIndependentInputSource) callconv(.winapi) HRESULT,
    };
};
pub const ISwapChainPanelFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SwapChainPanel {
        var _r: *SwapChainPanel = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISwapChainPanelFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f38f8d7f-1a48-49cb-86d2-10eaaaf6fd70";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **SwapChainPanel) callconv(.winapi) HRESULT,
    };
};
pub const ISwapChainPanelStatics = extern struct {
    vtable: *const VTable,
    pub fn getCompositionScaleXProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CompositionScaleXProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCompositionScaleYProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CompositionScaleYProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISwapChainPanelStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f89c0297-eea8-498c-99c4-257e3660df7e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CompositionScaleXProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CompositionScaleYProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ISwipeControl = extern struct {
    vtable: *const VTable,
    pub fn getLeftItems(self: *@This()) core.HResult!*SwipeItems {
        var _r: *SwipeItems = undefined;
        const _c = self.vtable.get_LeftItems(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putLeftItems(self: *@This(), value: *SwipeItems) core.HResult!void {
        const _c = self.vtable.put_LeftItems(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getRightItems(self: *@This()) core.HResult!*SwipeItems {
        var _r: *SwipeItems = undefined;
        const _c = self.vtable.get_RightItems(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putRightItems(self: *@This(), value: *SwipeItems) core.HResult!void {
        const _c = self.vtable.put_RightItems(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTopItems(self: *@This()) core.HResult!*SwipeItems {
        var _r: *SwipeItems = undefined;
        const _c = self.vtable.get_TopItems(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTopItems(self: *@This(), value: *SwipeItems) core.HResult!void {
        const _c = self.vtable.put_TopItems(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBottomItems(self: *@This()) core.HResult!*SwipeItems {
        var _r: *SwipeItems = undefined;
        const _c = self.vtable.get_BottomItems(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBottomItems(self: *@This(), value: *SwipeItems) core.HResult!void {
        const _c = self.vtable.put_BottomItems(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Close(self: *@This()) core.HResult!void {
        const _c = self.vtable.Close(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISwipeControl";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9ee3d96f-6704-4823-aa15-1c143bc53cf7";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LeftItems: *const fn(self: *anyopaque, _r: **SwipeItems) callconv(.winapi) HRESULT,
        put_LeftItems: *const fn(self: *anyopaque, value: *SwipeItems) callconv(.winapi) HRESULT,
        get_RightItems: *const fn(self: *anyopaque, _r: **SwipeItems) callconv(.winapi) HRESULT,
        put_RightItems: *const fn(self: *anyopaque, value: *SwipeItems) callconv(.winapi) HRESULT,
        get_TopItems: *const fn(self: *anyopaque, _r: **SwipeItems) callconv(.winapi) HRESULT,
        put_TopItems: *const fn(self: *anyopaque, value: *SwipeItems) callconv(.winapi) HRESULT,
        get_BottomItems: *const fn(self: *anyopaque, _r: **SwipeItems) callconv(.winapi) HRESULT,
        put_BottomItems: *const fn(self: *anyopaque, value: *SwipeItems) callconv(.winapi) HRESULT,
        Close: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
    };
};
pub const ISwipeControlFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SwipeControl {
        var _r: *SwipeControl = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISwipeControlFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c0aaa3ae-d141-4e12-a728-5f95b507e7ab";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **SwipeControl) callconv(.winapi) HRESULT,
    };
};
pub const ISwipeControlStatics = extern struct {
    vtable: *const VTable,
    pub fn getLeftItemsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LeftItemsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getRightItemsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_RightItemsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTopItemsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TopItemsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBottomItemsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BottomItemsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISwipeControlStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e57ae83c-2216-4717-9ef6-4662334c6501";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LeftItemsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_RightItemsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TopItemsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BottomItemsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ISwipeItem = extern struct {
    vtable: *const VTable,
    pub fn getText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Text(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putText(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_Text(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIconSource(self: *@This()) core.HResult!*IconSource {
        var _r: *IconSource = undefined;
        const _c = self.vtable.get_IconSource(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIconSource(self: *@This(), value: *IconSource) core.HResult!void {
        const _c = self.vtable.put_IconSource(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBackground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_Background(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBackground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_Background(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_Foreground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_Foreground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCommand(self: *@This()) core.HResult!*ICommand {
        var _r: *ICommand = undefined;
        const _c = self.vtable.get_Command(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCommand(self: *@This(), value: *ICommand) core.HResult!void {
        const _c = self.vtable.put_Command(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCommandParameter(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_CommandParameter(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCommandParameter(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_CommandParameter(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getBehaviorOnInvoked(self: *@This()) core.HResult!SwipeBehaviorOnInvoked {
        var _r: SwipeBehaviorOnInvoked = undefined;
        const _c = self.vtable.get_BehaviorOnInvoked(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putBehaviorOnInvoked(self: *@This(), value: SwipeBehaviorOnInvoked) core.HResult!void {
        const _c = self.vtable.put_BehaviorOnInvoked(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addInvoked(self: *@This(), handler: *TypedEventHandler(SwipeItem,SwipeItemInvokedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Invoked(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeInvoked(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Invoked(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISwipeItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "836edadc-45c8-4a00-90a0-7107fa894a1b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Text: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_Text: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_IconSource: *const fn(self: *anyopaque, _r: **IconSource) callconv(.winapi) HRESULT,
        put_IconSource: *const fn(self: *anyopaque, value: *IconSource) callconv(.winapi) HRESULT,
        get_Background: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_Background: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_Foreground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_Foreground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_Command: *const fn(self: *anyopaque, _r: **ICommand) callconv(.winapi) HRESULT,
        put_Command: *const fn(self: *anyopaque, value: *ICommand) callconv(.winapi) HRESULT,
        get_CommandParameter: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_CommandParameter: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_BehaviorOnInvoked: *const fn(self: *anyopaque, _r: *SwipeBehaviorOnInvoked) callconv(.winapi) HRESULT,
        put_BehaviorOnInvoked: *const fn(self: *anyopaque, value: SwipeBehaviorOnInvoked) callconv(.winapi) HRESULT,
        add_Invoked: *const fn(self: *anyopaque, handler: *TypedEventHandler(SwipeItem,SwipeItemInvokedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Invoked: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const ISwipeItemFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SwipeItem {
        var _r: *SwipeItem = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISwipeItemFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "844bd61a-1716-4097-bba2-7526da22de39";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **SwipeItem) callconv(.winapi) HRESULT,
    };
};
pub const ISwipeItemInvokedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getSwipeControl(self: *@This()) core.HResult!*SwipeControl {
        var _r: *SwipeControl = undefined;
        const _c = self.vtable.get_SwipeControl(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISwipeItemInvokedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c5b025f5-cb32-4733-8011-5d0d37f4550a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SwipeControl: *const fn(self: *anyopaque, _r: **SwipeControl) callconv(.winapi) HRESULT,
    };
};
pub const ISwipeItemStatics = extern struct {
    vtable: *const VTable,
    pub fn getIconSourceProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IconSourceProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBackgroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BackgroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCommandProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CommandProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCommandParameterProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CommandParameterProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBehaviorOnInvokedProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_BehaviorOnInvokedProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISwipeItemStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d0b44e96-2766-4d93-b5db-f5e1be832c2d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IconSourceProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BackgroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CommandProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CommandParameterProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_BehaviorOnInvokedProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ISwipeItems = extern struct {
    vtable: *const VTable,
    pub fn getMode(self: *@This()) core.HResult!SwipeMode {
        var _r: SwipeMode = undefined;
        const _c = self.vtable.get_Mode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMode(self: *@This(), value: SwipeMode) core.HResult!void {
        const _c = self.vtable.put_Mode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISwipeItems";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b01726ff-969a-40d0-9f04-76084ce6d7b7";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Mode: *const fn(self: *anyopaque, _r: *SwipeMode) callconv(.winapi) HRESULT,
        put_Mode: *const fn(self: *anyopaque, value: SwipeMode) callconv(.winapi) HRESULT,
    };
};
pub const ISwipeItemsFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SwipeItems {
        var _r: *SwipeItems = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISwipeItemsFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "47c460ee-d5aa-445f-b31e-50c076c011b9";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **SwipeItems) callconv(.winapi) HRESULT,
    };
};
pub const ISwipeItemsStatics = extern struct {
    vtable: *const VTable,
    pub fn getModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISwipeItemsStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "376250df-48db-43e3-b0e9-089e5da9a114";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ISymbolIcon = extern struct {
    vtable: *const VTable,
    pub fn getSymbol(self: *@This()) core.HResult!Symbol {
        var _r: Symbol = undefined;
        const _c = self.vtable.get_Symbol(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSymbol(self: *@This(), value: Symbol) core.HResult!void {
        const _c = self.vtable.put_Symbol(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISymbolIcon";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "7a4774c9-a6a3-4b30-8ff1-9081d70e9a5c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Symbol: *const fn(self: *anyopaque, _r: *Symbol) callconv(.winapi) HRESULT,
        put_Symbol: *const fn(self: *anyopaque, value: Symbol) callconv(.winapi) HRESULT,
    };
};
pub const ISymbolIconFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstanceWithSymbol(self: *@This(), symbol: Symbol) core.HResult!*SymbolIcon {
        var _r: *SymbolIcon = undefined;
        const _c = self.vtable.CreateInstanceWithSymbol(@ptrCast(self), symbol, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISymbolIconFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c7252b88-e76c-4b44-8a05-046b9dc772b8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstanceWithSymbol: *const fn(self: *anyopaque, symbol: Symbol, _r: **SymbolIcon) callconv(.winapi) HRESULT,
    };
};
pub const ISymbolIconSource = extern struct {
    vtable: *const VTable,
    pub fn getSymbol(self: *@This()) core.HResult!Symbol {
        var _r: Symbol = undefined;
        const _c = self.vtable.get_Symbol(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSymbol(self: *@This(), value: Symbol) core.HResult!void {
        const _c = self.vtable.put_Symbol(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISymbolIconSource";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "625d95a2-b6b1-408a-b289-eab2ecba62d8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Symbol: *const fn(self: *anyopaque, _r: *Symbol) callconv(.winapi) HRESULT,
        put_Symbol: *const fn(self: *anyopaque, value: Symbol) callconv(.winapi) HRESULT,
    };
};
pub const ISymbolIconSourceFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SymbolIconSource {
        var _r: *SymbolIconSource = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISymbolIconSourceFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a526aab0-4130-4907-b049-21f9240c7a40";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **SymbolIconSource) callconv(.winapi) HRESULT,
    };
};
pub const ISymbolIconSourceStatics = extern struct {
    vtable: *const VTable,
    pub fn getSymbolProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SymbolProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISymbolIconSourceStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8bc49738-d94e-4148-8d64-1adf0f23f25f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SymbolProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ISymbolIconStatics = extern struct {
    vtable: *const VTable,
    pub fn getSymbolProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SymbolProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ISymbolIconStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8624fbdf-952c-4f76-b03f-30833be99572";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SymbolProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITextBlock = extern struct {
    vtable: *const VTable,
    pub fn getFontSize(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_FontSize(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontSize(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_FontSize(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontFamily(self: *@This()) core.HResult!*FontFamily {
        var _r: *FontFamily = undefined;
        const _c = self.vtable.get_FontFamily(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontFamily(self: *@This(), value: *FontFamily) core.HResult!void {
        const _c = self.vtable.put_FontFamily(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontWeight(self: *@This()) core.HResult!FontWeight {
        var _r: FontWeight = undefined;
        const _c = self.vtable.get_FontWeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontWeight(self: *@This(), value: FontWeight) core.HResult!void {
        const _c = self.vtable.put_FontWeight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontStyle(self: *@This()) core.HResult!FontStyle {
        var _r: FontStyle = undefined;
        const _c = self.vtable.get_FontStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontStyle(self: *@This(), value: FontStyle) core.HResult!void {
        const _c = self.vtable.put_FontStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getFontStretch(self: *@This()) core.HResult!FontStretch {
        var _r: FontStretch = undefined;
        const _c = self.vtable.get_FontStretch(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putFontStretch(self: *@This(), value: FontStretch) core.HResult!void {
        const _c = self.vtable.put_FontStretch(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCharacterSpacing(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_CharacterSpacing(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCharacterSpacing(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_CharacterSpacing(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_Foreground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_Foreground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextWrapping(self: *@This()) core.HResult!TextWrapping {
        var _r: TextWrapping = undefined;
        const _c = self.vtable.get_TextWrapping(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextWrapping(self: *@This(), value: TextWrapping) core.HResult!void {
        const _c = self.vtable.put_TextWrapping(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextTrimming(self: *@This()) core.HResult!TextTrimming {
        var _r: TextTrimming = undefined;
        const _c = self.vtable.get_TextTrimming(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextTrimming(self: *@This(), value: TextTrimming) core.HResult!void {
        const _c = self.vtable.put_TextTrimming(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextAlignment(self: *@This()) core.HResult!TextAlignment {
        var _r: TextAlignment = undefined;
        const _c = self.vtable.get_TextAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextAlignment(self: *@This(), value: TextAlignment) core.HResult!void {
        const _c = self.vtable.put_TextAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Text(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putText(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_Text(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getInlines(self: *@This()) core.HResult!*InlineCollection {
        var _r: *InlineCollection = undefined;
        const _c = self.vtable.get_Inlines(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPadding(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_Padding(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPadding(self: *@This(), value: Thickness) core.HResult!void {
        const _c = self.vtable.put_Padding(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getLineHeight(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_LineHeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putLineHeight(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_LineHeight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getLineStackingStrategy(self: *@This()) core.HResult!LineStackingStrategy {
        var _r: LineStackingStrategy = undefined;
        const _c = self.vtable.get_LineStackingStrategy(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putLineStackingStrategy(self: *@This(), value: LineStackingStrategy) core.HResult!void {
        const _c = self.vtable.put_LineStackingStrategy(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsTextSelectionEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsTextSelectionEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsTextSelectionEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsTextSelectionEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectedText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_SelectedText(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getContentStart(self: *@This()) core.HResult!*TextPointer {
        var _r: *TextPointer = undefined;
        const _c = self.vtable.get_ContentStart(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getContentEnd(self: *@This()) core.HResult!*TextPointer {
        var _r: *TextPointer = undefined;
        const _c = self.vtable.get_ContentEnd(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionStart(self: *@This()) core.HResult!*TextPointer {
        var _r: *TextPointer = undefined;
        const _c = self.vtable.get_SelectionStart(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionEnd(self: *@This()) core.HResult!*TextPointer {
        var _r: *TextPointer = undefined;
        const _c = self.vtable.get_SelectionEnd(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getBaselineOffset(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_BaselineOffset(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addSelectionChanged(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_SelectionChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeSelectionChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_SelectionChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addContextMenuOpening(self: *@This(), handler: *ContextMenuOpeningEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ContextMenuOpening(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeContextMenuOpening(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ContextMenuOpening(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn SelectAll(self: *@This()) core.HResult!void {
        const _c = self.vtable.SelectAll(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Select(self: *@This(), start: *TextPointer, end: *TextPointer) core.HResult!void {
        const _c = self.vtable.Select(@ptrCast(self), start, end);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Focus(self: *@This(), value: FocusState) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.Focus(@ptrCast(self), value, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBlock";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ae2d9271-3b4a-45fc-8468-f7949548f4d5";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_FontSize: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_FontSize: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_FontFamily: *const fn(self: *anyopaque, _r: **FontFamily) callconv(.winapi) HRESULT,
        put_FontFamily: *const fn(self: *anyopaque, value: *FontFamily) callconv(.winapi) HRESULT,
        get_FontWeight: *const fn(self: *anyopaque, _r: *FontWeight) callconv(.winapi) HRESULT,
        put_FontWeight: *const fn(self: *anyopaque, value: FontWeight) callconv(.winapi) HRESULT,
        get_FontStyle: *const fn(self: *anyopaque, _r: *FontStyle) callconv(.winapi) HRESULT,
        put_FontStyle: *const fn(self: *anyopaque, value: FontStyle) callconv(.winapi) HRESULT,
        get_FontStretch: *const fn(self: *anyopaque, _r: *FontStretch) callconv(.winapi) HRESULT,
        put_FontStretch: *const fn(self: *anyopaque, value: FontStretch) callconv(.winapi) HRESULT,
        get_CharacterSpacing: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_CharacterSpacing: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_Foreground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_Foreground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_TextWrapping: *const fn(self: *anyopaque, _r: *TextWrapping) callconv(.winapi) HRESULT,
        put_TextWrapping: *const fn(self: *anyopaque, value: TextWrapping) callconv(.winapi) HRESULT,
        get_TextTrimming: *const fn(self: *anyopaque, _r: *TextTrimming) callconv(.winapi) HRESULT,
        put_TextTrimming: *const fn(self: *anyopaque, value: TextTrimming) callconv(.winapi) HRESULT,
        get_TextAlignment: *const fn(self: *anyopaque, _r: *TextAlignment) callconv(.winapi) HRESULT,
        put_TextAlignment: *const fn(self: *anyopaque, value: TextAlignment) callconv(.winapi) HRESULT,
        get_Text: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_Text: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_Inlines: *const fn(self: *anyopaque, _r: **InlineCollection) callconv(.winapi) HRESULT,
        get_Padding: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        put_Padding: *const fn(self: *anyopaque, value: Thickness) callconv(.winapi) HRESULT,
        get_LineHeight: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_LineHeight: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_LineStackingStrategy: *const fn(self: *anyopaque, _r: *LineStackingStrategy) callconv(.winapi) HRESULT,
        put_LineStackingStrategy: *const fn(self: *anyopaque, value: LineStackingStrategy) callconv(.winapi) HRESULT,
        get_IsTextSelectionEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsTextSelectionEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_SelectedText: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        get_ContentStart: *const fn(self: *anyopaque, _r: **TextPointer) callconv(.winapi) HRESULT,
        get_ContentEnd: *const fn(self: *anyopaque, _r: **TextPointer) callconv(.winapi) HRESULT,
        get_SelectionStart: *const fn(self: *anyopaque, _r: **TextPointer) callconv(.winapi) HRESULT,
        get_SelectionEnd: *const fn(self: *anyopaque, _r: **TextPointer) callconv(.winapi) HRESULT,
        get_BaselineOffset: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        add_SelectionChanged: *const fn(self: *anyopaque, handler: *RoutedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_SelectionChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_ContextMenuOpening: *const fn(self: *anyopaque, handler: *ContextMenuOpeningEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ContextMenuOpening: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        SelectAll: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        Select: *const fn(self: *anyopaque, start: *TextPointer, end: *TextPointer) callconv(.winapi) HRESULT,
        Focus: *const fn(self: *anyopaque, value: FocusState, _r: *bool) callconv(.winapi) HRESULT,
    };
};
pub const ITextBlock2 = extern struct {
    vtable: *const VTable,
    pub fn getSelectionHighlightColor(self: *@This()) core.HResult!*SolidColorBrush {
        var _r: *SolidColorBrush = undefined;
        const _c = self.vtable.get_SelectionHighlightColor(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectionHighlightColor(self: *@This(), value: *SolidColorBrush) core.HResult!void {
        const _c = self.vtable.put_SelectionHighlightColor(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMaxLines(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_MaxLines(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxLines(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_MaxLines(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextLineBounds(self: *@This()) core.HResult!TextLineBounds {
        var _r: TextLineBounds = undefined;
        const _c = self.vtable.get_TextLineBounds(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextLineBounds(self: *@This(), value: TextLineBounds) core.HResult!void {
        const _c = self.vtable.put_TextLineBounds(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOpticalMarginAlignment(self: *@This()) core.HResult!OpticalMarginAlignment {
        var _r: OpticalMarginAlignment = undefined;
        const _c = self.vtable.get_OpticalMarginAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOpticalMarginAlignment(self: *@This(), value: OpticalMarginAlignment) core.HResult!void {
        const _c = self.vtable.put_OpticalMarginAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsColorFontEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsColorFontEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsColorFontEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsColorFontEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextReadingOrder(self: *@This()) core.HResult!TextReadingOrder {
        var _r: TextReadingOrder = undefined;
        const _c = self.vtable.get_TextReadingOrder(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextReadingOrder(self: *@This(), value: TextReadingOrder) core.HResult!void {
        const _c = self.vtable.put_TextReadingOrder(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBlock2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "45206a4c-0a4e-4fbf-aee9-335d5a205f6e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectionHighlightColor: *const fn(self: *anyopaque, _r: **SolidColorBrush) callconv(.winapi) HRESULT,
        put_SelectionHighlightColor: *const fn(self: *anyopaque, value: *SolidColorBrush) callconv(.winapi) HRESULT,
        get_MaxLines: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_MaxLines: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_TextLineBounds: *const fn(self: *anyopaque, _r: *TextLineBounds) callconv(.winapi) HRESULT,
        put_TextLineBounds: *const fn(self: *anyopaque, value: TextLineBounds) callconv(.winapi) HRESULT,
        get_OpticalMarginAlignment: *const fn(self: *anyopaque, _r: *OpticalMarginAlignment) callconv(.winapi) HRESULT,
        put_OpticalMarginAlignment: *const fn(self: *anyopaque, value: OpticalMarginAlignment) callconv(.winapi) HRESULT,
        get_IsColorFontEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsColorFontEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_TextReadingOrder: *const fn(self: *anyopaque, _r: *TextReadingOrder) callconv(.winapi) HRESULT,
        put_TextReadingOrder: *const fn(self: *anyopaque, value: TextReadingOrder) callconv(.winapi) HRESULT,
    };
};
pub const ITextBlock3 = extern struct {
    vtable: *const VTable,
    pub fn getIsTextScaleFactorEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsTextScaleFactorEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsTextScaleFactorEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsTextScaleFactorEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBlock3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b651dd5a-424b-48c3-9b67-486f4e139899";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsTextScaleFactorEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsTextScaleFactorEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const ITextBlock4 = extern struct {
    vtable: *const VTable,
    pub fn GetAlphaMask(self: *@This()) core.HResult!*CompositionBrush {
        var _r: *CompositionBrush = undefined;
        const _c = self.vtable.GetAlphaMask(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBlock4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b014f270-9808-4adc-b452-60cda54100c1";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        GetAlphaMask: *const fn(self: *anyopaque, _r: **CompositionBrush) callconv(.winapi) HRESULT,
    };
};
pub const ITextBlock5 = extern struct {
    vtable: *const VTable,
    pub fn getTextDecorations(self: *@This()) core.HResult!TextDecorations {
        var _r: TextDecorations = undefined;
        const _c = self.vtable.get_TextDecorations(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextDecorations(self: *@This(), value: TextDecorations) core.HResult!void {
        const _c = self.vtable.put_TextDecorations(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBlock5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "624a2d38-edbd-4a5a-b678-e49f1e07afbd";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TextDecorations: *const fn(self: *anyopaque, _r: *TextDecorations) callconv(.winapi) HRESULT,
        put_TextDecorations: *const fn(self: *anyopaque, value: TextDecorations) callconv(.winapi) HRESULT,
    };
};
pub const ITextBlock6 = extern struct {
    vtable: *const VTable,
    pub fn getIsTextTrimmed(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsTextTrimmed(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHorizontalTextAlignment(self: *@This()) core.HResult!TextAlignment {
        var _r: TextAlignment = undefined;
        const _c = self.vtable.get_HorizontalTextAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHorizontalTextAlignment(self: *@This(), value: TextAlignment) core.HResult!void {
        const _c = self.vtable.put_HorizontalTextAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextHighlighters(self: *@This()) core.HResult!*IVector(TextHighlighter) {
        var _r: *IVector(TextHighlighter) = undefined;
        const _c = self.vtable.get_TextHighlighters(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addIsTextTrimmedChanged(self: *@This(), handler: *TypedEventHandler(TextBlock,IsTextTrimmedChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_IsTextTrimmedChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeIsTextTrimmedChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_IsTextTrimmedChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBlock6";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "31816cd9-0404-410f-91ec-33b0a0bb92b2";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsTextTrimmed: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_HorizontalTextAlignment: *const fn(self: *anyopaque, _r: *TextAlignment) callconv(.winapi) HRESULT,
        put_HorizontalTextAlignment: *const fn(self: *anyopaque, value: TextAlignment) callconv(.winapi) HRESULT,
        get_TextHighlighters: *const fn(self: *anyopaque, _r: **IVector(TextHighlighter)) callconv(.winapi) HRESULT,
        add_IsTextTrimmedChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(TextBlock,IsTextTrimmedChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_IsTextTrimmedChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const ITextBlock7 = extern struct {
    vtable: *const VTable,
    pub fn getSelectionFlyout(self: *@This()) core.HResult!*FlyoutBase {
        var _r: *FlyoutBase = undefined;
        const _c = self.vtable.get_SelectionFlyout(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectionFlyout(self: *@This(), value: *FlyoutBase) core.HResult!void {
        const _c = self.vtable.put_SelectionFlyout(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn CopySelectionToClipboard(self: *@This()) core.HResult!void {
        const _c = self.vtable.CopySelectionToClipboard(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBlock7";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "dfe20a4e-8be7-5e33-9f37-72416875b121";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectionFlyout: *const fn(self: *anyopaque, _r: **FlyoutBase) callconv(.winapi) HRESULT,
        put_SelectionFlyout: *const fn(self: *anyopaque, value: *FlyoutBase) callconv(.winapi) HRESULT,
        CopySelectionToClipboard: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
    };
};
pub const ITextBlockStatics = extern struct {
    vtable: *const VTable,
    pub fn getFontSizeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontSizeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontFamilyProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontFamilyProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontWeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontWeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getFontStretchProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_FontStretchProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCharacterSpacingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CharacterSpacingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextWrappingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextWrappingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextTrimmingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextTrimmingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPaddingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PaddingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLineHeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LineHeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLineStackingStrategyProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LineStackingStrategyProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsTextSelectionEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsTextSelectionEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectedTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedTextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBlockStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "193ec042-a847-4552-b4e8-db36655b840a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_FontSizeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontFamilyProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontWeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_FontStretchProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CharacterSpacingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextWrappingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextTrimmingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PaddingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_LineHeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_LineStackingStrategyProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsTextSelectionEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectedTextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITextBlockStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getSelectionHighlightColorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectionHighlightColorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaxLinesProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxLinesProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextLineBoundsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextLineBoundsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOpticalMarginAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OpticalMarginAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsColorFontEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsColorFontEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextReadingOrderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextReadingOrderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBlockStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "88100b1b-ff24-4b93-a0e6-f029c94871f1";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectionHighlightColorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaxLinesProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextLineBoundsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OpticalMarginAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsColorFontEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextReadingOrderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITextBlockStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getIsTextScaleFactorEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsTextScaleFactorEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBlockStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8d16b9eb-20a1-4eab-bbf2-1d6bdcbcd705";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsTextScaleFactorEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITextBlockStatics5 = extern struct {
    vtable: *const VTable,
    pub fn getTextDecorationsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextDecorationsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBlockStatics5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8e4d9c70-0d4e-48df-ae7f-bb7a9af6852e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TextDecorationsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITextBlockStatics6 = extern struct {
    vtable: *const VTable,
    pub fn getIsTextTrimmedProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsTextTrimmedProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHorizontalTextAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HorizontalTextAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBlockStatics6";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3d1013a9-f9a6-43a2-99d3-573b89a83ca3";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsTextTrimmedProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HorizontalTextAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITextBlockStatics7 = extern struct {
    vtable: *const VTable,
    pub fn getSelectionFlyoutProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectionFlyoutProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBlockStatics7";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "cfd57e3b-0256-585d-8b3f-feafb69d3320";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectionFlyoutProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITextBox = extern struct {
    vtable: *const VTable,
    pub fn getText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_Text(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putText(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_Text(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectedText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_SelectedText(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectedText(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_SelectedText(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectionLength(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_SelectionLength(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectionLength(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_SelectionLength(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectionStart(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_SelectionStart(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectionStart(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_SelectionStart(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMaxLength(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_MaxLength(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaxLength(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_MaxLength(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsReadOnly(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsReadOnly(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsReadOnly(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsReadOnly(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAcceptsReturn(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_AcceptsReturn(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putAcceptsReturn(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_AcceptsReturn(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextAlignment(self: *@This()) core.HResult!TextAlignment {
        var _r: TextAlignment = undefined;
        const _c = self.vtable.get_TextAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextAlignment(self: *@This(), value: TextAlignment) core.HResult!void {
        const _c = self.vtable.put_TextAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextWrapping(self: *@This()) core.HResult!TextWrapping {
        var _r: TextWrapping = undefined;
        const _c = self.vtable.get_TextWrapping(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextWrapping(self: *@This(), value: TextWrapping) core.HResult!void {
        const _c = self.vtable.put_TextWrapping(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsSpellCheckEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsSpellCheckEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsSpellCheckEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsSpellCheckEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsTextPredictionEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsTextPredictionEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsTextPredictionEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsTextPredictionEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getInputScope(self: *@This()) core.HResult!*InputScope {
        var _r: *InputScope = undefined;
        const _c = self.vtable.get_InputScope(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putInputScope(self: *@This(), value: *InputScope) core.HResult!void {
        const _c = self.vtable.put_InputScope(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addTextChanged(self: *@This(), handler: *TextChangedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_TextChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeTextChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_TextChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addSelectionChanged(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_SelectionChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeSelectionChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_SelectionChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addContextMenuOpening(self: *@This(), handler: *ContextMenuOpeningEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ContextMenuOpening(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeContextMenuOpening(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ContextMenuOpening(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Select(self: *@This(), start: i32, length: i32) core.HResult!void {
        const _c = self.vtable.Select(@ptrCast(self), start, length);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn SelectAll(self: *@This()) core.HResult!void {
        const _c = self.vtable.SelectAll(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn GetRectFromCharacterIndex(self: *@This(), charIndex: i32, trailingEdge: bool) core.HResult!Rect {
        var _r: Rect = undefined;
        const _c = self.vtable.GetRectFromCharacterIndex(@ptrCast(self), charIndex, trailingEdge, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBox";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e48f5a8b-1dff-4352-a1f4-e516514ec882";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Text: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_Text: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_SelectedText: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_SelectedText: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_SelectionLength: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_SelectionLength: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_SelectionStart: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_SelectionStart: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_MaxLength: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_MaxLength: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_IsReadOnly: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsReadOnly: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_AcceptsReturn: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_AcceptsReturn: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_TextAlignment: *const fn(self: *anyopaque, _r: *TextAlignment) callconv(.winapi) HRESULT,
        put_TextAlignment: *const fn(self: *anyopaque, value: TextAlignment) callconv(.winapi) HRESULT,
        get_TextWrapping: *const fn(self: *anyopaque, _r: *TextWrapping) callconv(.winapi) HRESULT,
        put_TextWrapping: *const fn(self: *anyopaque, value: TextWrapping) callconv(.winapi) HRESULT,
        get_IsSpellCheckEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsSpellCheckEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsTextPredictionEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsTextPredictionEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_InputScope: *const fn(self: *anyopaque, _r: **InputScope) callconv(.winapi) HRESULT,
        put_InputScope: *const fn(self: *anyopaque, value: *InputScope) callconv(.winapi) HRESULT,
        add_TextChanged: *const fn(self: *anyopaque, handler: *TextChangedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_TextChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_SelectionChanged: *const fn(self: *anyopaque, handler: *RoutedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_SelectionChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_ContextMenuOpening: *const fn(self: *anyopaque, handler: *ContextMenuOpeningEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ContextMenuOpening: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        Select: *const fn(self: *anyopaque, start: i32, length: i32) callconv(.winapi) HRESULT,
        SelectAll: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        GetRectFromCharacterIndex: *const fn(self: *anyopaque, charIndex: i32, trailingEdge: bool, _r: *Rect) callconv(.winapi) HRESULT,
    };
};
pub const ITextBox2 = extern struct {
    vtable: *const VTable,
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Header(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Header(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_HeaderTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_HeaderTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPlaceholderText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_PlaceholderText(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPlaceholderText(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_PlaceholderText(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectionHighlightColor(self: *@This()) core.HResult!*SolidColorBrush {
        var _r: *SolidColorBrush = undefined;
        const _c = self.vtable.get_SelectionHighlightColor(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectionHighlightColor(self: *@This(), value: *SolidColorBrush) core.HResult!void {
        const _c = self.vtable.put_SelectionHighlightColor(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPreventKeyboardDisplayOnProgrammaticFocus(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_PreventKeyboardDisplayOnProgrammaticFocus(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPreventKeyboardDisplayOnProgrammaticFocus(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_PreventKeyboardDisplayOnProgrammaticFocus(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsColorFontEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsColorFontEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsColorFontEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsColorFontEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addPaste(self: *@This(), handler: *TextControlPasteEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Paste(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removePaste(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Paste(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBox2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f7168c00-1432-462a-9405-38f385bfc37c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Header: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Header: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_HeaderTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_HeaderTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_PlaceholderText: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_PlaceholderText: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_SelectionHighlightColor: *const fn(self: *anyopaque, _r: **SolidColorBrush) callconv(.winapi) HRESULT,
        put_SelectionHighlightColor: *const fn(self: *anyopaque, value: *SolidColorBrush) callconv(.winapi) HRESULT,
        get_PreventKeyboardDisplayOnProgrammaticFocus: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_PreventKeyboardDisplayOnProgrammaticFocus: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsColorFontEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsColorFontEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        add_Paste: *const fn(self: *anyopaque, handler: *TextControlPasteEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Paste: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const ITextBox3 = extern struct {
    vtable: *const VTable,
    pub fn addTextCompositionStarted(self: *@This(), handler: *TypedEventHandler(TextBox,TextCompositionStartedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_TextCompositionStarted(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeTextCompositionStarted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_TextCompositionStarted(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addTextCompositionChanged(self: *@This(), handler: *TypedEventHandler(TextBox,TextCompositionChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_TextCompositionChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeTextCompositionChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_TextCompositionChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addTextCompositionEnded(self: *@This(), handler: *TypedEventHandler(TextBox,TextCompositionEndedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_TextCompositionEnded(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeTextCompositionEnded(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_TextCompositionEnded(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTextReadingOrder(self: *@This()) core.HResult!TextReadingOrder {
        var _r: TextReadingOrder = undefined;
        const _c = self.vtable.get_TextReadingOrder(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTextReadingOrder(self: *@This(), value: TextReadingOrder) core.HResult!void {
        const _c = self.vtable.put_TextReadingOrder(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDesiredCandidateWindowAlignment(self: *@This()) core.HResult!CandidateWindowAlignment {
        var _r: CandidateWindowAlignment = undefined;
        const _c = self.vtable.get_DesiredCandidateWindowAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDesiredCandidateWindowAlignment(self: *@This(), value: CandidateWindowAlignment) core.HResult!void {
        const _c = self.vtable.put_DesiredCandidateWindowAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addCandidateWindowBoundsChanged(self: *@This(), handler: *TypedEventHandler(TextBox,CandidateWindowBoundsChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_CandidateWindowBoundsChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeCandidateWindowBoundsChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_CandidateWindowBoundsChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addTextChanging(self: *@This(), handler: *TypedEventHandler(TextBox,TextBoxTextChangingEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_TextChanging(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeTextChanging(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_TextChanging(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBox3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "7df18c3c-2826-425e-9a94-00b7f73f3756";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        add_TextCompositionStarted: *const fn(self: *anyopaque, handler: *TypedEventHandler(TextBox,TextCompositionStartedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_TextCompositionStarted: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_TextCompositionChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(TextBox,TextCompositionChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_TextCompositionChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_TextCompositionEnded: *const fn(self: *anyopaque, handler: *TypedEventHandler(TextBox,TextCompositionEndedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_TextCompositionEnded: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        get_TextReadingOrder: *const fn(self: *anyopaque, _r: *TextReadingOrder) callconv(.winapi) HRESULT,
        put_TextReadingOrder: *const fn(self: *anyopaque, value: TextReadingOrder) callconv(.winapi) HRESULT,
        get_DesiredCandidateWindowAlignment: *const fn(self: *anyopaque, _r: *CandidateWindowAlignment) callconv(.winapi) HRESULT,
        put_DesiredCandidateWindowAlignment: *const fn(self: *anyopaque, value: CandidateWindowAlignment) callconv(.winapi) HRESULT,
        add_CandidateWindowBoundsChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(TextBox,CandidateWindowBoundsChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_CandidateWindowBoundsChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_TextChanging: *const fn(self: *anyopaque, handler: *TypedEventHandler(TextBox,TextBoxTextChangingEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_TextChanging: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const ITextBox4 = extern struct {
    vtable: *const VTable,
    pub fn GetLinguisticAlternativesAsync(self: *@This()) core.HResult!*IAsyncOperation(IVectorView(HSTRING)) {
        var _r: *IAsyncOperation(IVectorView(HSTRING)) = undefined;
        const _c = self.vtable.GetLinguisticAlternativesAsync(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBox4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b5f1a675-cce1-45af-aef9-c4787bbb5e30";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        GetLinguisticAlternativesAsync: *const fn(self: *anyopaque, _r: **IAsyncOperation(IVectorView(HSTRING))) callconv(.winapi) HRESULT,
    };
};
pub const ITextBox5 = extern struct {
    vtable: *const VTable,
    pub fn getSelectionHighlightColorWhenNotFocused(self: *@This()) core.HResult!*SolidColorBrush {
        var _r: *SolidColorBrush = undefined;
        const _c = self.vtable.get_SelectionHighlightColorWhenNotFocused(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectionHighlightColorWhenNotFocused(self: *@This(), value: *SolidColorBrush) core.HResult!void {
        const _c = self.vtable.put_SelectionHighlightColorWhenNotFocused(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBox5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "35f9cfc1-4176-44f4-b756-e9ccc4399805";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectionHighlightColorWhenNotFocused: *const fn(self: *anyopaque, _r: **SolidColorBrush) callconv(.winapi) HRESULT,
        put_SelectionHighlightColorWhenNotFocused: *const fn(self: *anyopaque, value: *SolidColorBrush) callconv(.winapi) HRESULT,
    };
};
pub const ITextBox6 = extern struct {
    vtable: *const VTable,
    pub fn getHorizontalTextAlignment(self: *@This()) core.HResult!TextAlignment {
        var _r: TextAlignment = undefined;
        const _c = self.vtable.get_HorizontalTextAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHorizontalTextAlignment(self: *@This(), value: TextAlignment) core.HResult!void {
        const _c = self.vtable.put_HorizontalTextAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCharacterCasing(self: *@This()) core.HResult!CharacterCasing {
        var _r: CharacterCasing = undefined;
        const _c = self.vtable.get_CharacterCasing(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCharacterCasing(self: *@This(), value: CharacterCasing) core.HResult!void {
        const _c = self.vtable.put_CharacterCasing(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPlaceholderForeground(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_PlaceholderForeground(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPlaceholderForeground(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_PlaceholderForeground(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addCopyingToClipboard(self: *@This(), handler: *TypedEventHandler(TextBox,TextControlCopyingToClipboardEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_CopyingToClipboard(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeCopyingToClipboard(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_CopyingToClipboard(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addCuttingToClipboard(self: *@This(), handler: *TypedEventHandler(TextBox,TextControlCuttingToClipboardEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_CuttingToClipboard(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeCuttingToClipboard(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_CuttingToClipboard(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addBeforeTextChanging(self: *@This(), handler: *TypedEventHandler(TextBox,TextBoxBeforeTextChangingEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_BeforeTextChanging(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeBeforeTextChanging(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_BeforeTextChanging(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBox6";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "41ff2d07-5085-4e52-a51c-f94b06cd558b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HorizontalTextAlignment: *const fn(self: *anyopaque, _r: *TextAlignment) callconv(.winapi) HRESULT,
        put_HorizontalTextAlignment: *const fn(self: *anyopaque, value: TextAlignment) callconv(.winapi) HRESULT,
        get_CharacterCasing: *const fn(self: *anyopaque, _r: *CharacterCasing) callconv(.winapi) HRESULT,
        put_CharacterCasing: *const fn(self: *anyopaque, value: CharacterCasing) callconv(.winapi) HRESULT,
        get_PlaceholderForeground: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_PlaceholderForeground: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        add_CopyingToClipboard: *const fn(self: *anyopaque, handler: *TypedEventHandler(TextBox,TextControlCopyingToClipboardEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_CopyingToClipboard: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_CuttingToClipboard: *const fn(self: *anyopaque, handler: *TypedEventHandler(TextBox,TextControlCuttingToClipboardEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_CuttingToClipboard: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_BeforeTextChanging: *const fn(self: *anyopaque, handler: *TypedEventHandler(TextBox,TextBoxBeforeTextChangingEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_BeforeTextChanging: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const ITextBox7 = extern struct {
    vtable: *const VTable,
    pub fn getHandwritingView(self: *@This()) core.HResult!*HandwritingView {
        var _r: *HandwritingView = undefined;
        const _c = self.vtable.get_HandwritingView(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHandwritingView(self: *@This(), value: *HandwritingView) core.HResult!void {
        const _c = self.vtable.put_HandwritingView(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsHandwritingViewEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsHandwritingViewEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsHandwritingViewEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsHandwritingViewEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBox7";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "da4911f9-ffe1-4c6a-ac6d-1b4a174ccf80";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HandwritingView: *const fn(self: *anyopaque, _r: **HandwritingView) callconv(.winapi) HRESULT,
        put_HandwritingView: *const fn(self: *anyopaque, value: *HandwritingView) callconv(.winapi) HRESULT,
        get_IsHandwritingViewEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsHandwritingViewEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const ITextBox8 = extern struct {
    vtable: *const VTable,
    pub fn getCanPasteClipboardContent(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_CanPasteClipboardContent(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCanUndo(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_CanUndo(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCanRedo(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_CanRedo(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionFlyout(self: *@This()) core.HResult!*FlyoutBase {
        var _r: *FlyoutBase = undefined;
        const _c = self.vtable.get_SelectionFlyout(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectionFlyout(self: *@This(), value: *FlyoutBase) core.HResult!void {
        const _c = self.vtable.put_SelectionFlyout(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getProofingMenuFlyout(self: *@This()) core.HResult!*FlyoutBase {
        var _r: *FlyoutBase = undefined;
        const _c = self.vtable.get_ProofingMenuFlyout(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDescription(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Description(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDescription(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Description(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addSelectionChanging(self: *@This(), handler: *TypedEventHandler(TextBox,TextBoxSelectionChangingEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_SelectionChanging(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeSelectionChanging(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_SelectionChanging(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Undo(self: *@This()) core.HResult!void {
        const _c = self.vtable.Undo(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Redo(self: *@This()) core.HResult!void {
        const _c = self.vtable.Redo(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn PasteFromClipboard(self: *@This()) core.HResult!void {
        const _c = self.vtable.PasteFromClipboard(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn CopySelectionToClipboard(self: *@This()) core.HResult!void {
        const _c = self.vtable.CopySelectionToClipboard(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn CutSelectionToClipboard(self: *@This()) core.HResult!void {
        const _c = self.vtable.CutSelectionToClipboard(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn ClearUndoRedoHistory(self: *@This()) core.HResult!void {
        const _c = self.vtable.ClearUndoRedoHistory(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBox8";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1eb6d027-0317-5c37-8aea-f747ae7f0463";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CanPasteClipboardContent: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_CanUndo: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_CanRedo: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_SelectionFlyout: *const fn(self: *anyopaque, _r: **FlyoutBase) callconv(.winapi) HRESULT,
        put_SelectionFlyout: *const fn(self: *anyopaque, value: *FlyoutBase) callconv(.winapi) HRESULT,
        get_ProofingMenuFlyout: *const fn(self: *anyopaque, _r: **FlyoutBase) callconv(.winapi) HRESULT,
        get_Description: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Description: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        add_SelectionChanging: *const fn(self: *anyopaque, handler: *TypedEventHandler(TextBox,TextBoxSelectionChangingEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_SelectionChanging: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        Undo: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        Redo: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        PasteFromClipboard: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        CopySelectionToClipboard: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        CutSelectionToClipboard: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        ClearUndoRedoHistory: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
    };
};
pub const ITextBoxBeforeTextChangingEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getNewText(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_NewText(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCancel(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_Cancel(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCancel(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_Cancel(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBoxBeforeTextChangingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a5541db3-7784-4258-aa83-e4bedd727467";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_NewText: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        get_Cancel: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_Cancel: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const ITextBoxFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*TextBox {
        var _r: *TextBox = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBoxFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "710e4278-8529-47d3-8d8e-307e34cff081";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **TextBox) callconv(.winapi) HRESULT,
    };
};
pub const ITextBoxSelectionChangingEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getSelectionStart(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_SelectionStart(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionLength(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_SelectionLength(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCancel(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_Cancel(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCancel(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_Cancel(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBoxSelectionChangingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "847a24dd-9abe-52df-a80a-0cce4b496632";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectionStart: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_SelectionLength: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_Cancel: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_Cancel: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const ITextBoxStatics = extern struct {
    vtable: *const VTable,
    pub fn getTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaxLengthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaxLengthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsReadOnlyProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsReadOnlyProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getAcceptsReturnProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AcceptsReturnProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextWrappingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextWrappingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsSpellCheckEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsSpellCheckEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsTextPredictionEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsTextPredictionEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getInputScopeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_InputScopeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBoxStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "7e37f4fb-a4bc-4625-8838-8eb2a9091283";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_TextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaxLengthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsReadOnlyProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_AcceptsReturnProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextWrappingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsSpellCheckEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsTextPredictionEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_InputScopeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITextBoxStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPlaceholderTextProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlaceholderTextProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionHighlightColorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectionHighlightColorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPreventKeyboardDisplayOnProgrammaticFocusProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PreventKeyboardDisplayOnProgrammaticFocusProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsColorFontEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsColorFontEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBoxStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "7592f37d-4e76-4ee4-8e0f-7d6e1a23326b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PlaceholderTextProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectionHighlightColorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PreventKeyboardDisplayOnProgrammaticFocusProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsColorFontEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITextBoxStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getDesiredCandidateWindowAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DesiredCandidateWindowAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTextReadingOrderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TextReadingOrderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBoxStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0e1005c0-10b5-40f6-92c2-ce134b0d3457";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_DesiredCandidateWindowAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TextReadingOrderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITextBoxStatics5 = extern struct {
    vtable: *const VTable,
    pub fn getSelectionHighlightColorWhenNotFocusedProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectionHighlightColorWhenNotFocusedProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBoxStatics5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "07d04b45-1b2f-4627-82fd-683f197e5a75";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectionHighlightColorWhenNotFocusedProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITextBoxStatics6 = extern struct {
    vtable: *const VTable,
    pub fn getHorizontalTextAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HorizontalTextAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCharacterCasingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CharacterCasingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPlaceholderForegroundProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlaceholderForegroundProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBoxStatics6";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "dc0d97e7-1cb7-433e-aa4f-9c64c98cdee5";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HorizontalTextAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CharacterCasingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PlaceholderForegroundProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITextBoxStatics7 = extern struct {
    vtable: *const VTable,
    pub fn getHandwritingViewProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HandwritingViewProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsHandwritingViewEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsHandwritingViewEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBoxStatics7";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "cd6c6f47-147e-46f8-a4e8-749c49847a3e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HandwritingViewProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsHandwritingViewEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITextBoxStatics8 = extern struct {
    vtable: *const VTable,
    pub fn getCanPasteClipboardContentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CanPasteClipboardContentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCanUndoProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CanUndoProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCanRedoProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CanRedoProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionFlyoutProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectionFlyoutProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getProofingMenuFlyoutProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ProofingMenuFlyoutProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDescriptionProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DescriptionProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBoxStatics8";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "7f93d7c4-7d88-5f4d-8955-a5ad3848bcb6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CanPasteClipboardContentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CanUndoProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CanRedoProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_SelectionFlyoutProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ProofingMenuFlyoutProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DescriptionProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITextBoxTextChangingEventArgs = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBoxTextChangingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4e6a4b75-43dd-4e33-acbe-2d8796a17927";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const ITextBoxTextChangingEventArgs2 = extern struct {
    vtable: *const VTable,
    pub fn getIsContentChanging(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsContentChanging(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextBoxTextChangingEventArgs2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c0723d44-53a6-415f-a981-50dfaf1becbe";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsContentChanging: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
    };
};
pub const ITextChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4dd04f7d-7a11-4b2e-9933-577df39252b6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const ITextCommandBarFlyout = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextCommandBarFlyout";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "90384f66-cd3d-5325-8f40-59b076463c40";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const ITextCommandBarFlyoutFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*TextCommandBarFlyout {
        var _r: *TextCommandBarFlyout = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextCommandBarFlyoutFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1b5918d8-b006-5ecd-ab72-6fdb48abc1f4";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **TextCommandBarFlyout) callconv(.winapi) HRESULT,
    };
};
pub const ITextCompositionChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getStartIndex(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_StartIndex(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLength(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_Length(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextCompositionChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b9c7e0f2-50b7-441d-990c-68553e2e056b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_StartIndex: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_Length: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
    };
};
pub const ITextCompositionEndedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getStartIndex(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_StartIndex(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLength(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_Length(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextCompositionEndedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "46e34db2-77c0-4015-8eb4-92eefdfc5914";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_StartIndex: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_Length: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
    };
};
pub const ITextCompositionStartedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getStartIndex(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_StartIndex(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getLength(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_Length(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextCompositionStartedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "df22abb2-10cf-491e-91e8-d3cd72d8a0d3";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_StartIndex: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_Length: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
    };
};
pub const ITextControlCopyingToClipboardEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getHandled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_Handled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHandled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_Handled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextControlCopyingToClipboardEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e405ef19-d0df-43da-ace6-16f9113868c3";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Handled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_Handled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const ITextControlCuttingToClipboardEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getHandled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_Handled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHandled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_Handled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextControlCuttingToClipboardEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5f894995-a58d-4cf3-b589-b5e500e06475";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Handled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_Handled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const ITextControlPasteEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getHandled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_Handled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHandled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_Handled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITextControlPasteEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4bd1d625-221a-477e-bb2c-ad0c1ed125e7";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Handled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_Handled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const ITimePickedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getOldTime(self: *@This()) core.HResult!TimeSpan {
        var _r: TimeSpan = undefined;
        const _c = self.vtable.get_OldTime(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getNewTime(self: *@This()) core.HResult!TimeSpan {
        var _r: TimeSpan = undefined;
        const _c = self.vtable.get_NewTime(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITimePickedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8ad3ff21-5f66-4785-b999-24fef39fb6db";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_OldTime: *const fn(self: *anyopaque, _r: *TimeSpan) callconv(.winapi) HRESULT,
        get_NewTime: *const fn(self: *anyopaque, _r: *TimeSpan) callconv(.winapi) HRESULT,
    };
};
pub const ITimePicker = extern struct {
    vtable: *const VTable,
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Header(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Header(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_HeaderTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_HeaderTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getClockIdentifier(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_ClockIdentifier(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putClockIdentifier(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_ClockIdentifier(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMinuteIncrement(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_MinuteIncrement(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMinuteIncrement(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_MinuteIncrement(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTime(self: *@This()) core.HResult!TimeSpan {
        var _r: TimeSpan = undefined;
        const _c = self.vtable.get_Time(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTime(self: *@This(), value: TimeSpan) core.HResult!void {
        const _c = self.vtable.put_Time(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addTimeChanged(self: *@This(), handler: *EventHandler(TimePickerValueChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_TimeChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeTimeChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_TimeChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITimePicker";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e39099f2-3aff-4792-909e-2d9941ec0357";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Header: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Header: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_HeaderTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_HeaderTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_ClockIdentifier: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_ClockIdentifier: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_MinuteIncrement: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_MinuteIncrement: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        get_Time: *const fn(self: *anyopaque, _r: *TimeSpan) callconv(.winapi) HRESULT,
        put_Time: *const fn(self: *anyopaque, value: TimeSpan) callconv(.winapi) HRESULT,
        add_TimeChanged: *const fn(self: *anyopaque, handler: *EventHandler(TimePickerValueChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_TimeChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const ITimePicker2 = extern struct {
    vtable: *const VTable,
    pub fn getLightDismissOverlayMode(self: *@This()) core.HResult!LightDismissOverlayMode {
        var _r: LightDismissOverlayMode = undefined;
        const _c = self.vtable.get_LightDismissOverlayMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putLightDismissOverlayMode(self: *@This(), value: LightDismissOverlayMode) core.HResult!void {
        const _c = self.vtable.put_LightDismissOverlayMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITimePicker2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0ff0798c-f922-419f-8b3d-23ee7586d48e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LightDismissOverlayMode: *const fn(self: *anyopaque, _r: *LightDismissOverlayMode) callconv(.winapi) HRESULT,
        put_LightDismissOverlayMode: *const fn(self: *anyopaque, value: LightDismissOverlayMode) callconv(.winapi) HRESULT,
    };
};
pub const ITimePicker3 = extern struct {
    vtable: *const VTable,
    pub fn getSelectedTime(self: *@This()) core.HResult!*IReference(TimeSpan) {
        var _r: *IReference(TimeSpan) = undefined;
        const _c = self.vtable.get_SelectedTime(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectedTime(self: *@This(), value: *IReference(TimeSpan)) core.HResult!void {
        const _c = self.vtable.put_SelectedTime(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addSelectedTimeChanged(self: *@This(), handler: *TypedEventHandler(TimePicker,TimePickerSelectedValueChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_SelectedTimeChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeSelectedTimeChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_SelectedTimeChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITimePicker3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "fa6e4f91-ac32-59a4-94da-8b3d64289ed6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectedTime: *const fn(self: *anyopaque, _r: **IReference(TimeSpan)) callconv(.winapi) HRESULT,
        put_SelectedTime: *const fn(self: *anyopaque, value: *IReference(TimeSpan)) callconv(.winapi) HRESULT,
        add_SelectedTimeChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(TimePicker,TimePickerSelectedValueChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_SelectedTimeChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const ITimePickerFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*TimePicker {
        var _r: *TimePicker = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITimePickerFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "553fe413-6cd7-46a9-a97b-a18bdc4b4ca3";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **TimePicker) callconv(.winapi) HRESULT,
    };
};
pub const ITimePickerFlyout = extern struct {
    vtable: *const VTable,
    pub fn getClockIdentifier(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_ClockIdentifier(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putClockIdentifier(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_ClockIdentifier(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTime(self: *@This()) core.HResult!TimeSpan {
        var _r: TimeSpan = undefined;
        const _c = self.vtable.get_Time(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTime(self: *@This(), value: TimeSpan) core.HResult!void {
        const _c = self.vtable.put_Time(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMinuteIncrement(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_MinuteIncrement(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMinuteIncrement(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_MinuteIncrement(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addTimePicked(self: *@This(), handler: *TypedEventHandler(TimePickerFlyout,TimePickedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_TimePicked(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeTimePicked(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_TimePicked(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn ShowAtAsync(self: *@This(), target: *FrameworkElement) core.HResult!*IAsyncOperation(IReference(TimeSpan)) {
        var _r: *IAsyncOperation(IReference(TimeSpan)) = undefined;
        const _c = self.vtable.ShowAtAsync(@ptrCast(self), target, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITimePickerFlyout";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "bb739d75-e836-439e-86d5-506d2d18e404";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ClockIdentifier: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_ClockIdentifier: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_Time: *const fn(self: *anyopaque, _r: *TimeSpan) callconv(.winapi) HRESULT,
        put_Time: *const fn(self: *anyopaque, value: TimeSpan) callconv(.winapi) HRESULT,
        get_MinuteIncrement: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_MinuteIncrement: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
        add_TimePicked: *const fn(self: *anyopaque, handler: *TypedEventHandler(TimePickerFlyout,TimePickedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_TimePicked: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        ShowAtAsync: *const fn(self: *anyopaque, target: *FrameworkElement, _r: **IAsyncOperation(IReference(TimeSpan))) callconv(.winapi) HRESULT,
    };
};
pub const ITimePickerFlyoutPresenter = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITimePickerFlyoutPresenter";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c5320638-7a18-40ed-9fd0-4c852c09b24e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const ITimePickerFlyoutPresenter2 = extern struct {
    vtable: *const VTable,
    pub fn getIsDefaultShadowEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsDefaultShadowEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsDefaultShadowEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsDefaultShadowEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITimePickerFlyoutPresenter2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a13b5b68-7ee9-59f7-aad6-6532a8a8c3bf";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsDefaultShadowEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsDefaultShadowEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const ITimePickerFlyoutPresenterStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getIsDefaultShadowEnabledProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsDefaultShadowEnabledProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITimePickerFlyoutPresenterStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "aa5f0ddc-f2bb-53f2-a54d-b34acccf51e4";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsDefaultShadowEnabledProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITimePickerFlyoutStatics = extern struct {
    vtable: *const VTable,
    pub fn getClockIdentifierProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ClockIdentifierProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTimeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TimeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMinuteIncrementProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MinuteIncrementProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITimePickerFlyoutStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3f6728ce-2169-4003-b4a8-8de7035a0ad6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ClockIdentifierProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TimeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MinuteIncrementProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITimePickerSelectedValueChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getOldTime(self: *@This()) core.HResult!*IReference(TimeSpan) {
        var _r: *IReference(TimeSpan) = undefined;
        const _c = self.vtable.get_OldTime(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getNewTime(self: *@This()) core.HResult!*IReference(TimeSpan) {
        var _r: *IReference(TimeSpan) = undefined;
        const _c = self.vtable.get_NewTime(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITimePickerSelectedValueChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6e20fb35-3b9b-5bb6-9888-266524db181e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_OldTime: *const fn(self: *anyopaque, _r: **IReference(TimeSpan)) callconv(.winapi) HRESULT,
        get_NewTime: *const fn(self: *anyopaque, _r: **IReference(TimeSpan)) callconv(.winapi) HRESULT,
    };
};
pub const ITimePickerStatics = extern struct {
    vtable: *const VTable,
    pub fn getHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getClockIdentifierProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ClockIdentifierProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMinuteIncrementProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MinuteIncrementProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTimeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TimeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITimePickerStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "fa71dfb1-233e-4f31-b8be-a6ea670c25cd";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ClockIdentifierProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MinuteIncrementProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TimeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITimePickerStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getLightDismissOverlayModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_LightDismissOverlayModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITimePickerStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "36d8abcd-4e10-451a-b93b-1a731ea7ee3f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_LightDismissOverlayModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITimePickerStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getSelectedTimeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectedTimeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITimePickerStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "cfef1763-ba87-54d8-82d4-7c6b9734dc9d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectedTimeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITimePickerValueChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getOldTime(self: *@This()) core.HResult!TimeSpan {
        var _r: TimeSpan = undefined;
        const _c = self.vtable.get_OldTime(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getNewTime(self: *@This()) core.HResult!TimeSpan {
        var _r: TimeSpan = undefined;
        const _c = self.vtable.get_NewTime(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITimePickerValueChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "2f4edb8d-b995-4e31-8ba9-c4dcdeb21ca3";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_OldTime: *const fn(self: *anyopaque, _r: *TimeSpan) callconv(.winapi) HRESULT,
        get_NewTime: *const fn(self: *anyopaque, _r: *TimeSpan) callconv(.winapi) HRESULT,
    };
};
pub const IToggleMenuFlyoutItem = extern struct {
    vtable: *const VTable,
    pub fn getIsChecked(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsChecked(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsChecked(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsChecked(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IToggleMenuFlyoutItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "49841edd-88e9-4663-a701-cd4fd25e398f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsChecked: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsChecked: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IToggleMenuFlyoutItemFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ToggleMenuFlyoutItem {
        var _r: *ToggleMenuFlyoutItem = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IToggleMenuFlyoutItemFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a151966f-3bf7-46b6-b61c-9b2c1ba68843";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **ToggleMenuFlyoutItem) callconv(.winapi) HRESULT,
    };
};
pub const IToggleMenuFlyoutItemStatics = extern struct {
    vtable: *const VTable,
    pub fn getIsCheckedProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsCheckedProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IToggleMenuFlyoutItemStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "16c724fb-6c1a-4852-9258-08c038367907";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsCheckedProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IToggleSplitButton = extern struct {
    vtable: *const VTable,
    pub fn getIsChecked(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsChecked(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsChecked(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsChecked(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addIsCheckedChanged(self: *@This(), handler: *TypedEventHandler(ToggleSplitButton,ToggleSplitButtonIsCheckedChangedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_IsCheckedChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeIsCheckedChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_IsCheckedChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IToggleSplitButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "28981b31-8e78-570c-bebb-685814485ae9";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsChecked: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsChecked: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        add_IsCheckedChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(ToggleSplitButton,ToggleSplitButtonIsCheckedChangedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_IsCheckedChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IToggleSplitButtonAutomationPeer = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IToggleSplitButtonAutomationPeer";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "538e61de-7d46-5da7-94ab-acede6a12b9e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IToggleSplitButtonAutomationPeerFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), owner: *ToggleSplitButton, baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ToggleSplitButtonAutomationPeer {
        var _r: *ToggleSplitButtonAutomationPeer = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), owner, baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IToggleSplitButtonAutomationPeerFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9829b0a0-5a30-5eed-a3a3-1472c53b0a66";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, owner: *ToggleSplitButton, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **ToggleSplitButtonAutomationPeer) callconv(.winapi) HRESULT,
    };
};
pub const IToggleSplitButtonFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ToggleSplitButton {
        var _r: *ToggleSplitButton = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IToggleSplitButtonFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3fcf073b-e57c-573d-af38-d1b2ad387951";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **ToggleSplitButton) callconv(.winapi) HRESULT,
    };
};
pub const IToggleSplitButtonIsCheckedChangedEventArgs = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IToggleSplitButtonIsCheckedChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "2138f0cf-5fcd-5dbb-99ae-359483070f6b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IToggleSwitch = extern struct {
    vtable: *const VTable,
    pub fn getIsOn(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsOn(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsOn(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsOn(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Header(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Header(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_HeaderTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_HeaderTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOnContent(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_OnContent(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOnContent(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_OnContent(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOnContentTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_OnContentTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOnContentTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_OnContentTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOffContent(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_OffContent(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOffContent(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_OffContent(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOffContentTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_OffContentTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOffContentTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_OffContentTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*ToggleSwitchTemplateSettings {
        var _r: *ToggleSwitchTemplateSettings = undefined;
        const _c = self.vtable.get_TemplateSettings(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addToggled(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Toggled(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeToggled(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Toggled(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IToggleSwitch";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "331d8f00-c5f9-46a5-b6c8-ede539304567";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsOn: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsOn: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_Header: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Header: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_HeaderTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_HeaderTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_OnContent: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_OnContent: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_OnContentTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_OnContentTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_OffContent: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_OffContent: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_OffContentTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_OffContentTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_TemplateSettings: *const fn(self: *anyopaque, _r: **ToggleSwitchTemplateSettings) callconv(.winapi) HRESULT,
        add_Toggled: *const fn(self: *anyopaque, handler: *RoutedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Toggled: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IToggleSwitchOverrides = extern struct {
    vtable: *const VTable,
    pub fn OnToggled(self: *@This()) core.HResult!void {
        const _c = self.vtable.OnToggled(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnOnContentChanged(self: *@This(), oldContent: *IInspectable, newContent: *IInspectable) core.HResult!void {
        const _c = self.vtable.OnOnContentChanged(@ptrCast(self), oldContent, newContent);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnOffContentChanged(self: *@This(), oldContent: *IInspectable, newContent: *IInspectable) core.HResult!void {
        const _c = self.vtable.OnOffContentChanged(@ptrCast(self), oldContent, newContent);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnHeaderChanged(self: *@This(), oldContent: *IInspectable, newContent: *IInspectable) core.HResult!void {
        const _c = self.vtable.OnHeaderChanged(@ptrCast(self), oldContent, newContent);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IToggleSwitchOverrides";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "bfd07f53-f8ca-4e47-949e-9e80429b3d16";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        OnToggled: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        OnOnContentChanged: *const fn(self: *anyopaque, oldContent: *IInspectable, newContent: *IInspectable) callconv(.winapi) HRESULT,
        OnOffContentChanged: *const fn(self: *anyopaque, oldContent: *IInspectable, newContent: *IInspectable) callconv(.winapi) HRESULT,
        OnHeaderChanged: *const fn(self: *anyopaque, oldContent: *IInspectable, newContent: *IInspectable) callconv(.winapi) HRESULT,
    };
};
pub const IToggleSwitchStatics = extern struct {
    vtable: *const VTable,
    pub fn getIsOnProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsOnProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHeaderTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HeaderTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOnContentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OnContentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOnContentTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OnContentTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOffContentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OffContentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOffContentTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OffContentTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IToggleSwitchStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1d37147f-97df-4226-92ca-ddf453d7fd5a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsOnProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HeaderTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OnContentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OnContentTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OffContentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OffContentTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IToolTip = extern struct {
    vtable: *const VTable,
    pub fn getHorizontalOffset(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_HorizontalOffset(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHorizontalOffset(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_HorizontalOffset(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsOpen(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsOpen(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsOpen(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsOpen(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPlacement(self: *@This()) core.HResult!PlacementMode {
        var _r: PlacementMode = undefined;
        const _c = self.vtable.get_Placement(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPlacement(self: *@This(), value: PlacementMode) core.HResult!void {
        const _c = self.vtable.put_Placement(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPlacementTarget(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_PlacementTarget(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPlacementTarget(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_PlacementTarget(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getVerticalOffset(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_VerticalOffset(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putVerticalOffset(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_VerticalOffset(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*ToolTipTemplateSettings {
        var _r: *ToolTipTemplateSettings = undefined;
        const _c = self.vtable.get_TemplateSettings(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addClosed(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Closed(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeClosed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Closed(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addOpened(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Opened(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeOpened(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Opened(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IToolTip";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "7de5d75f-4415-429f-b523-699bdb8c30db";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HorizontalOffset: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_HorizontalOffset: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_IsOpen: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsOpen: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_Placement: *const fn(self: *anyopaque, _r: *PlacementMode) callconv(.winapi) HRESULT,
        put_Placement: *const fn(self: *anyopaque, value: PlacementMode) callconv(.winapi) HRESULT,
        get_PlacementTarget: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_PlacementTarget: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
        get_VerticalOffset: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_VerticalOffset: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_TemplateSettings: *const fn(self: *anyopaque, _r: **ToolTipTemplateSettings) callconv(.winapi) HRESULT,
        add_Closed: *const fn(self: *anyopaque, handler: *RoutedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Closed: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_Opened: *const fn(self: *anyopaque, handler: *RoutedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Opened: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IToolTip2 = extern struct {
    vtable: *const VTable,
    pub fn getPlacementRect(self: *@This()) core.HResult!*IReference(Rect) {
        var _r: *IReference(Rect) = undefined;
        const _c = self.vtable.get_PlacementRect(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPlacementRect(self: *@This(), value: *IReference(Rect)) core.HResult!void {
        const _c = self.vtable.put_PlacementRect(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IToolTip2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "2b1ade26-299a-5d54-800b-3bea123b4c20";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PlacementRect: *const fn(self: *anyopaque, _r: **IReference(Rect)) callconv(.winapi) HRESULT,
        put_PlacementRect: *const fn(self: *anyopaque, value: *IReference(Rect)) callconv(.winapi) HRESULT,
    };
};
pub const IToolTipFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ToolTip {
        var _r: *ToolTip = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IToolTipFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "89839403-b538-49e3-a430-3ac037dc6fe0";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **ToolTip) callconv(.winapi) HRESULT,
    };
};
pub const IToolTipService = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IToolTipService";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "03a55f87-bfcc-4a1e-8fea-98f610832cea";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IToolTipServiceStatics = extern struct {
    vtable: *const VTable,
    pub fn getPlacementProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlacementProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetPlacement(self: *@This(), element: *DependencyObject) core.HResult!PlacementMode {
        var _r: PlacementMode = undefined;
        const _c = self.vtable.GetPlacement(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetPlacement(self: *@This(), element: *DependencyObject, value: PlacementMode) core.HResult!void {
        const _c = self.vtable.SetPlacement(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPlacementTargetProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlacementTargetProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetPlacementTarget(self: *@This(), element: *DependencyObject) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.GetPlacementTarget(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetPlacementTarget(self: *@This(), element: *DependencyObject, value: *UIElement) core.HResult!void {
        const _c = self.vtable.SetPlacementTarget(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getToolTipProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ToolTipProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetToolTip(self: *@This(), element: *DependencyObject) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.GetToolTip(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetToolTip(self: *@This(), element: *DependencyObject, value: *IInspectable) core.HResult!void {
        const _c = self.vtable.SetToolTip(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IToolTipServiceStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "86e649f8-e245-48aa-a8c8-d1073ed76319";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PlacementProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetPlacement: *const fn(self: *anyopaque, element: *DependencyObject, _r: *PlacementMode) callconv(.winapi) HRESULT,
        SetPlacement: *const fn(self: *anyopaque, element: *DependencyObject, value: PlacementMode) callconv(.winapi) HRESULT,
        get_PlacementTargetProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetPlacementTarget: *const fn(self: *anyopaque, element: *DependencyObject, _r: **UIElement) callconv(.winapi) HRESULT,
        SetPlacementTarget: *const fn(self: *anyopaque, element: *DependencyObject, value: *UIElement) callconv(.winapi) HRESULT,
        get_ToolTipProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetToolTip: *const fn(self: *anyopaque, element: *DependencyObject, _r: **IInspectable) callconv(.winapi) HRESULT,
        SetToolTip: *const fn(self: *anyopaque, element: *DependencyObject, value: *IInspectable) callconv(.winapi) HRESULT,
    };
};
pub const IToolTipStatics = extern struct {
    vtable: *const VTable,
    pub fn getHorizontalOffsetProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HorizontalOffsetProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsOpenProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsOpenProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPlacementProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlacementProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPlacementTargetProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlacementTargetProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getVerticalOffsetProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_VerticalOffsetProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IToolTipStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f00285b8-4ba9-4f4f-86a7-86003813ceb3";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HorizontalOffsetProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsOpenProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PlacementProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PlacementTargetProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_VerticalOffsetProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IToolTipStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getPlacementRectProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PlacementRectProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IToolTipStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6845e646-9c7f-5011-8a78-7da9d87eb3b6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PlacementRectProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITreeView = extern struct {
    vtable: *const VTable,
    pub fn getRootNodes(self: *@This()) core.HResult!*IVector(TreeViewNode) {
        var _r: *IVector(TreeViewNode) = undefined;
        const _c = self.vtable.get_RootNodes(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSelectionMode(self: *@This()) core.HResult!TreeViewSelectionMode {
        var _r: TreeViewSelectionMode = undefined;
        const _c = self.vtable.get_SelectionMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSelectionMode(self: *@This(), value: TreeViewSelectionMode) core.HResult!void {
        const _c = self.vtable.put_SelectionMode(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getSelectedNodes(self: *@This()) core.HResult!*IVector(TreeViewNode) {
        var _r: *IVector(TreeViewNode) = undefined;
        const _c = self.vtable.get_SelectedNodes(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn Expand(self: *@This(), value: *TreeViewNode) core.HResult!void {
        const _c = self.vtable.Expand(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Collapse(self: *@This(), value: *TreeViewNode) core.HResult!void {
        const _c = self.vtable.Collapse(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn SelectAll(self: *@This()) core.HResult!void {
        const _c = self.vtable.SelectAll(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addItemInvoked(self: *@This(), handler: *TypedEventHandler(TreeView,TreeViewItemInvokedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ItemInvoked(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeItemInvoked(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ItemInvoked(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addExpanding(self: *@This(), handler: *TypedEventHandler(TreeView,TreeViewExpandingEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Expanding(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeExpanding(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Expanding(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addCollapsed(self: *@This(), handler: *TypedEventHandler(TreeView,TreeViewCollapsedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_Collapsed(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeCollapsed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_Collapsed(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9353cc5c-dd6e-453c-aedd-0c3ac993978b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_RootNodes: *const fn(self: *anyopaque, _r: **IVector(TreeViewNode)) callconv(.winapi) HRESULT,
        get_SelectionMode: *const fn(self: *anyopaque, _r: *TreeViewSelectionMode) callconv(.winapi) HRESULT,
        put_SelectionMode: *const fn(self: *anyopaque, value: TreeViewSelectionMode) callconv(.winapi) HRESULT,
        get_SelectedNodes: *const fn(self: *anyopaque, _r: **IVector(TreeViewNode)) callconv(.winapi) HRESULT,
        Expand: *const fn(self: *anyopaque, value: *TreeViewNode) callconv(.winapi) HRESULT,
        Collapse: *const fn(self: *anyopaque, value: *TreeViewNode) callconv(.winapi) HRESULT,
        SelectAll: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        add_ItemInvoked: *const fn(self: *anyopaque, handler: *TypedEventHandler(TreeView,TreeViewItemInvokedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ItemInvoked: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_Expanding: *const fn(self: *anyopaque, handler: *TypedEventHandler(TreeView,TreeViewExpandingEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Expanding: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_Collapsed: *const fn(self: *anyopaque, handler: *TypedEventHandler(TreeView,TreeViewCollapsedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_Collapsed: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const ITreeView2 = extern struct {
    vtable: *const VTable,
    pub fn NodeFromContainer(self: *@This(), container: *DependencyObject) core.HResult!*TreeViewNode {
        var _r: *TreeViewNode = undefined;
        const _c = self.vtable.NodeFromContainer(@ptrCast(self), container, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn ContainerFromNode(self: *@This(), node: *TreeViewNode) core.HResult!*DependencyObject {
        var _r: *DependencyObject = undefined;
        const _c = self.vtable.ContainerFromNode(@ptrCast(self), node, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn ItemFromContainer(self: *@This(), container: *DependencyObject) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.ItemFromContainer(@ptrCast(self), container, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn ContainerFromItem(self: *@This(), item: *IInspectable) core.HResult!*DependencyObject {
        var _r: *DependencyObject = undefined;
        const _c = self.vtable.ContainerFromItem(@ptrCast(self), item, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCanDragItems(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_CanDragItems(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCanDragItems(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_CanDragItems(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCanReorderItems(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_CanReorderItems(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCanReorderItems(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_CanReorderItems(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getItemTemplate(self: *@This()) core.HResult!*DataTemplate {
        var _r: *DataTemplate = undefined;
        const _c = self.vtable.get_ItemTemplate(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const _c = self.vtable.put_ItemTemplate(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getItemTemplateSelector(self: *@This()) core.HResult!*DataTemplateSelector {
        var _r: *DataTemplateSelector = undefined;
        const _c = self.vtable.get_ItemTemplateSelector(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemTemplateSelector(self: *@This(), value: *DataTemplateSelector) core.HResult!void {
        const _c = self.vtable.put_ItemTemplateSelector(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getItemContainerStyle(self: *@This()) core.HResult!*Style {
        var _r: *Style = undefined;
        const _c = self.vtable.get_ItemContainerStyle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemContainerStyle(self: *@This(), value: *Style) core.HResult!void {
        const _c = self.vtable.put_ItemContainerStyle(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getItemContainerStyleSelector(self: *@This()) core.HResult!*StyleSelector {
        var _r: *StyleSelector = undefined;
        const _c = self.vtable.get_ItemContainerStyleSelector(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemContainerStyleSelector(self: *@This(), value: *StyleSelector) core.HResult!void {
        const _c = self.vtable.put_ItemContainerStyleSelector(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getItemContainerTransitions(self: *@This()) core.HResult!*TransitionCollection {
        var _r: *TransitionCollection = undefined;
        const _c = self.vtable.get_ItemContainerTransitions(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemContainerTransitions(self: *@This(), value: *TransitionCollection) core.HResult!void {
        const _c = self.vtable.put_ItemContainerTransitions(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getItemsSource(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_ItemsSource(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemsSource(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_ItemsSource(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addDragItemsStarting(self: *@This(), handler: *TypedEventHandler(TreeView,TreeViewDragItemsStartingEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_DragItemsStarting(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeDragItemsStarting(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_DragItemsStarting(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addDragItemsCompleted(self: *@This(), handler: *TypedEventHandler(TreeView,TreeViewDragItemsCompletedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_DragItemsCompleted(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeDragItemsCompleted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_DragItemsCompleted(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeView2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4f33a2e6-2f29-55d3-a1ab-1f4a863bf960";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        NodeFromContainer: *const fn(self: *anyopaque, container: *DependencyObject, _r: **TreeViewNode) callconv(.winapi) HRESULT,
        ContainerFromNode: *const fn(self: *anyopaque, node: *TreeViewNode, _r: **DependencyObject) callconv(.winapi) HRESULT,
        ItemFromContainer: *const fn(self: *anyopaque, container: *DependencyObject, _r: **IInspectable) callconv(.winapi) HRESULT,
        ContainerFromItem: *const fn(self: *anyopaque, item: *IInspectable, _r: **DependencyObject) callconv(.winapi) HRESULT,
        get_CanDragItems: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_CanDragItems: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_CanReorderItems: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_CanReorderItems: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_ItemTemplate: *const fn(self: *anyopaque, _r: **DataTemplate) callconv(.winapi) HRESULT,
        put_ItemTemplate: *const fn(self: *anyopaque, value: *DataTemplate) callconv(.winapi) HRESULT,
        get_ItemTemplateSelector: *const fn(self: *anyopaque, _r: **DataTemplateSelector) callconv(.winapi) HRESULT,
        put_ItemTemplateSelector: *const fn(self: *anyopaque, value: *DataTemplateSelector) callconv(.winapi) HRESULT,
        get_ItemContainerStyle: *const fn(self: *anyopaque, _r: **Style) callconv(.winapi) HRESULT,
        put_ItemContainerStyle: *const fn(self: *anyopaque, value: *Style) callconv(.winapi) HRESULT,
        get_ItemContainerStyleSelector: *const fn(self: *anyopaque, _r: **StyleSelector) callconv(.winapi) HRESULT,
        put_ItemContainerStyleSelector: *const fn(self: *anyopaque, value: *StyleSelector) callconv(.winapi) HRESULT,
        get_ItemContainerTransitions: *const fn(self: *anyopaque, _r: **TransitionCollection) callconv(.winapi) HRESULT,
        put_ItemContainerTransitions: *const fn(self: *anyopaque, value: *TransitionCollection) callconv(.winapi) HRESULT,
        get_ItemsSource: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_ItemsSource: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        add_DragItemsStarting: *const fn(self: *anyopaque, handler: *TypedEventHandler(TreeView,TreeViewDragItemsStartingEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_DragItemsStarting: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_DragItemsCompleted: *const fn(self: *anyopaque, handler: *TypedEventHandler(TreeView,TreeViewDragItemsCompletedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_DragItemsCompleted: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewCollapsedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getNode(self: *@This()) core.HResult!*TreeViewNode {
        var _r: *TreeViewNode = undefined;
        const _c = self.vtable.get_Node(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewCollapsedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "391db3b0-1e58-4539-9e93-387978f46cce";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Node: *const fn(self: *anyopaque, _r: **TreeViewNode) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewCollapsedEventArgs2 = extern struct {
    vtable: *const VTable,
    pub fn getItem(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Item(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewCollapsedEventArgs2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "747b2f4f-7b25-56aa-8300-78d83b7ab2db";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Item: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewDragItemsCompletedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getDropResult(self: *@This()) core.HResult!DataPackageOperation {
        var _r: DataPackageOperation = undefined;
        const _c = self.vtable.get_DropResult(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItems(self: *@This()) core.HResult!*IVectorView(IInspectable) {
        var _r: *IVectorView(IInspectable) = undefined;
        const _c = self.vtable.get_Items(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewDragItemsCompletedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3ca8632c-4311-574e-8ab4-3b7aa5de7a88";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_DropResult: *const fn(self: *anyopaque, _r: *DataPackageOperation) callconv(.winapi) HRESULT,
        get_Items: *const fn(self: *anyopaque, _r: **IVectorView(IInspectable)) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewDragItemsStartingEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getCancel(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_Cancel(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCancel(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_Cancel(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getData(self: *@This()) core.HResult!*DataPackage {
        var _r: *DataPackage = undefined;
        const _c = self.vtable.get_Data(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItems(self: *@This()) core.HResult!*IVector(IInspectable) {
        var _r: *IVector(IInspectable) = undefined;
        const _c = self.vtable.get_Items(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewDragItemsStartingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "7bdb7ec4-e125-5773-9a3f-6695233d6250";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Cancel: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_Cancel: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_Data: *const fn(self: *anyopaque, _r: **DataPackage) callconv(.winapi) HRESULT,
        get_Items: *const fn(self: *anyopaque, _r: **IVector(IInspectable)) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewExpandingEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getNode(self: *@This()) core.HResult!*TreeViewNode {
        var _r: *TreeViewNode = undefined;
        const _c = self.vtable.get_Node(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewExpandingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c5e1fa63-4154-49d2-a21f-c34176605e3a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Node: *const fn(self: *anyopaque, _r: **TreeViewNode) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewExpandingEventArgs2 = extern struct {
    vtable: *const VTable,
    pub fn getItem(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Item(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewExpandingEventArgs2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a12f54c3-87b9-5623-9c74-e6dd443cde18";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Item: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*TreeView {
        var _r: *TreeView = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "cc5267c3-6c69-49ce-b445-753acee7948b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **TreeView) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewItem = extern struct {
    vtable: *const VTable,
    pub fn getGlyphOpacity(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_GlyphOpacity(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putGlyphOpacity(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_GlyphOpacity(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getGlyphBrush(self: *@This()) core.HResult!*Brush {
        var _r: *Brush = undefined;
        const _c = self.vtable.get_GlyphBrush(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putGlyphBrush(self: *@This(), value: *Brush) core.HResult!void {
        const _c = self.vtable.put_GlyphBrush(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getExpandedGlyph(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_ExpandedGlyph(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putExpandedGlyph(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_ExpandedGlyph(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getCollapsedGlyph(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_CollapsedGlyph(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCollapsedGlyph(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_CollapsedGlyph(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getGlyphSize(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_GlyphSize(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putGlyphSize(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_GlyphSize(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsExpanded(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsExpanded(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsExpanded(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsExpanded(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTreeViewItemTemplateSettings(self: *@This()) core.HResult!*TreeViewItemTemplateSettings {
        var _r: *TreeViewItemTemplateSettings = undefined;
        const _c = self.vtable.get_TreeViewItemTemplateSettings(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4e05d3e6-6167-44e7-9c74-291ddd6df6eb";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_GlyphOpacity: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_GlyphOpacity: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_GlyphBrush: *const fn(self: *anyopaque, _r: **Brush) callconv(.winapi) HRESULT,
        put_GlyphBrush: *const fn(self: *anyopaque, value: *Brush) callconv(.winapi) HRESULT,
        get_ExpandedGlyph: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_ExpandedGlyph: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_CollapsedGlyph: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_CollapsedGlyph: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        get_GlyphSize: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_GlyphSize: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_IsExpanded: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsExpanded: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_TreeViewItemTemplateSettings: *const fn(self: *anyopaque, _r: **TreeViewItemTemplateSettings) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewItem2 = extern struct {
    vtable: *const VTable,
    pub fn getHasUnrealizedChildren(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_HasUnrealizedChildren(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHasUnrealizedChildren(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_HasUnrealizedChildren(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getItemsSource(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_ItemsSource(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemsSource(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_ItemsSource(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewItem2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "007baf7f-0493-51b4-879c-458024b34149";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HasUnrealizedChildren: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_HasUnrealizedChildren: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_ItemsSource: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_ItemsSource: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewItemFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*TreeViewItem {
        var _r: *TreeViewItem = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewItemFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "4ea32731-568d-4d0d-adfd-3d8dc5aa5d88";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **TreeViewItem) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewItemInvokedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getInvokedItem(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_InvokedItem(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHandled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_Handled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHandled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_Handled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewItemInvokedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "472ab521-0242-4290-9363-ab4fe704527f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_InvokedItem: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Handled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_Handled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewItemStatics = extern struct {
    vtable: *const VTable,
    pub fn getGlyphOpacityProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_GlyphOpacityProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getGlyphBrushProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_GlyphBrushProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getExpandedGlyphProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ExpandedGlyphProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCollapsedGlyphProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CollapsedGlyphProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getGlyphSizeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_GlyphSizeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsExpandedProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsExpandedProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTreeViewItemTemplateSettingsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TreeViewItemTemplateSettingsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewItemStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "436795be-7396-46dc-a264-21c56581c5e5";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_GlyphOpacityProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_GlyphBrushProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ExpandedGlyphProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CollapsedGlyphProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_GlyphSizeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsExpandedProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TreeViewItemTemplateSettingsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewItemStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getHasUnrealizedChildrenProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HasUnrealizedChildrenProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemsSourceProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemsSourceProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewItemStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a8af82f3-d803-5c25-b48d-ae0e73b16d8e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_HasUnrealizedChildrenProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ItemsSourceProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewItemTemplateSettings = extern struct {
    vtable: *const VTable,
    pub fn getExpandedGlyphVisibility(self: *@This()) core.HResult!Visibility {
        var _r: Visibility = undefined;
        const _c = self.vtable.get_ExpandedGlyphVisibility(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCollapsedGlyphVisibility(self: *@This()) core.HResult!Visibility {
        var _r: Visibility = undefined;
        const _c = self.vtable.get_CollapsedGlyphVisibility(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIndentation(self: *@This()) core.HResult!Thickness {
        var _r: Thickness = undefined;
        const _c = self.vtable.get_Indentation(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDragItemsCount(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_DragItemsCount(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewItemTemplateSettings";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ec323744-de31-4936-bfc2-1cb37ba1dc08";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ExpandedGlyphVisibility: *const fn(self: *anyopaque, _r: *Visibility) callconv(.winapi) HRESULT,
        get_CollapsedGlyphVisibility: *const fn(self: *anyopaque, _r: *Visibility) callconv(.winapi) HRESULT,
        get_Indentation: *const fn(self: *anyopaque, _r: *Thickness) callconv(.winapi) HRESULT,
        get_DragItemsCount: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewItemTemplateSettingsFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*TreeViewItemTemplateSettings {
        var _r: *TreeViewItemTemplateSettings = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewItemTemplateSettingsFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "11a1953b-31b7-4f40-8633-02fc614b518c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **TreeViewItemTemplateSettings) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewItemTemplateSettingsStatics = extern struct {
    vtable: *const VTable,
    pub fn getExpandedGlyphVisibilityProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ExpandedGlyphVisibilityProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCollapsedGlyphVisibilityProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CollapsedGlyphVisibilityProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIndentationProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IndentationProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDragItemsCountProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DragItemsCountProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewItemTemplateSettingsStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "55c720a8-70ed-4c21-93f4-2d79c1a4a5f7";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ExpandedGlyphVisibilityProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CollapsedGlyphVisibilityProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IndentationProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DragItemsCountProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewList = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewList";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0f00a54e-099a-47a5-a942-94692b01f452";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewListFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*TreeViewList {
        var _r: *TreeViewList = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewListFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "288f6232-41d2-46f7-b1f5-691c625264b7";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **TreeViewList) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewNode = extern struct {
    vtable: *const VTable,
    pub fn getContent(self: *@This()) core.HResult!*IInspectable {
        var _r: *IInspectable = undefined;
        const _c = self.vtable.get_Content(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putContent(self: *@This(), value: *IInspectable) core.HResult!void {
        const _c = self.vtable.put_Content(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getParent(self: *@This()) core.HResult!*TreeViewNode {
        var _r: *TreeViewNode = undefined;
        const _c = self.vtable.get_Parent(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsExpanded(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsExpanded(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsExpanded(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsExpanded(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHasChildren(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_HasChildren(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDepth(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_Depth(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHasUnrealizedChildren(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_HasUnrealizedChildren(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHasUnrealizedChildren(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_HasUnrealizedChildren(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getChildren(self: *@This()) core.HResult!*IVector(TreeViewNode) {
        var _r: *IVector(TreeViewNode) = undefined;
        const _c = self.vtable.get_Children(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewNode";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c04c8ed3-9af2-4e75-a329-7497a110e7a8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Content: *const fn(self: *anyopaque, _r: **IInspectable) callconv(.winapi) HRESULT,
        put_Content: *const fn(self: *anyopaque, value: *IInspectable) callconv(.winapi) HRESULT,
        get_Parent: *const fn(self: *anyopaque, _r: **TreeViewNode) callconv(.winapi) HRESULT,
        get_IsExpanded: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsExpanded: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_HasChildren: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_Depth: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        get_HasUnrealizedChildren: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_HasUnrealizedChildren: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_Children: *const fn(self: *anyopaque, _r: **IVector(TreeViewNode)) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewNodeFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*TreeViewNode {
        var _r: *TreeViewNode = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewNodeFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6ec62d90-aa19-414a-8a45-0a5589a836f7";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **TreeViewNode) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewNodeStatics = extern struct {
    vtable: *const VTable,
    pub fn getContentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ContentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDepthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DepthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsExpandedProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsExpandedProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHasChildrenProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HasChildrenProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewNodeStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5d8276fe-e1d1-4b61-9e81-c7fb189a2980";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ContentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DepthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_IsExpandedProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HasChildrenProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewStatics = extern struct {
    vtable: *const VTable,
    pub fn getSelectionModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SelectionModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "ef913e08-83f2-4e16-bfb1-1577b98355f5";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SelectionModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITreeViewStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getCanDragItemsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CanDragItemsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCanReorderItemsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CanReorderItemsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemTemplateProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemTemplateProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemTemplateSelectorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemTemplateSelectorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemContainerStyleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemContainerStyleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemContainerStyleSelectorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemContainerStyleSelectorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemContainerTransitionsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemContainerTransitionsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemsSourceProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemsSourceProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITreeViewStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "16b1c8f9-7aa1-5e38-8218-7bba3ea417c0";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CanDragItemsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CanReorderItemsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ItemTemplateProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ItemTemplateSelectorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ItemContainerStyleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ItemContainerStyleSelectorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ItemContainerTransitionsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ItemsSourceProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const ITwoPaneView = extern struct {
    vtable: *const VTable,
    pub fn getPane1(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_Pane1(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPane1(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_Pane1(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPane2(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_Pane2(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPane2(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_Pane2(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPane1Length(self: *@This()) core.HResult!GridLength {
        var _r: GridLength = undefined;
        const _c = self.vtable.get_Pane1Length(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPane1Length(self: *@This(), value: GridLength) core.HResult!void {
        const _c = self.vtable.put_Pane1Length(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPane2Length(self: *@This()) core.HResult!GridLength {
        var _r: GridLength = undefined;
        const _c = self.vtable.get_Pane2Length(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPane2Length(self: *@This(), value: GridLength) core.HResult!void {
        const _c = self.vtable.put_Pane2Length(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getPanePriority(self: *@This()) core.HResult!TwoPaneViewPriority {
        var _r: TwoPaneViewPriority = undefined;
        const _c = self.vtable.get_PanePriority(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putPanePriority(self: *@This(), value: TwoPaneViewPriority) core.HResult!void {
        const _c = self.vtable.put_PanePriority(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMode(self: *@This()) core.HResult!TwoPaneViewMode {
        var _r: TwoPaneViewMode = undefined;
        const _c = self.vtable.get_Mode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getWideModeConfiguration(self: *@This()) core.HResult!TwoPaneViewWideModeConfiguration {
        var _r: TwoPaneViewWideModeConfiguration = undefined;
        const _c = self.vtable.get_WideModeConfiguration(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putWideModeConfiguration(self: *@This(), value: TwoPaneViewWideModeConfiguration) core.HResult!void {
        const _c = self.vtable.put_WideModeConfiguration(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getTallModeConfiguration(self: *@This()) core.HResult!TwoPaneViewTallModeConfiguration {
        var _r: TwoPaneViewTallModeConfiguration = undefined;
        const _c = self.vtable.get_TallModeConfiguration(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putTallModeConfiguration(self: *@This(), value: TwoPaneViewTallModeConfiguration) core.HResult!void {
        const _c = self.vtable.put_TallModeConfiguration(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMinWideModeWidth(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_MinWideModeWidth(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMinWideModeWidth(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_MinWideModeWidth(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMinTallModeHeight(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_MinTallModeHeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMinTallModeHeight(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_MinTallModeHeight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addModeChanged(self: *@This(), handler: *TypedEventHandler(TwoPaneView,IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ModeChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeModeChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ModeChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITwoPaneView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1b4d0db5-14ad-5926-bb8a-5b0a5c0085f0";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Pane1: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_Pane1: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
        get_Pane2: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_Pane2: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
        get_Pane1Length: *const fn(self: *anyopaque, _r: *GridLength) callconv(.winapi) HRESULT,
        put_Pane1Length: *const fn(self: *anyopaque, value: GridLength) callconv(.winapi) HRESULT,
        get_Pane2Length: *const fn(self: *anyopaque, _r: *GridLength) callconv(.winapi) HRESULT,
        put_Pane2Length: *const fn(self: *anyopaque, value: GridLength) callconv(.winapi) HRESULT,
        get_PanePriority: *const fn(self: *anyopaque, _r: *TwoPaneViewPriority) callconv(.winapi) HRESULT,
        put_PanePriority: *const fn(self: *anyopaque, value: TwoPaneViewPriority) callconv(.winapi) HRESULT,
        get_Mode: *const fn(self: *anyopaque, _r: *TwoPaneViewMode) callconv(.winapi) HRESULT,
        get_WideModeConfiguration: *const fn(self: *anyopaque, _r: *TwoPaneViewWideModeConfiguration) callconv(.winapi) HRESULT,
        put_WideModeConfiguration: *const fn(self: *anyopaque, value: TwoPaneViewWideModeConfiguration) callconv(.winapi) HRESULT,
        get_TallModeConfiguration: *const fn(self: *anyopaque, _r: *TwoPaneViewTallModeConfiguration) callconv(.winapi) HRESULT,
        put_TallModeConfiguration: *const fn(self: *anyopaque, value: TwoPaneViewTallModeConfiguration) callconv(.winapi) HRESULT,
        get_MinWideModeWidth: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_MinWideModeWidth: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_MinTallModeHeight: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_MinTallModeHeight: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        add_ModeChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(TwoPaneView,IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ModeChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const ITwoPaneViewFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*TwoPaneView {
        var _r: *TwoPaneView = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITwoPaneViewFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "18ff792d-58b4-59ed-a051-51aceffbcca9";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **TwoPaneView) callconv(.winapi) HRESULT,
    };
};
pub const ITwoPaneViewStatics = extern struct {
    vtable: *const VTable,
    pub fn getPane1Property(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_Pane1Property(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPane2Property(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_Pane2Property(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPane1LengthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_Pane1LengthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPane2LengthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_Pane2LengthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPanePriorityProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_PanePriorityProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getWideModeConfigurationProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_WideModeConfigurationProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getTallModeConfigurationProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_TallModeConfigurationProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMinWideModeWidthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MinWideModeWidthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMinTallModeHeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MinTallModeHeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ITwoPaneViewStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5a35c389-85c4-55f4-abb1-97451bc32d71";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Pane1Property: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_Pane2Property: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_Pane1LengthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_Pane2LengthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_PanePriorityProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_WideModeConfigurationProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_TallModeConfigurationProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MinWideModeWidthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MinTallModeHeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IUIElementCollection = extern struct {
    vtable: *const VTable,
    pub fn Move(self: *@This(), oldIndex: u32, newIndex: u32) core.HResult!void {
        const _c = self.vtable.Move(@ptrCast(self), oldIndex, newIndex);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IUIElementCollection";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d6602d54-88f6-43f6-85d8-a9d914a6dd3b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        Move: *const fn(self: *anyopaque, oldIndex: u32, newIndex: u32) callconv(.winapi) HRESULT,
    };
};
pub const IUserControl = extern struct {
    vtable: *const VTable,
    pub fn getContent(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_Content(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putContent(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_Content(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IUserControl";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a7a69ec9-ea35-4679-bf29-f4f09286d314";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Content: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_Content: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
    };
};
pub const IUserControlFactory = extern struct {
    vtable: *const VTable,
    pub fn CreateInstance(self: *@This(), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*UserControl {
        var _r: *UserControl = undefined;
        const _c = self.vtable.CreateInstance(@ptrCast(self), baseInterface, innerInterface, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IUserControlFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "38b1ed92-a28a-4972-93df-f4f759b8afd2";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstance: *const fn(self: *anyopaque, baseInterface: *IInspectable, innerInterface: *IInspectable, _r: **UserControl) callconv(.winapi) HRESULT,
    };
};
pub const IUserControlStatics = extern struct {
    vtable: *const VTable,
    pub fn getContentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ContentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IUserControlStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e8887976-2c5c-41cf-be6a-9e44befdf655";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ContentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IVariableSizedWrapGrid = extern struct {
    vtable: *const VTable,
    pub fn getItemHeight(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_ItemHeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemHeight(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_ItemHeight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getItemWidth(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_ItemWidth(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemWidth(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_ItemWidth(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOrientation(self: *@This()) core.HResult!Orientation {
        var _r: Orientation = undefined;
        const _c = self.vtable.get_Orientation(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOrientation(self: *@This(), value: Orientation) core.HResult!void {
        const _c = self.vtable.put_Orientation(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHorizontalChildrenAlignment(self: *@This()) core.HResult!HorizontalAlignment {
        var _r: HorizontalAlignment = undefined;
        const _c = self.vtable.get_HorizontalChildrenAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHorizontalChildrenAlignment(self: *@This(), value: HorizontalAlignment) core.HResult!void {
        const _c = self.vtable.put_HorizontalChildrenAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getVerticalChildrenAlignment(self: *@This()) core.HResult!VerticalAlignment {
        var _r: VerticalAlignment = undefined;
        const _c = self.vtable.get_VerticalChildrenAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putVerticalChildrenAlignment(self: *@This(), value: VerticalAlignment) core.HResult!void {
        const _c = self.vtable.put_VerticalChildrenAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMaximumRowsOrColumns(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_MaximumRowsOrColumns(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaximumRowsOrColumns(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_MaximumRowsOrColumns(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IVariableSizedWrapGrid";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9ca507c7-23c9-4f01-b80f-be5c21eef474";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ItemHeight: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_ItemHeight: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_ItemWidth: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_ItemWidth: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_Orientation: *const fn(self: *anyopaque, _r: *Orientation) callconv(.winapi) HRESULT,
        put_Orientation: *const fn(self: *anyopaque, value: Orientation) callconv(.winapi) HRESULT,
        get_HorizontalChildrenAlignment: *const fn(self: *anyopaque, _r: *HorizontalAlignment) callconv(.winapi) HRESULT,
        put_HorizontalChildrenAlignment: *const fn(self: *anyopaque, value: HorizontalAlignment) callconv(.winapi) HRESULT,
        get_VerticalChildrenAlignment: *const fn(self: *anyopaque, _r: *VerticalAlignment) callconv(.winapi) HRESULT,
        put_VerticalChildrenAlignment: *const fn(self: *anyopaque, value: VerticalAlignment) callconv(.winapi) HRESULT,
        get_MaximumRowsOrColumns: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_MaximumRowsOrColumns: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
    };
};
pub const IVariableSizedWrapGridStatics = extern struct {
    vtable: *const VTable,
    pub fn getItemHeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemHeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemWidthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemWidthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOrientationProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OrientationProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHorizontalChildrenAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HorizontalChildrenAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getVerticalChildrenAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_VerticalChildrenAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaximumRowsOrColumnsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaximumRowsOrColumnsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getRowSpanProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_RowSpanProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetRowSpan(self: *@This(), element: *UIElement) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.GetRowSpan(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetRowSpan(self: *@This(), element: *UIElement, value: i32) core.HResult!void {
        const _c = self.vtable.SetRowSpan(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getColumnSpanProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ColumnSpanProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetColumnSpan(self: *@This(), element: *UIElement) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.GetColumnSpan(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetColumnSpan(self: *@This(), element: *UIElement, value: i32) core.HResult!void {
        const _c = self.vtable.SetColumnSpan(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IVariableSizedWrapGridStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "fe9db859-8127-4aef-b7a2-949847486e96";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ItemHeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ItemWidthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OrientationProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HorizontalChildrenAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_VerticalChildrenAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaximumRowsOrColumnsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_RowSpanProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetRowSpan: *const fn(self: *anyopaque, element: *UIElement, _r: *i32) callconv(.winapi) HRESULT,
        SetRowSpan: *const fn(self: *anyopaque, element: *UIElement, value: i32) callconv(.winapi) HRESULT,
        get_ColumnSpanProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetColumnSpan: *const fn(self: *anyopaque, element: *UIElement, _r: *i32) callconv(.winapi) HRESULT,
        SetColumnSpan: *const fn(self: *anyopaque, element: *UIElement, value: i32) callconv(.winapi) HRESULT,
    };
};
pub const IViewbox = extern struct {
    vtable: *const VTable,
    pub fn getChild(self: *@This()) core.HResult!*UIElement {
        var _r: *UIElement = undefined;
        const _c = self.vtable.get_Child(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putChild(self: *@This(), value: *UIElement) core.HResult!void {
        const _c = self.vtable.put_Child(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getStretch(self: *@This()) core.HResult!Stretch {
        var _r: Stretch = undefined;
        const _c = self.vtable.get_Stretch(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putStretch(self: *@This(), value: Stretch) core.HResult!void {
        const _c = self.vtable.put_Stretch(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getStretchDirection(self: *@This()) core.HResult!StretchDirection {
        var _r: StretchDirection = undefined;
        const _c = self.vtable.get_StretchDirection(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putStretchDirection(self: *@This(), value: StretchDirection) core.HResult!void {
        const _c = self.vtable.put_StretchDirection(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IViewbox";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "05252c58-ba9d-4809-9ec3-fa0d16710ba1";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Child: *const fn(self: *anyopaque, _r: **UIElement) callconv(.winapi) HRESULT,
        put_Child: *const fn(self: *anyopaque, value: *UIElement) callconv(.winapi) HRESULT,
        get_Stretch: *const fn(self: *anyopaque, _r: *Stretch) callconv(.winapi) HRESULT,
        put_Stretch: *const fn(self: *anyopaque, value: Stretch) callconv(.winapi) HRESULT,
        get_StretchDirection: *const fn(self: *anyopaque, _r: *StretchDirection) callconv(.winapi) HRESULT,
        put_StretchDirection: *const fn(self: *anyopaque, value: StretchDirection) callconv(.winapi) HRESULT,
    };
};
pub const IViewboxStatics = extern struct {
    vtable: *const VTable,
    pub fn getStretchProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_StretchProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getStretchDirectionProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_StretchDirectionProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IViewboxStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5cd1e72d-e8d3-4865-8f08-b6b2d689adf1";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_StretchProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_StretchDirectionProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IVirtualizingPanel = extern struct {
    vtable: *const VTable,
    pub fn getItemContainerGenerator(self: *@This()) core.HResult!*ItemContainerGenerator {
        var _r: *ItemContainerGenerator = undefined;
        const _c = self.vtable.get_ItemContainerGenerator(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IVirtualizingPanel";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "38aad50c-12cf-4d1e-a884-c9df85f07cd9";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ItemContainerGenerator: *const fn(self: *anyopaque, _r: **ItemContainerGenerator) callconv(.winapi) HRESULT,
    };
};
pub const IVirtualizingPanelFactory = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IVirtualizingPanelFactory";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "be19f839-cbd0-43e9-a5d0-0bdba0ffbd38";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IVirtualizingPanelOverrides = extern struct {
    vtable: *const VTable,
    pub fn OnItemsChanged(self: *@This(), sender: *IInspectable, args: *ItemsChangedEventArgs) core.HResult!void {
        const _c = self.vtable.OnItemsChanged(@ptrCast(self), sender, args);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn OnClearChildren(self: *@This()) core.HResult!void {
        const _c = self.vtable.OnClearChildren(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn BringIndexIntoView(self: *@This(), index: i32) core.HResult!void {
        const _c = self.vtable.BringIndexIntoView(@ptrCast(self), index);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IVirtualizingPanelOverrides";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5ef6bd7d-677f-408d-a96c-b19507750466";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        OnItemsChanged: *const fn(self: *anyopaque, sender: *IInspectable, args: *ItemsChangedEventArgs) callconv(.winapi) HRESULT,
        OnClearChildren: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        BringIndexIntoView: *const fn(self: *anyopaque, index: i32) callconv(.winapi) HRESULT,
    };
};
pub const IVirtualizingPanelProtected = extern struct {
    vtable: *const VTable,
    pub fn AddInternalChild(self: *@This(), child: *UIElement) core.HResult!void {
        const _c = self.vtable.AddInternalChild(@ptrCast(self), child);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn InsertInternalChild(self: *@This(), index: i32, child: *UIElement) core.HResult!void {
        const _c = self.vtable.InsertInternalChild(@ptrCast(self), index, child);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn RemoveInternalChildRange(self: *@This(), index: i32, range: i32) core.HResult!void {
        const _c = self.vtable.RemoveInternalChildRange(@ptrCast(self), index, range);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IVirtualizingPanelProtected";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c9c9ab42-c232-479d-a7c9-5e7611196a45";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        AddInternalChild: *const fn(self: *anyopaque, child: *UIElement) callconv(.winapi) HRESULT,
        InsertInternalChild: *const fn(self: *anyopaque, index: i32, child: *UIElement) callconv(.winapi) HRESULT,
        RemoveInternalChildRange: *const fn(self: *anyopaque, index: i32, range: i32) callconv(.winapi) HRESULT,
    };
};
pub const IVirtualizingStackPanel = extern struct {
    vtable: *const VTable,
    pub fn getAreScrollSnapPointsRegular(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_AreScrollSnapPointsRegular(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putAreScrollSnapPointsRegular(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_AreScrollSnapPointsRegular(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOrientation(self: *@This()) core.HResult!Orientation {
        var _r: Orientation = undefined;
        const _c = self.vtable.get_Orientation(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOrientation(self: *@This(), value: Orientation) core.HResult!void {
        const _c = self.vtable.put_Orientation(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addCleanUpVirtualizedItemEvent(self: *@This(), handler: *CleanUpVirtualizedItemEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_CleanUpVirtualizedItemEvent(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeCleanUpVirtualizedItemEvent(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_CleanUpVirtualizedItemEvent(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IVirtualizingStackPanel";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "7567cd9a-a3b4-4dea-bb11-549e2c2f919d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_AreScrollSnapPointsRegular: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_AreScrollSnapPointsRegular: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_Orientation: *const fn(self: *anyopaque, _r: *Orientation) callconv(.winapi) HRESULT,
        put_Orientation: *const fn(self: *anyopaque, value: Orientation) callconv(.winapi) HRESULT,
        add_CleanUpVirtualizedItemEvent: *const fn(self: *anyopaque, handler: *CleanUpVirtualizedItemEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_CleanUpVirtualizedItemEvent: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IVirtualizingStackPanelOverrides = extern struct {
    vtable: *const VTable,
    pub fn OnCleanUpVirtualizedItem(self: *@This(), e: *CleanUpVirtualizedItemEventArgs) core.HResult!void {
        const _c = self.vtable.OnCleanUpVirtualizedItem(@ptrCast(self), e);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IVirtualizingStackPanelOverrides";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "cbe6f72c-2892-46d1-987f-58ca1081f040";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        OnCleanUpVirtualizedItem: *const fn(self: *anyopaque, e: *CleanUpVirtualizedItemEventArgs) callconv(.winapi) HRESULT,
    };
};
pub const IVirtualizingStackPanelStatics = extern struct {
    vtable: *const VTable,
    pub fn getAreScrollSnapPointsRegularProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AreScrollSnapPointsRegularProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOrientationProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OrientationProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getVirtualizationModeProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_VirtualizationModeProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetVirtualizationMode(self: *@This(), element: *DependencyObject) core.HResult!VirtualizationMode {
        var _r: VirtualizationMode = undefined;
        const _c = self.vtable.GetVirtualizationMode(@ptrCast(self), element, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn SetVirtualizationMode(self: *@This(), element: *DependencyObject, value: VirtualizationMode) core.HResult!void {
        const _c = self.vtable.SetVirtualizationMode(@ptrCast(self), element, value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsVirtualizingProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_IsVirtualizingProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn GetIsVirtualizing(self: *@This(), o: *DependencyObject) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.GetIsVirtualizing(@ptrCast(self), o, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IVirtualizingStackPanelStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8314e778-91d3-4d56-ac09-223adcd2bd3f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_AreScrollSnapPointsRegularProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OrientationProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_VirtualizationModeProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetVirtualizationMode: *const fn(self: *anyopaque, element: *DependencyObject, _r: *VirtualizationMode) callconv(.winapi) HRESULT,
        SetVirtualizationMode: *const fn(self: *anyopaque, element: *DependencyObject, value: VirtualizationMode) callconv(.winapi) HRESULT,
        get_IsVirtualizingProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        GetIsVirtualizing: *const fn(self: *anyopaque, o: *DependencyObject, _r: *bool) callconv(.winapi) HRESULT,
    };
};
pub const IWebView = extern struct {
    vtable: *const VTable,
    pub fn getSource(self: *@This()) core.HResult!*Uri {
        var _r: *Uri = undefined;
        const _c = self.vtable.get_Source(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSource(self: *@This(), value: *Uri) core.HResult!void {
        const _c = self.vtable.put_Source(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getAllowedScriptNotifyUris(self: *@This()) core.HResult!*IVector(Uri) {
        var _r: *IVector(Uri) = undefined;
        const _c = self.vtable.get_AllowedScriptNotifyUris(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putAllowedScriptNotifyUris(self: *@This(), value: *IVector(Uri)) core.HResult!void {
        const _c = self.vtable.put_AllowedScriptNotifyUris(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getDataTransferPackage(self: *@This()) core.HResult!*DataPackage {
        var _r: *DataPackage = undefined;
        const _c = self.vtable.get_DataTransferPackage(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addLoadCompleted(self: *@This(), handler: *LoadCompletedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_LoadCompleted(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeLoadCompleted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_LoadCompleted(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addScriptNotify(self: *@This(), handler: *NotifyEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ScriptNotify(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeScriptNotify(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ScriptNotify(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addNavigationFailed(self: *@This(), handler: *WebViewNavigationFailedEventHandler) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_NavigationFailed(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeNavigationFailed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_NavigationFailed(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn InvokeScript(self: *@This(), scriptName: HSTRING, arguments: [*]HSTRING) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.InvokeScript(@ptrCast(self), scriptName, arguments, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn Navigate(self: *@This(), source: *Uri) core.HResult!void {
        const _c = self.vtable.Navigate(@ptrCast(self), source);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn NavigateToString(self: *@This(), text: HSTRING) core.HResult!void {
        const _c = self.vtable.NavigateToString(@ptrCast(self), text);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "5862cc46-1f7d-479b-92a6-de7858fe8d54";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Source: *const fn(self: *anyopaque, _r: **Uri) callconv(.winapi) HRESULT,
        put_Source: *const fn(self: *anyopaque, value: *Uri) callconv(.winapi) HRESULT,
        get_AllowedScriptNotifyUris: *const fn(self: *anyopaque, _r: **IVector(Uri)) callconv(.winapi) HRESULT,
        put_AllowedScriptNotifyUris: *const fn(self: *anyopaque, value: *IVector(Uri)) callconv(.winapi) HRESULT,
        get_DataTransferPackage: *const fn(self: *anyopaque, _r: **DataPackage) callconv(.winapi) HRESULT,
        add_LoadCompleted: *const fn(self: *anyopaque, handler: *LoadCompletedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_LoadCompleted: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_ScriptNotify: *const fn(self: *anyopaque, handler: *NotifyEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ScriptNotify: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_NavigationFailed: *const fn(self: *anyopaque, handler: *WebViewNavigationFailedEventHandler, _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_NavigationFailed: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        InvokeScript: *const fn(self: *anyopaque, scriptName: HSTRING, arguments: [*]HSTRING, _r: *HSTRING) callconv(.winapi) HRESULT,
        Navigate: *const fn(self: *anyopaque, source: *Uri) callconv(.winapi) HRESULT,
        NavigateToString: *const fn(self: *anyopaque, text: HSTRING) callconv(.winapi) HRESULT,
    };
};
pub const IWebView2 = extern struct {
    vtable: *const VTable,
    pub fn getCanGoBack(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_CanGoBack(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCanGoForward(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_CanGoForward(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDocumentTitle(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_DocumentTitle(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addNavigationStarting(self: *@This(), handler: *TypedEventHandler(WebView,WebViewNavigationStartingEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_NavigationStarting(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeNavigationStarting(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_NavigationStarting(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addContentLoading(self: *@This(), handler: *TypedEventHandler(WebView,WebViewContentLoadingEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ContentLoading(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeContentLoading(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ContentLoading(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addDOMContentLoaded(self: *@This(), handler: *TypedEventHandler(WebView,WebViewDOMContentLoadedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_DOMContentLoaded(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeDOMContentLoaded(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_DOMContentLoaded(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn GoForward(self: *@This()) core.HResult!void {
        const _c = self.vtable.GoForward(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn GoBack(self: *@This()) core.HResult!void {
        const _c = self.vtable.GoBack(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Refresh(self: *@This()) core.HResult!void {
        const _c = self.vtable.Refresh(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Stop(self: *@This()) core.HResult!void {
        const _c = self.vtable.Stop(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn CapturePreviewToStreamAsync(self: *@This(), stream: *IRandomAccessStream) core.HResult!*IAsyncAction {
        var _r: *IAsyncAction = undefined;
        const _c = self.vtable.CapturePreviewToStreamAsync(@ptrCast(self), stream, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn InvokeScriptAsync(self: *@This(), scriptName: HSTRING, arguments: *IIterable(HSTRING)) core.HResult!*IAsyncOperation(HSTRING) {
        var _r: *IAsyncOperation(HSTRING) = undefined;
        const _c = self.vtable.InvokeScriptAsync(@ptrCast(self), scriptName, arguments, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn CaptureSelectedContentToDataPackageAsync(self: *@This()) core.HResult!*IAsyncOperation(DataPackage) {
        var _r: *IAsyncOperation(DataPackage) = undefined;
        const _c = self.vtable.CaptureSelectedContentToDataPackageAsync(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn NavigateToLocalStreamUri(self: *@This(), source: *Uri, streamResolver: *IUriToStreamResolver) core.HResult!void {
        const _c = self.vtable.NavigateToLocalStreamUri(@ptrCast(self), source, streamResolver);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn BuildLocalStreamUri(self: *@This(), contentIdentifier: HSTRING, relativePath: HSTRING) core.HResult!*Uri {
        var _r: *Uri = undefined;
        const _c = self.vtable.BuildLocalStreamUri(@ptrCast(self), contentIdentifier, relativePath, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDefaultBackgroundColor(self: *@This()) core.HResult!Color {
        var _r: Color = undefined;
        const _c = self.vtable.get_DefaultBackgroundColor(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putDefaultBackgroundColor(self: *@This(), value: Color) core.HResult!void {
        const _c = self.vtable.put_DefaultBackgroundColor(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addNavigationCompleted(self: *@This(), handler: *TypedEventHandler(WebView,WebViewNavigationCompletedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_NavigationCompleted(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeNavigationCompleted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_NavigationCompleted(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addFrameNavigationStarting(self: *@This(), handler: *TypedEventHandler(WebView,WebViewNavigationStartingEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_FrameNavigationStarting(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeFrameNavigationStarting(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_FrameNavigationStarting(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addFrameContentLoading(self: *@This(), handler: *TypedEventHandler(WebView,WebViewContentLoadingEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_FrameContentLoading(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeFrameContentLoading(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_FrameContentLoading(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addFrameDOMContentLoaded(self: *@This(), handler: *TypedEventHandler(WebView,WebViewDOMContentLoadedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_FrameDOMContentLoaded(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeFrameDOMContentLoaded(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_FrameDOMContentLoaded(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addFrameNavigationCompleted(self: *@This(), handler: *TypedEventHandler(WebView,WebViewNavigationCompletedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_FrameNavigationCompleted(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeFrameNavigationCompleted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_FrameNavigationCompleted(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addLongRunningScriptDetected(self: *@This(), handler: *TypedEventHandler(WebView,WebViewLongRunningScriptDetectedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_LongRunningScriptDetected(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeLongRunningScriptDetected(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_LongRunningScriptDetected(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addUnsafeContentWarningDisplaying(self: *@This(), handler: *TypedEventHandler(WebView,IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_UnsafeContentWarningDisplaying(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeUnsafeContentWarningDisplaying(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_UnsafeContentWarningDisplaying(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addUnviewableContentIdentified(self: *@This(), handler: *TypedEventHandler(WebView,WebViewUnviewableContentIdentifiedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_UnviewableContentIdentified(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeUnviewableContentIdentified(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_UnviewableContentIdentified(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn NavigateWithHttpRequestMessage(self: *@This(), requestMessage: *HttpRequestMessage) core.HResult!void {
        const _c = self.vtable.NavigateWithHttpRequestMessage(@ptrCast(self), requestMessage);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Focus(self: *@This(), value: FocusState) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.Focus(@ptrCast(self), value, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebView2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d481759e-3eff-4462-823d-fd52f9ba4cc8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CanGoBack: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_CanGoForward: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_DocumentTitle: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        add_NavigationStarting: *const fn(self: *anyopaque, handler: *TypedEventHandler(WebView,WebViewNavigationStartingEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_NavigationStarting: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_ContentLoading: *const fn(self: *anyopaque, handler: *TypedEventHandler(WebView,WebViewContentLoadingEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ContentLoading: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_DOMContentLoaded: *const fn(self: *anyopaque, handler: *TypedEventHandler(WebView,WebViewDOMContentLoadedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_DOMContentLoaded: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        GoForward: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        GoBack: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        Refresh: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        Stop: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        CapturePreviewToStreamAsync: *const fn(self: *anyopaque, stream: *IRandomAccessStream, _r: **IAsyncAction) callconv(.winapi) HRESULT,
        InvokeScriptAsync: *const fn(self: *anyopaque, scriptName: HSTRING, arguments: *IIterable(HSTRING), _r: **IAsyncOperation(HSTRING)) callconv(.winapi) HRESULT,
        CaptureSelectedContentToDataPackageAsync: *const fn(self: *anyopaque, _r: **IAsyncOperation(DataPackage)) callconv(.winapi) HRESULT,
        NavigateToLocalStreamUri: *const fn(self: *anyopaque, source: *Uri, streamResolver: *IUriToStreamResolver) callconv(.winapi) HRESULT,
        BuildLocalStreamUri: *const fn(self: *anyopaque, contentIdentifier: HSTRING, relativePath: HSTRING, _r: **Uri) callconv(.winapi) HRESULT,
        get_DefaultBackgroundColor: *const fn(self: *anyopaque, _r: *Color) callconv(.winapi) HRESULT,
        put_DefaultBackgroundColor: *const fn(self: *anyopaque, value: Color) callconv(.winapi) HRESULT,
        add_NavigationCompleted: *const fn(self: *anyopaque, handler: *TypedEventHandler(WebView,WebViewNavigationCompletedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_NavigationCompleted: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_FrameNavigationStarting: *const fn(self: *anyopaque, handler: *TypedEventHandler(WebView,WebViewNavigationStartingEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_FrameNavigationStarting: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_FrameContentLoading: *const fn(self: *anyopaque, handler: *TypedEventHandler(WebView,WebViewContentLoadingEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_FrameContentLoading: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_FrameDOMContentLoaded: *const fn(self: *anyopaque, handler: *TypedEventHandler(WebView,WebViewDOMContentLoadedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_FrameDOMContentLoaded: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_FrameNavigationCompleted: *const fn(self: *anyopaque, handler: *TypedEventHandler(WebView,WebViewNavigationCompletedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_FrameNavigationCompleted: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_LongRunningScriptDetected: *const fn(self: *anyopaque, handler: *TypedEventHandler(WebView,WebViewLongRunningScriptDetectedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_LongRunningScriptDetected: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_UnsafeContentWarningDisplaying: *const fn(self: *anyopaque, handler: *TypedEventHandler(WebView,IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_UnsafeContentWarningDisplaying: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_UnviewableContentIdentified: *const fn(self: *anyopaque, handler: *TypedEventHandler(WebView,WebViewUnviewableContentIdentifiedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_UnviewableContentIdentified: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        NavigateWithHttpRequestMessage: *const fn(self: *anyopaque, requestMessage: *HttpRequestMessage) callconv(.winapi) HRESULT,
        Focus: *const fn(self: *anyopaque, value: FocusState, _r: *bool) callconv(.winapi) HRESULT,
    };
};
pub const IWebView3 = extern struct {
    vtable: *const VTable,
    pub fn getContainsFullScreenElement(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_ContainsFullScreenElement(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addContainsFullScreenElementChanged(self: *@This(), handler: *TypedEventHandler(WebView,IInspectable)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_ContainsFullScreenElementChanged(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeContainsFullScreenElementChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_ContainsFullScreenElementChanged(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebView3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c497789b-b499-4d69-b5c2-ae9d5d6d594e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ContainsFullScreenElement: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        add_ContainsFullScreenElementChanged: *const fn(self: *anyopaque, handler: *TypedEventHandler(WebView,IInspectable), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_ContainsFullScreenElementChanged: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IWebView4 = extern struct {
    vtable: *const VTable,
    pub fn getExecutionMode(self: *@This()) core.HResult!WebViewExecutionMode {
        var _r: WebViewExecutionMode = undefined;
        const _c = self.vtable.get_ExecutionMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDeferredPermissionRequests(self: *@This()) core.HResult!*IVector(WebViewDeferredPermissionRequest) {
        var _r: *IVector(WebViewDeferredPermissionRequest) = undefined;
        const _c = self.vtable.get_DeferredPermissionRequests(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSettings(self: *@This()) core.HResult!*WebViewSettings {
        var _r: *WebViewSettings = undefined;
        const _c = self.vtable.get_Settings(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn addUnsupportedUriSchemeIdentified(self: *@This(), handler: *TypedEventHandler(WebView,WebViewUnsupportedUriSchemeIdentifiedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_UnsupportedUriSchemeIdentified(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeUnsupportedUriSchemeIdentified(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_UnsupportedUriSchemeIdentified(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addNewWindowRequested(self: *@This(), handler: *TypedEventHandler(WebView,WebViewNewWindowRequestedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_NewWindowRequested(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeNewWindowRequested(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_NewWindowRequested(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn addPermissionRequested(self: *@This(), handler: *TypedEventHandler(WebView,WebViewPermissionRequestedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_PermissionRequested(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removePermissionRequested(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_PermissionRequested(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn AddWebAllowedObject(self: *@This(), name: HSTRING, pObject: *IInspectable) core.HResult!void {
        const _c = self.vtable.AddWebAllowedObject(@ptrCast(self), name, pObject);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn DeferredPermissionRequestById(self: *@This(), id: u32) core.HResult!*WebViewDeferredPermissionRequest {
        var _r: *WebViewDeferredPermissionRequest = undefined;
        const _c = self.vtable.DeferredPermissionRequestById(@ptrCast(self), id, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebView4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e28243bc-67f3-462a-b4e0-3bbf6c3dab0b";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ExecutionMode: *const fn(self: *anyopaque, _r: *WebViewExecutionMode) callconv(.winapi) HRESULT,
        get_DeferredPermissionRequests: *const fn(self: *anyopaque, _r: **IVector(WebViewDeferredPermissionRequest)) callconv(.winapi) HRESULT,
        get_Settings: *const fn(self: *anyopaque, _r: **WebViewSettings) callconv(.winapi) HRESULT,
        add_UnsupportedUriSchemeIdentified: *const fn(self: *anyopaque, handler: *TypedEventHandler(WebView,WebViewUnsupportedUriSchemeIdentifiedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_UnsupportedUriSchemeIdentified: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_NewWindowRequested: *const fn(self: *anyopaque, handler: *TypedEventHandler(WebView,WebViewNewWindowRequestedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_NewWindowRequested: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        add_PermissionRequested: *const fn(self: *anyopaque, handler: *TypedEventHandler(WebView,WebViewPermissionRequestedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_PermissionRequested: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
        AddWebAllowedObject: *const fn(self: *anyopaque, name: HSTRING, pObject: *IInspectable) callconv(.winapi) HRESULT,
        DeferredPermissionRequestById: *const fn(self: *anyopaque, id: u32, _r: **WebViewDeferredPermissionRequest) callconv(.winapi) HRESULT,
    };
};
pub const IWebView5 = extern struct {
    vtable: *const VTable,
    pub fn getXYFocusLeft(self: *@This()) core.HResult!*DependencyObject {
        var _r: *DependencyObject = undefined;
        const _c = self.vtable.get_XYFocusLeft(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putXYFocusLeft(self: *@This(), value: *DependencyObject) core.HResult!void {
        const _c = self.vtable.put_XYFocusLeft(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getXYFocusRight(self: *@This()) core.HResult!*DependencyObject {
        var _r: *DependencyObject = undefined;
        const _c = self.vtable.get_XYFocusRight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putXYFocusRight(self: *@This(), value: *DependencyObject) core.HResult!void {
        const _c = self.vtable.put_XYFocusRight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getXYFocusUp(self: *@This()) core.HResult!*DependencyObject {
        var _r: *DependencyObject = undefined;
        const _c = self.vtable.get_XYFocusUp(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putXYFocusUp(self: *@This(), value: *DependencyObject) core.HResult!void {
        const _c = self.vtable.put_XYFocusUp(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getXYFocusDown(self: *@This()) core.HResult!*DependencyObject {
        var _r: *DependencyObject = undefined;
        const _c = self.vtable.get_XYFocusDown(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putXYFocusDown(self: *@This(), value: *DependencyObject) core.HResult!void {
        const _c = self.vtable.put_XYFocusDown(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebView5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8c9884a6-2f3b-4a55-a463-8444c2095d00";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_XYFocusLeft: *const fn(self: *anyopaque, _r: **DependencyObject) callconv(.winapi) HRESULT,
        put_XYFocusLeft: *const fn(self: *anyopaque, value: *DependencyObject) callconv(.winapi) HRESULT,
        get_XYFocusRight: *const fn(self: *anyopaque, _r: **DependencyObject) callconv(.winapi) HRESULT,
        put_XYFocusRight: *const fn(self: *anyopaque, value: *DependencyObject) callconv(.winapi) HRESULT,
        get_XYFocusUp: *const fn(self: *anyopaque, _r: **DependencyObject) callconv(.winapi) HRESULT,
        put_XYFocusUp: *const fn(self: *anyopaque, value: *DependencyObject) callconv(.winapi) HRESULT,
        get_XYFocusDown: *const fn(self: *anyopaque, _r: **DependencyObject) callconv(.winapi) HRESULT,
        put_XYFocusDown: *const fn(self: *anyopaque, value: *DependencyObject) callconv(.winapi) HRESULT,
    };
};
pub const IWebView6 = extern struct {
    vtable: *const VTable,
    pub fn addSeparateProcessLost(self: *@This(), handler: *TypedEventHandler(WebView,WebViewSeparateProcessLostEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_SeparateProcessLost(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeSeparateProcessLost(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_SeparateProcessLost(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebView6";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "38ccd942-2536-467c-a211-af359c3b4fda";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        add_SeparateProcessLost: *const fn(self: *anyopaque, handler: *TypedEventHandler(WebView,WebViewSeparateProcessLostEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_SeparateProcessLost: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IWebView7 = extern struct {
    vtable: *const VTable,
    pub fn addWebResourceRequested(self: *@This(), handler: *TypedEventHandler(WebView,WebViewWebResourceRequestedEventArgs)) core.HResult!EventRegistrationToken {
        var _r: EventRegistrationToken = undefined;
        const _c = self.vtable.add_WebResourceRequested(@ptrCast(self), handler, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn removeWebResourceRequested(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const _c = self.vtable.remove_WebResourceRequested(@ptrCast(self), token);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebView7";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "27707c2b-042f-5353-9021-55cd06585fdf";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        add_WebResourceRequested: *const fn(self: *anyopaque, handler: *TypedEventHandler(WebView,WebViewWebResourceRequestedEventArgs), _r: *EventRegistrationToken) callconv(.winapi) HRESULT,
        remove_WebResourceRequested: *const fn(self: *anyopaque, token: EventRegistrationToken) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewBrush = extern struct {
    vtable: *const VTable,
    pub fn getSourceName(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_SourceName(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putSourceName(self: *@This(), value: HSTRING) core.HResult!void {
        const _c = self.vtable.put_SourceName(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Redraw(self: *@This()) core.HResult!void {
        const _c = self.vtable.Redraw(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn SetSource(self: *@This(), source: *WebView) core.HResult!void {
        const _c = self.vtable.SetSource(@ptrCast(self), source);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewBrush";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "40e86f75-0cf4-4b72-a4d6-cf5d15780116";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SourceName: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
        put_SourceName: *const fn(self: *anyopaque, value: HSTRING) callconv(.winapi) HRESULT,
        Redraw: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        SetSource: *const fn(self: *anyopaque, source: *WebView) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewBrushStatics = extern struct {
    vtable: *const VTable,
    pub fn getSourceNameProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SourceNameProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewBrushStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d74daa24-1d05-463e-b028-6baa4420e762";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_SourceNameProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewContentLoadingEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getUri(self: *@This()) core.HResult!*Uri {
        var _r: *Uri = undefined;
        const _c = self.vtable.get_Uri(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewContentLoadingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6e2980bb-98b8-413e-8129-971c6f7e4c8a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Uri: *const fn(self: *anyopaque, _r: **Uri) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewDOMContentLoadedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getUri(self: *@This()) core.HResult!*Uri {
        var _r: *Uri = undefined;
        const _c = self.vtable.get_Uri(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewDOMContentLoadedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c47eba15-dc6b-4b36-9d80-82fb8817b988";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Uri: *const fn(self: *anyopaque, _r: **Uri) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewDeferredPermissionRequest = extern struct {
    vtable: *const VTable,
    pub fn getUri(self: *@This()) core.HResult!*Uri {
        var _r: *Uri = undefined;
        const _c = self.vtable.get_Uri(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPermissionType(self: *@This()) core.HResult!WebViewPermissionType {
        var _r: WebViewPermissionType = undefined;
        const _c = self.vtable.get_PermissionType(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getId(self: *@This()) core.HResult!u32 {
        var _r: u32 = undefined;
        const _c = self.vtable.get_Id(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn Allow(self: *@This()) core.HResult!void {
        const _c = self.vtable.Allow(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Deny(self: *@This()) core.HResult!void {
        const _c = self.vtable.Deny(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewDeferredPermissionRequest";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a3dcc461-7350-4d3a-8fb9-40eeec2746c2";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Uri: *const fn(self: *anyopaque, _r: **Uri) callconv(.winapi) HRESULT,
        get_PermissionType: *const fn(self: *anyopaque, _r: *WebViewPermissionType) callconv(.winapi) HRESULT,
        get_Id: *const fn(self: *anyopaque, _r: *u32) callconv(.winapi) HRESULT,
        Allow: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        Deny: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewFactory4 = extern struct {
    vtable: *const VTable,
    pub fn CreateInstanceWithExecutionMode(self: *@This(), executionMode: WebViewExecutionMode) core.HResult!*WebView {
        var _r: *WebView = undefined;
        const _c = self.vtable.CreateInstanceWithExecutionMode(@ptrCast(self), executionMode, &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewFactory4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "82edac58-ee6a-4c9b-a3a0-9347a7d0ef4c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        CreateInstanceWithExecutionMode: *const fn(self: *anyopaque, executionMode: WebViewExecutionMode, _r: **WebView) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewLongRunningScriptDetectedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getExecutionTime(self: *@This()) core.HResult!TimeSpan {
        var _r: TimeSpan = undefined;
        const _c = self.vtable.get_ExecutionTime(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getStopPageScriptExecution(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_StopPageScriptExecution(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putStopPageScriptExecution(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_StopPageScriptExecution(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewLongRunningScriptDetectedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "f3f020ab-a46c-42b0-9efe-69764d5cffa6";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ExecutionTime: *const fn(self: *anyopaque, _r: *TimeSpan) callconv(.winapi) HRESULT,
        get_StopPageScriptExecution: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_StopPageScriptExecution: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewNavigationCompletedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getUri(self: *@This()) core.HResult!*Uri {
        var _r: *Uri = undefined;
        const _c = self.vtable.get_Uri(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getIsSuccess(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsSuccess(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getWebErrorStatus(self: *@This()) core.HResult!WebErrorStatus {
        var _r: WebErrorStatus = undefined;
        const _c = self.vtable.get_WebErrorStatus(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewNavigationCompletedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "11e6f20b-eba7-44c0-889b-edeb6a064ddd";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Uri: *const fn(self: *anyopaque, _r: **Uri) callconv(.winapi) HRESULT,
        get_IsSuccess: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        get_WebErrorStatus: *const fn(self: *anyopaque, _r: *WebErrorStatus) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewNavigationFailedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getUri(self: *@This()) core.HResult!*Uri {
        var _r: *Uri = undefined;
        const _c = self.vtable.get_Uri(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getWebErrorStatus(self: *@This()) core.HResult!WebErrorStatus {
        var _r: WebErrorStatus = undefined;
        const _c = self.vtable.get_WebErrorStatus(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewNavigationFailedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "af09609a-129c-4170-9e9c-e2cdf025dca4";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Uri: *const fn(self: *anyopaque, _r: **Uri) callconv(.winapi) HRESULT,
        get_WebErrorStatus: *const fn(self: *anyopaque, _r: *WebErrorStatus) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewNavigationStartingEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getUri(self: *@This()) core.HResult!*Uri {
        var _r: *Uri = undefined;
        const _c = self.vtable.get_Uri(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCancel(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_Cancel(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putCancel(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_Cancel(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewNavigationStartingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "94cb8668-8367-43d5-91bb-96eba37ec784";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Uri: *const fn(self: *anyopaque, _r: **Uri) callconv(.winapi) HRESULT,
        get_Cancel: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_Cancel: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewNewWindowRequestedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getUri(self: *@This()) core.HResult!*Uri {
        var _r: *Uri = undefined;
        const _c = self.vtable.get_Uri(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getReferrer(self: *@This()) core.HResult!*Uri {
        var _r: *Uri = undefined;
        const _c = self.vtable.get_Referrer(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHandled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_Handled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHandled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_Handled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewNewWindowRequestedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "470fa818-6862-44d9-b3d1-c0696373de35";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Uri: *const fn(self: *anyopaque, _r: **Uri) callconv(.winapi) HRESULT,
        get_Referrer: *const fn(self: *anyopaque, _r: **Uri) callconv(.winapi) HRESULT,
        get_Handled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_Handled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewPermissionRequest = extern struct {
    vtable: *const VTable,
    pub fn getUri(self: *@This()) core.HResult!*Uri {
        var _r: *Uri = undefined;
        const _c = self.vtable.get_Uri(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getPermissionType(self: *@This()) core.HResult!WebViewPermissionType {
        var _r: WebViewPermissionType = undefined;
        const _c = self.vtable.get_PermissionType(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getId(self: *@This()) core.HResult!u32 {
        var _r: u32 = undefined;
        const _c = self.vtable.get_Id(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getState(self: *@This()) core.HResult!WebViewPermissionState {
        var _r: WebViewPermissionState = undefined;
        const _c = self.vtable.get_State(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn Defer(self: *@This()) core.HResult!void {
        const _c = self.vtable.Defer(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Allow(self: *@This()) core.HResult!void {
        const _c = self.vtable.Allow(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn Deny(self: *@This()) core.HResult!void {
        const _c = self.vtable.Deny(@ptrCast(self));
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewPermissionRequest";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "17b76332-66c4-4131-999e-df7de20a8c9c";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Uri: *const fn(self: *anyopaque, _r: **Uri) callconv(.winapi) HRESULT,
        get_PermissionType: *const fn(self: *anyopaque, _r: *WebViewPermissionType) callconv(.winapi) HRESULT,
        get_Id: *const fn(self: *anyopaque, _r: *u32) callconv(.winapi) HRESULT,
        get_State: *const fn(self: *anyopaque, _r: *WebViewPermissionState) callconv(.winapi) HRESULT,
        Defer: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        Allow: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
        Deny: *const fn(self: *anyopaque) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewPermissionRequestedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getPermissionRequest(self: *@This()) core.HResult!*WebViewPermissionRequest {
        var _r: *WebViewPermissionRequest = undefined;
        const _c = self.vtable.get_PermissionRequest(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewPermissionRequestedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "dadecfd0-6e1e-473f-b0be-b02404d6a86d";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_PermissionRequest: *const fn(self: *anyopaque, _r: **WebViewPermissionRequest) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewSeparateProcessLostEventArgs = extern struct {
    vtable: *const VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewSeparateProcessLostEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a405700a-c482-40b5-aaea-e10cfa9f5abe";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewSettings = extern struct {
    vtable: *const VTable,
    pub fn getIsJavaScriptEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsJavaScriptEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsJavaScriptEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsJavaScriptEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getIsIndexedDBEnabled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_IsIndexedDBEnabled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putIsIndexedDBEnabled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_IsIndexedDBEnabled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewSettings";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1d50ad4d-abf6-4785-8df3-fdebc1270301";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_IsJavaScriptEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsJavaScriptEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
        get_IsIndexedDBEnabled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_IsIndexedDBEnabled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewStatics = extern struct {
    vtable: *const VTable,
    pub fn getAnyScriptNotifyUri(self: *@This()) core.HResult!*IVector(Uri) {
        var _r: *IVector(Uri) = undefined;
        const _c = self.vtable.get_AnyScriptNotifyUri(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getSourceProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_SourceProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getAllowedScriptNotifyUrisProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_AllowedScriptNotifyUrisProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDataTransferPackageProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DataTransferPackageProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a0b561de-5fdb-443b-b9f0-5c30f6b7a1f4";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_AnyScriptNotifyUri: *const fn(self: *anyopaque, _r: **IVector(Uri)) callconv(.winapi) HRESULT,
        get_SourceProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_AllowedScriptNotifyUrisProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DataTransferPackageProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewStatics2 = extern struct {
    vtable: *const VTable,
    pub fn getCanGoBackProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CanGoBackProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getCanGoForwardProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_CanGoForwardProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDocumentTitleProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DocumentTitleProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getDefaultBackgroundColorProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_DefaultBackgroundColorProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewStatics2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "322f8780-e812-466b-9e50-8e9fec24018a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_CanGoBackProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_CanGoForwardProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DocumentTitleProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_DefaultBackgroundColorProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewStatics3 = extern struct {
    vtable: *const VTable,
    pub fn getContainsFullScreenElementProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ContainsFullScreenElementProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewStatics3";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "129bef8a-4509-4374-b0d1-a7104d0c3a2f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ContainsFullScreenElementProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewStatics4 = extern struct {
    vtable: *const VTable,
    pub fn getDefaultExecutionMode(self: *@This()) core.HResult!WebViewExecutionMode {
        var _r: WebViewExecutionMode = undefined;
        const _c = self.vtable.get_DefaultExecutionMode(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn ClearTemporaryWebDataAsync(self: *@This()) core.HResult!*IAsyncAction {
        var _r: *IAsyncAction = undefined;
        const _c = self.vtable.ClearTemporaryWebDataAsync(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewStatics4";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "44b197b0-b746-40f3-9936-4ebbff6b47b8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_DefaultExecutionMode: *const fn(self: *anyopaque, _r: *WebViewExecutionMode) callconv(.winapi) HRESULT,
        ClearTemporaryWebDataAsync: *const fn(self: *anyopaque, _r: **IAsyncAction) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewStatics5 = extern struct {
    vtable: *const VTable,
    pub fn getXYFocusLeftProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_XYFocusLeftProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getXYFocusRightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_XYFocusRightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getXYFocusUpProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_XYFocusUpProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getXYFocusDownProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_XYFocusDownProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewStatics5";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "08a0b8d1-508a-4db8-97ef-0fa505e19ec2";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_XYFocusLeftProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_XYFocusRightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_XYFocusUpProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_XYFocusDownProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewUnsupportedUriSchemeIdentifiedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getUri(self: *@This()) core.HResult!*Uri {
        var _r: *Uri = undefined;
        const _c = self.vtable.get_Uri(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHandled(self: *@This()) core.HResult!bool {
        var _r: bool = undefined;
        const _c = self.vtable.get_Handled(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHandled(self: *@This(), value: bool) core.HResult!void {
        const _c = self.vtable.put_Handled(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewUnsupportedUriSchemeIdentifiedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "b9c9e1a7-620f-4895-935d-10fbac6fd29e";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Uri: *const fn(self: *anyopaque, _r: **Uri) callconv(.winapi) HRESULT,
        get_Handled: *const fn(self: *anyopaque, _r: *bool) callconv(.winapi) HRESULT,
        put_Handled: *const fn(self: *anyopaque, value: bool) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewUnviewableContentIdentifiedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getUri(self: *@This()) core.HResult!*Uri {
        var _r: *Uri = undefined;
        const _c = self.vtable.get_Uri(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getReferrer(self: *@This()) core.HResult!*Uri {
        var _r: *Uri = undefined;
        const _c = self.vtable.get_Referrer(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewUnviewableContentIdentifiedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "37bc16e1-6062-4678-b20b-6c36ac9c59ac";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Uri: *const fn(self: *anyopaque, _r: **Uri) callconv(.winapi) HRESULT,
        get_Referrer: *const fn(self: *anyopaque, _r: **Uri) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewUnviewableContentIdentifiedEventArgs2 = extern struct {
    vtable: *const VTable,
    pub fn getMediaType(self: *@This()) core.HResult!HSTRING {
        var _r: HSTRING = undefined;
        const _c = self.vtable.get_MediaType(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewUnviewableContentIdentifiedEventArgs2";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "9abe1154-36f0-4268-8d88-121eedf45e6a";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_MediaType: *const fn(self: *anyopaque, _r: *HSTRING) callconv(.winapi) HRESULT,
    };
};
pub const IWebViewWebResourceRequestedEventArgs = extern struct {
    vtable: *const VTable,
    pub fn getRequest(self: *@This()) core.HResult!*HttpRequestMessage {
        var _r: *HttpRequestMessage = undefined;
        const _c = self.vtable.get_Request(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getResponse(self: *@This()) core.HResult!*HttpResponseMessage {
        var _r: *HttpResponseMessage = undefined;
        const _c = self.vtable.get_Response(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putResponse(self: *@This(), value: *HttpResponseMessage) core.HResult!void {
        const _c = self.vtable.put_Response(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn GetDeferral(self: *@This()) core.HResult!*Deferral {
        var _r: *Deferral = undefined;
        const _c = self.vtable.GetDeferral(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWebViewWebResourceRequestedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "378d21f6-c77f-5d8b-8f30-93c99df79435";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_Request: *const fn(self: *anyopaque, _r: **HttpRequestMessage) callconv(.winapi) HRESULT,
        get_Response: *const fn(self: *anyopaque, _r: **HttpResponseMessage) callconv(.winapi) HRESULT,
        put_Response: *const fn(self: *anyopaque, value: *HttpResponseMessage) callconv(.winapi) HRESULT,
        GetDeferral: *const fn(self: *anyopaque, _r: **Deferral) callconv(.winapi) HRESULT,
    };
};
pub const IWrapGrid = extern struct {
    vtable: *const VTable,
    pub fn getItemWidth(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_ItemWidth(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemWidth(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_ItemWidth(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getItemHeight(self: *@This()) core.HResult!f64 {
        var _r: f64 = undefined;
        const _c = self.vtable.get_ItemHeight(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putItemHeight(self: *@This(), value: f64) core.HResult!void {
        const _c = self.vtable.put_ItemHeight(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getOrientation(self: *@This()) core.HResult!Orientation {
        var _r: Orientation = undefined;
        const _c = self.vtable.get_Orientation(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putOrientation(self: *@This(), value: Orientation) core.HResult!void {
        const _c = self.vtable.put_Orientation(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getHorizontalChildrenAlignment(self: *@This()) core.HResult!HorizontalAlignment {
        var _r: HorizontalAlignment = undefined;
        const _c = self.vtable.get_HorizontalChildrenAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putHorizontalChildrenAlignment(self: *@This(), value: HorizontalAlignment) core.HResult!void {
        const _c = self.vtable.put_HorizontalChildrenAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getVerticalChildrenAlignment(self: *@This()) core.HResult!VerticalAlignment {
        var _r: VerticalAlignment = undefined;
        const _c = self.vtable.get_VerticalChildrenAlignment(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putVerticalChildrenAlignment(self: *@This(), value: VerticalAlignment) core.HResult!void {
        const _c = self.vtable.put_VerticalChildrenAlignment(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub fn getMaximumRowsOrColumns(self: *@This()) core.HResult!i32 {
        var _r: i32 = undefined;
        const _c = self.vtable.get_MaximumRowsOrColumns(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn putMaximumRowsOrColumns(self: *@This(), value: i32) core.HResult!void {
        const _c = self.vtable.put_MaximumRowsOrColumns(@ptrCast(self), value);
        if (_c != 0) return core.hresultToError(_c).err;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWrapGrid";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "0552178b-7567-47c2-bd5c-ad8394c828ba";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ItemWidth: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_ItemWidth: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_ItemHeight: *const fn(self: *anyopaque, _r: *f64) callconv(.winapi) HRESULT,
        put_ItemHeight: *const fn(self: *anyopaque, value: f64) callconv(.winapi) HRESULT,
        get_Orientation: *const fn(self: *anyopaque, _r: *Orientation) callconv(.winapi) HRESULT,
        put_Orientation: *const fn(self: *anyopaque, value: Orientation) callconv(.winapi) HRESULT,
        get_HorizontalChildrenAlignment: *const fn(self: *anyopaque, _r: *HorizontalAlignment) callconv(.winapi) HRESULT,
        put_HorizontalChildrenAlignment: *const fn(self: *anyopaque, value: HorizontalAlignment) callconv(.winapi) HRESULT,
        get_VerticalChildrenAlignment: *const fn(self: *anyopaque, _r: *VerticalAlignment) callconv(.winapi) HRESULT,
        put_VerticalChildrenAlignment: *const fn(self: *anyopaque, value: VerticalAlignment) callconv(.winapi) HRESULT,
        get_MaximumRowsOrColumns: *const fn(self: *anyopaque, _r: *i32) callconv(.winapi) HRESULT,
        put_MaximumRowsOrColumns: *const fn(self: *anyopaque, value: i32) callconv(.winapi) HRESULT,
    };
};
pub const IWrapGridStatics = extern struct {
    vtable: *const VTable,
    pub fn getItemWidthProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemWidthProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getItemHeightProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_ItemHeightProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getOrientationProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_OrientationProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getHorizontalChildrenAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_HorizontalChildrenAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getVerticalChildrenAlignmentProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_VerticalChildrenAlignmentProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub fn getMaximumRowsOrColumnsProperty(self: *@This()) core.HResult!*DependencyProperty {
        var _r: *DependencyProperty = undefined;
        const _c = self.vtable.get_MaximumRowsOrColumnsProperty(@ptrCast(self), &_r);
        if (_c != 0) return core.hresultToError(_c).err;
        return _r;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IWrapGridStatics";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d04a6b97-13cb-479c-a285-e4e56846c4cb";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.interface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        GetIids: *const fn(self: *anyopaque, iidCount: *u32, iids: *[*]Guid) callconv(.winapi) HRESULT,
        GetRuntimeClassName: *const fn(self: *anyopaque, className: *HSTRING) callconv(.winapi) HRESULT,
        GetTrustLevel: *const fn(self: *anyopaque, trustLevel: *TrustLevel) callconv(.winapi) HRESULT,
        get_ItemWidthProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_ItemHeightProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_OrientationProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_HorizontalChildrenAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_VerticalChildrenAlignmentProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
        get_MaximumRowsOrColumnsProperty: *const fn(self: *anyopaque, _r: **DependencyProperty) callconv(.winapi) HRESULT,
    };
};
pub const IconSourceElement = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIconSource(self: *@This()) core.HResult!*IconSource {
        const this: *IIconSourceElement = @ptrCast(self);
        return try this.getIconSource();
    }
    pub fn putIconSource(self: *@This(), value: *IconSource) core.HResult!void {
        const this: *IIconSourceElement = @ptrCast(self);
        return try this.putIconSource(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getIconSourceProperty() core.HResult!*DependencyProperty {
        const _f = @This().IIconSourceElementStaticsCache.get();
        return try _f.getIconSourceProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*IconSourceElement {
        const _f = @This().IIconSourceElementFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IconSourceElement";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IIconSourceElement.GUID;
    pub const IID: Guid = IIconSourceElement.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IIconSourceElement.SIGNATURE);
    var _IIconSourceElementStaticsCache: FactoryCache(IIconSourceElementStatics, RUNTIME_NAME) = .{};
    var _IIconSourceElementFactoryCache: FactoryCache(IIconSourceElementFactory, RUNTIME_NAME) = .{};
};
pub const Image = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getSource(self: *@This()) core.HResult!*ImageSource {
        const this: *IImage = @ptrCast(self);
        return try this.getSource();
    }
    pub fn putSource(self: *@This(), value: *ImageSource) core.HResult!void {
        const this: *IImage = @ptrCast(self);
        return try this.putSource(value);
    }
    pub fn getStretch(self: *@This()) core.HResult!Stretch {
        const this: *IImage = @ptrCast(self);
        return try this.getStretch();
    }
    pub fn putStretch(self: *@This(), value: Stretch) core.HResult!void {
        const this: *IImage = @ptrCast(self);
        return try this.putStretch(value);
    }
    pub fn getNineGrid(self: *@This()) core.HResult!Thickness {
        const this: *IImage = @ptrCast(self);
        return try this.getNineGrid();
    }
    pub fn putNineGrid(self: *@This(), value: Thickness) core.HResult!void {
        const this: *IImage = @ptrCast(self);
        return try this.putNineGrid(value);
    }
    pub fn getPlayToSource(self: *@This()) core.HResult!*PlayToSource {
        const this: *IImage = @ptrCast(self);
        return try this.getPlayToSource();
    }
    pub fn addImageFailed(self: *@This(), handler: *ExceptionRoutedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IImage = @ptrCast(self);
        return try this.addImageFailed(handler);
    }
    pub fn removeImageFailed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IImage = @ptrCast(self);
        return try this.removeImageFailed(token);
    }
    pub fn addImageOpened(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IImage = @ptrCast(self);
        return try this.addImageOpened(handler);
    }
    pub fn removeImageOpened(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IImage = @ptrCast(self);
        return try this.removeImageOpened(token);
    }
    pub fn GetAsCastingSource(self: *@This()) core.HResult!*CastingSource {
        var this: ?*IImage2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IImage2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GetAsCastingSource();
    }
    pub fn GetAlphaMask(self: *@This()) core.HResult!*CompositionBrush {
        var this: ?*IImage3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IImage3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GetAlphaMask();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IImage.IID)));
    }
    pub fn getSourceProperty() core.HResult!*DependencyProperty {
        const _f = @This().IImageStaticsCache.get();
        return try _f.getSourceProperty();
    }
    pub fn getStretchProperty() core.HResult!*DependencyProperty {
        const _f = @This().IImageStaticsCache.get();
        return try _f.getStretchProperty();
    }
    pub fn getNineGridProperty() core.HResult!*DependencyProperty {
        const _f = @This().IImageStaticsCache.get();
        return try _f.getNineGridProperty();
    }
    pub fn getPlayToSourceProperty() core.HResult!*DependencyProperty {
        const _f = @This().IImageStaticsCache.get();
        return try _f.getPlayToSourceProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.Image";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IImage.GUID;
    pub const IID: Guid = IImage.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IImage.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IImageStaticsCache: FactoryCache(IImageStatics, RUNTIME_NAME) = .{};
};
pub const IncrementalLoadingTrigger = enum(i32) {
    None = 0,
    Edge = 1,
};
pub const InkCanvas = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getInkPresenter(self: *@This()) core.HResult!*InkPresenter {
        const this: *IInkCanvas = @ptrCast(self);
        return try this.getInkPresenter();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkCanvas {
        const _f = @This().IInkCanvasFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.InkCanvas";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IInkCanvas.GUID;
    pub const IID: Guid = IInkCanvas.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IInkCanvas.SIGNATURE);
    var _IInkCanvasFactoryCache: FactoryCache(IInkCanvasFactory, RUNTIME_NAME) = .{};
};
pub const InkToolbar = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getInitialControls(self: *@This()) core.HResult!InkToolbarInitialControls {
        const this: *IInkToolbar = @ptrCast(self);
        return try this.getInitialControls();
    }
    pub fn putInitialControls(self: *@This(), value: InkToolbarInitialControls) core.HResult!void {
        const this: *IInkToolbar = @ptrCast(self);
        return try this.putInitialControls(value);
    }
    pub fn getChildren(self: *@This()) core.HResult!*DependencyObjectCollection {
        const this: *IInkToolbar = @ptrCast(self);
        return try this.getChildren();
    }
    pub fn getActiveTool(self: *@This()) core.HResult!*InkToolbarToolButton {
        const this: *IInkToolbar = @ptrCast(self);
        return try this.getActiveTool();
    }
    pub fn putActiveTool(self: *@This(), value: *InkToolbarToolButton) core.HResult!void {
        const this: *IInkToolbar = @ptrCast(self);
        return try this.putActiveTool(value);
    }
    pub fn getInkDrawingAttributes(self: *@This()) core.HResult!*InkDrawingAttributes {
        const this: *IInkToolbar = @ptrCast(self);
        return try this.getInkDrawingAttributes();
    }
    pub fn getIsRulerButtonChecked(self: *@This()) core.HResult!bool {
        const this: *IInkToolbar = @ptrCast(self);
        return try this.getIsRulerButtonChecked();
    }
    pub fn putIsRulerButtonChecked(self: *@This(), value: bool) core.HResult!void {
        const this: *IInkToolbar = @ptrCast(self);
        return try this.putIsRulerButtonChecked(value);
    }
    pub fn getTargetInkCanvas(self: *@This()) core.HResult!*InkCanvas {
        const this: *IInkToolbar = @ptrCast(self);
        return try this.getTargetInkCanvas();
    }
    pub fn putTargetInkCanvas(self: *@This(), value: *InkCanvas) core.HResult!void {
        const this: *IInkToolbar = @ptrCast(self);
        return try this.putTargetInkCanvas(value);
    }
    pub fn addActiveToolChanged(self: *@This(), handler: *TypedEventHandler(InkToolbar,IInspectable)) core.HResult!EventRegistrationToken {
        const this: *IInkToolbar = @ptrCast(self);
        return try this.addActiveToolChanged(handler);
    }
    pub fn removeActiveToolChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IInkToolbar = @ptrCast(self);
        return try this.removeActiveToolChanged(token);
    }
    pub fn addInkDrawingAttributesChanged(self: *@This(), handler: *TypedEventHandler(InkToolbar,IInspectable)) core.HResult!EventRegistrationToken {
        const this: *IInkToolbar = @ptrCast(self);
        return try this.addInkDrawingAttributesChanged(handler);
    }
    pub fn removeInkDrawingAttributesChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IInkToolbar = @ptrCast(self);
        return try this.removeInkDrawingAttributesChanged(token);
    }
    pub fn addEraseAllClicked(self: *@This(), handler: *TypedEventHandler(InkToolbar,IInspectable)) core.HResult!EventRegistrationToken {
        const this: *IInkToolbar = @ptrCast(self);
        return try this.addEraseAllClicked(handler);
    }
    pub fn removeEraseAllClicked(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IInkToolbar = @ptrCast(self);
        return try this.removeEraseAllClicked(token);
    }
    pub fn addIsRulerButtonCheckedChanged(self: *@This(), handler: *TypedEventHandler(InkToolbar,IInspectable)) core.HResult!EventRegistrationToken {
        const this: *IInkToolbar = @ptrCast(self);
        return try this.addIsRulerButtonCheckedChanged(handler);
    }
    pub fn removeIsRulerButtonCheckedChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IInkToolbar = @ptrCast(self);
        return try this.removeIsRulerButtonCheckedChanged(token);
    }
    pub fn GetToolButton(self: *@This(), tool: InkToolbarTool) core.HResult!*InkToolbarToolButton {
        const this: *IInkToolbar = @ptrCast(self);
        return try this.GetToolButton(tool);
    }
    pub fn GetToggleButton(self: *@This(), tool: InkToolbarToggle) core.HResult!*InkToolbarToggleButton {
        const this: *IInkToolbar = @ptrCast(self);
        return try this.GetToggleButton(tool);
    }
    pub fn getIsStencilButtonChecked(self: *@This()) core.HResult!bool {
        var this: ?*IInkToolbar2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IInkToolbar2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsStencilButtonChecked();
    }
    pub fn putIsStencilButtonChecked(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IInkToolbar2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IInkToolbar2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsStencilButtonChecked(value);
    }
    pub fn getButtonFlyoutPlacement(self: *@This()) core.HResult!InkToolbarButtonFlyoutPlacement {
        var this: ?*IInkToolbar2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IInkToolbar2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getButtonFlyoutPlacement();
    }
    pub fn putButtonFlyoutPlacement(self: *@This(), value: InkToolbarButtonFlyoutPlacement) core.HResult!void {
        var this: ?*IInkToolbar2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IInkToolbar2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putButtonFlyoutPlacement(value);
    }
    pub fn getOrientation(self: *@This()) core.HResult!Orientation {
        var this: ?*IInkToolbar2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IInkToolbar2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getOrientation();
    }
    pub fn putOrientation(self: *@This(), value: Orientation) core.HResult!void {
        var this: ?*IInkToolbar2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IInkToolbar2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putOrientation(value);
    }
    pub fn addIsStencilButtonCheckedChanged(self: *@This(), handler: *TypedEventHandler(InkToolbar,InkToolbarIsStencilButtonCheckedChangedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IInkToolbar2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IInkToolbar2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addIsStencilButtonCheckedChanged(handler);
    }
    pub fn removeIsStencilButtonCheckedChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IInkToolbar2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IInkToolbar2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeIsStencilButtonCheckedChanged(token);
    }
    pub fn GetMenuButton(self: *@This(), menu: InkToolbarMenuKind) core.HResult!*InkToolbarMenuButton {
        var this: ?*IInkToolbar2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IInkToolbar2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GetMenuButton(menu);
    }
    pub fn getTargetInkPresenter(self: *@This()) core.HResult!*InkPresenter {
        var this: ?*IInkToolbar3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IInkToolbar3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTargetInkPresenter();
    }
    pub fn putTargetInkPresenter(self: *@This(), value: *InkPresenter) core.HResult!void {
        var this: ?*IInkToolbar3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IInkToolbar3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTargetInkPresenter(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getTargetInkPresenterProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarStatics3Cache.get();
        return try _f.getTargetInkPresenterProperty();
    }
    pub fn getIsStencilButtonCheckedProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarStatics2Cache.get();
        return try _f.getIsStencilButtonCheckedProperty();
    }
    pub fn getButtonFlyoutPlacementProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarStatics2Cache.get();
        return try _f.getButtonFlyoutPlacementProperty();
    }
    pub fn getOrientationProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarStatics2Cache.get();
        return try _f.getOrientationProperty();
    }
    pub fn getInitialControlsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarStaticsCache.get();
        return try _f.getInitialControlsProperty();
    }
    pub fn getChildrenProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarStaticsCache.get();
        return try _f.getChildrenProperty();
    }
    pub fn getActiveToolProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarStaticsCache.get();
        return try _f.getActiveToolProperty();
    }
    pub fn getInkDrawingAttributesProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarStaticsCache.get();
        return try _f.getInkDrawingAttributesProperty();
    }
    pub fn getIsRulerButtonCheckedProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarStaticsCache.get();
        return try _f.getIsRulerButtonCheckedProperty();
    }
    pub fn getTargetInkCanvasProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarStaticsCache.get();
        return try _f.getTargetInkCanvasProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbar {
        const _f = @This().IInkToolbarFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.InkToolbar";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IInkToolbar.GUID;
    pub const IID: Guid = IInkToolbar.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IInkToolbar.SIGNATURE);
    var _IInkToolbarStatics3Cache: FactoryCache(IInkToolbarStatics3, RUNTIME_NAME) = .{};
    var _IInkToolbarStatics2Cache: FactoryCache(IInkToolbarStatics2, RUNTIME_NAME) = .{};
    var _IInkToolbarStaticsCache: FactoryCache(IInkToolbarStatics, RUNTIME_NAME) = .{};
    var _IInkToolbarFactoryCache: FactoryCache(IInkToolbarFactory, RUNTIME_NAME) = .{};
};
pub const RadioButton = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getGroupName(self: *@This()) core.HResult!HSTRING {
        const this: *IRadioButton = @ptrCast(self);
        return try this.getGroupName();
    }
    pub fn putGroupName(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IRadioButton = @ptrCast(self);
        return try this.putGroupName(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getGroupNameProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRadioButtonStaticsCache.get();
        return try _f.getGroupNameProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*RadioButton {
        const _f = @This().IRadioButtonFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.RadioButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IRadioButton.GUID;
    pub const IID: Guid = IRadioButton.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IRadioButton.SIGNATURE);
    var _IRadioButtonStaticsCache: FactoryCache(IRadioButtonStatics, RUNTIME_NAME) = .{};
    var _IRadioButtonFactoryCache: FactoryCache(IRadioButtonFactory, RUNTIME_NAME) = .{};
};
pub const InkToolbarToolButton = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getToolKind(self: *@This()) core.HResult!InkToolbarTool {
        const this: *IInkToolbarToolButton = @ptrCast(self);
        return try this.getToolKind();
    }
    pub fn getIsExtensionGlyphShown(self: *@This()) core.HResult!bool {
        const this: *IInkToolbarToolButton = @ptrCast(self);
        return try this.getIsExtensionGlyphShown();
    }
    pub fn putIsExtensionGlyphShown(self: *@This(), value: bool) core.HResult!void {
        const this: *IInkToolbarToolButton = @ptrCast(self);
        return try this.putIsExtensionGlyphShown(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getIsExtensionGlyphShownProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarToolButtonStaticsCache.get();
        return try _f.getIsExtensionGlyphShownProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.InkToolbarToolButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IInkToolbarToolButton.GUID;
    pub const IID: Guid = IInkToolbarToolButton.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IInkToolbarToolButton.SIGNATURE);
    var _IInkToolbarToolButtonStaticsCache: FactoryCache(IInkToolbarToolButtonStatics, RUNTIME_NAME) = .{};
    var _IInkToolbarToolButtonFactoryCache: FactoryCache(IInkToolbarToolButtonFactory, RUNTIME_NAME) = .{};
};
pub const InkToolbarPenButton = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getPalette(self: *@This()) core.HResult!*IVector(Brush) {
        const this: *IInkToolbarPenButton = @ptrCast(self);
        return try this.getPalette();
    }
    pub fn putPalette(self: *@This(), value: *IVector(Brush)) core.HResult!void {
        const this: *IInkToolbarPenButton = @ptrCast(self);
        return try this.putPalette(value);
    }
    pub fn getMinStrokeWidth(self: *@This()) core.HResult!f64 {
        const this: *IInkToolbarPenButton = @ptrCast(self);
        return try this.getMinStrokeWidth();
    }
    pub fn putMinStrokeWidth(self: *@This(), value: f64) core.HResult!void {
        const this: *IInkToolbarPenButton = @ptrCast(self);
        return try this.putMinStrokeWidth(value);
    }
    pub fn getMaxStrokeWidth(self: *@This()) core.HResult!f64 {
        const this: *IInkToolbarPenButton = @ptrCast(self);
        return try this.getMaxStrokeWidth();
    }
    pub fn putMaxStrokeWidth(self: *@This(), value: f64) core.HResult!void {
        const this: *IInkToolbarPenButton = @ptrCast(self);
        return try this.putMaxStrokeWidth(value);
    }
    pub fn getSelectedBrush(self: *@This()) core.HResult!*Brush {
        const this: *IInkToolbarPenButton = @ptrCast(self);
        return try this.getSelectedBrush();
    }
    pub fn getSelectedBrushIndex(self: *@This()) core.HResult!i32 {
        const this: *IInkToolbarPenButton = @ptrCast(self);
        return try this.getSelectedBrushIndex();
    }
    pub fn putSelectedBrushIndex(self: *@This(), value: i32) core.HResult!void {
        const this: *IInkToolbarPenButton = @ptrCast(self);
        return try this.putSelectedBrushIndex(value);
    }
    pub fn getSelectedStrokeWidth(self: *@This()) core.HResult!f64 {
        const this: *IInkToolbarPenButton = @ptrCast(self);
        return try this.getSelectedStrokeWidth();
    }
    pub fn putSelectedStrokeWidth(self: *@This(), value: f64) core.HResult!void {
        const this: *IInkToolbarPenButton = @ptrCast(self);
        return try this.putSelectedStrokeWidth(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getPaletteProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarPenButtonStaticsCache.get();
        return try _f.getPaletteProperty();
    }
    pub fn getMinStrokeWidthProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarPenButtonStaticsCache.get();
        return try _f.getMinStrokeWidthProperty();
    }
    pub fn getMaxStrokeWidthProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarPenButtonStaticsCache.get();
        return try _f.getMaxStrokeWidthProperty();
    }
    pub fn getSelectedBrushProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarPenButtonStaticsCache.get();
        return try _f.getSelectedBrushProperty();
    }
    pub fn getSelectedBrushIndexProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarPenButtonStaticsCache.get();
        return try _f.getSelectedBrushIndexProperty();
    }
    pub fn getSelectedStrokeWidthProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarPenButtonStaticsCache.get();
        return try _f.getSelectedStrokeWidthProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.InkToolbarPenButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IInkToolbarPenButton.GUID;
    pub const IID: Guid = IInkToolbarPenButton.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IInkToolbarPenButton.SIGNATURE);
    var _IInkToolbarPenButtonStaticsCache: FactoryCache(IInkToolbarPenButtonStatics, RUNTIME_NAME) = .{};
    var _IInkToolbarPenButtonFactoryCache: FactoryCache(IInkToolbarPenButtonFactory, RUNTIME_NAME) = .{};
};
pub const InkToolbarBallpointPenButton = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarBallpointPenButton {
        const _f = @This().IInkToolbarBallpointPenButtonFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.InkToolbarBallpointPenButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IInkToolbarBallpointPenButton.GUID;
    pub const IID: Guid = IInkToolbarBallpointPenButton.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IInkToolbarBallpointPenButton.SIGNATURE);
    var _IInkToolbarBallpointPenButtonFactoryCache: FactoryCache(IInkToolbarBallpointPenButtonFactory, RUNTIME_NAME) = .{};
};
pub const InkToolbarButtonFlyoutPlacement = enum(i32) {
    Auto = 0,
    Top = 1,
    Bottom = 2,
    Left = 3,
    Right = 4,
};
pub const InkToolbarCustomPen = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn CreateInkDrawingAttributes(self: *@This(), brush: *Brush, strokeWidth: f64) core.HResult!*InkDrawingAttributes {
        const this: *IInkToolbarCustomPen = @ptrCast(self);
        return try this.CreateInkDrawingAttributes(brush, strokeWidth);
    }
    pub fn CreateInkDrawingAttributesCore(self: *@This(), brush: *Brush, strokeWidth: f64) core.HResult!*InkDrawingAttributes {
        var this: ?*IInkToolbarCustomPenOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IInkToolbarCustomPenOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.CreateInkDrawingAttributesCore(brush, strokeWidth);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarCustomPen {
        const _f = @This().IInkToolbarCustomPenFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.InkToolbarCustomPen";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IInkToolbarCustomPen.GUID;
    pub const IID: Guid = IInkToolbarCustomPen.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IInkToolbarCustomPen.SIGNATURE);
    var _IInkToolbarCustomPenFactoryCache: FactoryCache(IInkToolbarCustomPenFactory, RUNTIME_NAME) = .{};
};
pub const InkToolbarCustomPenButton = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getCustomPen(self: *@This()) core.HResult!*InkToolbarCustomPen {
        const this: *IInkToolbarCustomPenButton = @ptrCast(self);
        return try this.getCustomPen();
    }
    pub fn putCustomPen(self: *@This(), value: *InkToolbarCustomPen) core.HResult!void {
        const this: *IInkToolbarCustomPenButton = @ptrCast(self);
        return try this.putCustomPen(value);
    }
    pub fn getConfigurationContent(self: *@This()) core.HResult!*UIElement {
        const this: *IInkToolbarCustomPenButton = @ptrCast(self);
        return try this.getConfigurationContent();
    }
    pub fn putConfigurationContent(self: *@This(), value: *UIElement) core.HResult!void {
        const this: *IInkToolbarCustomPenButton = @ptrCast(self);
        return try this.putConfigurationContent(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getCustomPenProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarCustomPenButtonStaticsCache.get();
        return try _f.getCustomPenProperty();
    }
    pub fn getConfigurationContentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarCustomPenButtonStaticsCache.get();
        return try _f.getConfigurationContentProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarCustomPenButton {
        const _f = @This().IInkToolbarCustomPenButtonFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.InkToolbarCustomPenButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IInkToolbarCustomPenButton.GUID;
    pub const IID: Guid = IInkToolbarCustomPenButton.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IInkToolbarCustomPenButton.SIGNATURE);
    var _IInkToolbarCustomPenButtonStaticsCache: FactoryCache(IInkToolbarCustomPenButtonStatics, RUNTIME_NAME) = .{};
    var _IInkToolbarCustomPenButtonFactoryCache: FactoryCache(IInkToolbarCustomPenButtonFactory, RUNTIME_NAME) = .{};
};
pub const InkToolbarToggleButton = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getToggleKind(self: *@This()) core.HResult!InkToolbarToggle {
        const this: *IInkToolbarToggleButton = @ptrCast(self);
        return try this.getToggleKind();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.InkToolbarToggleButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IInkToolbarToggleButton.GUID;
    pub const IID: Guid = IInkToolbarToggleButton.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IInkToolbarToggleButton.SIGNATURE);
    var _IInkToolbarToggleButtonFactoryCache: FactoryCache(IInkToolbarToggleButtonFactory, RUNTIME_NAME) = .{};
};
pub const InkToolbarCustomToggleButton = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarCustomToggleButton {
        const _f = @This().IInkToolbarCustomToggleButtonFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.InkToolbarCustomToggleButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IInkToolbarCustomToggleButton.GUID;
    pub const IID: Guid = IInkToolbarCustomToggleButton.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IInkToolbarCustomToggleButton.SIGNATURE);
    var _IInkToolbarCustomToggleButtonFactoryCache: FactoryCache(IInkToolbarCustomToggleButtonFactory, RUNTIME_NAME) = .{};
};
pub const InkToolbarCustomToolButton = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getConfigurationContent(self: *@This()) core.HResult!*UIElement {
        const this: *IInkToolbarCustomToolButton = @ptrCast(self);
        return try this.getConfigurationContent();
    }
    pub fn putConfigurationContent(self: *@This(), value: *UIElement) core.HResult!void {
        const this: *IInkToolbarCustomToolButton = @ptrCast(self);
        return try this.putConfigurationContent(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getConfigurationContentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarCustomToolButtonStaticsCache.get();
        return try _f.getConfigurationContentProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarCustomToolButton {
        const _f = @This().IInkToolbarCustomToolButtonFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.InkToolbarCustomToolButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IInkToolbarCustomToolButton.GUID;
    pub const IID: Guid = IInkToolbarCustomToolButton.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IInkToolbarCustomToolButton.SIGNATURE);
    var _IInkToolbarCustomToolButtonStaticsCache: FactoryCache(IInkToolbarCustomToolButtonStatics, RUNTIME_NAME) = .{};
    var _IInkToolbarCustomToolButtonFactoryCache: FactoryCache(IInkToolbarCustomToolButtonFactory, RUNTIME_NAME) = .{};
};
pub const InkToolbarEraserButton = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsClearAllVisible(self: *@This()) core.HResult!bool {
        var this: ?*IInkToolbarEraserButton2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IInkToolbarEraserButton2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsClearAllVisible();
    }
    pub fn putIsClearAllVisible(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IInkToolbarEraserButton2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IInkToolbarEraserButton2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsClearAllVisible(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getIsClearAllVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarEraserButtonStatics2Cache.get();
        return try _f.getIsClearAllVisibleProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarEraserButton {
        const _f = @This().IInkToolbarEraserButtonFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.InkToolbarEraserButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IInkToolbarEraserButton.GUID;
    pub const IID: Guid = IInkToolbarEraserButton.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IInkToolbarEraserButton.SIGNATURE);
    var _IInkToolbarEraserButtonStatics2Cache: FactoryCache(IInkToolbarEraserButtonStatics2, RUNTIME_NAME) = .{};
    var _IInkToolbarEraserButtonFactoryCache: FactoryCache(IInkToolbarEraserButtonFactory, RUNTIME_NAME) = .{};
};
pub const InkToolbarFlyoutItem = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getKind(self: *@This()) core.HResult!InkToolbarFlyoutItemKind {
        const this: *IInkToolbarFlyoutItem = @ptrCast(self);
        return try this.getKind();
    }
    pub fn putKind(self: *@This(), value: InkToolbarFlyoutItemKind) core.HResult!void {
        const this: *IInkToolbarFlyoutItem = @ptrCast(self);
        return try this.putKind(value);
    }
    pub fn getIsChecked(self: *@This()) core.HResult!bool {
        const this: *IInkToolbarFlyoutItem = @ptrCast(self);
        return try this.getIsChecked();
    }
    pub fn putIsChecked(self: *@This(), value: bool) core.HResult!void {
        const this: *IInkToolbarFlyoutItem = @ptrCast(self);
        return try this.putIsChecked(value);
    }
    pub fn addChecked(self: *@This(), handler: *TypedEventHandler(InkToolbarFlyoutItem,IInspectable)) core.HResult!EventRegistrationToken {
        const this: *IInkToolbarFlyoutItem = @ptrCast(self);
        return try this.addChecked(handler);
    }
    pub fn removeChecked(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IInkToolbarFlyoutItem = @ptrCast(self);
        return try this.removeChecked(token);
    }
    pub fn addUnchecked(self: *@This(), handler: *TypedEventHandler(InkToolbarFlyoutItem,IInspectable)) core.HResult!EventRegistrationToken {
        const this: *IInkToolbarFlyoutItem = @ptrCast(self);
        return try this.addUnchecked(handler);
    }
    pub fn removeUnchecked(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IInkToolbarFlyoutItem = @ptrCast(self);
        return try this.removeUnchecked(token);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getKindProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarFlyoutItemStaticsCache.get();
        return try _f.getKindProperty();
    }
    pub fn getIsCheckedProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarFlyoutItemStaticsCache.get();
        return try _f.getIsCheckedProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarFlyoutItem {
        const _f = @This().IInkToolbarFlyoutItemFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.InkToolbarFlyoutItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IInkToolbarFlyoutItem.GUID;
    pub const IID: Guid = IInkToolbarFlyoutItem.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IInkToolbarFlyoutItem.SIGNATURE);
    var _IInkToolbarFlyoutItemStaticsCache: FactoryCache(IInkToolbarFlyoutItemStatics, RUNTIME_NAME) = .{};
    var _IInkToolbarFlyoutItemFactoryCache: FactoryCache(IInkToolbarFlyoutItemFactory, RUNTIME_NAME) = .{};
};
pub const InkToolbarFlyoutItemKind = enum(i32) {
    Simple = 0,
    Radio = 1,
    Check = 2,
    RadioCheck = 3,
};
pub const InkToolbarHighlighterButton = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarHighlighterButton {
        const _f = @This().IInkToolbarHighlighterButtonFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.InkToolbarHighlighterButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IInkToolbarHighlighterButton.GUID;
    pub const IID: Guid = IInkToolbarHighlighterButton.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IInkToolbarHighlighterButton.SIGNATURE);
    var _IInkToolbarHighlighterButtonFactoryCache: FactoryCache(IInkToolbarHighlighterButtonFactory, RUNTIME_NAME) = .{};
};
pub const InkToolbarInitialControls = enum(i32) {
    All = 0,
    None = 1,
    PensOnly = 2,
    AllExceptPens = 3,
};
pub const InkToolbarIsStencilButtonCheckedChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getStencilButton(self: *@This()) core.HResult!*InkToolbarStencilButton {
        const this: *IInkToolbarIsStencilButtonCheckedChangedEventArgs = @ptrCast(self);
        return try this.getStencilButton();
    }
    pub fn getStencilKind(self: *@This()) core.HResult!InkToolbarStencilKind {
        const this: *IInkToolbarIsStencilButtonCheckedChangedEventArgs = @ptrCast(self);
        return try this.getStencilKind();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IInkToolbarIsStencilButtonCheckedChangedEventArgs.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.InkToolbarIsStencilButtonCheckedChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IInkToolbarIsStencilButtonCheckedChangedEventArgs.GUID;
    pub const IID: Guid = IInkToolbarIsStencilButtonCheckedChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IInkToolbarIsStencilButtonCheckedChangedEventArgs.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const InkToolbarMenuButton = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getMenuKind(self: *@This()) core.HResult!InkToolbarMenuKind {
        const this: *IInkToolbarMenuButton = @ptrCast(self);
        return try this.getMenuKind();
    }
    pub fn getIsExtensionGlyphShown(self: *@This()) core.HResult!bool {
        const this: *IInkToolbarMenuButton = @ptrCast(self);
        return try this.getIsExtensionGlyphShown();
    }
    pub fn putIsExtensionGlyphShown(self: *@This(), value: bool) core.HResult!void {
        const this: *IInkToolbarMenuButton = @ptrCast(self);
        return try this.putIsExtensionGlyphShown(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getIsExtensionGlyphShownProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarMenuButtonStaticsCache.get();
        return try _f.getIsExtensionGlyphShownProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.InkToolbarMenuButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IInkToolbarMenuButton.GUID;
    pub const IID: Guid = IInkToolbarMenuButton.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IInkToolbarMenuButton.SIGNATURE);
    var _IInkToolbarMenuButtonStaticsCache: FactoryCache(IInkToolbarMenuButtonStatics, RUNTIME_NAME) = .{};
    var _IInkToolbarMenuButtonFactoryCache: FactoryCache(IInkToolbarMenuButtonFactory, RUNTIME_NAME) = .{};
};
pub const InkToolbarMenuKind = enum(i32) {
    Stencil = 0,
};
pub const InkToolbarPenConfigurationControl = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getPenButton(self: *@This()) core.HResult!*InkToolbarPenButton {
        const this: *IInkToolbarPenConfigurationControl = @ptrCast(self);
        return try this.getPenButton();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getPenButtonProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarPenConfigurationControlStaticsCache.get();
        return try _f.getPenButtonProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarPenConfigurationControl {
        const _f = @This().IInkToolbarPenConfigurationControlFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.InkToolbarPenConfigurationControl";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IInkToolbarPenConfigurationControl.GUID;
    pub const IID: Guid = IInkToolbarPenConfigurationControl.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IInkToolbarPenConfigurationControl.SIGNATURE);
    var _IInkToolbarPenConfigurationControlStaticsCache: FactoryCache(IInkToolbarPenConfigurationControlStatics, RUNTIME_NAME) = .{};
    var _IInkToolbarPenConfigurationControlFactoryCache: FactoryCache(IInkToolbarPenConfigurationControlFactory, RUNTIME_NAME) = .{};
};
pub const InkToolbarPencilButton = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarPencilButton {
        const _f = @This().IInkToolbarPencilButtonFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.InkToolbarPencilButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IInkToolbarPencilButton.GUID;
    pub const IID: Guid = IInkToolbarPencilButton.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IInkToolbarPencilButton.SIGNATURE);
    var _IInkToolbarPencilButtonFactoryCache: FactoryCache(IInkToolbarPencilButtonFactory, RUNTIME_NAME) = .{};
};
pub const InkToolbarRulerButton = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getRuler(self: *@This()) core.HResult!*InkPresenterRuler {
        const this: *IInkToolbarRulerButton = @ptrCast(self);
        return try this.getRuler();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getRulerProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarRulerButtonStaticsCache.get();
        return try _f.getRulerProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarRulerButton {
        const _f = @This().IInkToolbarRulerButtonFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.InkToolbarRulerButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IInkToolbarRulerButton.GUID;
    pub const IID: Guid = IInkToolbarRulerButton.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IInkToolbarRulerButton.SIGNATURE);
    var _IInkToolbarRulerButtonStaticsCache: FactoryCache(IInkToolbarRulerButtonStatics, RUNTIME_NAME) = .{};
    var _IInkToolbarRulerButtonFactoryCache: FactoryCache(IInkToolbarRulerButtonFactory, RUNTIME_NAME) = .{};
};
pub const InkToolbarStencilButton = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getRuler(self: *@This()) core.HResult!*InkPresenterRuler {
        const this: *IInkToolbarStencilButton = @ptrCast(self);
        return try this.getRuler();
    }
    pub fn getProtractor(self: *@This()) core.HResult!*InkPresenterProtractor {
        const this: *IInkToolbarStencilButton = @ptrCast(self);
        return try this.getProtractor();
    }
    pub fn getSelectedStencil(self: *@This()) core.HResult!InkToolbarStencilKind {
        const this: *IInkToolbarStencilButton = @ptrCast(self);
        return try this.getSelectedStencil();
    }
    pub fn putSelectedStencil(self: *@This(), value: InkToolbarStencilKind) core.HResult!void {
        const this: *IInkToolbarStencilButton = @ptrCast(self);
        return try this.putSelectedStencil(value);
    }
    pub fn getIsRulerItemVisible(self: *@This()) core.HResult!bool {
        const this: *IInkToolbarStencilButton = @ptrCast(self);
        return try this.getIsRulerItemVisible();
    }
    pub fn putIsRulerItemVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IInkToolbarStencilButton = @ptrCast(self);
        return try this.putIsRulerItemVisible(value);
    }
    pub fn getIsProtractorItemVisible(self: *@This()) core.HResult!bool {
        const this: *IInkToolbarStencilButton = @ptrCast(self);
        return try this.getIsProtractorItemVisible();
    }
    pub fn putIsProtractorItemVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IInkToolbarStencilButton = @ptrCast(self);
        return try this.putIsProtractorItemVisible(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getRulerProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarStencilButtonStaticsCache.get();
        return try _f.getRulerProperty();
    }
    pub fn getProtractorProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarStencilButtonStaticsCache.get();
        return try _f.getProtractorProperty();
    }
    pub fn getSelectedStencilProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarStencilButtonStaticsCache.get();
        return try _f.getSelectedStencilProperty();
    }
    pub fn getIsRulerItemVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarStencilButtonStaticsCache.get();
        return try _f.getIsRulerItemVisibleProperty();
    }
    pub fn getIsProtractorItemVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IInkToolbarStencilButtonStaticsCache.get();
        return try _f.getIsProtractorItemVisibleProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*InkToolbarStencilButton {
        const _f = @This().IInkToolbarStencilButtonFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.InkToolbarStencilButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IInkToolbarStencilButton.GUID;
    pub const IID: Guid = IInkToolbarStencilButton.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IInkToolbarStencilButton.SIGNATURE);
    var _IInkToolbarStencilButtonStaticsCache: FactoryCache(IInkToolbarStencilButtonStatics, RUNTIME_NAME) = .{};
    var _IInkToolbarStencilButtonFactoryCache: FactoryCache(IInkToolbarStencilButtonFactory, RUNTIME_NAME) = .{};
};
pub const InkToolbarStencilKind = enum(i32) {
    Ruler = 0,
    Protractor = 1,
};
pub const InkToolbarToggle = enum(i32) {
    Ruler = 0,
    Custom = 1,
};
pub const InkToolbarTool = enum(i32) {
    BallpointPen = 0,
    Pencil = 1,
    Highlighter = 2,
    Eraser = 3,
    CustomPen = 4,
    CustomTool = 5,
};
pub const IsTextTrimmedChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.IsTextTrimmedChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IIsTextTrimmedChangedEventArgs.GUID;
    pub const IID: Guid = IIsTextTrimmedChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IIsTextTrimmedChangedEventArgs.SIGNATURE);
};
pub const ItemClickEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getClickedItem(self: *@This()) core.HResult!*IInspectable {
        const this: *IItemClickEventArgs = @ptrCast(self);
        return try this.getClickedItem();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IItemClickEventArgs.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ItemClickEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IItemClickEventArgs.GUID;
    pub const IID: Guid = IItemClickEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IItemClickEventArgs.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const ItemClickEventHandler = extern struct {
    vtable: *const VTable,
    _refs: @import("std").atomic.Value(u32),
    _cb: *const fn (context: ?*anyopaque) callconv(.winapi) void,
    _context: ?*anyopaque = null,
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn init(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *ItemClickEventArgs) callconv(.winapi) void,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
        };
        return _r;
    }
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn initWithState(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *ItemClickEventArgs) callconv(.winapi) void,
        context: anytype,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
            ._context = @ptrCast(context),
        };
        return _r;
    }
    /// This calls Release and voids the returned ref count. If ref count is 0 the memory is released,
    /// Otherwise the memory stays until all references are released, including all references Windows holds.
    ///
    /// The caller *MUST* always call deinit/Release at least once for every AddRef and init called.
    pub fn deinit(self: *@This()) void {
        _ = Release(@ptrCast(self));
    }
    fn QueryInterface(self: *anyopaque, riid: *const Guid, out: *?*anyopaque) callconv(.c) HRESULT {
        const me: *@This() = @ptrCast(@alignCast(self));
        // TODO: Handle IMarshal
        if (core.wiredGuidEql(riid, &IID) or
            core.wiredGuidEql(riid, &IUnknown.IID) or
            core.wiredGuidEql(riid, &IAgileObject.IID))
        {
            out.* = @as(?*anyopaque, @ptrCast(me));
            _ = AddRef(self);
            return 0;
        }
        out.* = null;
        return -2147467262; // E_NOINTERFACE
    }
    fn AddRef(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        return this._refs.fetchAdd(1, .monotonic) + 1;
    }
    fn Release(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        const left = this._refs.fetchSub(1, .acq_rel) - 1;
        if (left == 0) @import("std").heap.c_allocator.destroy(this);
        return left;
    }
    pub fn Invoke(self: *anyopaque, sender: *IInspectable, e: *ItemClickEventArgs) callconv(.winapi) HRESULT {
        const this: *@This() = @ptrCast(@alignCast(self));
        this._cb(this._context, sender, e);
        return 0;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ItemClickEventHandler";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "3df6d14e-e18a-4a75-9395-627c5f3cd489";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.pinterface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        Invoke: *const fn(self: *anyopaque, sender: *IInspectable, e: *ItemClickEventArgs) callconv(.winapi) HRESULT
    };
    pub const VTABLE = VTable {
        .QueryInterface = QueryInterface,
        .AddRef = AddRef,
        .Release = Release,
        .Invoke = Invoke,
    };
};
pub const ItemCollection = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn addVectorChanged(self: *@This(), vhnd: *VectorChangedEventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        const this: *IObservableVector(IInspectable) = @ptrCast(self);
        return try this.addVectorChanged(vhnd);
    }
    pub fn removeVectorChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IObservableVector(IInspectable) = @ptrCast(self);
        return try this.removeVectorChanged(token);
    }
    pub fn getSize(self: *@This()) core.HResult!u32 {
        var this: ?*IVector(IInspectable) = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IVector.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSize();
    }
    pub fn GetView(self: *@This()) core.HResult!*IVectorView(IInspectable) {
        var this: ?*IVector(IInspectable) = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IVector.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GetView();
    }
    pub fn RemoveAt(self: *@This(), index: u32) core.HResult!void {
        var this: ?*IVector(IInspectable) = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IVector.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.RemoveAt(index);
    }
    pub fn RemoveAtEnd(self: *@This()) core.HResult!void {
        var this: ?*IVector(IInspectable) = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IVector.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.RemoveAtEnd();
    }
    pub fn Clear(self: *@This()) core.HResult!void {
        var this: ?*IVector(IInspectable) = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IVector.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.Clear();
    }
    pub fn First(self: *@This()) core.HResult!*IIterator(IInspectable) {
        var this: ?*IIterable(IInspectable) = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IIterable.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.First();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ItemCollection";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IObservableVector.GUID;
    pub const IID: Guid = IObservableVector.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IObservableVector.SIGNATURE);
};
pub const ItemContainerGenerator = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn addItemsChanged(self: *@This(), handler: *ItemsChangedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IItemContainerGenerator = @ptrCast(self);
        return try this.addItemsChanged(handler);
    }
    pub fn removeItemsChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IItemContainerGenerator = @ptrCast(self);
        return try this.removeItemsChanged(token);
    }
    pub fn ItemFromContainer(self: *@This(), container: *DependencyObject) core.HResult!*IInspectable {
        const this: *IItemContainerGenerator = @ptrCast(self);
        return try this.ItemFromContainer(container);
    }
    pub fn ContainerFromItem(self: *@This(), item: *IInspectable) core.HResult!*DependencyObject {
        const this: *IItemContainerGenerator = @ptrCast(self);
        return try this.ContainerFromItem(item);
    }
    pub fn IndexFromContainer(self: *@This(), container: *DependencyObject) core.HResult!i32 {
        const this: *IItemContainerGenerator = @ptrCast(self);
        return try this.IndexFromContainer(container);
    }
    pub fn ContainerFromIndex(self: *@This(), index: i32) core.HResult!*DependencyObject {
        const this: *IItemContainerGenerator = @ptrCast(self);
        return try this.ContainerFromIndex(index);
    }
    pub fn GetItemContainerGeneratorForPanel(self: *@This(), panel: *Panel) core.HResult!*ItemContainerGenerator {
        const this: *IItemContainerGenerator = @ptrCast(self);
        return try this.GetItemContainerGeneratorForPanel(panel);
    }
    pub fn StartAt(self: *@This(), position: GeneratorPosition, direction: GeneratorDirection, allowStartAtRealizedItem: bool) core.HResult!void {
        const this: *IItemContainerGenerator = @ptrCast(self);
        return try this.StartAt(position, direction, allowStartAtRealizedItem);
    }
    pub fn Stop(self: *@This()) core.HResult!void {
        const this: *IItemContainerGenerator = @ptrCast(self);
        return try this.Stop();
    }
    pub fn GenerateNext(self: *@This(), isNewlyRealized: bool) core.HResult!*DependencyObject {
        const this: *IItemContainerGenerator = @ptrCast(self);
        return try this.GenerateNext(isNewlyRealized);
    }
    pub fn PrepareItemContainer(self: *@This(), container: *DependencyObject) core.HResult!void {
        const this: *IItemContainerGenerator = @ptrCast(self);
        return try this.PrepareItemContainer(container);
    }
    pub fn RemoveAll(self: *@This()) core.HResult!void {
        const this: *IItemContainerGenerator = @ptrCast(self);
        return try this.RemoveAll();
    }
    pub fn Remove(self: *@This(), position: GeneratorPosition, count: i32) core.HResult!void {
        const this: *IItemContainerGenerator = @ptrCast(self);
        return try this.Remove(position, count);
    }
    pub fn GeneratorPositionFromIndex(self: *@This(), itemIndex: i32) core.HResult!GeneratorPosition {
        const this: *IItemContainerGenerator = @ptrCast(self);
        return try this.GeneratorPositionFromIndex(itemIndex);
    }
    pub fn IndexFromGeneratorPosition(self: *@This(), position: GeneratorPosition) core.HResult!i32 {
        const this: *IItemContainerGenerator = @ptrCast(self);
        return try this.IndexFromGeneratorPosition(position);
    }
    pub fn Recycle(self: *@This(), position: GeneratorPosition, count: i32) core.HResult!void {
        const this: *IItemContainerGenerator = @ptrCast(self);
        return try this.Recycle(position, count);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ItemContainerGenerator";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IItemContainerGenerator.GUID;
    pub const IID: Guid = IItemContainerGenerator.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IItemContainerGenerator.SIGNATURE);
};
pub const ItemsPanelTemplate = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IItemsPanelTemplate.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ItemsPanelTemplate";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IItemsPanelTemplate.GUID;
    pub const IID: Guid = IItemsPanelTemplate.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IItemsPanelTemplate.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const ItemsPickedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getAddedItems(self: *@This()) core.HResult!*IVector(IInspectable) {
        const this: *IItemsPickedEventArgs = @ptrCast(self);
        return try this.getAddedItems();
    }
    pub fn getRemovedItems(self: *@This()) core.HResult!*IVector(IInspectable) {
        const this: *IItemsPickedEventArgs = @ptrCast(self);
        return try this.getRemovedItems();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IItemsPickedEventArgs.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ItemsPickedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IItemsPickedEventArgs.GUID;
    pub const IID: Guid = IItemsPickedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IItemsPickedEventArgs.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const ItemsPresenter = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        const this: *IItemsPresenter = @ptrCast(self);
        return try this.getHeader();
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IItemsPresenter = @ptrCast(self);
        return try this.putHeader(value);
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        const this: *IItemsPresenter = @ptrCast(self);
        return try this.getHeaderTemplate();
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const this: *IItemsPresenter = @ptrCast(self);
        return try this.putHeaderTemplate(value);
    }
    pub fn getHeaderTransitions(self: *@This()) core.HResult!*TransitionCollection {
        const this: *IItemsPresenter = @ptrCast(self);
        return try this.getHeaderTransitions();
    }
    pub fn putHeaderTransitions(self: *@This(), value: *TransitionCollection) core.HResult!void {
        const this: *IItemsPresenter = @ptrCast(self);
        return try this.putHeaderTransitions(value);
    }
    pub fn getPadding(self: *@This()) core.HResult!Thickness {
        const this: *IItemsPresenter = @ptrCast(self);
        return try this.getPadding();
    }
    pub fn putPadding(self: *@This(), value: Thickness) core.HResult!void {
        const this: *IItemsPresenter = @ptrCast(self);
        return try this.putPadding(value);
    }
    pub fn getFooter(self: *@This()) core.HResult!*IInspectable {
        var this: ?*IItemsPresenter2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemsPresenter2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getFooter();
    }
    pub fn putFooter(self: *@This(), value: *IInspectable) core.HResult!void {
        var this: ?*IItemsPresenter2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemsPresenter2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putFooter(value);
    }
    pub fn getFooterTemplate(self: *@This()) core.HResult!*DataTemplate {
        var this: ?*IItemsPresenter2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemsPresenter2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getFooterTemplate();
    }
    pub fn putFooterTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        var this: ?*IItemsPresenter2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemsPresenter2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putFooterTemplate(value);
    }
    pub fn getFooterTransitions(self: *@This()) core.HResult!*TransitionCollection {
        var this: ?*IItemsPresenter2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemsPresenter2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getFooterTransitions();
    }
    pub fn putFooterTransitions(self: *@This(), value: *TransitionCollection) core.HResult!void {
        var this: ?*IItemsPresenter2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemsPresenter2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putFooterTransitions(value);
    }
    pub fn getAreHorizontalSnapPointsRegular(self: *@This()) core.HResult!bool {
        var this: ?*IScrollSnapPointsInfo = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollSnapPointsInfo.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getAreHorizontalSnapPointsRegular();
    }
    pub fn getAreVerticalSnapPointsRegular(self: *@This()) core.HResult!bool {
        var this: ?*IScrollSnapPointsInfo = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollSnapPointsInfo.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getAreVerticalSnapPointsRegular();
    }
    pub fn addHorizontalSnapPointsChanged(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        var this: ?*IScrollSnapPointsInfo = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollSnapPointsInfo.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addHorizontalSnapPointsChanged(handler);
    }
    pub fn removeHorizontalSnapPointsChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IScrollSnapPointsInfo = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollSnapPointsInfo.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeHorizontalSnapPointsChanged(token);
    }
    pub fn addVerticalSnapPointsChanged(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        var this: ?*IScrollSnapPointsInfo = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollSnapPointsInfo.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addVerticalSnapPointsChanged(handler);
    }
    pub fn removeVerticalSnapPointsChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IScrollSnapPointsInfo = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollSnapPointsInfo.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeVerticalSnapPointsChanged(token);
    }
    pub fn GetIrregularSnapPoints(self: *@This(), orientation: Orientation, alignment: SnapPointsAlignment) core.HResult!*IVectorView(f32) {
        var this: ?*IScrollSnapPointsInfo = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollSnapPointsInfo.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GetIrregularSnapPoints(orientation, alignment);
    }
    pub fn GetRegularSnapPoints(self: *@This(), orientation: Orientation, alignment: SnapPointsAlignment, offset: f32) core.HResult!f32 {
        var this: ?*IScrollSnapPointsInfo = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollSnapPointsInfo.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GetRegularSnapPoints(orientation, alignment, offset);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IItemsPresenter.IID)));
    }
    pub fn getFooterProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsPresenterStatics2Cache.get();
        return try _f.getFooterProperty();
    }
    pub fn getFooterTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsPresenterStatics2Cache.get();
        return try _f.getFooterTemplateProperty();
    }
    pub fn getFooterTransitionsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsPresenterStatics2Cache.get();
        return try _f.getFooterTransitionsProperty();
    }
    pub fn getHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsPresenterStaticsCache.get();
        return try _f.getHeaderProperty();
    }
    pub fn getHeaderTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsPresenterStaticsCache.get();
        return try _f.getHeaderTemplateProperty();
    }
    pub fn getHeaderTransitionsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsPresenterStaticsCache.get();
        return try _f.getHeaderTransitionsProperty();
    }
    pub fn getPaddingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsPresenterStaticsCache.get();
        return try _f.getPaddingProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ItemsPresenter";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IItemsPresenter.GUID;
    pub const IID: Guid = IItemsPresenter.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IItemsPresenter.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IItemsPresenterStatics2Cache: FactoryCache(IItemsPresenterStatics2, RUNTIME_NAME) = .{};
    var _IItemsPresenterStaticsCache: FactoryCache(IItemsPresenterStatics, RUNTIME_NAME) = .{};
};
pub const ItemsStackPanel = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getGroupPadding(self: *@This()) core.HResult!Thickness {
        const this: *IItemsStackPanel = @ptrCast(self);
        return try this.getGroupPadding();
    }
    pub fn putGroupPadding(self: *@This(), value: Thickness) core.HResult!void {
        const this: *IItemsStackPanel = @ptrCast(self);
        return try this.putGroupPadding(value);
    }
    pub fn getOrientation(self: *@This()) core.HResult!Orientation {
        const this: *IItemsStackPanel = @ptrCast(self);
        return try this.getOrientation();
    }
    pub fn putOrientation(self: *@This(), value: Orientation) core.HResult!void {
        const this: *IItemsStackPanel = @ptrCast(self);
        return try this.putOrientation(value);
    }
    pub fn getFirstCacheIndex(self: *@This()) core.HResult!i32 {
        const this: *IItemsStackPanel = @ptrCast(self);
        return try this.getFirstCacheIndex();
    }
    pub fn getFirstVisibleIndex(self: *@This()) core.HResult!i32 {
        const this: *IItemsStackPanel = @ptrCast(self);
        return try this.getFirstVisibleIndex();
    }
    pub fn getLastVisibleIndex(self: *@This()) core.HResult!i32 {
        const this: *IItemsStackPanel = @ptrCast(self);
        return try this.getLastVisibleIndex();
    }
    pub fn getLastCacheIndex(self: *@This()) core.HResult!i32 {
        const this: *IItemsStackPanel = @ptrCast(self);
        return try this.getLastCacheIndex();
    }
    pub fn getScrollingDirection(self: *@This()) core.HResult!PanelScrollingDirection {
        const this: *IItemsStackPanel = @ptrCast(self);
        return try this.getScrollingDirection();
    }
    pub fn getGroupHeaderPlacement(self: *@This()) core.HResult!GroupHeaderPlacement {
        const this: *IItemsStackPanel = @ptrCast(self);
        return try this.getGroupHeaderPlacement();
    }
    pub fn putGroupHeaderPlacement(self: *@This(), value: GroupHeaderPlacement) core.HResult!void {
        const this: *IItemsStackPanel = @ptrCast(self);
        return try this.putGroupHeaderPlacement(value);
    }
    pub fn getItemsUpdatingScrollMode(self: *@This()) core.HResult!ItemsUpdatingScrollMode {
        const this: *IItemsStackPanel = @ptrCast(self);
        return try this.getItemsUpdatingScrollMode();
    }
    pub fn putItemsUpdatingScrollMode(self: *@This(), value: ItemsUpdatingScrollMode) core.HResult!void {
        const this: *IItemsStackPanel = @ptrCast(self);
        return try this.putItemsUpdatingScrollMode(value);
    }
    pub fn getCacheLength(self: *@This()) core.HResult!f64 {
        const this: *IItemsStackPanel = @ptrCast(self);
        return try this.getCacheLength();
    }
    pub fn putCacheLength(self: *@This(), value: f64) core.HResult!void {
        const this: *IItemsStackPanel = @ptrCast(self);
        return try this.putCacheLength(value);
    }
    pub fn getAreStickyGroupHeadersEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IItemsStackPanel2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemsStackPanel2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getAreStickyGroupHeadersEnabled();
    }
    pub fn putAreStickyGroupHeadersEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IItemsStackPanel2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemsStackPanel2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putAreStickyGroupHeadersEnabled(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IItemsStackPanel.IID)));
    }
    pub fn getAreStickyGroupHeadersEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsStackPanelStatics2Cache.get();
        return try _f.getAreStickyGroupHeadersEnabledProperty();
    }
    pub fn getGroupPaddingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsStackPanelStaticsCache.get();
        return try _f.getGroupPaddingProperty();
    }
    pub fn getOrientationProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsStackPanelStaticsCache.get();
        return try _f.getOrientationProperty();
    }
    pub fn getGroupHeaderPlacementProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsStackPanelStaticsCache.get();
        return try _f.getGroupHeaderPlacementProperty();
    }
    pub fn getCacheLengthProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsStackPanelStaticsCache.get();
        return try _f.getCacheLengthProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ItemsStackPanel";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IItemsStackPanel.GUID;
    pub const IID: Guid = IItemsStackPanel.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IItemsStackPanel.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IItemsStackPanelStatics2Cache: FactoryCache(IItemsStackPanelStatics2, RUNTIME_NAME) = .{};
    var _IItemsStackPanelStaticsCache: FactoryCache(IItemsStackPanelStatics, RUNTIME_NAME) = .{};
};
pub const ItemsUpdatingScrollMode = enum(i32) {
    KeepItemsInView = 0,
    KeepScrollOffset = 1,
    KeepLastItemInView = 2,
};
pub const ItemsWrapGrid = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getGroupPadding(self: *@This()) core.HResult!Thickness {
        const this: *IItemsWrapGrid = @ptrCast(self);
        return try this.getGroupPadding();
    }
    pub fn putGroupPadding(self: *@This(), value: Thickness) core.HResult!void {
        const this: *IItemsWrapGrid = @ptrCast(self);
        return try this.putGroupPadding(value);
    }
    pub fn getOrientation(self: *@This()) core.HResult!Orientation {
        const this: *IItemsWrapGrid = @ptrCast(self);
        return try this.getOrientation();
    }
    pub fn putOrientation(self: *@This(), value: Orientation) core.HResult!void {
        const this: *IItemsWrapGrid = @ptrCast(self);
        return try this.putOrientation(value);
    }
    pub fn getMaximumRowsOrColumns(self: *@This()) core.HResult!i32 {
        const this: *IItemsWrapGrid = @ptrCast(self);
        return try this.getMaximumRowsOrColumns();
    }
    pub fn putMaximumRowsOrColumns(self: *@This(), value: i32) core.HResult!void {
        const this: *IItemsWrapGrid = @ptrCast(self);
        return try this.putMaximumRowsOrColumns(value);
    }
    pub fn getItemWidth(self: *@This()) core.HResult!f64 {
        const this: *IItemsWrapGrid = @ptrCast(self);
        return try this.getItemWidth();
    }
    pub fn putItemWidth(self: *@This(), value: f64) core.HResult!void {
        const this: *IItemsWrapGrid = @ptrCast(self);
        return try this.putItemWidth(value);
    }
    pub fn getItemHeight(self: *@This()) core.HResult!f64 {
        const this: *IItemsWrapGrid = @ptrCast(self);
        return try this.getItemHeight();
    }
    pub fn putItemHeight(self: *@This(), value: f64) core.HResult!void {
        const this: *IItemsWrapGrid = @ptrCast(self);
        return try this.putItemHeight(value);
    }
    pub fn getFirstCacheIndex(self: *@This()) core.HResult!i32 {
        const this: *IItemsWrapGrid = @ptrCast(self);
        return try this.getFirstCacheIndex();
    }
    pub fn getFirstVisibleIndex(self: *@This()) core.HResult!i32 {
        const this: *IItemsWrapGrid = @ptrCast(self);
        return try this.getFirstVisibleIndex();
    }
    pub fn getLastVisibleIndex(self: *@This()) core.HResult!i32 {
        const this: *IItemsWrapGrid = @ptrCast(self);
        return try this.getLastVisibleIndex();
    }
    pub fn getLastCacheIndex(self: *@This()) core.HResult!i32 {
        const this: *IItemsWrapGrid = @ptrCast(self);
        return try this.getLastCacheIndex();
    }
    pub fn getScrollingDirection(self: *@This()) core.HResult!PanelScrollingDirection {
        const this: *IItemsWrapGrid = @ptrCast(self);
        return try this.getScrollingDirection();
    }
    pub fn getGroupHeaderPlacement(self: *@This()) core.HResult!GroupHeaderPlacement {
        const this: *IItemsWrapGrid = @ptrCast(self);
        return try this.getGroupHeaderPlacement();
    }
    pub fn putGroupHeaderPlacement(self: *@This(), value: GroupHeaderPlacement) core.HResult!void {
        const this: *IItemsWrapGrid = @ptrCast(self);
        return try this.putGroupHeaderPlacement(value);
    }
    pub fn getCacheLength(self: *@This()) core.HResult!f64 {
        const this: *IItemsWrapGrid = @ptrCast(self);
        return try this.getCacheLength();
    }
    pub fn putCacheLength(self: *@This(), value: f64) core.HResult!void {
        const this: *IItemsWrapGrid = @ptrCast(self);
        return try this.putCacheLength(value);
    }
    pub fn getAreStickyGroupHeadersEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IItemsWrapGrid2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemsWrapGrid2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getAreStickyGroupHeadersEnabled();
    }
    pub fn putAreStickyGroupHeadersEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IItemsWrapGrid2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IItemsWrapGrid2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putAreStickyGroupHeadersEnabled(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IItemsWrapGrid.IID)));
    }
    pub fn getGroupPaddingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsWrapGridStaticsCache.get();
        return try _f.getGroupPaddingProperty();
    }
    pub fn getOrientationProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsWrapGridStaticsCache.get();
        return try _f.getOrientationProperty();
    }
    pub fn getMaximumRowsOrColumnsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsWrapGridStaticsCache.get();
        return try _f.getMaximumRowsOrColumnsProperty();
    }
    pub fn getItemWidthProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsWrapGridStaticsCache.get();
        return try _f.getItemWidthProperty();
    }
    pub fn getItemHeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsWrapGridStaticsCache.get();
        return try _f.getItemHeightProperty();
    }
    pub fn getGroupHeaderPlacementProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsWrapGridStaticsCache.get();
        return try _f.getGroupHeaderPlacementProperty();
    }
    pub fn getCacheLengthProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsWrapGridStaticsCache.get();
        return try _f.getCacheLengthProperty();
    }
    pub fn getAreStickyGroupHeadersEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IItemsWrapGridStatics2Cache.get();
        return try _f.getAreStickyGroupHeadersEnabledProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ItemsWrapGrid";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IItemsWrapGrid.GUID;
    pub const IID: Guid = IItemsWrapGrid.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IItemsWrapGrid.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IItemsWrapGridStaticsCache: FactoryCache(IItemsWrapGridStatics, RUNTIME_NAME) = .{};
    var _IItemsWrapGridStatics2Cache: FactoryCache(IItemsWrapGridStatics2, RUNTIME_NAME) = .{};
};
pub const LightDismissOverlayMode = enum(i32) {
    Auto = 0,
    On = 1,
    Off = 2,
};
pub const ListBox = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getSelectedItems(self: *@This()) core.HResult!*IVector(IInspectable) {
        const this: *IListBox = @ptrCast(self);
        return try this.getSelectedItems();
    }
    pub fn getSelectionMode(self: *@This()) core.HResult!SelectionMode {
        const this: *IListBox = @ptrCast(self);
        return try this.getSelectionMode();
    }
    pub fn putSelectionMode(self: *@This(), value: SelectionMode) core.HResult!void {
        const this: *IListBox = @ptrCast(self);
        return try this.putSelectionMode(value);
    }
    pub fn ScrollIntoView(self: *@This(), item: *IInspectable) core.HResult!void {
        const this: *IListBox = @ptrCast(self);
        return try this.ScrollIntoView(item);
    }
    pub fn SelectAll(self: *@This()) core.HResult!void {
        const this: *IListBox = @ptrCast(self);
        return try this.SelectAll();
    }
    pub fn getSingleSelectionFollowsFocus(self: *@This()) core.HResult!bool {
        var this: ?*IListBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSingleSelectionFollowsFocus();
    }
    pub fn putSingleSelectionFollowsFocus(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IListBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IListBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSingleSelectionFollowsFocus(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getSingleSelectionFollowsFocusProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListBoxStatics2Cache.get();
        return try _f.getSingleSelectionFollowsFocusProperty();
    }
    pub fn getSelectionModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListBoxStaticsCache.get();
        return try _f.getSelectionModeProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ListBox {
        const _f = @This().IListBoxFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ListBox";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IListBox.GUID;
    pub const IID: Guid = IListBox.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IListBox.SIGNATURE);
    var _IListBoxStatics2Cache: FactoryCache(IListBoxStatics2, RUNTIME_NAME) = .{};
    var _IListBoxStaticsCache: FactoryCache(IListBoxStatics, RUNTIME_NAME) = .{};
    var _IListBoxFactoryCache: FactoryCache(IListBoxFactory, RUNTIME_NAME) = .{};
};
pub const ListBoxItem = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ListBoxItem {
        const _f = @This().IListBoxItemFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ListBoxItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IListBoxItem.GUID;
    pub const IID: Guid = IListBoxItem.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IListBoxItem.SIGNATURE);
    var _IListBoxItemFactoryCache: FactoryCache(IListBoxItemFactory, RUNTIME_NAME) = .{};
};
pub const ListPickerFlyout = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getItemsSource(self: *@This()) core.HResult!*IInspectable {
        const this: *IListPickerFlyout = @ptrCast(self);
        return try this.getItemsSource();
    }
    pub fn putItemsSource(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IListPickerFlyout = @ptrCast(self);
        return try this.putItemsSource(value);
    }
    pub fn getItemTemplate(self: *@This()) core.HResult!*DataTemplate {
        const this: *IListPickerFlyout = @ptrCast(self);
        return try this.getItemTemplate();
    }
    pub fn putItemTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const this: *IListPickerFlyout = @ptrCast(self);
        return try this.putItemTemplate(value);
    }
    pub fn getDisplayMemberPath(self: *@This()) core.HResult!HSTRING {
        const this: *IListPickerFlyout = @ptrCast(self);
        return try this.getDisplayMemberPath();
    }
    pub fn putDisplayMemberPath(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IListPickerFlyout = @ptrCast(self);
        return try this.putDisplayMemberPath(value);
    }
    pub fn getSelectionMode(self: *@This()) core.HResult!ListPickerFlyoutSelectionMode {
        const this: *IListPickerFlyout = @ptrCast(self);
        return try this.getSelectionMode();
    }
    pub fn putSelectionMode(self: *@This(), value: ListPickerFlyoutSelectionMode) core.HResult!void {
        const this: *IListPickerFlyout = @ptrCast(self);
        return try this.putSelectionMode(value);
    }
    pub fn getSelectedIndex(self: *@This()) core.HResult!i32 {
        const this: *IListPickerFlyout = @ptrCast(self);
        return try this.getSelectedIndex();
    }
    pub fn putSelectedIndex(self: *@This(), value: i32) core.HResult!void {
        const this: *IListPickerFlyout = @ptrCast(self);
        return try this.putSelectedIndex(value);
    }
    pub fn getSelectedItem(self: *@This()) core.HResult!*IInspectable {
        const this: *IListPickerFlyout = @ptrCast(self);
        return try this.getSelectedItem();
    }
    pub fn putSelectedItem(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IListPickerFlyout = @ptrCast(self);
        return try this.putSelectedItem(value);
    }
    pub fn getSelectedValue(self: *@This()) core.HResult!*IInspectable {
        const this: *IListPickerFlyout = @ptrCast(self);
        return try this.getSelectedValue();
    }
    pub fn putSelectedValue(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IListPickerFlyout = @ptrCast(self);
        return try this.putSelectedValue(value);
    }
    pub fn getSelectedValuePath(self: *@This()) core.HResult!HSTRING {
        const this: *IListPickerFlyout = @ptrCast(self);
        return try this.getSelectedValuePath();
    }
    pub fn putSelectedValuePath(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IListPickerFlyout = @ptrCast(self);
        return try this.putSelectedValuePath(value);
    }
    pub fn getSelectedItems(self: *@This()) core.HResult!*IVector(IInspectable) {
        const this: *IListPickerFlyout = @ptrCast(self);
        return try this.getSelectedItems();
    }
    pub fn addItemsPicked(self: *@This(), handler: *TypedEventHandler(ListPickerFlyout,ItemsPickedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IListPickerFlyout = @ptrCast(self);
        return try this.addItemsPicked(handler);
    }
    pub fn removeItemsPicked(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IListPickerFlyout = @ptrCast(self);
        return try this.removeItemsPicked(token);
    }
    pub fn ShowAtAsync(self: *@This(), target: *FrameworkElement) core.HResult!*IAsyncOperation(IVectorView(IInspectable)) {
        const this: *IListPickerFlyout = @ptrCast(self);
        return try this.ShowAtAsync(target);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IListPickerFlyout.IID)));
    }
    pub fn getItemsSourceProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListPickerFlyoutStaticsCache.get();
        return try _f.getItemsSourceProperty();
    }
    pub fn getItemTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListPickerFlyoutStaticsCache.get();
        return try _f.getItemTemplateProperty();
    }
    pub fn getDisplayMemberPathProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListPickerFlyoutStaticsCache.get();
        return try _f.getDisplayMemberPathProperty();
    }
    pub fn getSelectionModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListPickerFlyoutStaticsCache.get();
        return try _f.getSelectionModeProperty();
    }
    pub fn getSelectedIndexProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListPickerFlyoutStaticsCache.get();
        return try _f.getSelectedIndexProperty();
    }
    pub fn getSelectedItemProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListPickerFlyoutStaticsCache.get();
        return try _f.getSelectedItemProperty();
    }
    pub fn getSelectedValueProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListPickerFlyoutStaticsCache.get();
        return try _f.getSelectedValueProperty();
    }
    pub fn getSelectedValuePathProperty() core.HResult!*DependencyProperty {
        const _f = @This().IListPickerFlyoutStaticsCache.get();
        return try _f.getSelectedValuePathProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ListPickerFlyout";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IListPickerFlyout.GUID;
    pub const IID: Guid = IListPickerFlyout.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IListPickerFlyout.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IListPickerFlyoutStaticsCache: FactoryCache(IListPickerFlyoutStatics, RUNTIME_NAME) = .{};
};
pub const ListPickerFlyoutPresenter = extern struct {
    vtable: *const IInspectable.VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ListPickerFlyoutPresenter";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IListPickerFlyoutPresenter.GUID;
    pub const IID: Guid = IListPickerFlyoutPresenter.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IListPickerFlyoutPresenter.SIGNATURE);
};
pub const ListPickerFlyoutSelectionMode = enum(i32) {
    Single = 0,
    Multiple = 1,
};
pub const ListView = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ListView {
        const _f = @This().IListViewFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ListView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IListView.GUID;
    pub const IID: Guid = IListView.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IListView.SIGNATURE);
    var _IListViewFactoryCache: FactoryCache(IListViewFactory, RUNTIME_NAME) = .{};
};
pub const ListViewHeaderItem = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ListViewHeaderItem {
        const _f = @This().IListViewHeaderItemFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ListViewHeaderItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IListViewHeaderItem.GUID;
    pub const IID: Guid = IListViewHeaderItem.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IListViewHeaderItem.SIGNATURE);
    var _IListViewHeaderItemFactoryCache: FactoryCache(IListViewHeaderItemFactory, RUNTIME_NAME) = .{};
};
pub const ListViewItem = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getTemplateSettings(self: *@This()) core.HResult!*ListViewItemTemplateSettings {
        const this: *IListViewItem = @ptrCast(self);
        return try this.getTemplateSettings();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ListViewItem {
        const _f = @This().IListViewItemFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ListViewItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IListViewItem.GUID;
    pub const IID: Guid = IListViewItem.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IListViewItem.SIGNATURE);
    var _IListViewItemFactoryCache: FactoryCache(IListViewItemFactory, RUNTIME_NAME) = .{};
};
pub const ListViewItemToKeyHandler = extern struct {
    vtable: *const VTable,
    _refs: @import("std").atomic.Value(u32),
    _cb: *const fn (context: ?*anyopaque) callconv(.winapi) void,
    _context: ?*anyopaque = null,
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn init(
        cb: *const fn(?*anyopaque, item: *IInspectable) callconv(.winapi) void,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
        };
        return _r;
    }
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn initWithState(
        cb: *const fn(?*anyopaque, item: *IInspectable) callconv(.winapi) void,
        context: anytype,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
            ._context = @ptrCast(context),
        };
        return _r;
    }
    /// This calls Release and voids the returned ref count. If ref count is 0 the memory is released,
    /// Otherwise the memory stays until all references are released, including all references Windows holds.
    ///
    /// The caller *MUST* always call deinit/Release at least once for every AddRef and init called.
    pub fn deinit(self: *@This()) void {
        _ = Release(@ptrCast(self));
    }
    fn QueryInterface(self: *anyopaque, riid: *const Guid, out: *?*anyopaque) callconv(.c) HRESULT {
        const me: *@This() = @ptrCast(@alignCast(self));
        // TODO: Handle IMarshal
        if (core.wiredGuidEql(riid, &IID) or
            core.wiredGuidEql(riid, &IUnknown.IID) or
            core.wiredGuidEql(riid, &IAgileObject.IID))
        {
            out.* = @as(?*anyopaque, @ptrCast(me));
            _ = AddRef(self);
            return 0;
        }
        out.* = null;
        return -2147467262; // E_NOINTERFACE
    }
    fn AddRef(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        return this._refs.fetchAdd(1, .monotonic) + 1;
    }
    fn Release(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        const left = this._refs.fetchSub(1, .acq_rel) - 1;
        if (left == 0) @import("std").heap.c_allocator.destroy(this);
        return left;
    }
    pub fn Invoke(self: *anyopaque, item: *IInspectable) callconv(.winapi) HRESULT {
        const this: *@This() = @ptrCast(@alignCast(self));
        this._cb(this._context, item);
        return 0;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ListViewItemToKeyHandler";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6af5da76-7e8b-4a91-9a56-460cb47d523f";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.pinterface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        Invoke: *const fn(self: *anyopaque, item: *IInspectable, _r: *HSTRING) callconv(.winapi) HRESULT
    };
    pub const VTABLE = VTable {
        .QueryInterface = QueryInterface,
        .AddRef = AddRef,
        .Release = Release,
        .Invoke = Invoke,
    };
};
pub const ListViewKeyToItemHandler = extern struct {
    vtable: *const VTable,
    _refs: @import("std").atomic.Value(u32),
    _cb: *const fn (context: ?*anyopaque) callconv(.winapi) void,
    _context: ?*anyopaque = null,
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn init(
        cb: *const fn(?*anyopaque, key: HSTRING) callconv(.winapi) void,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
        };
        return _r;
    }
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn initWithState(
        cb: *const fn(?*anyopaque, key: HSTRING) callconv(.winapi) void,
        context: anytype,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
            ._context = @ptrCast(context),
        };
        return _r;
    }
    /// This calls Release and voids the returned ref count. If ref count is 0 the memory is released,
    /// Otherwise the memory stays until all references are released, including all references Windows holds.
    ///
    /// The caller *MUST* always call deinit/Release at least once for every AddRef and init called.
    pub fn deinit(self: *@This()) void {
        _ = Release(@ptrCast(self));
    }
    fn QueryInterface(self: *anyopaque, riid: *const Guid, out: *?*anyopaque) callconv(.c) HRESULT {
        const me: *@This() = @ptrCast(@alignCast(self));
        // TODO: Handle IMarshal
        if (core.wiredGuidEql(riid, &IID) or
            core.wiredGuidEql(riid, &IUnknown.IID) or
            core.wiredGuidEql(riid, &IAgileObject.IID))
        {
            out.* = @as(?*anyopaque, @ptrCast(me));
            _ = AddRef(self);
            return 0;
        }
        out.* = null;
        return -2147467262; // E_NOINTERFACE
    }
    fn AddRef(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        return this._refs.fetchAdd(1, .monotonic) + 1;
    }
    fn Release(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        const left = this._refs.fetchSub(1, .acq_rel) - 1;
        if (left == 0) @import("std").heap.c_allocator.destroy(this);
        return left;
    }
    pub fn Invoke(self: *anyopaque, key: HSTRING) callconv(.winapi) HRESULT {
        const this: *@This() = @ptrCast(@alignCast(self));
        this._cb(this._context, key);
        return 0;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ListViewKeyToItemHandler";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "26fd5855-b530-4688-b9f0-428249178ef8";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.pinterface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        Invoke: *const fn(self: *anyopaque, key: HSTRING, _r: **IAsyncOperation(IInspectable)) callconv(.winapi) HRESULT
    };
    pub const VTABLE = VTable {
        .QueryInterface = QueryInterface,
        .AddRef = AddRef,
        .Release = Release,
        .Invoke = Invoke,
    };
};
pub const ListViewPersistenceHelper = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn GetRelativeScrollPosition(listViewBase: *ListViewBase, itemToKeyHandler: *ListViewItemToKeyHandler) core.HResult!HSTRING {
        const _f = @This().IListViewPersistenceHelperStaticsCache.get();
        return try _f.GetRelativeScrollPosition(listViewBase, itemToKeyHandler);
    }
    pub fn SetRelativeScrollPositionAsync(listViewBase: *ListViewBase, relativeScrollPosition: HSTRING, keyToItemHandler: *ListViewKeyToItemHandler) core.HResult!*IAsyncAction {
        const _f = @This().IListViewPersistenceHelperStaticsCache.get();
        return try _f.SetRelativeScrollPositionAsync(listViewBase, relativeScrollPosition, keyToItemHandler);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ListViewPersistenceHelper";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IListViewPersistenceHelper.GUID;
    pub const IID: Guid = IListViewPersistenceHelper.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IListViewPersistenceHelper.SIGNATURE);
    var _IListViewPersistenceHelperStaticsCache: FactoryCache(IListViewPersistenceHelperStatics, RUNTIME_NAME) = .{};
};
pub const ListViewReorderMode = enum(i32) {
    Disabled = 0,
    Enabled = 1,
};
pub const ListViewSelectionMode = enum(i32) {
    None = 0,
    Single = 1,
    Multiple = 2,
    Extended = 3,
};
pub const MediaElement = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getPosterSource(self: *@This()) core.HResult!*ImageSource {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getPosterSource();
    }
    pub fn putPosterSource(self: *@This(), value: *ImageSource) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.putPosterSource(value);
    }
    pub fn getSource(self: *@This()) core.HResult!*Uri {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getSource();
    }
    pub fn putSource(self: *@This(), value: *Uri) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.putSource(value);
    }
    pub fn getIsMuted(self: *@This()) core.HResult!bool {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getIsMuted();
    }
    pub fn putIsMuted(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.putIsMuted(value);
    }
    pub fn getIsAudioOnly(self: *@This()) core.HResult!bool {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getIsAudioOnly();
    }
    pub fn getAutoPlay(self: *@This()) core.HResult!bool {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getAutoPlay();
    }
    pub fn putAutoPlay(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.putAutoPlay(value);
    }
    pub fn getVolume(self: *@This()) core.HResult!f64 {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getVolume();
    }
    pub fn putVolume(self: *@This(), value: f64) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.putVolume(value);
    }
    pub fn getBalance(self: *@This()) core.HResult!f64 {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getBalance();
    }
    pub fn putBalance(self: *@This(), value: f64) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.putBalance(value);
    }
    pub fn getNaturalVideoHeight(self: *@This()) core.HResult!i32 {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getNaturalVideoHeight();
    }
    pub fn getNaturalVideoWidth(self: *@This()) core.HResult!i32 {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getNaturalVideoWidth();
    }
    pub fn getNaturalDuration(self: *@This()) core.HResult!Duration {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getNaturalDuration();
    }
    pub fn getPosition(self: *@This()) core.HResult!TimeSpan {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getPosition();
    }
    pub fn putPosition(self: *@This(), value: TimeSpan) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.putPosition(value);
    }
    pub fn getDownloadProgress(self: *@This()) core.HResult!f64 {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getDownloadProgress();
    }
    pub fn getBufferingProgress(self: *@This()) core.HResult!f64 {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getBufferingProgress();
    }
    pub fn getDownloadProgressOffset(self: *@This()) core.HResult!f64 {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getDownloadProgressOffset();
    }
    pub fn getCurrentState(self: *@This()) core.HResult!MediaElementState {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getCurrentState();
    }
    pub fn getMarkers(self: *@This()) core.HResult!*TimelineMarkerCollection {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getMarkers();
    }
    pub fn getCanSeek(self: *@This()) core.HResult!bool {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getCanSeek();
    }
    pub fn getCanPause(self: *@This()) core.HResult!bool {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getCanPause();
    }
    pub fn getAudioStreamCount(self: *@This()) core.HResult!i32 {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getAudioStreamCount();
    }
    pub fn getAudioStreamIndex(self: *@This()) core.HResult!*IReference(i32) {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getAudioStreamIndex();
    }
    pub fn putAudioStreamIndex(self: *@This(), value: *IReference(i32)) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.putAudioStreamIndex(value);
    }
    pub fn getPlaybackRate(self: *@This()) core.HResult!f64 {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getPlaybackRate();
    }
    pub fn putPlaybackRate(self: *@This(), value: f64) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.putPlaybackRate(value);
    }
    pub fn getIsLooping(self: *@This()) core.HResult!bool {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getIsLooping();
    }
    pub fn putIsLooping(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.putIsLooping(value);
    }
    pub fn getPlayToSource(self: *@This()) core.HResult!*PlayToSource {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getPlayToSource();
    }
    pub fn getDefaultPlaybackRate(self: *@This()) core.HResult!f64 {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getDefaultPlaybackRate();
    }
    pub fn putDefaultPlaybackRate(self: *@This(), value: f64) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.putDefaultPlaybackRate(value);
    }
    pub fn getAspectRatioWidth(self: *@This()) core.HResult!i32 {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getAspectRatioWidth();
    }
    pub fn getAspectRatioHeight(self: *@This()) core.HResult!i32 {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getAspectRatioHeight();
    }
    pub fn getRealTimePlayback(self: *@This()) core.HResult!bool {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getRealTimePlayback();
    }
    pub fn putRealTimePlayback(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.putRealTimePlayback(value);
    }
    pub fn getAudioCategory(self: *@This()) core.HResult!AudioCategory {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getAudioCategory();
    }
    pub fn putAudioCategory(self: *@This(), value: AudioCategory) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.putAudioCategory(value);
    }
    pub fn getAudioDeviceType(self: *@This()) core.HResult!AudioDeviceType {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getAudioDeviceType();
    }
    pub fn putAudioDeviceType(self: *@This(), value: AudioDeviceType) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.putAudioDeviceType(value);
    }
    pub fn getProtectionManager(self: *@This()) core.HResult!*MediaProtectionManager {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getProtectionManager();
    }
    pub fn putProtectionManager(self: *@This(), value: *MediaProtectionManager) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.putProtectionManager(value);
    }
    pub fn getStereo3DVideoPackingMode(self: *@This()) core.HResult!Stereo3DVideoPackingMode {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getStereo3DVideoPackingMode();
    }
    pub fn putStereo3DVideoPackingMode(self: *@This(), value: Stereo3DVideoPackingMode) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.putStereo3DVideoPackingMode(value);
    }
    pub fn getStereo3DVideoRenderMode(self: *@This()) core.HResult!Stereo3DVideoRenderMode {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getStereo3DVideoRenderMode();
    }
    pub fn putStereo3DVideoRenderMode(self: *@This(), value: Stereo3DVideoRenderMode) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.putStereo3DVideoRenderMode(value);
    }
    pub fn getIsStereo3DVideo(self: *@This()) core.HResult!bool {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getIsStereo3DVideo();
    }
    pub fn addMediaOpened(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IMediaElement = @ptrCast(self);
        return try this.addMediaOpened(handler);
    }
    pub fn removeMediaOpened(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.removeMediaOpened(token);
    }
    pub fn addMediaEnded(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IMediaElement = @ptrCast(self);
        return try this.addMediaEnded(handler);
    }
    pub fn removeMediaEnded(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.removeMediaEnded(token);
    }
    pub fn addMediaFailed(self: *@This(), handler: *ExceptionRoutedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IMediaElement = @ptrCast(self);
        return try this.addMediaFailed(handler);
    }
    pub fn removeMediaFailed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.removeMediaFailed(token);
    }
    pub fn addDownloadProgressChanged(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IMediaElement = @ptrCast(self);
        return try this.addDownloadProgressChanged(handler);
    }
    pub fn removeDownloadProgressChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.removeDownloadProgressChanged(token);
    }
    pub fn addBufferingProgressChanged(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IMediaElement = @ptrCast(self);
        return try this.addBufferingProgressChanged(handler);
    }
    pub fn removeBufferingProgressChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.removeBufferingProgressChanged(token);
    }
    pub fn addCurrentStateChanged(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IMediaElement = @ptrCast(self);
        return try this.addCurrentStateChanged(handler);
    }
    pub fn removeCurrentStateChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.removeCurrentStateChanged(token);
    }
    pub fn addMarkerReached(self: *@This(), handler: *TimelineMarkerRoutedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IMediaElement = @ptrCast(self);
        return try this.addMarkerReached(handler);
    }
    pub fn removeMarkerReached(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.removeMarkerReached(token);
    }
    pub fn addRateChanged(self: *@This(), handler: *RateChangedRoutedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IMediaElement = @ptrCast(self);
        return try this.addRateChanged(handler);
    }
    pub fn removeRateChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.removeRateChanged(token);
    }
    pub fn addVolumeChanged(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IMediaElement = @ptrCast(self);
        return try this.addVolumeChanged(handler);
    }
    pub fn removeVolumeChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.removeVolumeChanged(token);
    }
    pub fn addSeekCompleted(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IMediaElement = @ptrCast(self);
        return try this.addSeekCompleted(handler);
    }
    pub fn removeSeekCompleted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.removeSeekCompleted(token);
    }
    pub fn Stop(self: *@This()) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.Stop();
    }
    pub fn Play(self: *@This()) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.Play();
    }
    pub fn Pause(self: *@This()) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.Pause();
    }
    pub fn CanPlayType(self: *@This(), ty: HSTRING) core.HResult!MediaCanPlayResponse {
        const this: *IMediaElement = @ptrCast(self);
        return try this.CanPlayType(ty);
    }
    pub fn SetSource(self: *@This(), stream: *IRandomAccessStream, mimeType: HSTRING) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.SetSource(stream, mimeType);
    }
    pub fn GetAudioStreamLanguage(self: *@This(), index: *IReference(i32)) core.HResult!HSTRING {
        const this: *IMediaElement = @ptrCast(self);
        return try this.GetAudioStreamLanguage(index);
    }
    pub fn AddAudioEffect(self: *@This(), effectID: HSTRING, effectOptional: bool, effectConfiguration: *IPropertySet) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.AddAudioEffect(effectID, effectOptional, effectConfiguration);
    }
    pub fn AddVideoEffect(self: *@This(), effectID: HSTRING, effectOptional: bool, effectConfiguration: *IPropertySet) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.AddVideoEffect(effectID, effectOptional, effectConfiguration);
    }
    pub fn RemoveAllEffects(self: *@This()) core.HResult!void {
        const this: *IMediaElement = @ptrCast(self);
        return try this.RemoveAllEffects();
    }
    pub fn getActualStereo3DVideoPackingMode(self: *@This()) core.HResult!Stereo3DVideoPackingMode {
        const this: *IMediaElement = @ptrCast(self);
        return try this.getActualStereo3DVideoPackingMode();
    }
    pub fn getAreTransportControlsEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IMediaElement2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaElement2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getAreTransportControlsEnabled();
    }
    pub fn putAreTransportControlsEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IMediaElement2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaElement2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putAreTransportControlsEnabled(value);
    }
    pub fn getStretch(self: *@This()) core.HResult!Stretch {
        var this: ?*IMediaElement2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaElement2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getStretch();
    }
    pub fn putStretch(self: *@This(), value: Stretch) core.HResult!void {
        var this: ?*IMediaElement2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaElement2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putStretch(value);
    }
    pub fn getIsFullWindow(self: *@This()) core.HResult!bool {
        var this: ?*IMediaElement2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaElement2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsFullWindow();
    }
    pub fn putIsFullWindow(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IMediaElement2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaElement2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsFullWindow(value);
    }
    pub fn SetMediaStreamSource(self: *@This(), source: *IMediaSource) core.HResult!void {
        var this: ?*IMediaElement2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaElement2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.SetMediaStreamSource(source);
    }
    pub fn getPlayToPreferredSourceUri(self: *@This()) core.HResult!*Uri {
        var this: ?*IMediaElement2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaElement2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getPlayToPreferredSourceUri();
    }
    pub fn putPlayToPreferredSourceUri(self: *@This(), value: *Uri) core.HResult!void {
        var this: ?*IMediaElement2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaElement2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putPlayToPreferredSourceUri(value);
    }
    pub fn getTransportControls(self: *@This()) core.HResult!*MediaTransportControls {
        var this: ?*IMediaElement3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaElement3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTransportControls();
    }
    pub fn putTransportControls(self: *@This(), value: *MediaTransportControls) core.HResult!void {
        var this: ?*IMediaElement3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaElement3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTransportControls(value);
    }
    pub fn addPartialMediaFailureDetected(self: *@This(), handler: *TypedEventHandler(MediaElement,PartialMediaFailureDetectedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IMediaElement3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaElement3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addPartialMediaFailureDetected(handler);
    }
    pub fn removePartialMediaFailureDetected(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IMediaElement3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaElement3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removePartialMediaFailureDetected(token);
    }
    pub fn SetPlaybackSource(self: *@This(), source: *IMediaPlaybackSource) core.HResult!void {
        var this: ?*IMediaElement3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaElement3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.SetPlaybackSource(source);
    }
    pub fn GetAsCastingSource(self: *@This()) core.HResult!*CastingSource {
        var this: ?*IMediaElement3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaElement3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GetAsCastingSource();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IMediaElement.IID)));
    }
    pub fn getAreTransportControlsEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStatics2Cache.get();
        return try _f.getAreTransportControlsEnabledProperty();
    }
    pub fn getStretchProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStatics2Cache.get();
        return try _f.getStretchProperty();
    }
    pub fn getIsFullWindowProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStatics2Cache.get();
        return try _f.getIsFullWindowProperty();
    }
    pub fn getPlayToPreferredSourceUriProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStatics2Cache.get();
        return try _f.getPlayToPreferredSourceUriProperty();
    }
    pub fn getPosterSourceProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getPosterSourceProperty();
    }
    pub fn getSourceProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getSourceProperty();
    }
    pub fn getIsMutedProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getIsMutedProperty();
    }
    pub fn getIsAudioOnlyProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getIsAudioOnlyProperty();
    }
    pub fn getAutoPlayProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getAutoPlayProperty();
    }
    pub fn getVolumeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getVolumeProperty();
    }
    pub fn getBalanceProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getBalanceProperty();
    }
    pub fn getNaturalVideoHeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getNaturalVideoHeightProperty();
    }
    pub fn getNaturalVideoWidthProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getNaturalVideoWidthProperty();
    }
    pub fn getNaturalDurationProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getNaturalDurationProperty();
    }
    pub fn getPositionProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getPositionProperty();
    }
    pub fn getDownloadProgressProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getDownloadProgressProperty();
    }
    pub fn getBufferingProgressProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getBufferingProgressProperty();
    }
    pub fn getDownloadProgressOffsetProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getDownloadProgressOffsetProperty();
    }
    pub fn getCurrentStateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getCurrentStateProperty();
    }
    pub fn getCanSeekProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getCanSeekProperty();
    }
    pub fn getCanPauseProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getCanPauseProperty();
    }
    pub fn getAudioStreamCountProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getAudioStreamCountProperty();
    }
    pub fn getAudioStreamIndexProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getAudioStreamIndexProperty();
    }
    pub fn getPlaybackRateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getPlaybackRateProperty();
    }
    pub fn getIsLoopingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getIsLoopingProperty();
    }
    pub fn getPlayToSourceProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getPlayToSourceProperty();
    }
    pub fn getDefaultPlaybackRateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getDefaultPlaybackRateProperty();
    }
    pub fn getAspectRatioWidthProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getAspectRatioWidthProperty();
    }
    pub fn getAspectRatioHeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getAspectRatioHeightProperty();
    }
    pub fn getRealTimePlaybackProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getRealTimePlaybackProperty();
    }
    pub fn getAudioCategoryProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getAudioCategoryProperty();
    }
    pub fn getAudioDeviceTypeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getAudioDeviceTypeProperty();
    }
    pub fn getProtectionManagerProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getProtectionManagerProperty();
    }
    pub fn getStereo3DVideoPackingModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getStereo3DVideoPackingModeProperty();
    }
    pub fn getStereo3DVideoRenderModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getStereo3DVideoRenderModeProperty();
    }
    pub fn getIsStereo3DVideoProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getIsStereo3DVideoProperty();
    }
    pub fn getActualStereo3DVideoPackingModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaElementStaticsCache.get();
        return try _f.getActualStereo3DVideoPackingModeProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.MediaElement";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IMediaElement.GUID;
    pub const IID: Guid = IMediaElement.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IMediaElement.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IMediaElementStatics2Cache: FactoryCache(IMediaElementStatics2, RUNTIME_NAME) = .{};
    var _IMediaElementStaticsCache: FactoryCache(IMediaElementStatics, RUNTIME_NAME) = .{};
};
pub const MediaPlayerElement = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getSource(self: *@This()) core.HResult!*IMediaPlaybackSource {
        const this: *IMediaPlayerElement = @ptrCast(self);
        return try this.getSource();
    }
    pub fn putSource(self: *@This(), value: *IMediaPlaybackSource) core.HResult!void {
        const this: *IMediaPlayerElement = @ptrCast(self);
        return try this.putSource(value);
    }
    pub fn getTransportControls(self: *@This()) core.HResult!*MediaTransportControls {
        const this: *IMediaPlayerElement = @ptrCast(self);
        return try this.getTransportControls();
    }
    pub fn putTransportControls(self: *@This(), value: *MediaTransportControls) core.HResult!void {
        const this: *IMediaPlayerElement = @ptrCast(self);
        return try this.putTransportControls(value);
    }
    pub fn getAreTransportControlsEnabled(self: *@This()) core.HResult!bool {
        const this: *IMediaPlayerElement = @ptrCast(self);
        return try this.getAreTransportControlsEnabled();
    }
    pub fn putAreTransportControlsEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaPlayerElement = @ptrCast(self);
        return try this.putAreTransportControlsEnabled(value);
    }
    pub fn getPosterSource(self: *@This()) core.HResult!*ImageSource {
        const this: *IMediaPlayerElement = @ptrCast(self);
        return try this.getPosterSource();
    }
    pub fn putPosterSource(self: *@This(), value: *ImageSource) core.HResult!void {
        const this: *IMediaPlayerElement = @ptrCast(self);
        return try this.putPosterSource(value);
    }
    pub fn getStretch(self: *@This()) core.HResult!Stretch {
        const this: *IMediaPlayerElement = @ptrCast(self);
        return try this.getStretch();
    }
    pub fn putStretch(self: *@This(), value: Stretch) core.HResult!void {
        const this: *IMediaPlayerElement = @ptrCast(self);
        return try this.putStretch(value);
    }
    pub fn getAutoPlay(self: *@This()) core.HResult!bool {
        const this: *IMediaPlayerElement = @ptrCast(self);
        return try this.getAutoPlay();
    }
    pub fn putAutoPlay(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaPlayerElement = @ptrCast(self);
        return try this.putAutoPlay(value);
    }
    pub fn getIsFullWindow(self: *@This()) core.HResult!bool {
        const this: *IMediaPlayerElement = @ptrCast(self);
        return try this.getIsFullWindow();
    }
    pub fn putIsFullWindow(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaPlayerElement = @ptrCast(self);
        return try this.putIsFullWindow(value);
    }
    pub fn getMediaPlayer(self: *@This()) core.HResult!*MediaPlayer {
        const this: *IMediaPlayerElement = @ptrCast(self);
        return try this.getMediaPlayer();
    }
    pub fn SetMediaPlayer(self: *@This(), mediaPlayer: *MediaPlayer) core.HResult!void {
        const this: *IMediaPlayerElement = @ptrCast(self);
        return try this.SetMediaPlayer(mediaPlayer);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getSourceProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaPlayerElementStaticsCache.get();
        return try _f.getSourceProperty();
    }
    pub fn getAreTransportControlsEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaPlayerElementStaticsCache.get();
        return try _f.getAreTransportControlsEnabledProperty();
    }
    pub fn getPosterSourceProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaPlayerElementStaticsCache.get();
        return try _f.getPosterSourceProperty();
    }
    pub fn getStretchProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaPlayerElementStaticsCache.get();
        return try _f.getStretchProperty();
    }
    pub fn getAutoPlayProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaPlayerElementStaticsCache.get();
        return try _f.getAutoPlayProperty();
    }
    pub fn getIsFullWindowProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaPlayerElementStaticsCache.get();
        return try _f.getIsFullWindowProperty();
    }
    pub fn getMediaPlayerProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaPlayerElementStaticsCache.get();
        return try _f.getMediaPlayerProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*MediaPlayerElement {
        const _f = @This().IMediaPlayerElementFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.MediaPlayerElement";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IMediaPlayerElement.GUID;
    pub const IID: Guid = IMediaPlayerElement.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IMediaPlayerElement.SIGNATURE);
    var _IMediaPlayerElementStaticsCache: FactoryCache(IMediaPlayerElementStatics, RUNTIME_NAME) = .{};
    var _IMediaPlayerElementFactoryCache: FactoryCache(IMediaPlayerElementFactory, RUNTIME_NAME) = .{};
};
pub const MediaPlayerPresenter = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getMediaPlayer(self: *@This()) core.HResult!*MediaPlayer {
        const this: *IMediaPlayerPresenter = @ptrCast(self);
        return try this.getMediaPlayer();
    }
    pub fn putMediaPlayer(self: *@This(), value: *MediaPlayer) core.HResult!void {
        const this: *IMediaPlayerPresenter = @ptrCast(self);
        return try this.putMediaPlayer(value);
    }
    pub fn getStretch(self: *@This()) core.HResult!Stretch {
        const this: *IMediaPlayerPresenter = @ptrCast(self);
        return try this.getStretch();
    }
    pub fn putStretch(self: *@This(), value: Stretch) core.HResult!void {
        const this: *IMediaPlayerPresenter = @ptrCast(self);
        return try this.putStretch(value);
    }
    pub fn getIsFullWindow(self: *@This()) core.HResult!bool {
        const this: *IMediaPlayerPresenter = @ptrCast(self);
        return try this.getIsFullWindow();
    }
    pub fn putIsFullWindow(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaPlayerPresenter = @ptrCast(self);
        return try this.putIsFullWindow(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getMediaPlayerProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaPlayerPresenterStaticsCache.get();
        return try _f.getMediaPlayerProperty();
    }
    pub fn getStretchProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaPlayerPresenterStaticsCache.get();
        return try _f.getStretchProperty();
    }
    pub fn getIsFullWindowProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaPlayerPresenterStaticsCache.get();
        return try _f.getIsFullWindowProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*MediaPlayerPresenter {
        const _f = @This().IMediaPlayerPresenterFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.MediaPlayerPresenter";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IMediaPlayerPresenter.GUID;
    pub const IID: Guid = IMediaPlayerPresenter.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IMediaPlayerPresenter.SIGNATURE);
    var _IMediaPlayerPresenterStaticsCache: FactoryCache(IMediaPlayerPresenterStatics, RUNTIME_NAME) = .{};
    var _IMediaPlayerPresenterFactoryCache: FactoryCache(IMediaPlayerPresenterFactory, RUNTIME_NAME) = .{};
};
pub const MediaTransportControls = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsFullWindowButtonVisible(self: *@This()) core.HResult!bool {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.getIsFullWindowButtonVisible();
    }
    pub fn putIsFullWindowButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.putIsFullWindowButtonVisible(value);
    }
    pub fn getIsFullWindowEnabled(self: *@This()) core.HResult!bool {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.getIsFullWindowEnabled();
    }
    pub fn putIsFullWindowEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.putIsFullWindowEnabled(value);
    }
    pub fn getIsZoomButtonVisible(self: *@This()) core.HResult!bool {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.getIsZoomButtonVisible();
    }
    pub fn putIsZoomButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.putIsZoomButtonVisible(value);
    }
    pub fn getIsZoomEnabled(self: *@This()) core.HResult!bool {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.getIsZoomEnabled();
    }
    pub fn putIsZoomEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.putIsZoomEnabled(value);
    }
    pub fn getIsFastForwardButtonVisible(self: *@This()) core.HResult!bool {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.getIsFastForwardButtonVisible();
    }
    pub fn putIsFastForwardButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.putIsFastForwardButtonVisible(value);
    }
    pub fn getIsFastForwardEnabled(self: *@This()) core.HResult!bool {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.getIsFastForwardEnabled();
    }
    pub fn putIsFastForwardEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.putIsFastForwardEnabled(value);
    }
    pub fn getIsFastRewindButtonVisible(self: *@This()) core.HResult!bool {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.getIsFastRewindButtonVisible();
    }
    pub fn putIsFastRewindButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.putIsFastRewindButtonVisible(value);
    }
    pub fn getIsFastRewindEnabled(self: *@This()) core.HResult!bool {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.getIsFastRewindEnabled();
    }
    pub fn putIsFastRewindEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.putIsFastRewindEnabled(value);
    }
    pub fn getIsStopButtonVisible(self: *@This()) core.HResult!bool {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.getIsStopButtonVisible();
    }
    pub fn putIsStopButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.putIsStopButtonVisible(value);
    }
    pub fn getIsStopEnabled(self: *@This()) core.HResult!bool {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.getIsStopEnabled();
    }
    pub fn putIsStopEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.putIsStopEnabled(value);
    }
    pub fn getIsVolumeButtonVisible(self: *@This()) core.HResult!bool {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.getIsVolumeButtonVisible();
    }
    pub fn putIsVolumeButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.putIsVolumeButtonVisible(value);
    }
    pub fn getIsVolumeEnabled(self: *@This()) core.HResult!bool {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.getIsVolumeEnabled();
    }
    pub fn putIsVolumeEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.putIsVolumeEnabled(value);
    }
    pub fn getIsPlaybackRateButtonVisible(self: *@This()) core.HResult!bool {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.getIsPlaybackRateButtonVisible();
    }
    pub fn putIsPlaybackRateButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.putIsPlaybackRateButtonVisible(value);
    }
    pub fn getIsPlaybackRateEnabled(self: *@This()) core.HResult!bool {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.getIsPlaybackRateEnabled();
    }
    pub fn putIsPlaybackRateEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.putIsPlaybackRateEnabled(value);
    }
    pub fn getIsSeekBarVisible(self: *@This()) core.HResult!bool {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.getIsSeekBarVisible();
    }
    pub fn putIsSeekBarVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.putIsSeekBarVisible(value);
    }
    pub fn getIsSeekEnabled(self: *@This()) core.HResult!bool {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.getIsSeekEnabled();
    }
    pub fn putIsSeekEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.putIsSeekEnabled(value);
    }
    pub fn getIsCompact(self: *@This()) core.HResult!bool {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.getIsCompact();
    }
    pub fn putIsCompact(self: *@This(), value: bool) core.HResult!void {
        const this: *IMediaTransportControls = @ptrCast(self);
        return try this.putIsCompact(value);
    }
    pub fn getIsSkipForwardButtonVisible(self: *@This()) core.HResult!bool {
        var this: ?*IMediaTransportControls2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsSkipForwardButtonVisible();
    }
    pub fn putIsSkipForwardButtonVisible(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IMediaTransportControls2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsSkipForwardButtonVisible(value);
    }
    pub fn getIsSkipForwardEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IMediaTransportControls2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsSkipForwardEnabled();
    }
    pub fn putIsSkipForwardEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IMediaTransportControls2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsSkipForwardEnabled(value);
    }
    pub fn getIsSkipBackwardButtonVisible(self: *@This()) core.HResult!bool {
        var this: ?*IMediaTransportControls2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsSkipBackwardButtonVisible();
    }
    pub fn putIsSkipBackwardButtonVisible(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IMediaTransportControls2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsSkipBackwardButtonVisible(value);
    }
    pub fn getIsSkipBackwardEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IMediaTransportControls2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsSkipBackwardEnabled();
    }
    pub fn putIsSkipBackwardEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IMediaTransportControls2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsSkipBackwardEnabled(value);
    }
    pub fn getIsNextTrackButtonVisible(self: *@This()) core.HResult!bool {
        var this: ?*IMediaTransportControls2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsNextTrackButtonVisible();
    }
    pub fn putIsNextTrackButtonVisible(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IMediaTransportControls2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsNextTrackButtonVisible(value);
    }
    pub fn getIsPreviousTrackButtonVisible(self: *@This()) core.HResult!bool {
        var this: ?*IMediaTransportControls2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsPreviousTrackButtonVisible();
    }
    pub fn putIsPreviousTrackButtonVisible(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IMediaTransportControls2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsPreviousTrackButtonVisible(value);
    }
    pub fn getFastPlayFallbackBehaviour(self: *@This()) core.HResult!FastPlayFallbackBehaviour {
        var this: ?*IMediaTransportControls2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getFastPlayFallbackBehaviour();
    }
    pub fn putFastPlayFallbackBehaviour(self: *@This(), value: FastPlayFallbackBehaviour) core.HResult!void {
        var this: ?*IMediaTransportControls2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putFastPlayFallbackBehaviour(value);
    }
    pub fn addThumbnailRequested(self: *@This(), handler: *TypedEventHandler(MediaTransportControls,MediaTransportControlsThumbnailRequestedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IMediaTransportControls2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addThumbnailRequested(handler);
    }
    pub fn removeThumbnailRequested(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IMediaTransportControls2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeThumbnailRequested(token);
    }
    pub fn getShowAndHideAutomatically(self: *@This()) core.HResult!bool {
        var this: ?*IMediaTransportControls3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getShowAndHideAutomatically();
    }
    pub fn putShowAndHideAutomatically(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IMediaTransportControls3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putShowAndHideAutomatically(value);
    }
    pub fn getIsRepeatEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IMediaTransportControls3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsRepeatEnabled();
    }
    pub fn putIsRepeatEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IMediaTransportControls3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsRepeatEnabled(value);
    }
    pub fn getIsRepeatButtonVisible(self: *@This()) core.HResult!bool {
        var this: ?*IMediaTransportControls3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsRepeatButtonVisible();
    }
    pub fn putIsRepeatButtonVisible(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IMediaTransportControls3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsRepeatButtonVisible(value);
    }
    pub fn Show(self: *@This()) core.HResult!void {
        var this: ?*IMediaTransportControls3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.Show();
    }
    pub fn Hide(self: *@This()) core.HResult!void {
        var this: ?*IMediaTransportControls3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.Hide();
    }
    pub fn getIsCompactOverlayButtonVisible(self: *@This()) core.HResult!bool {
        var this: ?*IMediaTransportControls4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsCompactOverlayButtonVisible();
    }
    pub fn putIsCompactOverlayButtonVisible(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IMediaTransportControls4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsCompactOverlayButtonVisible(value);
    }
    pub fn getIsCompactOverlayEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IMediaTransportControls4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsCompactOverlayEnabled();
    }
    pub fn putIsCompactOverlayEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IMediaTransportControls4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMediaTransportControls4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsCompactOverlayEnabled(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getIsCompactOverlayButtonVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStatics4Cache.get();
        return try _f.getIsCompactOverlayButtonVisibleProperty();
    }
    pub fn getIsCompactOverlayEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStatics4Cache.get();
        return try _f.getIsCompactOverlayEnabledProperty();
    }
    pub fn getShowAndHideAutomaticallyProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStatics3Cache.get();
        return try _f.getShowAndHideAutomaticallyProperty();
    }
    pub fn getIsRepeatEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStatics3Cache.get();
        return try _f.getIsRepeatEnabledProperty();
    }
    pub fn getIsRepeatButtonVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStatics3Cache.get();
        return try _f.getIsRepeatButtonVisibleProperty();
    }
    pub fn getIsSkipForwardButtonVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStatics2Cache.get();
        return try _f.getIsSkipForwardButtonVisibleProperty();
    }
    pub fn getIsSkipForwardEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStatics2Cache.get();
        return try _f.getIsSkipForwardEnabledProperty();
    }
    pub fn getIsSkipBackwardButtonVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStatics2Cache.get();
        return try _f.getIsSkipBackwardButtonVisibleProperty();
    }
    pub fn getIsSkipBackwardEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStatics2Cache.get();
        return try _f.getIsSkipBackwardEnabledProperty();
    }
    pub fn getIsNextTrackButtonVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStatics2Cache.get();
        return try _f.getIsNextTrackButtonVisibleProperty();
    }
    pub fn getIsPreviousTrackButtonVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStatics2Cache.get();
        return try _f.getIsPreviousTrackButtonVisibleProperty();
    }
    pub fn getFastPlayFallbackBehaviourProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStatics2Cache.get();
        return try _f.getFastPlayFallbackBehaviourProperty();
    }
    pub fn getIsFullWindowButtonVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStaticsCache.get();
        return try _f.getIsFullWindowButtonVisibleProperty();
    }
    pub fn getIsFullWindowEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStaticsCache.get();
        return try _f.getIsFullWindowEnabledProperty();
    }
    pub fn getIsZoomButtonVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStaticsCache.get();
        return try _f.getIsZoomButtonVisibleProperty();
    }
    pub fn getIsZoomEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStaticsCache.get();
        return try _f.getIsZoomEnabledProperty();
    }
    pub fn getIsFastForwardButtonVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStaticsCache.get();
        return try _f.getIsFastForwardButtonVisibleProperty();
    }
    pub fn getIsFastForwardEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStaticsCache.get();
        return try _f.getIsFastForwardEnabledProperty();
    }
    pub fn getIsFastRewindButtonVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStaticsCache.get();
        return try _f.getIsFastRewindButtonVisibleProperty();
    }
    pub fn getIsFastRewindEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStaticsCache.get();
        return try _f.getIsFastRewindEnabledProperty();
    }
    pub fn getIsStopButtonVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStaticsCache.get();
        return try _f.getIsStopButtonVisibleProperty();
    }
    pub fn getIsStopEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStaticsCache.get();
        return try _f.getIsStopEnabledProperty();
    }
    pub fn getIsVolumeButtonVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStaticsCache.get();
        return try _f.getIsVolumeButtonVisibleProperty();
    }
    pub fn getIsVolumeEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStaticsCache.get();
        return try _f.getIsVolumeEnabledProperty();
    }
    pub fn getIsPlaybackRateButtonVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStaticsCache.get();
        return try _f.getIsPlaybackRateButtonVisibleProperty();
    }
    pub fn getIsPlaybackRateEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStaticsCache.get();
        return try _f.getIsPlaybackRateEnabledProperty();
    }
    pub fn getIsSeekBarVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStaticsCache.get();
        return try _f.getIsSeekBarVisibleProperty();
    }
    pub fn getIsSeekEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStaticsCache.get();
        return try _f.getIsSeekEnabledProperty();
    }
    pub fn getIsCompactProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsStaticsCache.get();
        return try _f.getIsCompactProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*MediaTransportControls {
        const _f = @This().IMediaTransportControlsFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.MediaTransportControls";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IMediaTransportControls.GUID;
    pub const IID: Guid = IMediaTransportControls.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IMediaTransportControls.SIGNATURE);
    var _IMediaTransportControlsStatics4Cache: FactoryCache(IMediaTransportControlsStatics4, RUNTIME_NAME) = .{};
    var _IMediaTransportControlsStatics3Cache: FactoryCache(IMediaTransportControlsStatics3, RUNTIME_NAME) = .{};
    var _IMediaTransportControlsStatics2Cache: FactoryCache(IMediaTransportControlsStatics2, RUNTIME_NAME) = .{};
    var _IMediaTransportControlsStaticsCache: FactoryCache(IMediaTransportControlsStatics, RUNTIME_NAME) = .{};
    var _IMediaTransportControlsFactoryCache: FactoryCache(IMediaTransportControlsFactory, RUNTIME_NAME) = .{};
};
pub const MediaTransportControlsHelper = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getDropoutOrderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMediaTransportControlsHelperStaticsCache.get();
        return try _f.getDropoutOrderProperty();
    }
    pub fn GetDropoutOrder(element: *UIElement) core.HResult!*IReference(i32) {
        const _f = @This().IMediaTransportControlsHelperStaticsCache.get();
        return try _f.GetDropoutOrder(element);
    }
    pub fn SetDropoutOrder(element: *UIElement, value: *IReference(i32)) core.HResult!void {
        const _f = @This().IMediaTransportControlsHelperStaticsCache.get();
        return try _f.SetDropoutOrder(element, value);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.MediaTransportControlsHelper";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IMediaTransportControlsHelper.GUID;
    pub const IID: Guid = IMediaTransportControlsHelper.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IMediaTransportControlsHelper.SIGNATURE);
    var _IMediaTransportControlsHelperStaticsCache: FactoryCache(IMediaTransportControlsHelperStatics, RUNTIME_NAME) = .{};
};
pub const MenuBar = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getItems(self: *@This()) core.HResult!*IVector(MenuBarItem) {
        const this: *IMenuBar = @ptrCast(self);
        return try this.getItems();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getItemsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMenuBarStaticsCache.get();
        return try _f.getItemsProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*MenuBar {
        const _f = @This().IMenuBarFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.MenuBar";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IMenuBar.GUID;
    pub const IID: Guid = IMenuBar.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IMenuBar.SIGNATURE);
    var _IMenuBarStaticsCache: FactoryCache(IMenuBarStatics, RUNTIME_NAME) = .{};
    var _IMenuBarFactoryCache: FactoryCache(IMenuBarFactory, RUNTIME_NAME) = .{};
};
pub const MenuBarItem = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getTitle(self: *@This()) core.HResult!HSTRING {
        const this: *IMenuBarItem = @ptrCast(self);
        return try this.getTitle();
    }
    pub fn putTitle(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IMenuBarItem = @ptrCast(self);
        return try this.putTitle(value);
    }
    pub fn getItems(self: *@This()) core.HResult!*IVector(MenuFlyoutItemBase) {
        const this: *IMenuBarItem = @ptrCast(self);
        return try this.getItems();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getTitleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMenuBarItemStaticsCache.get();
        return try _f.getTitleProperty();
    }
    pub fn getItemsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMenuBarItemStaticsCache.get();
        return try _f.getItemsProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*MenuBarItem {
        const _f = @This().IMenuBarItemFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.MenuBarItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IMenuBarItem.GUID;
    pub const IID: Guid = IMenuBarItem.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IMenuBarItem.SIGNATURE);
    var _IMenuBarItemStaticsCache: FactoryCache(IMenuBarItemStatics, RUNTIME_NAME) = .{};
    var _IMenuBarItemFactoryCache: FactoryCache(IMenuBarItemFactory, RUNTIME_NAME) = .{};
};
pub const MenuFlyout = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getItems(self: *@This()) core.HResult!*IVector(MenuFlyoutItemBase) {
        const this: *IMenuFlyout = @ptrCast(self);
        return try this.getItems();
    }
    pub fn getMenuFlyoutPresenterStyle(self: *@This()) core.HResult!*Style {
        const this: *IMenuFlyout = @ptrCast(self);
        return try this.getMenuFlyoutPresenterStyle();
    }
    pub fn putMenuFlyoutPresenterStyle(self: *@This(), value: *Style) core.HResult!void {
        const this: *IMenuFlyout = @ptrCast(self);
        return try this.putMenuFlyoutPresenterStyle(value);
    }
    pub fn ShowAt(self: *@This(), targetElement: *UIElement, point: Point) core.HResult!void {
        var this: ?*IMenuFlyout2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMenuFlyout2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.ShowAt(targetElement, point);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getMenuFlyoutPresenterStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMenuFlyoutStaticsCache.get();
        return try _f.getMenuFlyoutPresenterStyleProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*MenuFlyout {
        const _f = @This().IMenuFlyoutFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.MenuFlyout";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IMenuFlyout.GUID;
    pub const IID: Guid = IMenuFlyout.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IMenuFlyout.SIGNATURE);
    var _IMenuFlyoutStaticsCache: FactoryCache(IMenuFlyoutStatics, RUNTIME_NAME) = .{};
    var _IMenuFlyoutFactoryCache: FactoryCache(IMenuFlyoutFactory, RUNTIME_NAME) = .{};
};
pub const MenuBarItemFlyout = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*MenuBarItemFlyout {
        const _f = @This().IMenuBarItemFlyoutFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.MenuBarItemFlyout";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IMenuBarItemFlyout.GUID;
    pub const IID: Guid = IMenuBarItemFlyout.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IMenuBarItemFlyout.SIGNATURE);
    var _IMenuBarItemFlyoutFactoryCache: FactoryCache(IMenuBarItemFlyoutFactory, RUNTIME_NAME) = .{};
};
pub const MenuFlyoutItemBase = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.MenuFlyoutItemBase";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IMenuFlyoutItemBase.GUID;
    pub const IID: Guid = IMenuFlyoutItemBase.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IMenuFlyoutItemBase.SIGNATURE);
    var _IMenuFlyoutItemBaseFactoryCache: FactoryCache(IMenuFlyoutItemBaseFactory, RUNTIME_NAME) = .{};
};
pub const MenuFlyoutItem = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getText(self: *@This()) core.HResult!HSTRING {
        const this: *IMenuFlyoutItem = @ptrCast(self);
        return try this.getText();
    }
    pub fn putText(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IMenuFlyoutItem = @ptrCast(self);
        return try this.putText(value);
    }
    pub fn getCommand(self: *@This()) core.HResult!*ICommand {
        const this: *IMenuFlyoutItem = @ptrCast(self);
        return try this.getCommand();
    }
    pub fn putCommand(self: *@This(), value: *ICommand) core.HResult!void {
        const this: *IMenuFlyoutItem = @ptrCast(self);
        return try this.putCommand(value);
    }
    pub fn getCommandParameter(self: *@This()) core.HResult!*IInspectable {
        const this: *IMenuFlyoutItem = @ptrCast(self);
        return try this.getCommandParameter();
    }
    pub fn putCommandParameter(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IMenuFlyoutItem = @ptrCast(self);
        return try this.putCommandParameter(value);
    }
    pub fn addClick(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IMenuFlyoutItem = @ptrCast(self);
        return try this.addClick(handler);
    }
    pub fn removeClick(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IMenuFlyoutItem = @ptrCast(self);
        return try this.removeClick(token);
    }
    pub fn getIcon(self: *@This()) core.HResult!*IconElement {
        var this: ?*IMenuFlyoutItem2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMenuFlyoutItem2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIcon();
    }
    pub fn putIcon(self: *@This(), value: *IconElement) core.HResult!void {
        var this: ?*IMenuFlyoutItem2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMenuFlyoutItem2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIcon(value);
    }
    pub fn getKeyboardAcceleratorTextOverride(self: *@This()) core.HResult!HSTRING {
        var this: ?*IMenuFlyoutItem3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMenuFlyoutItem3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getKeyboardAcceleratorTextOverride();
    }
    pub fn putKeyboardAcceleratorTextOverride(self: *@This(), value: HSTRING) core.HResult!void {
        var this: ?*IMenuFlyoutItem3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMenuFlyoutItem3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putKeyboardAcceleratorTextOverride(value);
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*MenuFlyoutItemTemplateSettings {
        var this: ?*IMenuFlyoutItem3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMenuFlyoutItem3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTemplateSettings();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMenuFlyoutItemStaticsCache.get();
        return try _f.getTextProperty();
    }
    pub fn getCommandProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMenuFlyoutItemStaticsCache.get();
        return try _f.getCommandProperty();
    }
    pub fn getCommandParameterProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMenuFlyoutItemStaticsCache.get();
        return try _f.getCommandParameterProperty();
    }
    pub fn getKeyboardAcceleratorTextOverrideProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMenuFlyoutItemStatics3Cache.get();
        return try _f.getKeyboardAcceleratorTextOverrideProperty();
    }
    pub fn getIconProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMenuFlyoutItemStatics2Cache.get();
        return try _f.getIconProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*MenuFlyoutItem {
        const _f = @This().IMenuFlyoutItemFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.MenuFlyoutItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IMenuFlyoutItem.GUID;
    pub const IID: Guid = IMenuFlyoutItem.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IMenuFlyoutItem.SIGNATURE);
    var _IMenuFlyoutItemStaticsCache: FactoryCache(IMenuFlyoutItemStatics, RUNTIME_NAME) = .{};
    var _IMenuFlyoutItemStatics3Cache: FactoryCache(IMenuFlyoutItemStatics3, RUNTIME_NAME) = .{};
    var _IMenuFlyoutItemStatics2Cache: FactoryCache(IMenuFlyoutItemStatics2, RUNTIME_NAME) = .{};
    var _IMenuFlyoutItemFactoryCache: FactoryCache(IMenuFlyoutItemFactory, RUNTIME_NAME) = .{};
};
pub const MenuFlyoutPresenter = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getTemplateSettings(self: *@This()) core.HResult!*MenuFlyoutPresenterTemplateSettings {
        var this: ?*IMenuFlyoutPresenter2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMenuFlyoutPresenter2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTemplateSettings();
    }
    pub fn getIsDefaultShadowEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IMenuFlyoutPresenter3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMenuFlyoutPresenter3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsDefaultShadowEnabled();
    }
    pub fn putIsDefaultShadowEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IMenuFlyoutPresenter3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMenuFlyoutPresenter3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsDefaultShadowEnabled(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getIsDefaultShadowEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMenuFlyoutPresenterStatics3Cache.get();
        return try _f.getIsDefaultShadowEnabledProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*MenuFlyoutPresenter {
        const _f = @This().IMenuFlyoutPresenterFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.MenuFlyoutPresenter";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IMenuFlyoutPresenter.GUID;
    pub const IID: Guid = IMenuFlyoutPresenter.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IMenuFlyoutPresenter.SIGNATURE);
    var _IMenuFlyoutPresenterStatics3Cache: FactoryCache(IMenuFlyoutPresenterStatics3, RUNTIME_NAME) = .{};
    var _IMenuFlyoutPresenterFactoryCache: FactoryCache(IMenuFlyoutPresenterFactory, RUNTIME_NAME) = .{};
};
pub const MenuFlyoutSeparator = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*MenuFlyoutSeparator {
        const _f = @This().IMenuFlyoutSeparatorFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.MenuFlyoutSeparator";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IMenuFlyoutSeparator.GUID;
    pub const IID: Guid = IMenuFlyoutSeparator.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IMenuFlyoutSeparator.SIGNATURE);
    var _IMenuFlyoutSeparatorFactoryCache: FactoryCache(IMenuFlyoutSeparatorFactory, RUNTIME_NAME) = .{};
};
pub const MenuFlyoutSubItem = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getItems(self: *@This()) core.HResult!*IVector(MenuFlyoutItemBase) {
        const this: *IMenuFlyoutSubItem = @ptrCast(self);
        return try this.getItems();
    }
    pub fn getText(self: *@This()) core.HResult!HSTRING {
        const this: *IMenuFlyoutSubItem = @ptrCast(self);
        return try this.getText();
    }
    pub fn putText(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IMenuFlyoutSubItem = @ptrCast(self);
        return try this.putText(value);
    }
    pub fn getIcon(self: *@This()) core.HResult!*IconElement {
        var this: ?*IMenuFlyoutSubItem2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMenuFlyoutSubItem2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIcon();
    }
    pub fn putIcon(self: *@This(), value: *IconElement) core.HResult!void {
        var this: ?*IMenuFlyoutSubItem2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IMenuFlyoutSubItem2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIcon(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IMenuFlyoutSubItem.IID)));
    }
    pub fn getIconProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMenuFlyoutSubItemStatics2Cache.get();
        return try _f.getIconProperty();
    }
    pub fn getTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().IMenuFlyoutSubItemStaticsCache.get();
        return try _f.getTextProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.MenuFlyoutSubItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IMenuFlyoutSubItem.GUID;
    pub const IID: Guid = IMenuFlyoutSubItem.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IMenuFlyoutSubItem.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IMenuFlyoutSubItemStatics2Cache: FactoryCache(IMenuFlyoutSubItemStatics2, RUNTIME_NAME) = .{};
    var _IMenuFlyoutSubItemStaticsCache: FactoryCache(IMenuFlyoutSubItemStatics, RUNTIME_NAME) = .{};
};
pub const NavigationView = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsPaneOpen(self: *@This()) core.HResult!bool {
        const this: *INavigationView = @ptrCast(self);
        return try this.getIsPaneOpen();
    }
    pub fn putIsPaneOpen(self: *@This(), value: bool) core.HResult!void {
        const this: *INavigationView = @ptrCast(self);
        return try this.putIsPaneOpen(value);
    }
    pub fn getCompactModeThresholdWidth(self: *@This()) core.HResult!f64 {
        const this: *INavigationView = @ptrCast(self);
        return try this.getCompactModeThresholdWidth();
    }
    pub fn putCompactModeThresholdWidth(self: *@This(), value: f64) core.HResult!void {
        const this: *INavigationView = @ptrCast(self);
        return try this.putCompactModeThresholdWidth(value);
    }
    pub fn getExpandedModeThresholdWidth(self: *@This()) core.HResult!f64 {
        const this: *INavigationView = @ptrCast(self);
        return try this.getExpandedModeThresholdWidth();
    }
    pub fn putExpandedModeThresholdWidth(self: *@This(), value: f64) core.HResult!void {
        const this: *INavigationView = @ptrCast(self);
        return try this.putExpandedModeThresholdWidth(value);
    }
    pub fn getPaneFooter(self: *@This()) core.HResult!*UIElement {
        const this: *INavigationView = @ptrCast(self);
        return try this.getPaneFooter();
    }
    pub fn putPaneFooter(self: *@This(), value: *UIElement) core.HResult!void {
        const this: *INavigationView = @ptrCast(self);
        return try this.putPaneFooter(value);
    }
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        const this: *INavigationView = @ptrCast(self);
        return try this.getHeader();
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *INavigationView = @ptrCast(self);
        return try this.putHeader(value);
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        const this: *INavigationView = @ptrCast(self);
        return try this.getHeaderTemplate();
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const this: *INavigationView = @ptrCast(self);
        return try this.putHeaderTemplate(value);
    }
    pub fn getDisplayMode(self: *@This()) core.HResult!NavigationViewDisplayMode {
        const this: *INavigationView = @ptrCast(self);
        return try this.getDisplayMode();
    }
    pub fn getIsSettingsVisible(self: *@This()) core.HResult!bool {
        const this: *INavigationView = @ptrCast(self);
        return try this.getIsSettingsVisible();
    }
    pub fn putIsSettingsVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *INavigationView = @ptrCast(self);
        return try this.putIsSettingsVisible(value);
    }
    pub fn getIsPaneToggleButtonVisible(self: *@This()) core.HResult!bool {
        const this: *INavigationView = @ptrCast(self);
        return try this.getIsPaneToggleButtonVisible();
    }
    pub fn putIsPaneToggleButtonVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *INavigationView = @ptrCast(self);
        return try this.putIsPaneToggleButtonVisible(value);
    }
    pub fn getAlwaysShowHeader(self: *@This()) core.HResult!bool {
        const this: *INavigationView = @ptrCast(self);
        return try this.getAlwaysShowHeader();
    }
    pub fn putAlwaysShowHeader(self: *@This(), value: bool) core.HResult!void {
        const this: *INavigationView = @ptrCast(self);
        return try this.putAlwaysShowHeader(value);
    }
    pub fn getCompactPaneLength(self: *@This()) core.HResult!f64 {
        const this: *INavigationView = @ptrCast(self);
        return try this.getCompactPaneLength();
    }
    pub fn putCompactPaneLength(self: *@This(), value: f64) core.HResult!void {
        const this: *INavigationView = @ptrCast(self);
        return try this.putCompactPaneLength(value);
    }
    pub fn getOpenPaneLength(self: *@This()) core.HResult!f64 {
        const this: *INavigationView = @ptrCast(self);
        return try this.getOpenPaneLength();
    }
    pub fn putOpenPaneLength(self: *@This(), value: f64) core.HResult!void {
        const this: *INavigationView = @ptrCast(self);
        return try this.putOpenPaneLength(value);
    }
    pub fn getPaneToggleButtonStyle(self: *@This()) core.HResult!*Style {
        const this: *INavigationView = @ptrCast(self);
        return try this.getPaneToggleButtonStyle();
    }
    pub fn putPaneToggleButtonStyle(self: *@This(), value: *Style) core.HResult!void {
        const this: *INavigationView = @ptrCast(self);
        return try this.putPaneToggleButtonStyle(value);
    }
    pub fn getSelectedItem(self: *@This()) core.HResult!*IInspectable {
        const this: *INavigationView = @ptrCast(self);
        return try this.getSelectedItem();
    }
    pub fn putSelectedItem(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *INavigationView = @ptrCast(self);
        return try this.putSelectedItem(value);
    }
    pub fn getMenuItems(self: *@This()) core.HResult!*IVector(IInspectable) {
        const this: *INavigationView = @ptrCast(self);
        return try this.getMenuItems();
    }
    pub fn getMenuItemsSource(self: *@This()) core.HResult!*IInspectable {
        const this: *INavigationView = @ptrCast(self);
        return try this.getMenuItemsSource();
    }
    pub fn putMenuItemsSource(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *INavigationView = @ptrCast(self);
        return try this.putMenuItemsSource(value);
    }
    pub fn getSettingsItem(self: *@This()) core.HResult!*IInspectable {
        const this: *INavigationView = @ptrCast(self);
        return try this.getSettingsItem();
    }
    pub fn getAutoSuggestBox(self: *@This()) core.HResult!*AutoSuggestBox {
        const this: *INavigationView = @ptrCast(self);
        return try this.getAutoSuggestBox();
    }
    pub fn putAutoSuggestBox(self: *@This(), value: *AutoSuggestBox) core.HResult!void {
        const this: *INavigationView = @ptrCast(self);
        return try this.putAutoSuggestBox(value);
    }
    pub fn getMenuItemTemplate(self: *@This()) core.HResult!*DataTemplate {
        const this: *INavigationView = @ptrCast(self);
        return try this.getMenuItemTemplate();
    }
    pub fn putMenuItemTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const this: *INavigationView = @ptrCast(self);
        return try this.putMenuItemTemplate(value);
    }
    pub fn getMenuItemTemplateSelector(self: *@This()) core.HResult!*DataTemplateSelector {
        const this: *INavigationView = @ptrCast(self);
        return try this.getMenuItemTemplateSelector();
    }
    pub fn putMenuItemTemplateSelector(self: *@This(), value: *DataTemplateSelector) core.HResult!void {
        const this: *INavigationView = @ptrCast(self);
        return try this.putMenuItemTemplateSelector(value);
    }
    pub fn getMenuItemContainerStyle(self: *@This()) core.HResult!*Style {
        const this: *INavigationView = @ptrCast(self);
        return try this.getMenuItemContainerStyle();
    }
    pub fn putMenuItemContainerStyle(self: *@This(), value: *Style) core.HResult!void {
        const this: *INavigationView = @ptrCast(self);
        return try this.putMenuItemContainerStyle(value);
    }
    pub fn getMenuItemContainerStyleSelector(self: *@This()) core.HResult!*StyleSelector {
        const this: *INavigationView = @ptrCast(self);
        return try this.getMenuItemContainerStyleSelector();
    }
    pub fn putMenuItemContainerStyleSelector(self: *@This(), value: *StyleSelector) core.HResult!void {
        const this: *INavigationView = @ptrCast(self);
        return try this.putMenuItemContainerStyleSelector(value);
    }
    pub fn MenuItemFromContainer(self: *@This(), container: *DependencyObject) core.HResult!*IInspectable {
        const this: *INavigationView = @ptrCast(self);
        return try this.MenuItemFromContainer(container);
    }
    pub fn ContainerFromMenuItem(self: *@This(), item: *IInspectable) core.HResult!*DependencyObject {
        const this: *INavigationView = @ptrCast(self);
        return try this.ContainerFromMenuItem(item);
    }
    pub fn addSelectionChanged(self: *@This(), handler: *TypedEventHandler(NavigationView,NavigationViewSelectionChangedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *INavigationView = @ptrCast(self);
        return try this.addSelectionChanged(handler);
    }
    pub fn removeSelectionChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *INavigationView = @ptrCast(self);
        return try this.removeSelectionChanged(token);
    }
    pub fn addItemInvoked(self: *@This(), handler: *TypedEventHandler(NavigationView,NavigationViewItemInvokedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *INavigationView = @ptrCast(self);
        return try this.addItemInvoked(handler);
    }
    pub fn removeItemInvoked(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *INavigationView = @ptrCast(self);
        return try this.removeItemInvoked(token);
    }
    pub fn addDisplayModeChanged(self: *@This(), handler: *TypedEventHandler(NavigationView,NavigationViewDisplayModeChangedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *INavigationView = @ptrCast(self);
        return try this.addDisplayModeChanged(handler);
    }
    pub fn removeDisplayModeChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *INavigationView = @ptrCast(self);
        return try this.removeDisplayModeChanged(token);
    }
    pub fn getIsBackButtonVisible(self: *@This()) core.HResult!NavigationViewBackButtonVisible {
        var this: ?*INavigationView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsBackButtonVisible();
    }
    pub fn putIsBackButtonVisible(self: *@This(), value: NavigationViewBackButtonVisible) core.HResult!void {
        var this: ?*INavigationView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsBackButtonVisible(value);
    }
    pub fn getIsBackEnabled(self: *@This()) core.HResult!bool {
        var this: ?*INavigationView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsBackEnabled();
    }
    pub fn putIsBackEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*INavigationView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsBackEnabled(value);
    }
    pub fn getPaneTitle(self: *@This()) core.HResult!HSTRING {
        var this: ?*INavigationView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getPaneTitle();
    }
    pub fn putPaneTitle(self: *@This(), value: HSTRING) core.HResult!void {
        var this: ?*INavigationView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putPaneTitle(value);
    }
    pub fn addBackRequested(self: *@This(), handler: *TypedEventHandler(NavigationView,NavigationViewBackRequestedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*INavigationView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addBackRequested(handler);
    }
    pub fn removeBackRequested(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*INavigationView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeBackRequested(token);
    }
    pub fn addPaneClosed(self: *@This(), handler: *TypedEventHandler(NavigationView,IInspectable)) core.HResult!EventRegistrationToken {
        var this: ?*INavigationView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addPaneClosed(handler);
    }
    pub fn removePaneClosed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*INavigationView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removePaneClosed(token);
    }
    pub fn addPaneClosing(self: *@This(), handler: *TypedEventHandler(NavigationView,NavigationViewPaneClosingEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*INavigationView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addPaneClosing(handler);
    }
    pub fn removePaneClosing(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*INavigationView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removePaneClosing(token);
    }
    pub fn addPaneOpened(self: *@This(), handler: *TypedEventHandler(NavigationView,IInspectable)) core.HResult!EventRegistrationToken {
        var this: ?*INavigationView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addPaneOpened(handler);
    }
    pub fn removePaneOpened(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*INavigationView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removePaneOpened(token);
    }
    pub fn addPaneOpening(self: *@This(), handler: *TypedEventHandler(NavigationView,IInspectable)) core.HResult!EventRegistrationToken {
        var this: ?*INavigationView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addPaneOpening(handler);
    }
    pub fn removePaneOpening(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*INavigationView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removePaneOpening(token);
    }
    pub fn getPaneDisplayMode(self: *@This()) core.HResult!NavigationViewPaneDisplayMode {
        var this: ?*INavigationView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getPaneDisplayMode();
    }
    pub fn putPaneDisplayMode(self: *@This(), value: NavigationViewPaneDisplayMode) core.HResult!void {
        var this: ?*INavigationView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putPaneDisplayMode(value);
    }
    pub fn getPaneHeader(self: *@This()) core.HResult!*UIElement {
        var this: ?*INavigationView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getPaneHeader();
    }
    pub fn putPaneHeader(self: *@This(), value: *UIElement) core.HResult!void {
        var this: ?*INavigationView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putPaneHeader(value);
    }
    pub fn getPaneCustomContent(self: *@This()) core.HResult!*UIElement {
        var this: ?*INavigationView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getPaneCustomContent();
    }
    pub fn putPaneCustomContent(self: *@This(), value: *UIElement) core.HResult!void {
        var this: ?*INavigationView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putPaneCustomContent(value);
    }
    pub fn getContentOverlay(self: *@This()) core.HResult!*UIElement {
        var this: ?*INavigationView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getContentOverlay();
    }
    pub fn putContentOverlay(self: *@This(), value: *UIElement) core.HResult!void {
        var this: ?*INavigationView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putContentOverlay(value);
    }
    pub fn getIsPaneVisible(self: *@This()) core.HResult!bool {
        var this: ?*INavigationView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsPaneVisible();
    }
    pub fn putIsPaneVisible(self: *@This(), value: bool) core.HResult!void {
        var this: ?*INavigationView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsPaneVisible(value);
    }
    pub fn getSelectionFollowsFocus(self: *@This()) core.HResult!NavigationViewSelectionFollowsFocus {
        var this: ?*INavigationView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectionFollowsFocus();
    }
    pub fn putSelectionFollowsFocus(self: *@This(), value: NavigationViewSelectionFollowsFocus) core.HResult!void {
        var this: ?*INavigationView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSelectionFollowsFocus(value);
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*NavigationViewTemplateSettings {
        var this: ?*INavigationView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTemplateSettings();
    }
    pub fn getShoulderNavigationEnabled(self: *@This()) core.HResult!NavigationViewShoulderNavigationEnabled {
        var this: ?*INavigationView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getShoulderNavigationEnabled();
    }
    pub fn putShoulderNavigationEnabled(self: *@This(), value: NavigationViewShoulderNavigationEnabled) core.HResult!void {
        var this: ?*INavigationView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putShoulderNavigationEnabled(value);
    }
    pub fn getOverflowLabelMode(self: *@This()) core.HResult!NavigationViewOverflowLabelMode {
        var this: ?*INavigationView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getOverflowLabelMode();
    }
    pub fn putOverflowLabelMode(self: *@This(), value: NavigationViewOverflowLabelMode) core.HResult!void {
        var this: ?*INavigationView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putOverflowLabelMode(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getPaneDisplayModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStatics3Cache.get();
        return try _f.getPaneDisplayModeProperty();
    }
    pub fn getPaneHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStatics3Cache.get();
        return try _f.getPaneHeaderProperty();
    }
    pub fn getPaneCustomContentProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStatics3Cache.get();
        return try _f.getPaneCustomContentProperty();
    }
    pub fn getContentOverlayProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStatics3Cache.get();
        return try _f.getContentOverlayProperty();
    }
    pub fn getIsPaneVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStatics3Cache.get();
        return try _f.getIsPaneVisibleProperty();
    }
    pub fn getSelectionFollowsFocusProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStatics3Cache.get();
        return try _f.getSelectionFollowsFocusProperty();
    }
    pub fn getTemplateSettingsProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStatics3Cache.get();
        return try _f.getTemplateSettingsProperty();
    }
    pub fn getShoulderNavigationEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStatics3Cache.get();
        return try _f.getShoulderNavigationEnabledProperty();
    }
    pub fn getOverflowLabelModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStatics3Cache.get();
        return try _f.getOverflowLabelModeProperty();
    }
    pub fn getIsBackButtonVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStatics2Cache.get();
        return try _f.getIsBackButtonVisibleProperty();
    }
    pub fn getIsBackEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStatics2Cache.get();
        return try _f.getIsBackEnabledProperty();
    }
    pub fn getPaneTitleProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStatics2Cache.get();
        return try _f.getPaneTitleProperty();
    }
    pub fn getIsPaneOpenProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStaticsCache.get();
        return try _f.getIsPaneOpenProperty();
    }
    pub fn getCompactModeThresholdWidthProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStaticsCache.get();
        return try _f.getCompactModeThresholdWidthProperty();
    }
    pub fn getExpandedModeThresholdWidthProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStaticsCache.get();
        return try _f.getExpandedModeThresholdWidthProperty();
    }
    pub fn getPaneFooterProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStaticsCache.get();
        return try _f.getPaneFooterProperty();
    }
    pub fn getHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStaticsCache.get();
        return try _f.getHeaderProperty();
    }
    pub fn getHeaderTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStaticsCache.get();
        return try _f.getHeaderTemplateProperty();
    }
    pub fn getDisplayModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStaticsCache.get();
        return try _f.getDisplayModeProperty();
    }
    pub fn getIsSettingsVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStaticsCache.get();
        return try _f.getIsSettingsVisibleProperty();
    }
    pub fn getIsPaneToggleButtonVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStaticsCache.get();
        return try _f.getIsPaneToggleButtonVisibleProperty();
    }
    pub fn getAlwaysShowHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStaticsCache.get();
        return try _f.getAlwaysShowHeaderProperty();
    }
    pub fn getCompactPaneLengthProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStaticsCache.get();
        return try _f.getCompactPaneLengthProperty();
    }
    pub fn getOpenPaneLengthProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStaticsCache.get();
        return try _f.getOpenPaneLengthProperty();
    }
    pub fn getPaneToggleButtonStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStaticsCache.get();
        return try _f.getPaneToggleButtonStyleProperty();
    }
    pub fn getMenuItemsProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStaticsCache.get();
        return try _f.getMenuItemsProperty();
    }
    pub fn getMenuItemsSourceProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStaticsCache.get();
        return try _f.getMenuItemsSourceProperty();
    }
    pub fn getSelectedItemProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStaticsCache.get();
        return try _f.getSelectedItemProperty();
    }
    pub fn getSettingsItemProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStaticsCache.get();
        return try _f.getSettingsItemProperty();
    }
    pub fn getAutoSuggestBoxProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStaticsCache.get();
        return try _f.getAutoSuggestBoxProperty();
    }
    pub fn getMenuItemTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStaticsCache.get();
        return try _f.getMenuItemTemplateProperty();
    }
    pub fn getMenuItemTemplateSelectorProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStaticsCache.get();
        return try _f.getMenuItemTemplateSelectorProperty();
    }
    pub fn getMenuItemContainerStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStaticsCache.get();
        return try _f.getMenuItemContainerStyleProperty();
    }
    pub fn getMenuItemContainerStyleSelectorProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewStaticsCache.get();
        return try _f.getMenuItemContainerStyleSelectorProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*NavigationView {
        const _f = @This().INavigationViewFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.NavigationView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = INavigationView.GUID;
    pub const IID: Guid = INavigationView.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, INavigationView.SIGNATURE);
    var _INavigationViewStatics3Cache: FactoryCache(INavigationViewStatics3, RUNTIME_NAME) = .{};
    var _INavigationViewStatics2Cache: FactoryCache(INavigationViewStatics2, RUNTIME_NAME) = .{};
    var _INavigationViewStaticsCache: FactoryCache(INavigationViewStatics, RUNTIME_NAME) = .{};
    var _INavigationViewFactoryCache: FactoryCache(INavigationViewFactory, RUNTIME_NAME) = .{};
};
pub const NavigationViewBackButtonVisible = enum(i32) {
    Collapsed = 0,
    Visible = 1,
    Auto = 2,
};
pub const NavigationViewBackRequestedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.NavigationViewBackRequestedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = INavigationViewBackRequestedEventArgs.GUID;
    pub const IID: Guid = INavigationViewBackRequestedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, INavigationViewBackRequestedEventArgs.SIGNATURE);
};
pub const NavigationViewDisplayMode = enum(i32) {
    Minimal = 0,
    Compact = 1,
    Expanded = 2,
};
pub const NavigationViewDisplayModeChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getDisplayMode(self: *@This()) core.HResult!NavigationViewDisplayMode {
        const this: *INavigationViewDisplayModeChangedEventArgs = @ptrCast(self);
        return try this.getDisplayMode();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.NavigationViewDisplayModeChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = INavigationViewDisplayModeChangedEventArgs.GUID;
    pub const IID: Guid = INavigationViewDisplayModeChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, INavigationViewDisplayModeChangedEventArgs.SIGNATURE);
};
pub const NavigationViewItemBase = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.NavigationViewItemBase";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = INavigationViewItemBase.GUID;
    pub const IID: Guid = INavigationViewItemBase.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, INavigationViewItemBase.SIGNATURE);
    var _INavigationViewItemBaseFactoryCache: FactoryCache(INavigationViewItemBaseFactory, RUNTIME_NAME) = .{};
};
pub const NavigationViewItem = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIcon(self: *@This()) core.HResult!*IconElement {
        const this: *INavigationViewItem = @ptrCast(self);
        return try this.getIcon();
    }
    pub fn putIcon(self: *@This(), value: *IconElement) core.HResult!void {
        const this: *INavigationViewItem = @ptrCast(self);
        return try this.putIcon(value);
    }
    pub fn getCompactPaneLength(self: *@This()) core.HResult!f64 {
        const this: *INavigationViewItem = @ptrCast(self);
        return try this.getCompactPaneLength();
    }
    pub fn getSelectsOnInvoked(self: *@This()) core.HResult!bool {
        var this: ?*INavigationViewItem2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationViewItem2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectsOnInvoked();
    }
    pub fn putSelectsOnInvoked(self: *@This(), value: bool) core.HResult!void {
        var this: ?*INavigationViewItem2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationViewItem2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSelectsOnInvoked(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getSelectsOnInvokedProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewItemStatics2Cache.get();
        return try _f.getSelectsOnInvokedProperty();
    }
    pub fn getIconProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewItemStaticsCache.get();
        return try _f.getIconProperty();
    }
    pub fn getCompactPaneLengthProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewItemStaticsCache.get();
        return try _f.getCompactPaneLengthProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*NavigationViewItem {
        const _f = @This().INavigationViewItemFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.NavigationViewItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = INavigationViewItem.GUID;
    pub const IID: Guid = INavigationViewItem.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, INavigationViewItem.SIGNATURE);
    var _INavigationViewItemStatics2Cache: FactoryCache(INavigationViewItemStatics2, RUNTIME_NAME) = .{};
    var _INavigationViewItemStaticsCache: FactoryCache(INavigationViewItemStatics, RUNTIME_NAME) = .{};
    var _INavigationViewItemFactoryCache: FactoryCache(INavigationViewItemFactory, RUNTIME_NAME) = .{};
};
pub const NavigationViewItemHeader = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*NavigationViewItemHeader {
        const _f = @This().INavigationViewItemHeaderFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.NavigationViewItemHeader";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = INavigationViewItemHeader.GUID;
    pub const IID: Guid = INavigationViewItemHeader.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, INavigationViewItemHeader.SIGNATURE);
    var _INavigationViewItemHeaderFactoryCache: FactoryCache(INavigationViewItemHeaderFactory, RUNTIME_NAME) = .{};
};
pub const NavigationViewItemInvokedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getInvokedItem(self: *@This()) core.HResult!*IInspectable {
        const this: *INavigationViewItemInvokedEventArgs = @ptrCast(self);
        return try this.getInvokedItem();
    }
    pub fn getIsSettingsInvoked(self: *@This()) core.HResult!bool {
        const this: *INavigationViewItemInvokedEventArgs = @ptrCast(self);
        return try this.getIsSettingsInvoked();
    }
    pub fn getInvokedItemContainer(self: *@This()) core.HResult!*NavigationViewItemBase {
        var this: ?*INavigationViewItemInvokedEventArgs2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationViewItemInvokedEventArgs2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getInvokedItemContainer();
    }
    pub fn getRecommendedNavigationTransitionInfo(self: *@This()) core.HResult!*NavigationTransitionInfo {
        var this: ?*INavigationViewItemInvokedEventArgs2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationViewItemInvokedEventArgs2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getRecommendedNavigationTransitionInfo();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&INavigationViewItemInvokedEventArgs.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.NavigationViewItemInvokedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = INavigationViewItemInvokedEventArgs.GUID;
    pub const IID: Guid = INavigationViewItemInvokedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, INavigationViewItemInvokedEventArgs.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const NavigationViewItemSeparator = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*NavigationViewItemSeparator {
        const _f = @This().INavigationViewItemSeparatorFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.NavigationViewItemSeparator";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = INavigationViewItemSeparator.GUID;
    pub const IID: Guid = INavigationViewItemSeparator.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, INavigationViewItemSeparator.SIGNATURE);
    var _INavigationViewItemSeparatorFactoryCache: FactoryCache(INavigationViewItemSeparatorFactory, RUNTIME_NAME) = .{};
};
pub const NavigationViewList = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*NavigationViewList {
        const _f = @This().INavigationViewListFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.NavigationViewList";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = INavigationViewList.GUID;
    pub const IID: Guid = INavigationViewList.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, INavigationViewList.SIGNATURE);
    var _INavigationViewListFactoryCache: FactoryCache(INavigationViewListFactory, RUNTIME_NAME) = .{};
};
pub const NavigationViewOverflowLabelMode = enum(i32) {
    MoreLabel = 0,
    NoLabel = 1,
};
pub const NavigationViewPaneClosingEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getCancel(self: *@This()) core.HResult!bool {
        const this: *INavigationViewPaneClosingEventArgs = @ptrCast(self);
        return try this.getCancel();
    }
    pub fn putCancel(self: *@This(), value: bool) core.HResult!void {
        const this: *INavigationViewPaneClosingEventArgs = @ptrCast(self);
        return try this.putCancel(value);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.NavigationViewPaneClosingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = INavigationViewPaneClosingEventArgs.GUID;
    pub const IID: Guid = INavigationViewPaneClosingEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, INavigationViewPaneClosingEventArgs.SIGNATURE);
};
pub const NavigationViewPaneDisplayMode = enum(i32) {
    Auto = 0,
    Left = 1,
    Top = 2,
    LeftCompact = 3,
    LeftMinimal = 4,
};
pub const NavigationViewSelectionChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getSelectedItem(self: *@This()) core.HResult!*IInspectable {
        const this: *INavigationViewSelectionChangedEventArgs = @ptrCast(self);
        return try this.getSelectedItem();
    }
    pub fn getIsSettingsSelected(self: *@This()) core.HResult!bool {
        const this: *INavigationViewSelectionChangedEventArgs = @ptrCast(self);
        return try this.getIsSettingsSelected();
    }
    pub fn getSelectedItemContainer(self: *@This()) core.HResult!*NavigationViewItemBase {
        var this: ?*INavigationViewSelectionChangedEventArgs2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationViewSelectionChangedEventArgs2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectedItemContainer();
    }
    pub fn getRecommendedNavigationTransitionInfo(self: *@This()) core.HResult!*NavigationTransitionInfo {
        var this: ?*INavigationViewSelectionChangedEventArgs2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INavigationViewSelectionChangedEventArgs2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getRecommendedNavigationTransitionInfo();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.NavigationViewSelectionChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = INavigationViewSelectionChangedEventArgs.GUID;
    pub const IID: Guid = INavigationViewSelectionChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, INavigationViewSelectionChangedEventArgs.SIGNATURE);
};
pub const NavigationViewSelectionFollowsFocus = enum(i32) {
    Disabled = 0,
    Enabled = 1,
};
pub const NavigationViewShoulderNavigationEnabled = enum(i32) {
    WhenSelectionFollowsFocus = 0,
    Always = 1,
    Never = 2,
};
pub const NavigationViewTemplateSettings = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getTopPadding(self: *@This()) core.HResult!f64 {
        const this: *INavigationViewTemplateSettings = @ptrCast(self);
        return try this.getTopPadding();
    }
    pub fn getOverflowButtonVisibility(self: *@This()) core.HResult!Visibility {
        const this: *INavigationViewTemplateSettings = @ptrCast(self);
        return try this.getOverflowButtonVisibility();
    }
    pub fn getPaneToggleButtonVisibility(self: *@This()) core.HResult!Visibility {
        const this: *INavigationViewTemplateSettings = @ptrCast(self);
        return try this.getPaneToggleButtonVisibility();
    }
    pub fn getBackButtonVisibility(self: *@This()) core.HResult!Visibility {
        const this: *INavigationViewTemplateSettings = @ptrCast(self);
        return try this.getBackButtonVisibility();
    }
    pub fn getTopPaneVisibility(self: *@This()) core.HResult!Visibility {
        const this: *INavigationViewTemplateSettings = @ptrCast(self);
        return try this.getTopPaneVisibility();
    }
    pub fn getLeftPaneVisibility(self: *@This()) core.HResult!Visibility {
        const this: *INavigationViewTemplateSettings = @ptrCast(self);
        return try this.getLeftPaneVisibility();
    }
    pub fn getSingleSelectionFollowsFocus(self: *@This()) core.HResult!bool {
        const this: *INavigationViewTemplateSettings = @ptrCast(self);
        return try this.getSingleSelectionFollowsFocus();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getTopPaddingProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewTemplateSettingsStaticsCache.get();
        return try _f.getTopPaddingProperty();
    }
    pub fn getOverflowButtonVisibilityProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewTemplateSettingsStaticsCache.get();
        return try _f.getOverflowButtonVisibilityProperty();
    }
    pub fn getPaneToggleButtonVisibilityProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewTemplateSettingsStaticsCache.get();
        return try _f.getPaneToggleButtonVisibilityProperty();
    }
    pub fn getBackButtonVisibilityProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewTemplateSettingsStaticsCache.get();
        return try _f.getBackButtonVisibilityProperty();
    }
    pub fn getTopPaneVisibilityProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewTemplateSettingsStaticsCache.get();
        return try _f.getTopPaneVisibilityProperty();
    }
    pub fn getLeftPaneVisibilityProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewTemplateSettingsStaticsCache.get();
        return try _f.getLeftPaneVisibilityProperty();
    }
    pub fn getSingleSelectionFollowsFocusProperty() core.HResult!*DependencyProperty {
        const _f = @This().INavigationViewTemplateSettingsStaticsCache.get();
        return try _f.getSingleSelectionFollowsFocusProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*NavigationViewTemplateSettings {
        const _f = @This().INavigationViewTemplateSettingsFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.NavigationViewTemplateSettings";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = INavigationViewTemplateSettings.GUID;
    pub const IID: Guid = INavigationViewTemplateSettings.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, INavigationViewTemplateSettings.SIGNATURE);
    var _INavigationViewTemplateSettingsStaticsCache: FactoryCache(INavigationViewTemplateSettingsStatics, RUNTIME_NAME) = .{};
    var _INavigationViewTemplateSettingsFactoryCache: FactoryCache(INavigationViewTemplateSettingsFactory, RUNTIME_NAME) = .{};
};
pub const NotifyEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getValue(self: *@This()) core.HResult!HSTRING {
        const this: *INotifyEventArgs = @ptrCast(self);
        return try this.getValue();
    }
    pub fn getCallingUri(self: *@This()) core.HResult!*Uri {
        var this: ?*INotifyEventArgs2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &INotifyEventArgs2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCallingUri();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.NotifyEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = INotifyEventArgs.GUID;
    pub const IID: Guid = INotifyEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, INotifyEventArgs.SIGNATURE);
};
pub const NotifyEventHandler = extern struct {
    vtable: *const VTable,
    _refs: @import("std").atomic.Value(u32),
    _cb: *const fn (context: ?*anyopaque) callconv(.winapi) void,
    _context: ?*anyopaque = null,
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn init(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *NotifyEventArgs) callconv(.winapi) void,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
        };
        return _r;
    }
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn initWithState(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *NotifyEventArgs) callconv(.winapi) void,
        context: anytype,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
            ._context = @ptrCast(context),
        };
        return _r;
    }
    /// This calls Release and voids the returned ref count. If ref count is 0 the memory is released,
    /// Otherwise the memory stays until all references are released, including all references Windows holds.
    ///
    /// The caller *MUST* always call deinit/Release at least once for every AddRef and init called.
    pub fn deinit(self: *@This()) void {
        _ = Release(@ptrCast(self));
    }
    fn QueryInterface(self: *anyopaque, riid: *const Guid, out: *?*anyopaque) callconv(.c) HRESULT {
        const me: *@This() = @ptrCast(@alignCast(self));
        // TODO: Handle IMarshal
        if (core.wiredGuidEql(riid, &IID) or
            core.wiredGuidEql(riid, &IUnknown.IID) or
            core.wiredGuidEql(riid, &IAgileObject.IID))
        {
            out.* = @as(?*anyopaque, @ptrCast(me));
            _ = AddRef(self);
            return 0;
        }
        out.* = null;
        return -2147467262; // E_NOINTERFACE
    }
    fn AddRef(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        return this._refs.fetchAdd(1, .monotonic) + 1;
    }
    fn Release(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        const left = this._refs.fetchSub(1, .acq_rel) - 1;
        if (left == 0) @import("std").heap.c_allocator.destroy(this);
        return left;
    }
    pub fn Invoke(self: *anyopaque, sender: *IInspectable, e: *NotifyEventArgs) callconv(.winapi) HRESULT {
        const this: *@This() = @ptrCast(@alignCast(self));
        this._cb(this._context, sender, e);
        return 0;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.NotifyEventHandler";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "c2fdd1f8-7105-4a74-a109-de29dff56b98";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.pinterface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        Invoke: *const fn(self: *anyopaque, sender: *IInspectable, e: *NotifyEventArgs) callconv(.winapi) HRESULT
    };
    pub const VTABLE = VTable {
        .QueryInterface = QueryInterface,
        .AddRef = AddRef,
        .Release = Release,
        .Invoke = Invoke,
    };
};
pub const Orientation = enum(i32) {
    Vertical = 0,
    Horizontal = 1,
};
pub const UserControl = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getContent(self: *@This()) core.HResult!*UIElement {
        const this: *IUserControl = @ptrCast(self);
        return try this.getContent();
    }
    pub fn putContent(self: *@This(), value: *UIElement) core.HResult!void {
        const this: *IUserControl = @ptrCast(self);
        return try this.putContent(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getContentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IUserControlStaticsCache.get();
        return try _f.getContentProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*UserControl {
        const _f = @This().IUserControlFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.UserControl";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IUserControl.GUID;
    pub const IID: Guid = IUserControl.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IUserControl.SIGNATURE);
    var _IUserControlStaticsCache: FactoryCache(IUserControlStatics, RUNTIME_NAME) = .{};
    var _IUserControlFactoryCache: FactoryCache(IUserControlFactory, RUNTIME_NAME) = .{};
};
pub const Page = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getFrame(self: *@This()) core.HResult!*Frame {
        const this: *IPage = @ptrCast(self);
        return try this.getFrame();
    }
    pub fn getNavigationCacheMode(self: *@This()) core.HResult!NavigationCacheMode {
        const this: *IPage = @ptrCast(self);
        return try this.getNavigationCacheMode();
    }
    pub fn putNavigationCacheMode(self: *@This(), value: NavigationCacheMode) core.HResult!void {
        const this: *IPage = @ptrCast(self);
        return try this.putNavigationCacheMode(value);
    }
    pub fn getTopAppBar(self: *@This()) core.HResult!*AppBar {
        const this: *IPage = @ptrCast(self);
        return try this.getTopAppBar();
    }
    pub fn putTopAppBar(self: *@This(), value: *AppBar) core.HResult!void {
        const this: *IPage = @ptrCast(self);
        return try this.putTopAppBar(value);
    }
    pub fn getBottomAppBar(self: *@This()) core.HResult!*AppBar {
        const this: *IPage = @ptrCast(self);
        return try this.getBottomAppBar();
    }
    pub fn putBottomAppBar(self: *@This(), value: *AppBar) core.HResult!void {
        const this: *IPage = @ptrCast(self);
        return try this.putBottomAppBar(value);
    }
    pub fn OnNavigatedFrom(self: *@This(), e: *NavigationEventArgs) core.HResult!void {
        var this: ?*IPageOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPageOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnNavigatedFrom(e);
    }
    pub fn OnNavigatedTo(self: *@This(), e: *NavigationEventArgs) core.HResult!void {
        var this: ?*IPageOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPageOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnNavigatedTo(e);
    }
    pub fn OnNavigatingFrom(self: *@This(), e: *NavigatingCancelEventArgs) core.HResult!void {
        var this: ?*IPageOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPageOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnNavigatingFrom(e);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getFrameProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPageStaticsCache.get();
        return try _f.getFrameProperty();
    }
    pub fn getTopAppBarProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPageStaticsCache.get();
        return try _f.getTopAppBarProperty();
    }
    pub fn getBottomAppBarProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPageStaticsCache.get();
        return try _f.getBottomAppBarProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*Page {
        const _f = @This().IPageFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.Page";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IPage.GUID;
    pub const IID: Guid = IPage.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IPage.SIGNATURE);
    var _IPageStaticsCache: FactoryCache(IPageStatics, RUNTIME_NAME) = .{};
    var _IPageFactoryCache: FactoryCache(IPageFactory, RUNTIME_NAME) = .{};
};
pub const PanelScrollingDirection = enum(i32) {
    None = 0,
    Forward = 1,
    Backward = 2,
};
pub const ParallaxSourceOffsetKind = enum(i32) {
    Absolute = 0,
    Relative = 1,
};
pub const ParallaxView = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getChild(self: *@This()) core.HResult!*UIElement {
        const this: *IParallaxView = @ptrCast(self);
        return try this.getChild();
    }
    pub fn putChild(self: *@This(), value: *UIElement) core.HResult!void {
        const this: *IParallaxView = @ptrCast(self);
        return try this.putChild(value);
    }
    pub fn getHorizontalShift(self: *@This()) core.HResult!f64 {
        const this: *IParallaxView = @ptrCast(self);
        return try this.getHorizontalShift();
    }
    pub fn putHorizontalShift(self: *@This(), value: f64) core.HResult!void {
        const this: *IParallaxView = @ptrCast(self);
        return try this.putHorizontalShift(value);
    }
    pub fn getHorizontalSourceEndOffset(self: *@This()) core.HResult!f64 {
        const this: *IParallaxView = @ptrCast(self);
        return try this.getHorizontalSourceEndOffset();
    }
    pub fn putHorizontalSourceEndOffset(self: *@This(), value: f64) core.HResult!void {
        const this: *IParallaxView = @ptrCast(self);
        return try this.putHorizontalSourceEndOffset(value);
    }
    pub fn getHorizontalSourceOffsetKind(self: *@This()) core.HResult!ParallaxSourceOffsetKind {
        const this: *IParallaxView = @ptrCast(self);
        return try this.getHorizontalSourceOffsetKind();
    }
    pub fn putHorizontalSourceOffsetKind(self: *@This(), value: ParallaxSourceOffsetKind) core.HResult!void {
        const this: *IParallaxView = @ptrCast(self);
        return try this.putHorizontalSourceOffsetKind(value);
    }
    pub fn getHorizontalSourceStartOffset(self: *@This()) core.HResult!f64 {
        const this: *IParallaxView = @ptrCast(self);
        return try this.getHorizontalSourceStartOffset();
    }
    pub fn putHorizontalSourceStartOffset(self: *@This(), value: f64) core.HResult!void {
        const this: *IParallaxView = @ptrCast(self);
        return try this.putHorizontalSourceStartOffset(value);
    }
    pub fn getIsHorizontalShiftClamped(self: *@This()) core.HResult!bool {
        const this: *IParallaxView = @ptrCast(self);
        return try this.getIsHorizontalShiftClamped();
    }
    pub fn putIsHorizontalShiftClamped(self: *@This(), value: bool) core.HResult!void {
        const this: *IParallaxView = @ptrCast(self);
        return try this.putIsHorizontalShiftClamped(value);
    }
    pub fn getIsVerticalShiftClamped(self: *@This()) core.HResult!bool {
        const this: *IParallaxView = @ptrCast(self);
        return try this.getIsVerticalShiftClamped();
    }
    pub fn putIsVerticalShiftClamped(self: *@This(), value: bool) core.HResult!void {
        const this: *IParallaxView = @ptrCast(self);
        return try this.putIsVerticalShiftClamped(value);
    }
    pub fn getMaxHorizontalShiftRatio(self: *@This()) core.HResult!f64 {
        const this: *IParallaxView = @ptrCast(self);
        return try this.getMaxHorizontalShiftRatio();
    }
    pub fn putMaxHorizontalShiftRatio(self: *@This(), value: f64) core.HResult!void {
        const this: *IParallaxView = @ptrCast(self);
        return try this.putMaxHorizontalShiftRatio(value);
    }
    pub fn getMaxVerticalShiftRatio(self: *@This()) core.HResult!f64 {
        const this: *IParallaxView = @ptrCast(self);
        return try this.getMaxVerticalShiftRatio();
    }
    pub fn putMaxVerticalShiftRatio(self: *@This(), value: f64) core.HResult!void {
        const this: *IParallaxView = @ptrCast(self);
        return try this.putMaxVerticalShiftRatio(value);
    }
    pub fn getSource(self: *@This()) core.HResult!*UIElement {
        const this: *IParallaxView = @ptrCast(self);
        return try this.getSource();
    }
    pub fn putSource(self: *@This(), value: *UIElement) core.HResult!void {
        const this: *IParallaxView = @ptrCast(self);
        return try this.putSource(value);
    }
    pub fn getVerticalShift(self: *@This()) core.HResult!f64 {
        const this: *IParallaxView = @ptrCast(self);
        return try this.getVerticalShift();
    }
    pub fn putVerticalShift(self: *@This(), value: f64) core.HResult!void {
        const this: *IParallaxView = @ptrCast(self);
        return try this.putVerticalShift(value);
    }
    pub fn getVerticalSourceEndOffset(self: *@This()) core.HResult!f64 {
        const this: *IParallaxView = @ptrCast(self);
        return try this.getVerticalSourceEndOffset();
    }
    pub fn putVerticalSourceEndOffset(self: *@This(), value: f64) core.HResult!void {
        const this: *IParallaxView = @ptrCast(self);
        return try this.putVerticalSourceEndOffset(value);
    }
    pub fn getVerticalSourceOffsetKind(self: *@This()) core.HResult!ParallaxSourceOffsetKind {
        const this: *IParallaxView = @ptrCast(self);
        return try this.getVerticalSourceOffsetKind();
    }
    pub fn putVerticalSourceOffsetKind(self: *@This(), value: ParallaxSourceOffsetKind) core.HResult!void {
        const this: *IParallaxView = @ptrCast(self);
        return try this.putVerticalSourceOffsetKind(value);
    }
    pub fn getVerticalSourceStartOffset(self: *@This()) core.HResult!f64 {
        const this: *IParallaxView = @ptrCast(self);
        return try this.getVerticalSourceStartOffset();
    }
    pub fn putVerticalSourceStartOffset(self: *@This(), value: f64) core.HResult!void {
        const this: *IParallaxView = @ptrCast(self);
        return try this.putVerticalSourceStartOffset(value);
    }
    pub fn RefreshAutomaticHorizontalOffsets(self: *@This()) core.HResult!void {
        const this: *IParallaxView = @ptrCast(self);
        return try this.RefreshAutomaticHorizontalOffsets();
    }
    pub fn RefreshAutomaticVerticalOffsets(self: *@This()) core.HResult!void {
        const this: *IParallaxView = @ptrCast(self);
        return try this.RefreshAutomaticVerticalOffsets();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getChildProperty() core.HResult!*DependencyProperty {
        const _f = @This().IParallaxViewStaticsCache.get();
        return try _f.getChildProperty();
    }
    pub fn getHorizontalSourceEndOffsetProperty() core.HResult!*DependencyProperty {
        const _f = @This().IParallaxViewStaticsCache.get();
        return try _f.getHorizontalSourceEndOffsetProperty();
    }
    pub fn getHorizontalSourceOffsetKindProperty() core.HResult!*DependencyProperty {
        const _f = @This().IParallaxViewStaticsCache.get();
        return try _f.getHorizontalSourceOffsetKindProperty();
    }
    pub fn getHorizontalSourceStartOffsetProperty() core.HResult!*DependencyProperty {
        const _f = @This().IParallaxViewStaticsCache.get();
        return try _f.getHorizontalSourceStartOffsetProperty();
    }
    pub fn getMaxHorizontalShiftRatioProperty() core.HResult!*DependencyProperty {
        const _f = @This().IParallaxViewStaticsCache.get();
        return try _f.getMaxHorizontalShiftRatioProperty();
    }
    pub fn getHorizontalShiftProperty() core.HResult!*DependencyProperty {
        const _f = @This().IParallaxViewStaticsCache.get();
        return try _f.getHorizontalShiftProperty();
    }
    pub fn getIsHorizontalShiftClampedProperty() core.HResult!*DependencyProperty {
        const _f = @This().IParallaxViewStaticsCache.get();
        return try _f.getIsHorizontalShiftClampedProperty();
    }
    pub fn getIsVerticalShiftClampedProperty() core.HResult!*DependencyProperty {
        const _f = @This().IParallaxViewStaticsCache.get();
        return try _f.getIsVerticalShiftClampedProperty();
    }
    pub fn getSourceProperty() core.HResult!*DependencyProperty {
        const _f = @This().IParallaxViewStaticsCache.get();
        return try _f.getSourceProperty();
    }
    pub fn getVerticalSourceEndOffsetProperty() core.HResult!*DependencyProperty {
        const _f = @This().IParallaxViewStaticsCache.get();
        return try _f.getVerticalSourceEndOffsetProperty();
    }
    pub fn getVerticalSourceOffsetKindProperty() core.HResult!*DependencyProperty {
        const _f = @This().IParallaxViewStaticsCache.get();
        return try _f.getVerticalSourceOffsetKindProperty();
    }
    pub fn getVerticalSourceStartOffsetProperty() core.HResult!*DependencyProperty {
        const _f = @This().IParallaxViewStaticsCache.get();
        return try _f.getVerticalSourceStartOffsetProperty();
    }
    pub fn getMaxVerticalShiftRatioProperty() core.HResult!*DependencyProperty {
        const _f = @This().IParallaxViewStaticsCache.get();
        return try _f.getMaxVerticalShiftRatioProperty();
    }
    pub fn getVerticalShiftProperty() core.HResult!*DependencyProperty {
        const _f = @This().IParallaxViewStaticsCache.get();
        return try _f.getVerticalShiftProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ParallaxView {
        const _f = @This().IParallaxViewFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ParallaxView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IParallaxView.GUID;
    pub const IID: Guid = IParallaxView.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IParallaxView.SIGNATURE);
    var _IParallaxViewStaticsCache: FactoryCache(IParallaxViewStatics, RUNTIME_NAME) = .{};
    var _IParallaxViewFactoryCache: FactoryCache(IParallaxViewFactory, RUNTIME_NAME) = .{};
};
pub const PasswordBox = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getPassword(self: *@This()) core.HResult!HSTRING {
        const this: *IPasswordBox = @ptrCast(self);
        return try this.getPassword();
    }
    pub fn putPassword(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IPasswordBox = @ptrCast(self);
        return try this.putPassword(value);
    }
    pub fn getPasswordChar(self: *@This()) core.HResult!HSTRING {
        const this: *IPasswordBox = @ptrCast(self);
        return try this.getPasswordChar();
    }
    pub fn putPasswordChar(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IPasswordBox = @ptrCast(self);
        return try this.putPasswordChar(value);
    }
    pub fn getIsPasswordRevealButtonEnabled(self: *@This()) core.HResult!bool {
        const this: *IPasswordBox = @ptrCast(self);
        return try this.getIsPasswordRevealButtonEnabled();
    }
    pub fn putIsPasswordRevealButtonEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IPasswordBox = @ptrCast(self);
        return try this.putIsPasswordRevealButtonEnabled(value);
    }
    pub fn getMaxLength(self: *@This()) core.HResult!i32 {
        const this: *IPasswordBox = @ptrCast(self);
        return try this.getMaxLength();
    }
    pub fn putMaxLength(self: *@This(), value: i32) core.HResult!void {
        const this: *IPasswordBox = @ptrCast(self);
        return try this.putMaxLength(value);
    }
    pub fn addPasswordChanged(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IPasswordBox = @ptrCast(self);
        return try this.addPasswordChanged(handler);
    }
    pub fn removePasswordChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IPasswordBox = @ptrCast(self);
        return try this.removePasswordChanged(token);
    }
    pub fn addContextMenuOpening(self: *@This(), handler: *ContextMenuOpeningEventHandler) core.HResult!EventRegistrationToken {
        const this: *IPasswordBox = @ptrCast(self);
        return try this.addContextMenuOpening(handler);
    }
    pub fn removeContextMenuOpening(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IPasswordBox = @ptrCast(self);
        return try this.removeContextMenuOpening(token);
    }
    pub fn SelectAll(self: *@This()) core.HResult!void {
        const this: *IPasswordBox = @ptrCast(self);
        return try this.SelectAll();
    }
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        var this: ?*IPasswordBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getHeader();
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        var this: ?*IPasswordBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putHeader(value);
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var this: ?*IPasswordBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getHeaderTemplate();
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        var this: ?*IPasswordBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putHeaderTemplate(value);
    }
    pub fn getPlaceholderText(self: *@This()) core.HResult!HSTRING {
        var this: ?*IPasswordBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getPlaceholderText();
    }
    pub fn putPlaceholderText(self: *@This(), value: HSTRING) core.HResult!void {
        var this: ?*IPasswordBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putPlaceholderText(value);
    }
    pub fn getSelectionHighlightColor(self: *@This()) core.HResult!*SolidColorBrush {
        var this: ?*IPasswordBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectionHighlightColor();
    }
    pub fn putSelectionHighlightColor(self: *@This(), value: *SolidColorBrush) core.HResult!void {
        var this: ?*IPasswordBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSelectionHighlightColor(value);
    }
    pub fn getPreventKeyboardDisplayOnProgrammaticFocus(self: *@This()) core.HResult!bool {
        var this: ?*IPasswordBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getPreventKeyboardDisplayOnProgrammaticFocus();
    }
    pub fn putPreventKeyboardDisplayOnProgrammaticFocus(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IPasswordBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putPreventKeyboardDisplayOnProgrammaticFocus(value);
    }
    pub fn addPaste(self: *@This(), handler: *TextControlPasteEventHandler) core.HResult!EventRegistrationToken {
        var this: ?*IPasswordBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addPaste(handler);
    }
    pub fn removePaste(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IPasswordBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removePaste(token);
    }
    pub fn getPasswordRevealMode(self: *@This()) core.HResult!PasswordRevealMode {
        var this: ?*IPasswordBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getPasswordRevealMode();
    }
    pub fn putPasswordRevealMode(self: *@This(), value: PasswordRevealMode) core.HResult!void {
        var this: ?*IPasswordBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putPasswordRevealMode(value);
    }
    pub fn getTextReadingOrder(self: *@This()) core.HResult!TextReadingOrder {
        var this: ?*IPasswordBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTextReadingOrder();
    }
    pub fn putTextReadingOrder(self: *@This(), value: TextReadingOrder) core.HResult!void {
        var this: ?*IPasswordBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTextReadingOrder(value);
    }
    pub fn getInputScope(self: *@This()) core.HResult!*InputScope {
        var this: ?*IPasswordBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getInputScope();
    }
    pub fn putInputScope(self: *@This(), value: *InputScope) core.HResult!void {
        var this: ?*IPasswordBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putInputScope(value);
    }
    pub fn addPasswordChanging(self: *@This(), handler: *TypedEventHandler(PasswordBox,PasswordBoxPasswordChangingEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IPasswordBox4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addPasswordChanging(handler);
    }
    pub fn removePasswordChanging(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IPasswordBox4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removePasswordChanging(token);
    }
    pub fn getCanPasteClipboardContent(self: *@This()) core.HResult!bool {
        var this: ?*IPasswordBox5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCanPasteClipboardContent();
    }
    pub fn getSelectionFlyout(self: *@This()) core.HResult!*FlyoutBase {
        var this: ?*IPasswordBox5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectionFlyout();
    }
    pub fn putSelectionFlyout(self: *@This(), value: *FlyoutBase) core.HResult!void {
        var this: ?*IPasswordBox5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSelectionFlyout(value);
    }
    pub fn getDescription(self: *@This()) core.HResult!*IInspectable {
        var this: ?*IPasswordBox5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDescription();
    }
    pub fn putDescription(self: *@This(), value: *IInspectable) core.HResult!void {
        var this: ?*IPasswordBox5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putDescription(value);
    }
    pub fn PasteFromClipboard(self: *@This()) core.HResult!void {
        var this: ?*IPasswordBox5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPasswordBox5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.PasteFromClipboard();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IPasswordBox.IID)));
    }
    pub fn getCanPasteClipboardContentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPasswordBoxStatics5Cache.get();
        return try _f.getCanPasteClipboardContentProperty();
    }
    pub fn getSelectionFlyoutProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPasswordBoxStatics5Cache.get();
        return try _f.getSelectionFlyoutProperty();
    }
    pub fn getDescriptionProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPasswordBoxStatics5Cache.get();
        return try _f.getDescriptionProperty();
    }
    pub fn getPasswordRevealModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPasswordBoxStatics3Cache.get();
        return try _f.getPasswordRevealModeProperty();
    }
    pub fn getTextReadingOrderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPasswordBoxStatics3Cache.get();
        return try _f.getTextReadingOrderProperty();
    }
    pub fn getInputScopeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPasswordBoxStatics3Cache.get();
        return try _f.getInputScopeProperty();
    }
    pub fn getHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPasswordBoxStatics2Cache.get();
        return try _f.getHeaderProperty();
    }
    pub fn getHeaderTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPasswordBoxStatics2Cache.get();
        return try _f.getHeaderTemplateProperty();
    }
    pub fn getPlaceholderTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPasswordBoxStatics2Cache.get();
        return try _f.getPlaceholderTextProperty();
    }
    pub fn getSelectionHighlightColorProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPasswordBoxStatics2Cache.get();
        return try _f.getSelectionHighlightColorProperty();
    }
    pub fn getPreventKeyboardDisplayOnProgrammaticFocusProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPasswordBoxStatics2Cache.get();
        return try _f.getPreventKeyboardDisplayOnProgrammaticFocusProperty();
    }
    pub fn getPasswordProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPasswordBoxStaticsCache.get();
        return try _f.getPasswordProperty();
    }
    pub fn getPasswordCharProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPasswordBoxStaticsCache.get();
        return try _f.getPasswordCharProperty();
    }
    pub fn getIsPasswordRevealButtonEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPasswordBoxStaticsCache.get();
        return try _f.getIsPasswordRevealButtonEnabledProperty();
    }
    pub fn getMaxLengthProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPasswordBoxStaticsCache.get();
        return try _f.getMaxLengthProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.PasswordBox";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IPasswordBox.GUID;
    pub const IID: Guid = IPasswordBox.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IPasswordBox.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IPasswordBoxStatics5Cache: FactoryCache(IPasswordBoxStatics5, RUNTIME_NAME) = .{};
    var _IPasswordBoxStatics3Cache: FactoryCache(IPasswordBoxStatics3, RUNTIME_NAME) = .{};
    var _IPasswordBoxStatics2Cache: FactoryCache(IPasswordBoxStatics2, RUNTIME_NAME) = .{};
    var _IPasswordBoxStaticsCache: FactoryCache(IPasswordBoxStatics, RUNTIME_NAME) = .{};
};
pub const PasswordBoxPasswordChangingEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsContentChanging(self: *@This()) core.HResult!bool {
        const this: *IPasswordBoxPasswordChangingEventArgs = @ptrCast(self);
        return try this.getIsContentChanging();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.PasswordBoxPasswordChangingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IPasswordBoxPasswordChangingEventArgs.GUID;
    pub const IID: Guid = IPasswordBoxPasswordChangingEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IPasswordBoxPasswordChangingEventArgs.SIGNATURE);
};
pub const PasswordRevealMode = enum(i32) {
    Peek = 0,
    Hidden = 1,
    Visible = 2,
};
pub const PathIcon = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getData(self: *@This()) core.HResult!*Geometry {
        const this: *IPathIcon = @ptrCast(self);
        return try this.getData();
    }
    pub fn putData(self: *@This(), value: *Geometry) core.HResult!void {
        const this: *IPathIcon = @ptrCast(self);
        return try this.putData(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getDataProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPathIconStaticsCache.get();
        return try _f.getDataProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*PathIcon {
        const _f = @This().IPathIconFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.PathIcon";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IPathIcon.GUID;
    pub const IID: Guid = IPathIcon.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IPathIcon.SIGNATURE);
    var _IPathIconStaticsCache: FactoryCache(IPathIconStatics, RUNTIME_NAME) = .{};
    var _IPathIconFactoryCache: FactoryCache(IPathIconFactory, RUNTIME_NAME) = .{};
};
pub const PathIconSource = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getData(self: *@This()) core.HResult!*Geometry {
        const this: *IPathIconSource = @ptrCast(self);
        return try this.getData();
    }
    pub fn putData(self: *@This(), value: *Geometry) core.HResult!void {
        const this: *IPathIconSource = @ptrCast(self);
        return try this.putData(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getDataProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPathIconSourceStaticsCache.get();
        return try _f.getDataProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*PathIconSource {
        const _f = @This().IPathIconSourceFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.PathIconSource";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IPathIconSource.GUID;
    pub const IID: Guid = IPathIconSource.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IPathIconSource.SIGNATURE);
    var _IPathIconSourceStaticsCache: FactoryCache(IPathIconSourceStatics, RUNTIME_NAME) = .{};
    var _IPathIconSourceFactoryCache: FactoryCache(IPathIconSourceFactory, RUNTIME_NAME) = .{};
};
pub const PersonPicture = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getBadgeNumber(self: *@This()) core.HResult!i32 {
        const this: *IPersonPicture = @ptrCast(self);
        return try this.getBadgeNumber();
    }
    pub fn putBadgeNumber(self: *@This(), value: i32) core.HResult!void {
        const this: *IPersonPicture = @ptrCast(self);
        return try this.putBadgeNumber(value);
    }
    pub fn getBadgeGlyph(self: *@This()) core.HResult!HSTRING {
        const this: *IPersonPicture = @ptrCast(self);
        return try this.getBadgeGlyph();
    }
    pub fn putBadgeGlyph(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IPersonPicture = @ptrCast(self);
        return try this.putBadgeGlyph(value);
    }
    pub fn getBadgeImageSource(self: *@This()) core.HResult!*ImageSource {
        const this: *IPersonPicture = @ptrCast(self);
        return try this.getBadgeImageSource();
    }
    pub fn putBadgeImageSource(self: *@This(), value: *ImageSource) core.HResult!void {
        const this: *IPersonPicture = @ptrCast(self);
        return try this.putBadgeImageSource(value);
    }
    pub fn getBadgeText(self: *@This()) core.HResult!HSTRING {
        const this: *IPersonPicture = @ptrCast(self);
        return try this.getBadgeText();
    }
    pub fn putBadgeText(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IPersonPicture = @ptrCast(self);
        return try this.putBadgeText(value);
    }
    pub fn getIsGroup(self: *@This()) core.HResult!bool {
        const this: *IPersonPicture = @ptrCast(self);
        return try this.getIsGroup();
    }
    pub fn putIsGroup(self: *@This(), value: bool) core.HResult!void {
        const this: *IPersonPicture = @ptrCast(self);
        return try this.putIsGroup(value);
    }
    pub fn getContact(self: *@This()) core.HResult!*Contact {
        const this: *IPersonPicture = @ptrCast(self);
        return try this.getContact();
    }
    pub fn putContact(self: *@This(), value: *Contact) core.HResult!void {
        const this: *IPersonPicture = @ptrCast(self);
        return try this.putContact(value);
    }
    pub fn getDisplayName(self: *@This()) core.HResult!HSTRING {
        const this: *IPersonPicture = @ptrCast(self);
        return try this.getDisplayName();
    }
    pub fn putDisplayName(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IPersonPicture = @ptrCast(self);
        return try this.putDisplayName(value);
    }
    pub fn getInitials(self: *@This()) core.HResult!HSTRING {
        const this: *IPersonPicture = @ptrCast(self);
        return try this.getInitials();
    }
    pub fn putInitials(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IPersonPicture = @ptrCast(self);
        return try this.putInitials(value);
    }
    pub fn getPreferSmallImage(self: *@This()) core.HResult!bool {
        const this: *IPersonPicture = @ptrCast(self);
        return try this.getPreferSmallImage();
    }
    pub fn putPreferSmallImage(self: *@This(), value: bool) core.HResult!void {
        const this: *IPersonPicture = @ptrCast(self);
        return try this.putPreferSmallImage(value);
    }
    pub fn getProfilePicture(self: *@This()) core.HResult!*ImageSource {
        const this: *IPersonPicture = @ptrCast(self);
        return try this.getProfilePicture();
    }
    pub fn putProfilePicture(self: *@This(), value: *ImageSource) core.HResult!void {
        const this: *IPersonPicture = @ptrCast(self);
        return try this.putProfilePicture(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getBadgeNumberProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPersonPictureStaticsCache.get();
        return try _f.getBadgeNumberProperty();
    }
    pub fn getBadgeGlyphProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPersonPictureStaticsCache.get();
        return try _f.getBadgeGlyphProperty();
    }
    pub fn getBadgeImageSourceProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPersonPictureStaticsCache.get();
        return try _f.getBadgeImageSourceProperty();
    }
    pub fn getBadgeTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPersonPictureStaticsCache.get();
        return try _f.getBadgeTextProperty();
    }
    pub fn getIsGroupProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPersonPictureStaticsCache.get();
        return try _f.getIsGroupProperty();
    }
    pub fn getContactProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPersonPictureStaticsCache.get();
        return try _f.getContactProperty();
    }
    pub fn getDisplayNameProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPersonPictureStaticsCache.get();
        return try _f.getDisplayNameProperty();
    }
    pub fn getInitialsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPersonPictureStaticsCache.get();
        return try _f.getInitialsProperty();
    }
    pub fn getPreferSmallImageProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPersonPictureStaticsCache.get();
        return try _f.getPreferSmallImageProperty();
    }
    pub fn getProfilePictureProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPersonPictureStaticsCache.get();
        return try _f.getProfilePictureProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*PersonPicture {
        const _f = @This().IPersonPictureFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.PersonPicture";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IPersonPicture.GUID;
    pub const IID: Guid = IPersonPicture.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IPersonPicture.SIGNATURE);
    var _IPersonPictureStaticsCache: FactoryCache(IPersonPictureStatics, RUNTIME_NAME) = .{};
    var _IPersonPictureFactoryCache: FactoryCache(IPersonPictureFactory, RUNTIME_NAME) = .{};
};
pub const PickerConfirmedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IPickerConfirmedEventArgs.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.PickerConfirmedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IPickerConfirmedEventArgs.GUID;
    pub const IID: Guid = IPickerConfirmedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IPickerConfirmedEventArgs.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const PickerFlyout = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getContent(self: *@This()) core.HResult!*UIElement {
        const this: *IPickerFlyout = @ptrCast(self);
        return try this.getContent();
    }
    pub fn putContent(self: *@This(), value: *UIElement) core.HResult!void {
        const this: *IPickerFlyout = @ptrCast(self);
        return try this.putContent(value);
    }
    pub fn getConfirmationButtonsVisible(self: *@This()) core.HResult!bool {
        const this: *IPickerFlyout = @ptrCast(self);
        return try this.getConfirmationButtonsVisible();
    }
    pub fn putConfirmationButtonsVisible(self: *@This(), value: bool) core.HResult!void {
        const this: *IPickerFlyout = @ptrCast(self);
        return try this.putConfirmationButtonsVisible(value);
    }
    pub fn addConfirmed(self: *@This(), handler: *TypedEventHandler(PickerFlyout,PickerConfirmedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IPickerFlyout = @ptrCast(self);
        return try this.addConfirmed(handler);
    }
    pub fn removeConfirmed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IPickerFlyout = @ptrCast(self);
        return try this.removeConfirmed(token);
    }
    pub fn ShowAtAsync(self: *@This(), target: *FrameworkElement) core.HResult!*IAsyncOperation(bool) {
        const this: *IPickerFlyout = @ptrCast(self);
        return try this.ShowAtAsync(target);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IPickerFlyout.IID)));
    }
    pub fn getContentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPickerFlyoutStaticsCache.get();
        return try _f.getContentProperty();
    }
    pub fn getConfirmationButtonsVisibleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPickerFlyoutStaticsCache.get();
        return try _f.getConfirmationButtonsVisibleProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.PickerFlyout";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IPickerFlyout.GUID;
    pub const IID: Guid = IPickerFlyout.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IPickerFlyout.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IPickerFlyoutStaticsCache: FactoryCache(IPickerFlyoutStatics, RUNTIME_NAME) = .{};
};
pub const PickerFlyoutPresenter = extern struct {
    vtable: *const IInspectable.VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.PickerFlyoutPresenter";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IPickerFlyoutPresenter.GUID;
    pub const IID: Guid = IPickerFlyoutPresenter.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IPickerFlyoutPresenter.SIGNATURE);
};
pub const Pivot = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getTitle(self: *@This()) core.HResult!*IInspectable {
        const this: *IPivot = @ptrCast(self);
        return try this.getTitle();
    }
    pub fn putTitle(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IPivot = @ptrCast(self);
        return try this.putTitle(value);
    }
    pub fn getTitleTemplate(self: *@This()) core.HResult!*DataTemplate {
        const this: *IPivot = @ptrCast(self);
        return try this.getTitleTemplate();
    }
    pub fn putTitleTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const this: *IPivot = @ptrCast(self);
        return try this.putTitleTemplate(value);
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        const this: *IPivot = @ptrCast(self);
        return try this.getHeaderTemplate();
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const this: *IPivot = @ptrCast(self);
        return try this.putHeaderTemplate(value);
    }
    pub fn getSelectedIndex(self: *@This()) core.HResult!i32 {
        const this: *IPivot = @ptrCast(self);
        return try this.getSelectedIndex();
    }
    pub fn putSelectedIndex(self: *@This(), value: i32) core.HResult!void {
        const this: *IPivot = @ptrCast(self);
        return try this.putSelectedIndex(value);
    }
    pub fn getSelectedItem(self: *@This()) core.HResult!*IInspectable {
        const this: *IPivot = @ptrCast(self);
        return try this.getSelectedItem();
    }
    pub fn putSelectedItem(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IPivot = @ptrCast(self);
        return try this.putSelectedItem(value);
    }
    pub fn getIsLocked(self: *@This()) core.HResult!bool {
        const this: *IPivot = @ptrCast(self);
        return try this.getIsLocked();
    }
    pub fn putIsLocked(self: *@This(), value: bool) core.HResult!void {
        const this: *IPivot = @ptrCast(self);
        return try this.putIsLocked(value);
    }
    pub fn addSelectionChanged(self: *@This(), handler: *SelectionChangedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IPivot = @ptrCast(self);
        return try this.addSelectionChanged(handler);
    }
    pub fn removeSelectionChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IPivot = @ptrCast(self);
        return try this.removeSelectionChanged(token);
    }
    pub fn addPivotItemLoading(self: *@This(), handler: *TypedEventHandler(Pivot,PivotItemEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IPivot = @ptrCast(self);
        return try this.addPivotItemLoading(handler);
    }
    pub fn removePivotItemLoading(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IPivot = @ptrCast(self);
        return try this.removePivotItemLoading(token);
    }
    pub fn addPivotItemLoaded(self: *@This(), handler: *TypedEventHandler(Pivot,PivotItemEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IPivot = @ptrCast(self);
        return try this.addPivotItemLoaded(handler);
    }
    pub fn removePivotItemLoaded(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IPivot = @ptrCast(self);
        return try this.removePivotItemLoaded(token);
    }
    pub fn addPivotItemUnloading(self: *@This(), handler: *TypedEventHandler(Pivot,PivotItemEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IPivot = @ptrCast(self);
        return try this.addPivotItemUnloading(handler);
    }
    pub fn removePivotItemUnloading(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IPivot = @ptrCast(self);
        return try this.removePivotItemUnloading(token);
    }
    pub fn addPivotItemUnloaded(self: *@This(), handler: *TypedEventHandler(Pivot,PivotItemEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IPivot = @ptrCast(self);
        return try this.addPivotItemUnloaded(handler);
    }
    pub fn removePivotItemUnloaded(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IPivot = @ptrCast(self);
        return try this.removePivotItemUnloaded(token);
    }
    pub fn getLeftHeader(self: *@This()) core.HResult!*IInspectable {
        var this: ?*IPivot2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPivot2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getLeftHeader();
    }
    pub fn putLeftHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        var this: ?*IPivot2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPivot2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putLeftHeader(value);
    }
    pub fn getLeftHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var this: ?*IPivot2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPivot2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getLeftHeaderTemplate();
    }
    pub fn putLeftHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        var this: ?*IPivot2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPivot2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putLeftHeaderTemplate(value);
    }
    pub fn getRightHeader(self: *@This()) core.HResult!*IInspectable {
        var this: ?*IPivot2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPivot2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getRightHeader();
    }
    pub fn putRightHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        var this: ?*IPivot2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPivot2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putRightHeader(value);
    }
    pub fn getRightHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var this: ?*IPivot2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPivot2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getRightHeaderTemplate();
    }
    pub fn putRightHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        var this: ?*IPivot2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPivot2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putRightHeaderTemplate(value);
    }
    pub fn getHeaderFocusVisualPlacement(self: *@This()) core.HResult!PivotHeaderFocusVisualPlacement {
        var this: ?*IPivot3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPivot3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getHeaderFocusVisualPlacement();
    }
    pub fn putHeaderFocusVisualPlacement(self: *@This(), value: PivotHeaderFocusVisualPlacement) core.HResult!void {
        var this: ?*IPivot3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPivot3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putHeaderFocusVisualPlacement(value);
    }
    pub fn getIsHeaderItemsCarouselEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IPivot3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPivot3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsHeaderItemsCarouselEnabled();
    }
    pub fn putIsHeaderItemsCarouselEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IPivot3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IPivot3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsHeaderItemsCarouselEnabled(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getTitleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPivotStaticsCache.get();
        return try _f.getTitleProperty();
    }
    pub fn getTitleTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPivotStaticsCache.get();
        return try _f.getTitleTemplateProperty();
    }
    pub fn getHeaderTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPivotStaticsCache.get();
        return try _f.getHeaderTemplateProperty();
    }
    pub fn getSelectedIndexProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPivotStaticsCache.get();
        return try _f.getSelectedIndexProperty();
    }
    pub fn getSelectedItemProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPivotStaticsCache.get();
        return try _f.getSelectedItemProperty();
    }
    pub fn getIsLockedProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPivotStaticsCache.get();
        return try _f.getIsLockedProperty();
    }
    pub fn getSlideInAnimationGroupProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPivotStaticsCache.get();
        return try _f.getSlideInAnimationGroupProperty();
    }
    pub fn GetSlideInAnimationGroup(element: *FrameworkElement) core.HResult!PivotSlideInAnimationGroup {
        const _f = @This().IPivotStaticsCache.get();
        return try _f.GetSlideInAnimationGroup(element);
    }
    pub fn SetSlideInAnimationGroup(element: *FrameworkElement, value: PivotSlideInAnimationGroup) core.HResult!void {
        const _f = @This().IPivotStaticsCache.get();
        return try _f.SetSlideInAnimationGroup(element, value);
    }
    pub fn getHeaderFocusVisualPlacementProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPivotStatics3Cache.get();
        return try _f.getHeaderFocusVisualPlacementProperty();
    }
    pub fn getIsHeaderItemsCarouselEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPivotStatics3Cache.get();
        return try _f.getIsHeaderItemsCarouselEnabledProperty();
    }
    pub fn getLeftHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPivotStatics2Cache.get();
        return try _f.getLeftHeaderProperty();
    }
    pub fn getLeftHeaderTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPivotStatics2Cache.get();
        return try _f.getLeftHeaderTemplateProperty();
    }
    pub fn getRightHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPivotStatics2Cache.get();
        return try _f.getRightHeaderProperty();
    }
    pub fn getRightHeaderTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPivotStatics2Cache.get();
        return try _f.getRightHeaderTemplateProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*Pivot {
        const _f = @This().IPivotFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.Pivot";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IPivot.GUID;
    pub const IID: Guid = IPivot.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IPivot.SIGNATURE);
    var _IPivotStaticsCache: FactoryCache(IPivotStatics, RUNTIME_NAME) = .{};
    var _IPivotStatics3Cache: FactoryCache(IPivotStatics3, RUNTIME_NAME) = .{};
    var _IPivotStatics2Cache: FactoryCache(IPivotStatics2, RUNTIME_NAME) = .{};
    var _IPivotFactoryCache: FactoryCache(IPivotFactory, RUNTIME_NAME) = .{};
};
pub const PivotHeaderFocusVisualPlacement = enum(i32) {
    ItemHeaders = 0,
    SelectedItemHeader = 1,
};
pub const PivotItem = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        const this: *IPivotItem = @ptrCast(self);
        return try this.getHeader();
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IPivotItem = @ptrCast(self);
        return try this.putHeader(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IPivotItemStaticsCache.get();
        return try _f.getHeaderProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*PivotItem {
        const _f = @This().IPivotItemFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.PivotItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IPivotItem.GUID;
    pub const IID: Guid = IPivotItem.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IPivotItem.SIGNATURE);
    var _IPivotItemStaticsCache: FactoryCache(IPivotItemStatics, RUNTIME_NAME) = .{};
    var _IPivotItemFactoryCache: FactoryCache(IPivotItemFactory, RUNTIME_NAME) = .{};
};
pub const PivotItemEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getItem(self: *@This()) core.HResult!*PivotItem {
        const this: *IPivotItemEventArgs = @ptrCast(self);
        return try this.getItem();
    }
    pub fn putItem(self: *@This(), value: *PivotItem) core.HResult!void {
        const this: *IPivotItemEventArgs = @ptrCast(self);
        return try this.putItem(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IPivotItemEventArgs.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.PivotItemEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IPivotItemEventArgs.GUID;
    pub const IID: Guid = IPivotItemEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IPivotItemEventArgs.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const PivotSlideInAnimationGroup = enum(i32) {
    Default = 0,
    GroupOne = 1,
    GroupTwo = 2,
    GroupThree = 3,
};
pub const VirtualizingPanel = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getItemContainerGenerator(self: *@This()) core.HResult!*ItemContainerGenerator {
        const this: *IVirtualizingPanel = @ptrCast(self);
        return try this.getItemContainerGenerator();
    }
    pub fn AddInternalChild(self: *@This(), child: *UIElement) core.HResult!void {
        var this: ?*IVirtualizingPanelProtected = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IVirtualizingPanelProtected.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.AddInternalChild(child);
    }
    pub fn InsertInternalChild(self: *@This(), index: i32, child: *UIElement) core.HResult!void {
        var this: ?*IVirtualizingPanelProtected = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IVirtualizingPanelProtected.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.InsertInternalChild(index, child);
    }
    pub fn RemoveInternalChildRange(self: *@This(), index: i32, range: i32) core.HResult!void {
        var this: ?*IVirtualizingPanelProtected = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IVirtualizingPanelProtected.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.RemoveInternalChildRange(index, range);
    }
    pub fn OnItemsChanged(self: *@This(), sender: *IInspectable, args: *ItemsChangedEventArgs) core.HResult!void {
        var this: ?*IVirtualizingPanelOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IVirtualizingPanelOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnItemsChanged(sender, args);
    }
    pub fn OnClearChildren(self: *@This()) core.HResult!void {
        var this: ?*IVirtualizingPanelOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IVirtualizingPanelOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnClearChildren();
    }
    pub fn BringIndexIntoView(self: *@This(), index: i32) core.HResult!void {
        var this: ?*IVirtualizingPanelOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IVirtualizingPanelOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.BringIndexIntoView(index);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.VirtualizingPanel";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IVirtualizingPanel.GUID;
    pub const IID: Guid = IVirtualizingPanel.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IVirtualizingPanel.SIGNATURE);
    var _IVirtualizingPanelFactoryCache: FactoryCache(IVirtualizingPanelFactory, RUNTIME_NAME) = .{};
};
pub const Slider = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIntermediateValue(self: *@This()) core.HResult!f64 {
        const this: *ISlider = @ptrCast(self);
        return try this.getIntermediateValue();
    }
    pub fn putIntermediateValue(self: *@This(), value: f64) core.HResult!void {
        const this: *ISlider = @ptrCast(self);
        return try this.putIntermediateValue(value);
    }
    pub fn getStepFrequency(self: *@This()) core.HResult!f64 {
        const this: *ISlider = @ptrCast(self);
        return try this.getStepFrequency();
    }
    pub fn putStepFrequency(self: *@This(), value: f64) core.HResult!void {
        const this: *ISlider = @ptrCast(self);
        return try this.putStepFrequency(value);
    }
    pub fn getSnapsTo(self: *@This()) core.HResult!SliderSnapsTo {
        const this: *ISlider = @ptrCast(self);
        return try this.getSnapsTo();
    }
    pub fn putSnapsTo(self: *@This(), value: SliderSnapsTo) core.HResult!void {
        const this: *ISlider = @ptrCast(self);
        return try this.putSnapsTo(value);
    }
    pub fn getTickFrequency(self: *@This()) core.HResult!f64 {
        const this: *ISlider = @ptrCast(self);
        return try this.getTickFrequency();
    }
    pub fn putTickFrequency(self: *@This(), value: f64) core.HResult!void {
        const this: *ISlider = @ptrCast(self);
        return try this.putTickFrequency(value);
    }
    pub fn getTickPlacement(self: *@This()) core.HResult!TickPlacement {
        const this: *ISlider = @ptrCast(self);
        return try this.getTickPlacement();
    }
    pub fn putTickPlacement(self: *@This(), value: TickPlacement) core.HResult!void {
        const this: *ISlider = @ptrCast(self);
        return try this.putTickPlacement(value);
    }
    pub fn getOrientation(self: *@This()) core.HResult!Orientation {
        const this: *ISlider = @ptrCast(self);
        return try this.getOrientation();
    }
    pub fn putOrientation(self: *@This(), value: Orientation) core.HResult!void {
        const this: *ISlider = @ptrCast(self);
        return try this.putOrientation(value);
    }
    pub fn getIsDirectionReversed(self: *@This()) core.HResult!bool {
        const this: *ISlider = @ptrCast(self);
        return try this.getIsDirectionReversed();
    }
    pub fn putIsDirectionReversed(self: *@This(), value: bool) core.HResult!void {
        const this: *ISlider = @ptrCast(self);
        return try this.putIsDirectionReversed(value);
    }
    pub fn getIsThumbToolTipEnabled(self: *@This()) core.HResult!bool {
        const this: *ISlider = @ptrCast(self);
        return try this.getIsThumbToolTipEnabled();
    }
    pub fn putIsThumbToolTipEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *ISlider = @ptrCast(self);
        return try this.putIsThumbToolTipEnabled(value);
    }
    pub fn getThumbToolTipValueConverter(self: *@This()) core.HResult!*IValueConverter {
        const this: *ISlider = @ptrCast(self);
        return try this.getThumbToolTipValueConverter();
    }
    pub fn putThumbToolTipValueConverter(self: *@This(), value: *IValueConverter) core.HResult!void {
        const this: *ISlider = @ptrCast(self);
        return try this.putThumbToolTipValueConverter(value);
    }
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        var this: ?*ISlider2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISlider2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getHeader();
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        var this: ?*ISlider2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISlider2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putHeader(value);
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var this: ?*ISlider2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISlider2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getHeaderTemplate();
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        var this: ?*ISlider2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISlider2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putHeaderTemplate(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISliderStatics2Cache.get();
        return try _f.getHeaderProperty();
    }
    pub fn getHeaderTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISliderStatics2Cache.get();
        return try _f.getHeaderTemplateProperty();
    }
    pub fn getIntermediateValueProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISliderStaticsCache.get();
        return try _f.getIntermediateValueProperty();
    }
    pub fn getStepFrequencyProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISliderStaticsCache.get();
        return try _f.getStepFrequencyProperty();
    }
    pub fn getSnapsToProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISliderStaticsCache.get();
        return try _f.getSnapsToProperty();
    }
    pub fn getTickFrequencyProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISliderStaticsCache.get();
        return try _f.getTickFrequencyProperty();
    }
    pub fn getTickPlacementProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISliderStaticsCache.get();
        return try _f.getTickPlacementProperty();
    }
    pub fn getOrientationProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISliderStaticsCache.get();
        return try _f.getOrientationProperty();
    }
    pub fn getIsDirectionReversedProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISliderStaticsCache.get();
        return try _f.getIsDirectionReversedProperty();
    }
    pub fn getIsThumbToolTipEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISliderStaticsCache.get();
        return try _f.getIsThumbToolTipEnabledProperty();
    }
    pub fn getThumbToolTipValueConverterProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISliderStaticsCache.get();
        return try _f.getThumbToolTipValueConverterProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*Slider {
        const _f = @This().ISliderFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.Slider";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISlider.GUID;
    pub const IID: Guid = ISlider.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISlider.SIGNATURE);
    var _ISliderStatics2Cache: FactoryCache(ISliderStatics2, RUNTIME_NAME) = .{};
    var _ISliderStaticsCache: FactoryCache(ISliderStatics, RUNTIME_NAME) = .{};
    var _ISliderFactoryCache: FactoryCache(ISliderFactory, RUNTIME_NAME) = .{};
};
pub const ProgressBar = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsIndeterminate(self: *@This()) core.HResult!bool {
        const this: *IProgressBar = @ptrCast(self);
        return try this.getIsIndeterminate();
    }
    pub fn putIsIndeterminate(self: *@This(), value: bool) core.HResult!void {
        const this: *IProgressBar = @ptrCast(self);
        return try this.putIsIndeterminate(value);
    }
    pub fn getShowError(self: *@This()) core.HResult!bool {
        const this: *IProgressBar = @ptrCast(self);
        return try this.getShowError();
    }
    pub fn putShowError(self: *@This(), value: bool) core.HResult!void {
        const this: *IProgressBar = @ptrCast(self);
        return try this.putShowError(value);
    }
    pub fn getShowPaused(self: *@This()) core.HResult!bool {
        const this: *IProgressBar = @ptrCast(self);
        return try this.getShowPaused();
    }
    pub fn putShowPaused(self: *@This(), value: bool) core.HResult!void {
        const this: *IProgressBar = @ptrCast(self);
        return try this.putShowPaused(value);
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*ProgressBarTemplateSettings {
        const this: *IProgressBar = @ptrCast(self);
        return try this.getTemplateSettings();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getIsIndeterminateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IProgressBarStaticsCache.get();
        return try _f.getIsIndeterminateProperty();
    }
    pub fn getShowErrorProperty() core.HResult!*DependencyProperty {
        const _f = @This().IProgressBarStaticsCache.get();
        return try _f.getShowErrorProperty();
    }
    pub fn getShowPausedProperty() core.HResult!*DependencyProperty {
        const _f = @This().IProgressBarStaticsCache.get();
        return try _f.getShowPausedProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ProgressBar {
        const _f = @This().IProgressBarFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ProgressBar";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IProgressBar.GUID;
    pub const IID: Guid = IProgressBar.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IProgressBar.SIGNATURE);
    var _IProgressBarStaticsCache: FactoryCache(IProgressBarStatics, RUNTIME_NAME) = .{};
    var _IProgressBarFactoryCache: FactoryCache(IProgressBarFactory, RUNTIME_NAME) = .{};
};
pub const ProgressRing = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsActive(self: *@This()) core.HResult!bool {
        const this: *IProgressRing = @ptrCast(self);
        return try this.getIsActive();
    }
    pub fn putIsActive(self: *@This(), value: bool) core.HResult!void {
        const this: *IProgressRing = @ptrCast(self);
        return try this.putIsActive(value);
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*ProgressRingTemplateSettings {
        const this: *IProgressRing = @ptrCast(self);
        return try this.getTemplateSettings();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IProgressRing.IID)));
    }
    pub fn getIsActiveProperty() core.HResult!*DependencyProperty {
        const _f = @This().IProgressRingStaticsCache.get();
        return try _f.getIsActiveProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ProgressRing";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IProgressRing.GUID;
    pub const IID: Guid = IProgressRing.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IProgressRing.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IProgressRingStaticsCache: FactoryCache(IProgressRingStatics, RUNTIME_NAME) = .{};
};
pub const RatingControl = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getCaption(self: *@This()) core.HResult!HSTRING {
        const this: *IRatingControl = @ptrCast(self);
        return try this.getCaption();
    }
    pub fn putCaption(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IRatingControl = @ptrCast(self);
        return try this.putCaption(value);
    }
    pub fn getInitialSetValue(self: *@This()) core.HResult!i32 {
        const this: *IRatingControl = @ptrCast(self);
        return try this.getInitialSetValue();
    }
    pub fn putInitialSetValue(self: *@This(), value: i32) core.HResult!void {
        const this: *IRatingControl = @ptrCast(self);
        return try this.putInitialSetValue(value);
    }
    pub fn getIsClearEnabled(self: *@This()) core.HResult!bool {
        const this: *IRatingControl = @ptrCast(self);
        return try this.getIsClearEnabled();
    }
    pub fn putIsClearEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IRatingControl = @ptrCast(self);
        return try this.putIsClearEnabled(value);
    }
    pub fn getIsReadOnly(self: *@This()) core.HResult!bool {
        const this: *IRatingControl = @ptrCast(self);
        return try this.getIsReadOnly();
    }
    pub fn putIsReadOnly(self: *@This(), value: bool) core.HResult!void {
        const this: *IRatingControl = @ptrCast(self);
        return try this.putIsReadOnly(value);
    }
    pub fn getMaxRating(self: *@This()) core.HResult!i32 {
        const this: *IRatingControl = @ptrCast(self);
        return try this.getMaxRating();
    }
    pub fn putMaxRating(self: *@This(), value: i32) core.HResult!void {
        const this: *IRatingControl = @ptrCast(self);
        return try this.putMaxRating(value);
    }
    pub fn getPlaceholderValue(self: *@This()) core.HResult!f64 {
        const this: *IRatingControl = @ptrCast(self);
        return try this.getPlaceholderValue();
    }
    pub fn putPlaceholderValue(self: *@This(), value: f64) core.HResult!void {
        const this: *IRatingControl = @ptrCast(self);
        return try this.putPlaceholderValue(value);
    }
    pub fn getItemInfo(self: *@This()) core.HResult!*RatingItemInfo {
        const this: *IRatingControl = @ptrCast(self);
        return try this.getItemInfo();
    }
    pub fn putItemInfo(self: *@This(), value: *RatingItemInfo) core.HResult!void {
        const this: *IRatingControl = @ptrCast(self);
        return try this.putItemInfo(value);
    }
    pub fn getValue(self: *@This()) core.HResult!f64 {
        const this: *IRatingControl = @ptrCast(self);
        return try this.getValue();
    }
    pub fn putValue(self: *@This(), value: f64) core.HResult!void {
        const this: *IRatingControl = @ptrCast(self);
        return try this.putValue(value);
    }
    pub fn addValueChanged(self: *@This(), handler: *TypedEventHandler(RatingControl,IInspectable)) core.HResult!EventRegistrationToken {
        const this: *IRatingControl = @ptrCast(self);
        return try this.addValueChanged(handler);
    }
    pub fn removeValueChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IRatingControl = @ptrCast(self);
        return try this.removeValueChanged(token);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getCaptionProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRatingControlStaticsCache.get();
        return try _f.getCaptionProperty();
    }
    pub fn getInitialSetValueProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRatingControlStaticsCache.get();
        return try _f.getInitialSetValueProperty();
    }
    pub fn getIsClearEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRatingControlStaticsCache.get();
        return try _f.getIsClearEnabledProperty();
    }
    pub fn getIsReadOnlyProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRatingControlStaticsCache.get();
        return try _f.getIsReadOnlyProperty();
    }
    pub fn getMaxRatingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRatingControlStaticsCache.get();
        return try _f.getMaxRatingProperty();
    }
    pub fn getPlaceholderValueProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRatingControlStaticsCache.get();
        return try _f.getPlaceholderValueProperty();
    }
    pub fn getItemInfoProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRatingControlStaticsCache.get();
        return try _f.getItemInfoProperty();
    }
    pub fn getValueProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRatingControlStaticsCache.get();
        return try _f.getValueProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*RatingControl {
        const _f = @This().IRatingControlFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.RatingControl";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IRatingControl.GUID;
    pub const IID: Guid = IRatingControl.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IRatingControl.SIGNATURE);
    var _IRatingControlStaticsCache: FactoryCache(IRatingControlStatics, RUNTIME_NAME) = .{};
    var _IRatingControlFactoryCache: FactoryCache(IRatingControlFactory, RUNTIME_NAME) = .{};
};
pub const RatingItemInfo = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*RatingItemInfo {
        const _f = @This().IRatingItemInfoFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.RatingItemInfo";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IRatingItemInfo.GUID;
    pub const IID: Guid = IRatingItemInfo.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IRatingItemInfo.SIGNATURE);
    var _IRatingItemInfoFactoryCache: FactoryCache(IRatingItemInfoFactory, RUNTIME_NAME) = .{};
};
pub const RatingItemFontInfo = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getDisabledGlyph(self: *@This()) core.HResult!HSTRING {
        const this: *IRatingItemFontInfo = @ptrCast(self);
        return try this.getDisabledGlyph();
    }
    pub fn putDisabledGlyph(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IRatingItemFontInfo = @ptrCast(self);
        return try this.putDisabledGlyph(value);
    }
    pub fn getGlyph(self: *@This()) core.HResult!HSTRING {
        const this: *IRatingItemFontInfo = @ptrCast(self);
        return try this.getGlyph();
    }
    pub fn putGlyph(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IRatingItemFontInfo = @ptrCast(self);
        return try this.putGlyph(value);
    }
    pub fn getPointerOverGlyph(self: *@This()) core.HResult!HSTRING {
        const this: *IRatingItemFontInfo = @ptrCast(self);
        return try this.getPointerOverGlyph();
    }
    pub fn putPointerOverGlyph(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IRatingItemFontInfo = @ptrCast(self);
        return try this.putPointerOverGlyph(value);
    }
    pub fn getPointerOverPlaceholderGlyph(self: *@This()) core.HResult!HSTRING {
        const this: *IRatingItemFontInfo = @ptrCast(self);
        return try this.getPointerOverPlaceholderGlyph();
    }
    pub fn putPointerOverPlaceholderGlyph(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IRatingItemFontInfo = @ptrCast(self);
        return try this.putPointerOverPlaceholderGlyph(value);
    }
    pub fn getPlaceholderGlyph(self: *@This()) core.HResult!HSTRING {
        const this: *IRatingItemFontInfo = @ptrCast(self);
        return try this.getPlaceholderGlyph();
    }
    pub fn putPlaceholderGlyph(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IRatingItemFontInfo = @ptrCast(self);
        return try this.putPlaceholderGlyph(value);
    }
    pub fn getUnsetGlyph(self: *@This()) core.HResult!HSTRING {
        const this: *IRatingItemFontInfo = @ptrCast(self);
        return try this.getUnsetGlyph();
    }
    pub fn putUnsetGlyph(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IRatingItemFontInfo = @ptrCast(self);
        return try this.putUnsetGlyph(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getDisabledGlyphProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRatingItemFontInfoStaticsCache.get();
        return try _f.getDisabledGlyphProperty();
    }
    pub fn getGlyphProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRatingItemFontInfoStaticsCache.get();
        return try _f.getGlyphProperty();
    }
    pub fn getPlaceholderGlyphProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRatingItemFontInfoStaticsCache.get();
        return try _f.getPlaceholderGlyphProperty();
    }
    pub fn getPointerOverGlyphProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRatingItemFontInfoStaticsCache.get();
        return try _f.getPointerOverGlyphProperty();
    }
    pub fn getPointerOverPlaceholderGlyphProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRatingItemFontInfoStaticsCache.get();
        return try _f.getPointerOverPlaceholderGlyphProperty();
    }
    pub fn getUnsetGlyphProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRatingItemFontInfoStaticsCache.get();
        return try _f.getUnsetGlyphProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*RatingItemFontInfo {
        const _f = @This().IRatingItemFontInfoFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.RatingItemFontInfo";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IRatingItemFontInfo.GUID;
    pub const IID: Guid = IRatingItemFontInfo.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IRatingItemFontInfo.SIGNATURE);
    var _IRatingItemFontInfoStaticsCache: FactoryCache(IRatingItemFontInfoStatics, RUNTIME_NAME) = .{};
    var _IRatingItemFontInfoFactoryCache: FactoryCache(IRatingItemFontInfoFactory, RUNTIME_NAME) = .{};
};
pub const RatingItemImageInfo = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getDisabledImage(self: *@This()) core.HResult!*ImageSource {
        const this: *IRatingItemImageInfo = @ptrCast(self);
        return try this.getDisabledImage();
    }
    pub fn putDisabledImage(self: *@This(), value: *ImageSource) core.HResult!void {
        const this: *IRatingItemImageInfo = @ptrCast(self);
        return try this.putDisabledImage(value);
    }
    pub fn getImage(self: *@This()) core.HResult!*ImageSource {
        const this: *IRatingItemImageInfo = @ptrCast(self);
        return try this.getImage();
    }
    pub fn putImage(self: *@This(), value: *ImageSource) core.HResult!void {
        const this: *IRatingItemImageInfo = @ptrCast(self);
        return try this.putImage(value);
    }
    pub fn getPlaceholderImage(self: *@This()) core.HResult!*ImageSource {
        const this: *IRatingItemImageInfo = @ptrCast(self);
        return try this.getPlaceholderImage();
    }
    pub fn putPlaceholderImage(self: *@This(), value: *ImageSource) core.HResult!void {
        const this: *IRatingItemImageInfo = @ptrCast(self);
        return try this.putPlaceholderImage(value);
    }
    pub fn getPointerOverImage(self: *@This()) core.HResult!*ImageSource {
        const this: *IRatingItemImageInfo = @ptrCast(self);
        return try this.getPointerOverImage();
    }
    pub fn putPointerOverImage(self: *@This(), value: *ImageSource) core.HResult!void {
        const this: *IRatingItemImageInfo = @ptrCast(self);
        return try this.putPointerOverImage(value);
    }
    pub fn getPointerOverPlaceholderImage(self: *@This()) core.HResult!*ImageSource {
        const this: *IRatingItemImageInfo = @ptrCast(self);
        return try this.getPointerOverPlaceholderImage();
    }
    pub fn putPointerOverPlaceholderImage(self: *@This(), value: *ImageSource) core.HResult!void {
        const this: *IRatingItemImageInfo = @ptrCast(self);
        return try this.putPointerOverPlaceholderImage(value);
    }
    pub fn getUnsetImage(self: *@This()) core.HResult!*ImageSource {
        const this: *IRatingItemImageInfo = @ptrCast(self);
        return try this.getUnsetImage();
    }
    pub fn putUnsetImage(self: *@This(), value: *ImageSource) core.HResult!void {
        const this: *IRatingItemImageInfo = @ptrCast(self);
        return try this.putUnsetImage(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getDisabledImageProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRatingItemImageInfoStaticsCache.get();
        return try _f.getDisabledImageProperty();
    }
    pub fn getImageProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRatingItemImageInfoStaticsCache.get();
        return try _f.getImageProperty();
    }
    pub fn getPlaceholderImageProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRatingItemImageInfoStaticsCache.get();
        return try _f.getPlaceholderImageProperty();
    }
    pub fn getPointerOverImageProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRatingItemImageInfoStaticsCache.get();
        return try _f.getPointerOverImageProperty();
    }
    pub fn getPointerOverPlaceholderImageProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRatingItemImageInfoStaticsCache.get();
        return try _f.getPointerOverPlaceholderImageProperty();
    }
    pub fn getUnsetImageProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRatingItemImageInfoStaticsCache.get();
        return try _f.getUnsetImageProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*RatingItemImageInfo {
        const _f = @This().IRatingItemImageInfoFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.RatingItemImageInfo";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IRatingItemImageInfo.GUID;
    pub const IID: Guid = IRatingItemImageInfo.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IRatingItemImageInfo.SIGNATURE);
    var _IRatingItemImageInfoStaticsCache: FactoryCache(IRatingItemImageInfoStatics, RUNTIME_NAME) = .{};
    var _IRatingItemImageInfoFactoryCache: FactoryCache(IRatingItemImageInfoFactory, RUNTIME_NAME) = .{};
};
pub const RefreshContainer = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getVisualizer(self: *@This()) core.HResult!*RefreshVisualizer {
        const this: *IRefreshContainer = @ptrCast(self);
        return try this.getVisualizer();
    }
    pub fn putVisualizer(self: *@This(), value: *RefreshVisualizer) core.HResult!void {
        const this: *IRefreshContainer = @ptrCast(self);
        return try this.putVisualizer(value);
    }
    pub fn getPullDirection(self: *@This()) core.HResult!RefreshPullDirection {
        const this: *IRefreshContainer = @ptrCast(self);
        return try this.getPullDirection();
    }
    pub fn putPullDirection(self: *@This(), value: RefreshPullDirection) core.HResult!void {
        const this: *IRefreshContainer = @ptrCast(self);
        return try this.putPullDirection(value);
    }
    pub fn addRefreshRequested(self: *@This(), handler: *TypedEventHandler(RefreshContainer,RefreshRequestedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IRefreshContainer = @ptrCast(self);
        return try this.addRefreshRequested(handler);
    }
    pub fn removeRefreshRequested(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IRefreshContainer = @ptrCast(self);
        return try this.removeRefreshRequested(token);
    }
    pub fn RequestRefresh(self: *@This()) core.HResult!void {
        const this: *IRefreshContainer = @ptrCast(self);
        return try this.RequestRefresh();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getVisualizerProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRefreshContainerStaticsCache.get();
        return try _f.getVisualizerProperty();
    }
    pub fn getPullDirectionProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRefreshContainerStaticsCache.get();
        return try _f.getPullDirectionProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*RefreshContainer {
        const _f = @This().IRefreshContainerFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.RefreshContainer";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IRefreshContainer.GUID;
    pub const IID: Guid = IRefreshContainer.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IRefreshContainer.SIGNATURE);
    var _IRefreshContainerStaticsCache: FactoryCache(IRefreshContainerStatics, RUNTIME_NAME) = .{};
    var _IRefreshContainerFactoryCache: FactoryCache(IRefreshContainerFactory, RUNTIME_NAME) = .{};
};
pub const RefreshInteractionRatioChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getInteractionRatio(self: *@This()) core.HResult!f64 {
        const this: *IRefreshInteractionRatioChangedEventArgs = @ptrCast(self);
        return try this.getInteractionRatio();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.RefreshInteractionRatioChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IRefreshInteractionRatioChangedEventArgs.GUID;
    pub const IID: Guid = IRefreshInteractionRatioChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IRefreshInteractionRatioChangedEventArgs.SIGNATURE);
};
pub const RefreshPullDirection = enum(i32) {
    LeftToRight = 0,
    TopToBottom = 1,
    RightToLeft = 2,
    BottomToTop = 3,
};
pub const RefreshRequestedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn GetDeferral(self: *@This()) core.HResult!*Deferral {
        const this: *IRefreshRequestedEventArgs = @ptrCast(self);
        return try this.GetDeferral();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.RefreshRequestedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IRefreshRequestedEventArgs.GUID;
    pub const IID: Guid = IRefreshRequestedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IRefreshRequestedEventArgs.SIGNATURE);
};
pub const RefreshStateChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getOldState(self: *@This()) core.HResult!RefreshVisualizerState {
        const this: *IRefreshStateChangedEventArgs = @ptrCast(self);
        return try this.getOldState();
    }
    pub fn getNewState(self: *@This()) core.HResult!RefreshVisualizerState {
        const this: *IRefreshStateChangedEventArgs = @ptrCast(self);
        return try this.getNewState();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.RefreshStateChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IRefreshStateChangedEventArgs.GUID;
    pub const IID: Guid = IRefreshStateChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IRefreshStateChangedEventArgs.SIGNATURE);
};
pub const RefreshVisualizer = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn RequestRefresh(self: *@This()) core.HResult!void {
        const this: *IRefreshVisualizer = @ptrCast(self);
        return try this.RequestRefresh();
    }
    pub fn getOrientation(self: *@This()) core.HResult!RefreshVisualizerOrientation {
        const this: *IRefreshVisualizer = @ptrCast(self);
        return try this.getOrientation();
    }
    pub fn putOrientation(self: *@This(), value: RefreshVisualizerOrientation) core.HResult!void {
        const this: *IRefreshVisualizer = @ptrCast(self);
        return try this.putOrientation(value);
    }
    pub fn getContent(self: *@This()) core.HResult!*UIElement {
        const this: *IRefreshVisualizer = @ptrCast(self);
        return try this.getContent();
    }
    pub fn putContent(self: *@This(), value: *UIElement) core.HResult!void {
        const this: *IRefreshVisualizer = @ptrCast(self);
        return try this.putContent(value);
    }
    pub fn getState(self: *@This()) core.HResult!RefreshVisualizerState {
        const this: *IRefreshVisualizer = @ptrCast(self);
        return try this.getState();
    }
    pub fn addRefreshRequested(self: *@This(), handler: *TypedEventHandler(RefreshVisualizer,RefreshRequestedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IRefreshVisualizer = @ptrCast(self);
        return try this.addRefreshRequested(handler);
    }
    pub fn removeRefreshRequested(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IRefreshVisualizer = @ptrCast(self);
        return try this.removeRefreshRequested(token);
    }
    pub fn addRefreshStateChanged(self: *@This(), handler: *TypedEventHandler(RefreshVisualizer,RefreshStateChangedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IRefreshVisualizer = @ptrCast(self);
        return try this.addRefreshStateChanged(handler);
    }
    pub fn removeRefreshStateChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IRefreshVisualizer = @ptrCast(self);
        return try this.removeRefreshStateChanged(token);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getInfoProviderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRefreshVisualizerStaticsCache.get();
        return try _f.getInfoProviderProperty();
    }
    pub fn getOrientationProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRefreshVisualizerStaticsCache.get();
        return try _f.getOrientationProperty();
    }
    pub fn getContentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRefreshVisualizerStaticsCache.get();
        return try _f.getContentProperty();
    }
    pub fn getStateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRefreshVisualizerStaticsCache.get();
        return try _f.getStateProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*RefreshVisualizer {
        const _f = @This().IRefreshVisualizerFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.RefreshVisualizer";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IRefreshVisualizer.GUID;
    pub const IID: Guid = IRefreshVisualizer.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IRefreshVisualizer.SIGNATURE);
    var _IRefreshVisualizerStaticsCache: FactoryCache(IRefreshVisualizerStatics, RUNTIME_NAME) = .{};
    var _IRefreshVisualizerFactoryCache: FactoryCache(IRefreshVisualizerFactory, RUNTIME_NAME) = .{};
};
pub const RefreshVisualizerOrientation = enum(i32) {
    Auto = 0,
    Normal = 1,
    Rotate90DegreesCounterclockwise = 2,
    Rotate270DegreesCounterclockwise = 3,
};
pub const RefreshVisualizerState = enum(i32) {
    Idle = 0,
    Peeking = 1,
    Interacting = 2,
    Pending = 3,
    Refreshing = 4,
};
pub const RelativePanel = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getBorderBrush(self: *@This()) core.HResult!*Brush {
        const this: *IRelativePanel = @ptrCast(self);
        return try this.getBorderBrush();
    }
    pub fn putBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        const this: *IRelativePanel = @ptrCast(self);
        return try this.putBorderBrush(value);
    }
    pub fn getBorderThickness(self: *@This()) core.HResult!Thickness {
        const this: *IRelativePanel = @ptrCast(self);
        return try this.getBorderThickness();
    }
    pub fn putBorderThickness(self: *@This(), value: Thickness) core.HResult!void {
        const this: *IRelativePanel = @ptrCast(self);
        return try this.putBorderThickness(value);
    }
    pub fn getCornerRadius(self: *@This()) core.HResult!CornerRadius {
        const this: *IRelativePanel = @ptrCast(self);
        return try this.getCornerRadius();
    }
    pub fn putCornerRadius(self: *@This(), value: CornerRadius) core.HResult!void {
        const this: *IRelativePanel = @ptrCast(self);
        return try this.putCornerRadius(value);
    }
    pub fn getPadding(self: *@This()) core.HResult!Thickness {
        const this: *IRelativePanel = @ptrCast(self);
        return try this.getPadding();
    }
    pub fn putPadding(self: *@This(), value: Thickness) core.HResult!void {
        const this: *IRelativePanel = @ptrCast(self);
        return try this.putPadding(value);
    }
    pub fn getBackgroundSizing(self: *@This()) core.HResult!BackgroundSizing {
        var this: ?*IRelativePanel2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRelativePanel2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getBackgroundSizing();
    }
    pub fn putBackgroundSizing(self: *@This(), value: BackgroundSizing) core.HResult!void {
        var this: ?*IRelativePanel2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRelativePanel2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putBackgroundSizing(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getLeftOfProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.getLeftOfProperty();
    }
    pub fn GetLeftOf(element: *UIElement) core.HResult!*IInspectable {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.GetLeftOf(element);
    }
    pub fn SetLeftOf(element: *UIElement, value: *IInspectable) core.HResult!void {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.SetLeftOf(element, value);
    }
    pub fn getAboveProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.getAboveProperty();
    }
    pub fn GetAbove(element: *UIElement) core.HResult!*IInspectable {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.GetAbove(element);
    }
    pub fn SetAbove(element: *UIElement, value: *IInspectable) core.HResult!void {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.SetAbove(element, value);
    }
    pub fn getRightOfProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.getRightOfProperty();
    }
    pub fn GetRightOf(element: *UIElement) core.HResult!*IInspectable {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.GetRightOf(element);
    }
    pub fn SetRightOf(element: *UIElement, value: *IInspectable) core.HResult!void {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.SetRightOf(element, value);
    }
    pub fn getBelowProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.getBelowProperty();
    }
    pub fn GetBelow(element: *UIElement) core.HResult!*IInspectable {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.GetBelow(element);
    }
    pub fn SetBelow(element: *UIElement, value: *IInspectable) core.HResult!void {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.SetBelow(element, value);
    }
    pub fn getAlignHorizontalCenterWithProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.getAlignHorizontalCenterWithProperty();
    }
    pub fn GetAlignHorizontalCenterWith(element: *UIElement) core.HResult!*IInspectable {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.GetAlignHorizontalCenterWith(element);
    }
    pub fn SetAlignHorizontalCenterWith(element: *UIElement, value: *IInspectable) core.HResult!void {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.SetAlignHorizontalCenterWith(element, value);
    }
    pub fn getAlignVerticalCenterWithProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.getAlignVerticalCenterWithProperty();
    }
    pub fn GetAlignVerticalCenterWith(element: *UIElement) core.HResult!*IInspectable {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.GetAlignVerticalCenterWith(element);
    }
    pub fn SetAlignVerticalCenterWith(element: *UIElement, value: *IInspectable) core.HResult!void {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.SetAlignVerticalCenterWith(element, value);
    }
    pub fn getAlignLeftWithProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.getAlignLeftWithProperty();
    }
    pub fn GetAlignLeftWith(element: *UIElement) core.HResult!*IInspectable {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.GetAlignLeftWith(element);
    }
    pub fn SetAlignLeftWith(element: *UIElement, value: *IInspectable) core.HResult!void {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.SetAlignLeftWith(element, value);
    }
    pub fn getAlignTopWithProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.getAlignTopWithProperty();
    }
    pub fn GetAlignTopWith(element: *UIElement) core.HResult!*IInspectable {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.GetAlignTopWith(element);
    }
    pub fn SetAlignTopWith(element: *UIElement, value: *IInspectable) core.HResult!void {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.SetAlignTopWith(element, value);
    }
    pub fn getAlignRightWithProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.getAlignRightWithProperty();
    }
    pub fn GetAlignRightWith(element: *UIElement) core.HResult!*IInspectable {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.GetAlignRightWith(element);
    }
    pub fn SetAlignRightWith(element: *UIElement, value: *IInspectable) core.HResult!void {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.SetAlignRightWith(element, value);
    }
    pub fn getAlignBottomWithProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.getAlignBottomWithProperty();
    }
    pub fn GetAlignBottomWith(element: *UIElement) core.HResult!*IInspectable {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.GetAlignBottomWith(element);
    }
    pub fn SetAlignBottomWith(element: *UIElement, value: *IInspectable) core.HResult!void {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.SetAlignBottomWith(element, value);
    }
    pub fn getAlignLeftWithPanelProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.getAlignLeftWithPanelProperty();
    }
    pub fn GetAlignLeftWithPanel(element: *UIElement) core.HResult!bool {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.GetAlignLeftWithPanel(element);
    }
    pub fn SetAlignLeftWithPanel(element: *UIElement, value: bool) core.HResult!void {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.SetAlignLeftWithPanel(element, value);
    }
    pub fn getAlignTopWithPanelProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.getAlignTopWithPanelProperty();
    }
    pub fn GetAlignTopWithPanel(element: *UIElement) core.HResult!bool {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.GetAlignTopWithPanel(element);
    }
    pub fn SetAlignTopWithPanel(element: *UIElement, value: bool) core.HResult!void {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.SetAlignTopWithPanel(element, value);
    }
    pub fn getAlignRightWithPanelProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.getAlignRightWithPanelProperty();
    }
    pub fn GetAlignRightWithPanel(element: *UIElement) core.HResult!bool {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.GetAlignRightWithPanel(element);
    }
    pub fn SetAlignRightWithPanel(element: *UIElement, value: bool) core.HResult!void {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.SetAlignRightWithPanel(element, value);
    }
    pub fn getAlignBottomWithPanelProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.getAlignBottomWithPanelProperty();
    }
    pub fn GetAlignBottomWithPanel(element: *UIElement) core.HResult!bool {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.GetAlignBottomWithPanel(element);
    }
    pub fn SetAlignBottomWithPanel(element: *UIElement, value: bool) core.HResult!void {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.SetAlignBottomWithPanel(element, value);
    }
    pub fn getAlignHorizontalCenterWithPanelProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.getAlignHorizontalCenterWithPanelProperty();
    }
    pub fn GetAlignHorizontalCenterWithPanel(element: *UIElement) core.HResult!bool {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.GetAlignHorizontalCenterWithPanel(element);
    }
    pub fn SetAlignHorizontalCenterWithPanel(element: *UIElement, value: bool) core.HResult!void {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.SetAlignHorizontalCenterWithPanel(element, value);
    }
    pub fn getAlignVerticalCenterWithPanelProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.getAlignVerticalCenterWithPanelProperty();
    }
    pub fn GetAlignVerticalCenterWithPanel(element: *UIElement) core.HResult!bool {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.GetAlignVerticalCenterWithPanel(element);
    }
    pub fn SetAlignVerticalCenterWithPanel(element: *UIElement, value: bool) core.HResult!void {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.SetAlignVerticalCenterWithPanel(element, value);
    }
    pub fn getBorderBrushProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.getBorderBrushProperty();
    }
    pub fn getBorderThicknessProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.getBorderThicknessProperty();
    }
    pub fn getCornerRadiusProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.getCornerRadiusProperty();
    }
    pub fn getPaddingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRelativePanelStaticsCache.get();
        return try _f.getPaddingProperty();
    }
    pub fn getBackgroundSizingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRelativePanelStatics2Cache.get();
        return try _f.getBackgroundSizingProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*RelativePanel {
        const _f = @This().IRelativePanelFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.RelativePanel";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IRelativePanel.GUID;
    pub const IID: Guid = IRelativePanel.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IRelativePanel.SIGNATURE);
    var _IRelativePanelStaticsCache: FactoryCache(IRelativePanelStatics, RUNTIME_NAME) = .{};
    var _IRelativePanelStatics2Cache: FactoryCache(IRelativePanelStatics2, RUNTIME_NAME) = .{};
    var _IRelativePanelFactoryCache: FactoryCache(IRelativePanelFactory, RUNTIME_NAME) = .{};
};
pub const RequiresPointer = enum(i32) {
    Never = 0,
    WhenEngaged = 1,
    WhenFocused = 2,
};
pub const RichEditBox = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsReadOnly(self: *@This()) core.HResult!bool {
        const this: *IRichEditBox = @ptrCast(self);
        return try this.getIsReadOnly();
    }
    pub fn putIsReadOnly(self: *@This(), value: bool) core.HResult!void {
        const this: *IRichEditBox = @ptrCast(self);
        return try this.putIsReadOnly(value);
    }
    pub fn getAcceptsReturn(self: *@This()) core.HResult!bool {
        const this: *IRichEditBox = @ptrCast(self);
        return try this.getAcceptsReturn();
    }
    pub fn putAcceptsReturn(self: *@This(), value: bool) core.HResult!void {
        const this: *IRichEditBox = @ptrCast(self);
        return try this.putAcceptsReturn(value);
    }
    pub fn getTextAlignment(self: *@This()) core.HResult!TextAlignment {
        const this: *IRichEditBox = @ptrCast(self);
        return try this.getTextAlignment();
    }
    pub fn putTextAlignment(self: *@This(), value: TextAlignment) core.HResult!void {
        const this: *IRichEditBox = @ptrCast(self);
        return try this.putTextAlignment(value);
    }
    pub fn getTextWrapping(self: *@This()) core.HResult!TextWrapping {
        const this: *IRichEditBox = @ptrCast(self);
        return try this.getTextWrapping();
    }
    pub fn putTextWrapping(self: *@This(), value: TextWrapping) core.HResult!void {
        const this: *IRichEditBox = @ptrCast(self);
        return try this.putTextWrapping(value);
    }
    pub fn getIsSpellCheckEnabled(self: *@This()) core.HResult!bool {
        const this: *IRichEditBox = @ptrCast(self);
        return try this.getIsSpellCheckEnabled();
    }
    pub fn putIsSpellCheckEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IRichEditBox = @ptrCast(self);
        return try this.putIsSpellCheckEnabled(value);
    }
    pub fn getIsTextPredictionEnabled(self: *@This()) core.HResult!bool {
        const this: *IRichEditBox = @ptrCast(self);
        return try this.getIsTextPredictionEnabled();
    }
    pub fn putIsTextPredictionEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IRichEditBox = @ptrCast(self);
        return try this.putIsTextPredictionEnabled(value);
    }
    pub fn getDocument(self: *@This()) core.HResult!*ITextDocument {
        const this: *IRichEditBox = @ptrCast(self);
        return try this.getDocument();
    }
    pub fn getInputScope(self: *@This()) core.HResult!*InputScope {
        const this: *IRichEditBox = @ptrCast(self);
        return try this.getInputScope();
    }
    pub fn putInputScope(self: *@This(), value: *InputScope) core.HResult!void {
        const this: *IRichEditBox = @ptrCast(self);
        return try this.putInputScope(value);
    }
    pub fn addTextChanged(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IRichEditBox = @ptrCast(self);
        return try this.addTextChanged(handler);
    }
    pub fn removeTextChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IRichEditBox = @ptrCast(self);
        return try this.removeTextChanged(token);
    }
    pub fn addSelectionChanged(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IRichEditBox = @ptrCast(self);
        return try this.addSelectionChanged(handler);
    }
    pub fn removeSelectionChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IRichEditBox = @ptrCast(self);
        return try this.removeSelectionChanged(token);
    }
    pub fn addContextMenuOpening(self: *@This(), handler: *ContextMenuOpeningEventHandler) core.HResult!EventRegistrationToken {
        const this: *IRichEditBox = @ptrCast(self);
        return try this.addContextMenuOpening(handler);
    }
    pub fn removeContextMenuOpening(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IRichEditBox = @ptrCast(self);
        return try this.removeContextMenuOpening(token);
    }
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        var this: ?*IRichEditBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getHeader();
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        var this: ?*IRichEditBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putHeader(value);
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var this: ?*IRichEditBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getHeaderTemplate();
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        var this: ?*IRichEditBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putHeaderTemplate(value);
    }
    pub fn getPlaceholderText(self: *@This()) core.HResult!HSTRING {
        var this: ?*IRichEditBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getPlaceholderText();
    }
    pub fn putPlaceholderText(self: *@This(), value: HSTRING) core.HResult!void {
        var this: ?*IRichEditBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putPlaceholderText(value);
    }
    pub fn getSelectionHighlightColor(self: *@This()) core.HResult!*SolidColorBrush {
        var this: ?*IRichEditBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectionHighlightColor();
    }
    pub fn putSelectionHighlightColor(self: *@This(), value: *SolidColorBrush) core.HResult!void {
        var this: ?*IRichEditBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSelectionHighlightColor(value);
    }
    pub fn getPreventKeyboardDisplayOnProgrammaticFocus(self: *@This()) core.HResult!bool {
        var this: ?*IRichEditBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getPreventKeyboardDisplayOnProgrammaticFocus();
    }
    pub fn putPreventKeyboardDisplayOnProgrammaticFocus(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IRichEditBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putPreventKeyboardDisplayOnProgrammaticFocus(value);
    }
    pub fn getIsColorFontEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IRichEditBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsColorFontEnabled();
    }
    pub fn putIsColorFontEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IRichEditBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsColorFontEnabled(value);
    }
    pub fn addPaste(self: *@This(), handler: *TextControlPasteEventHandler) core.HResult!EventRegistrationToken {
        var this: ?*IRichEditBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addPaste(handler);
    }
    pub fn removePaste(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IRichEditBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removePaste(token);
    }
    pub fn addTextCompositionStarted(self: *@This(), handler: *TypedEventHandler(RichEditBox,TextCompositionStartedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IRichEditBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addTextCompositionStarted(handler);
    }
    pub fn removeTextCompositionStarted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IRichEditBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeTextCompositionStarted(token);
    }
    pub fn addTextCompositionChanged(self: *@This(), handler: *TypedEventHandler(RichEditBox,TextCompositionChangedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IRichEditBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addTextCompositionChanged(handler);
    }
    pub fn removeTextCompositionChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IRichEditBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeTextCompositionChanged(token);
    }
    pub fn addTextCompositionEnded(self: *@This(), handler: *TypedEventHandler(RichEditBox,TextCompositionEndedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IRichEditBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addTextCompositionEnded(handler);
    }
    pub fn removeTextCompositionEnded(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IRichEditBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeTextCompositionEnded(token);
    }
    pub fn getTextReadingOrder(self: *@This()) core.HResult!TextReadingOrder {
        var this: ?*IRichEditBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTextReadingOrder();
    }
    pub fn putTextReadingOrder(self: *@This(), value: TextReadingOrder) core.HResult!void {
        var this: ?*IRichEditBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTextReadingOrder(value);
    }
    pub fn getDesiredCandidateWindowAlignment(self: *@This()) core.HResult!CandidateWindowAlignment {
        var this: ?*IRichEditBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDesiredCandidateWindowAlignment();
    }
    pub fn putDesiredCandidateWindowAlignment(self: *@This(), value: CandidateWindowAlignment) core.HResult!void {
        var this: ?*IRichEditBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putDesiredCandidateWindowAlignment(value);
    }
    pub fn addCandidateWindowBoundsChanged(self: *@This(), handler: *TypedEventHandler(RichEditBox,CandidateWindowBoundsChangedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IRichEditBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addCandidateWindowBoundsChanged(handler);
    }
    pub fn removeCandidateWindowBoundsChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IRichEditBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeCandidateWindowBoundsChanged(token);
    }
    pub fn addTextChanging(self: *@This(), handler: *TypedEventHandler(RichEditBox,RichEditBoxTextChangingEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IRichEditBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addTextChanging(handler);
    }
    pub fn removeTextChanging(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IRichEditBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeTextChanging(token);
    }
    pub fn GetLinguisticAlternativesAsync(self: *@This()) core.HResult!*IAsyncOperation(IVectorView(HSTRING)) {
        var this: ?*IRichEditBox4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GetLinguisticAlternativesAsync();
    }
    pub fn getClipboardCopyFormat(self: *@This()) core.HResult!RichEditClipboardFormat {
        var this: ?*IRichEditBox4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getClipboardCopyFormat();
    }
    pub fn putClipboardCopyFormat(self: *@This(), value: RichEditClipboardFormat) core.HResult!void {
        var this: ?*IRichEditBox4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putClipboardCopyFormat(value);
    }
    pub fn getSelectionHighlightColorWhenNotFocused(self: *@This()) core.HResult!*SolidColorBrush {
        var this: ?*IRichEditBox5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectionHighlightColorWhenNotFocused();
    }
    pub fn putSelectionHighlightColorWhenNotFocused(self: *@This(), value: *SolidColorBrush) core.HResult!void {
        var this: ?*IRichEditBox5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSelectionHighlightColorWhenNotFocused(value);
    }
    pub fn getMaxLength(self: *@This()) core.HResult!i32 {
        var this: ?*IRichEditBox5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getMaxLength();
    }
    pub fn putMaxLength(self: *@This(), value: i32) core.HResult!void {
        var this: ?*IRichEditBox5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putMaxLength(value);
    }
    pub fn getHorizontalTextAlignment(self: *@This()) core.HResult!TextAlignment {
        var this: ?*IRichEditBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getHorizontalTextAlignment();
    }
    pub fn putHorizontalTextAlignment(self: *@This(), value: TextAlignment) core.HResult!void {
        var this: ?*IRichEditBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putHorizontalTextAlignment(value);
    }
    pub fn getCharacterCasing(self: *@This()) core.HResult!CharacterCasing {
        var this: ?*IRichEditBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCharacterCasing();
    }
    pub fn putCharacterCasing(self: *@This(), value: CharacterCasing) core.HResult!void {
        var this: ?*IRichEditBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putCharacterCasing(value);
    }
    pub fn getDisabledFormattingAccelerators(self: *@This()) core.HResult!DisabledFormattingAccelerators {
        var this: ?*IRichEditBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDisabledFormattingAccelerators();
    }
    pub fn putDisabledFormattingAccelerators(self: *@This(), value: DisabledFormattingAccelerators) core.HResult!void {
        var this: ?*IRichEditBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putDisabledFormattingAccelerators(value);
    }
    pub fn addCopyingToClipboard(self: *@This(), handler: *TypedEventHandler(RichEditBox,TextControlCopyingToClipboardEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IRichEditBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addCopyingToClipboard(handler);
    }
    pub fn removeCopyingToClipboard(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IRichEditBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeCopyingToClipboard(token);
    }
    pub fn addCuttingToClipboard(self: *@This(), handler: *TypedEventHandler(RichEditBox,TextControlCuttingToClipboardEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IRichEditBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addCuttingToClipboard(handler);
    }
    pub fn removeCuttingToClipboard(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IRichEditBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeCuttingToClipboard(token);
    }
    pub fn getContentLinkForegroundColor(self: *@This()) core.HResult!*SolidColorBrush {
        var this: ?*IRichEditBox7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getContentLinkForegroundColor();
    }
    pub fn putContentLinkForegroundColor(self: *@This(), value: *SolidColorBrush) core.HResult!void {
        var this: ?*IRichEditBox7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putContentLinkForegroundColor(value);
    }
    pub fn getContentLinkBackgroundColor(self: *@This()) core.HResult!*SolidColorBrush {
        var this: ?*IRichEditBox7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getContentLinkBackgroundColor();
    }
    pub fn putContentLinkBackgroundColor(self: *@This(), value: *SolidColorBrush) core.HResult!void {
        var this: ?*IRichEditBox7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putContentLinkBackgroundColor(value);
    }
    pub fn getContentLinkProviders(self: *@This()) core.HResult!*ContentLinkProviderCollection {
        var this: ?*IRichEditBox7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getContentLinkProviders();
    }
    pub fn putContentLinkProviders(self: *@This(), value: *ContentLinkProviderCollection) core.HResult!void {
        var this: ?*IRichEditBox7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putContentLinkProviders(value);
    }
    pub fn getHandwritingView(self: *@This()) core.HResult!*HandwritingView {
        var this: ?*IRichEditBox7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getHandwritingView();
    }
    pub fn putHandwritingView(self: *@This(), value: *HandwritingView) core.HResult!void {
        var this: ?*IRichEditBox7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putHandwritingView(value);
    }
    pub fn getIsHandwritingViewEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IRichEditBox7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsHandwritingViewEnabled();
    }
    pub fn putIsHandwritingViewEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IRichEditBox7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsHandwritingViewEnabled(value);
    }
    pub fn addContentLinkChanged(self: *@This(), handler: *TypedEventHandler(RichEditBox,ContentLinkChangedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IRichEditBox7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addContentLinkChanged(handler);
    }
    pub fn removeContentLinkChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IRichEditBox7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeContentLinkChanged(token);
    }
    pub fn addContentLinkInvoked(self: *@This(), handler: *TypedEventHandler(RichEditBox,ContentLinkInvokedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IRichEditBox7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addContentLinkInvoked(handler);
    }
    pub fn removeContentLinkInvoked(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IRichEditBox7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeContentLinkInvoked(token);
    }
    pub fn getTextDocument(self: *@This()) core.HResult!*RichEditTextDocument {
        var this: ?*IRichEditBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTextDocument();
    }
    pub fn getSelectionFlyout(self: *@This()) core.HResult!*FlyoutBase {
        var this: ?*IRichEditBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectionFlyout();
    }
    pub fn putSelectionFlyout(self: *@This(), value: *FlyoutBase) core.HResult!void {
        var this: ?*IRichEditBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSelectionFlyout(value);
    }
    pub fn getProofingMenuFlyout(self: *@This()) core.HResult!*FlyoutBase {
        var this: ?*IRichEditBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getProofingMenuFlyout();
    }
    pub fn getDescription(self: *@This()) core.HResult!*IInspectable {
        var this: ?*IRichEditBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDescription();
    }
    pub fn putDescription(self: *@This(), value: *IInspectable) core.HResult!void {
        var this: ?*IRichEditBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putDescription(value);
    }
    pub fn addSelectionChanging(self: *@This(), handler: *TypedEventHandler(RichEditBox,RichEditBoxSelectionChangingEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IRichEditBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addSelectionChanging(handler);
    }
    pub fn removeSelectionChanging(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IRichEditBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeSelectionChanging(token);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStatics2Cache.get();
        return try _f.getHeaderProperty();
    }
    pub fn getHeaderTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStatics2Cache.get();
        return try _f.getHeaderTemplateProperty();
    }
    pub fn getPlaceholderTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStatics2Cache.get();
        return try _f.getPlaceholderTextProperty();
    }
    pub fn getSelectionHighlightColorProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStatics2Cache.get();
        return try _f.getSelectionHighlightColorProperty();
    }
    pub fn getPreventKeyboardDisplayOnProgrammaticFocusProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStatics2Cache.get();
        return try _f.getPreventKeyboardDisplayOnProgrammaticFocusProperty();
    }
    pub fn getIsColorFontEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStatics2Cache.get();
        return try _f.getIsColorFontEnabledProperty();
    }
    pub fn getSelectionFlyoutProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStatics8Cache.get();
        return try _f.getSelectionFlyoutProperty();
    }
    pub fn getProofingMenuFlyoutProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStatics8Cache.get();
        return try _f.getProofingMenuFlyoutProperty();
    }
    pub fn getDescriptionProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStatics8Cache.get();
        return try _f.getDescriptionProperty();
    }
    pub fn getHorizontalTextAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStatics6Cache.get();
        return try _f.getHorizontalTextAlignmentProperty();
    }
    pub fn getCharacterCasingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStatics6Cache.get();
        return try _f.getCharacterCasingProperty();
    }
    pub fn getDisabledFormattingAcceleratorsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStatics6Cache.get();
        return try _f.getDisabledFormattingAcceleratorsProperty();
    }
    pub fn getSelectionHighlightColorWhenNotFocusedProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStatics5Cache.get();
        return try _f.getSelectionHighlightColorWhenNotFocusedProperty();
    }
    pub fn getMaxLengthProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStatics5Cache.get();
        return try _f.getMaxLengthProperty();
    }
    pub fn getDesiredCandidateWindowAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStatics3Cache.get();
        return try _f.getDesiredCandidateWindowAlignmentProperty();
    }
    pub fn getTextReadingOrderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStatics3Cache.get();
        return try _f.getTextReadingOrderProperty();
    }
    pub fn getIsReadOnlyProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStaticsCache.get();
        return try _f.getIsReadOnlyProperty();
    }
    pub fn getAcceptsReturnProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStaticsCache.get();
        return try _f.getAcceptsReturnProperty();
    }
    pub fn getTextAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStaticsCache.get();
        return try _f.getTextAlignmentProperty();
    }
    pub fn getTextWrappingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStaticsCache.get();
        return try _f.getTextWrappingProperty();
    }
    pub fn getIsSpellCheckEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStaticsCache.get();
        return try _f.getIsSpellCheckEnabledProperty();
    }
    pub fn getIsTextPredictionEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStaticsCache.get();
        return try _f.getIsTextPredictionEnabledProperty();
    }
    pub fn getInputScopeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStaticsCache.get();
        return try _f.getInputScopeProperty();
    }
    pub fn getClipboardCopyFormatProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStatics4Cache.get();
        return try _f.getClipboardCopyFormatProperty();
    }
    pub fn getContentLinkForegroundColorProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStatics7Cache.get();
        return try _f.getContentLinkForegroundColorProperty();
    }
    pub fn getContentLinkBackgroundColorProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStatics7Cache.get();
        return try _f.getContentLinkBackgroundColorProperty();
    }
    pub fn getContentLinkProvidersProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStatics7Cache.get();
        return try _f.getContentLinkProvidersProperty();
    }
    pub fn getHandwritingViewProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStatics7Cache.get();
        return try _f.getHandwritingViewProperty();
    }
    pub fn getIsHandwritingViewEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichEditBoxStatics7Cache.get();
        return try _f.getIsHandwritingViewEnabledProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*RichEditBox {
        const _f = @This().IRichEditBoxFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.RichEditBox";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IRichEditBox.GUID;
    pub const IID: Guid = IRichEditBox.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IRichEditBox.SIGNATURE);
    var _IRichEditBoxStatics2Cache: FactoryCache(IRichEditBoxStatics2, RUNTIME_NAME) = .{};
    var _IRichEditBoxStatics8Cache: FactoryCache(IRichEditBoxStatics8, RUNTIME_NAME) = .{};
    var _IRichEditBoxStatics6Cache: FactoryCache(IRichEditBoxStatics6, RUNTIME_NAME) = .{};
    var _IRichEditBoxStatics5Cache: FactoryCache(IRichEditBoxStatics5, RUNTIME_NAME) = .{};
    var _IRichEditBoxStatics3Cache: FactoryCache(IRichEditBoxStatics3, RUNTIME_NAME) = .{};
    var _IRichEditBoxStaticsCache: FactoryCache(IRichEditBoxStatics, RUNTIME_NAME) = .{};
    var _IRichEditBoxStatics4Cache: FactoryCache(IRichEditBoxStatics4, RUNTIME_NAME) = .{};
    var _IRichEditBoxStatics7Cache: FactoryCache(IRichEditBoxStatics7, RUNTIME_NAME) = .{};
    var _IRichEditBoxFactoryCache: FactoryCache(IRichEditBoxFactory, RUNTIME_NAME) = .{};
};
pub const RichEditBoxSelectionChangingEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getSelectionStart(self: *@This()) core.HResult!i32 {
        const this: *IRichEditBoxSelectionChangingEventArgs = @ptrCast(self);
        return try this.getSelectionStart();
    }
    pub fn getSelectionLength(self: *@This()) core.HResult!i32 {
        const this: *IRichEditBoxSelectionChangingEventArgs = @ptrCast(self);
        return try this.getSelectionLength();
    }
    pub fn getCancel(self: *@This()) core.HResult!bool {
        const this: *IRichEditBoxSelectionChangingEventArgs = @ptrCast(self);
        return try this.getCancel();
    }
    pub fn putCancel(self: *@This(), value: bool) core.HResult!void {
        const this: *IRichEditBoxSelectionChangingEventArgs = @ptrCast(self);
        return try this.putCancel(value);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.RichEditBoxSelectionChangingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IRichEditBoxSelectionChangingEventArgs.GUID;
    pub const IID: Guid = IRichEditBoxSelectionChangingEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IRichEditBoxSelectionChangingEventArgs.SIGNATURE);
};
pub const RichEditBoxTextChangingEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsContentChanging(self: *@This()) core.HResult!bool {
        var this: ?*IRichEditBoxTextChangingEventArgs2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichEditBoxTextChangingEventArgs2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsContentChanging();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.RichEditBoxTextChangingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IRichEditBoxTextChangingEventArgs.GUID;
    pub const IID: Guid = IRichEditBoxTextChangingEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IRichEditBoxTextChangingEventArgs.SIGNATURE);
};
pub const RichEditClipboardFormat = enum(i32) {
    AllFormats = 0,
    PlainText = 1,
};
pub const RichTextBlock = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getFontSize(self: *@This()) core.HResult!f64 {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getFontSize();
    }
    pub fn putFontSize(self: *@This(), value: f64) core.HResult!void {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.putFontSize(value);
    }
    pub fn getFontFamily(self: *@This()) core.HResult!*FontFamily {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getFontFamily();
    }
    pub fn putFontFamily(self: *@This(), value: *FontFamily) core.HResult!void {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.putFontFamily(value);
    }
    pub fn getFontWeight(self: *@This()) core.HResult!FontWeight {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getFontWeight();
    }
    pub fn putFontWeight(self: *@This(), value: FontWeight) core.HResult!void {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.putFontWeight(value);
    }
    pub fn getFontStyle(self: *@This()) core.HResult!FontStyle {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getFontStyle();
    }
    pub fn putFontStyle(self: *@This(), value: FontStyle) core.HResult!void {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.putFontStyle(value);
    }
    pub fn getFontStretch(self: *@This()) core.HResult!FontStretch {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getFontStretch();
    }
    pub fn putFontStretch(self: *@This(), value: FontStretch) core.HResult!void {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.putFontStretch(value);
    }
    pub fn getForeground(self: *@This()) core.HResult!*Brush {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getForeground();
    }
    pub fn putForeground(self: *@This(), value: *Brush) core.HResult!void {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.putForeground(value);
    }
    pub fn getTextWrapping(self: *@This()) core.HResult!TextWrapping {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getTextWrapping();
    }
    pub fn putTextWrapping(self: *@This(), value: TextWrapping) core.HResult!void {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.putTextWrapping(value);
    }
    pub fn getTextTrimming(self: *@This()) core.HResult!TextTrimming {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getTextTrimming();
    }
    pub fn putTextTrimming(self: *@This(), value: TextTrimming) core.HResult!void {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.putTextTrimming(value);
    }
    pub fn getTextAlignment(self: *@This()) core.HResult!TextAlignment {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getTextAlignment();
    }
    pub fn putTextAlignment(self: *@This(), value: TextAlignment) core.HResult!void {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.putTextAlignment(value);
    }
    pub fn getBlocks(self: *@This()) core.HResult!*BlockCollection {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getBlocks();
    }
    pub fn getPadding(self: *@This()) core.HResult!Thickness {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getPadding();
    }
    pub fn putPadding(self: *@This(), value: Thickness) core.HResult!void {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.putPadding(value);
    }
    pub fn getLineHeight(self: *@This()) core.HResult!f64 {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getLineHeight();
    }
    pub fn putLineHeight(self: *@This(), value: f64) core.HResult!void {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.putLineHeight(value);
    }
    pub fn getLineStackingStrategy(self: *@This()) core.HResult!LineStackingStrategy {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getLineStackingStrategy();
    }
    pub fn putLineStackingStrategy(self: *@This(), value: LineStackingStrategy) core.HResult!void {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.putLineStackingStrategy(value);
    }
    pub fn getCharacterSpacing(self: *@This()) core.HResult!i32 {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getCharacterSpacing();
    }
    pub fn putCharacterSpacing(self: *@This(), value: i32) core.HResult!void {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.putCharacterSpacing(value);
    }
    pub fn getOverflowContentTarget(self: *@This()) core.HResult!*RichTextBlockOverflow {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getOverflowContentTarget();
    }
    pub fn putOverflowContentTarget(self: *@This(), value: *RichTextBlockOverflow) core.HResult!void {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.putOverflowContentTarget(value);
    }
    pub fn getIsTextSelectionEnabled(self: *@This()) core.HResult!bool {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getIsTextSelectionEnabled();
    }
    pub fn putIsTextSelectionEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.putIsTextSelectionEnabled(value);
    }
    pub fn getHasOverflowContent(self: *@This()) core.HResult!bool {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getHasOverflowContent();
    }
    pub fn getSelectedText(self: *@This()) core.HResult!HSTRING {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getSelectedText();
    }
    pub fn getContentStart(self: *@This()) core.HResult!*TextPointer {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getContentStart();
    }
    pub fn getContentEnd(self: *@This()) core.HResult!*TextPointer {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getContentEnd();
    }
    pub fn getSelectionStart(self: *@This()) core.HResult!*TextPointer {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getSelectionStart();
    }
    pub fn getSelectionEnd(self: *@This()) core.HResult!*TextPointer {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getSelectionEnd();
    }
    pub fn getBaselineOffset(self: *@This()) core.HResult!f64 {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getBaselineOffset();
    }
    pub fn addSelectionChanged(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.addSelectionChanged(handler);
    }
    pub fn removeSelectionChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.removeSelectionChanged(token);
    }
    pub fn addContextMenuOpening(self: *@This(), handler: *ContextMenuOpeningEventHandler) core.HResult!EventRegistrationToken {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.addContextMenuOpening(handler);
    }
    pub fn removeContextMenuOpening(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.removeContextMenuOpening(token);
    }
    pub fn SelectAll(self: *@This()) core.HResult!void {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.SelectAll();
    }
    pub fn Select(self: *@This(), start: *TextPointer, end: *TextPointer) core.HResult!void {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.Select(start, end);
    }
    pub fn GetPositionFromPoint(self: *@This(), point: Point) core.HResult!*TextPointer {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.GetPositionFromPoint(point);
    }
    pub fn Focus(self: *@This(), value: FocusState) core.HResult!bool {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.Focus(value);
    }
    pub fn getTextIndent(self: *@This()) core.HResult!f64 {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.getTextIndent();
    }
    pub fn putTextIndent(self: *@This(), value: f64) core.HResult!void {
        const this: *IRichTextBlock = @ptrCast(self);
        return try this.putTextIndent(value);
    }
    pub fn getMaxLines(self: *@This()) core.HResult!i32 {
        var this: ?*IRichTextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getMaxLines();
    }
    pub fn putMaxLines(self: *@This(), value: i32) core.HResult!void {
        var this: ?*IRichTextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putMaxLines(value);
    }
    pub fn getTextLineBounds(self: *@This()) core.HResult!TextLineBounds {
        var this: ?*IRichTextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTextLineBounds();
    }
    pub fn putTextLineBounds(self: *@This(), value: TextLineBounds) core.HResult!void {
        var this: ?*IRichTextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTextLineBounds(value);
    }
    pub fn getSelectionHighlightColor(self: *@This()) core.HResult!*SolidColorBrush {
        var this: ?*IRichTextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectionHighlightColor();
    }
    pub fn putSelectionHighlightColor(self: *@This(), value: *SolidColorBrush) core.HResult!void {
        var this: ?*IRichTextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSelectionHighlightColor(value);
    }
    pub fn getOpticalMarginAlignment(self: *@This()) core.HResult!OpticalMarginAlignment {
        var this: ?*IRichTextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getOpticalMarginAlignment();
    }
    pub fn putOpticalMarginAlignment(self: *@This(), value: OpticalMarginAlignment) core.HResult!void {
        var this: ?*IRichTextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putOpticalMarginAlignment(value);
    }
    pub fn getIsColorFontEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IRichTextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsColorFontEnabled();
    }
    pub fn putIsColorFontEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IRichTextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsColorFontEnabled(value);
    }
    pub fn getTextReadingOrder(self: *@This()) core.HResult!TextReadingOrder {
        var this: ?*IRichTextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTextReadingOrder();
    }
    pub fn putTextReadingOrder(self: *@This(), value: TextReadingOrder) core.HResult!void {
        var this: ?*IRichTextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTextReadingOrder(value);
    }
    pub fn getIsTextScaleFactorEnabled(self: *@This()) core.HResult!bool {
        var this: ?*IRichTextBlock3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsTextScaleFactorEnabled();
    }
    pub fn putIsTextScaleFactorEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IRichTextBlock3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsTextScaleFactorEnabled(value);
    }
    pub fn getTextDecorations(self: *@This()) core.HResult!TextDecorations {
        var this: ?*IRichTextBlock4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTextDecorations();
    }
    pub fn putTextDecorations(self: *@This(), value: TextDecorations) core.HResult!void {
        var this: ?*IRichTextBlock4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTextDecorations(value);
    }
    pub fn getIsTextTrimmed(self: *@This()) core.HResult!bool {
        var this: ?*IRichTextBlock5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsTextTrimmed();
    }
    pub fn getHorizontalTextAlignment(self: *@This()) core.HResult!TextAlignment {
        var this: ?*IRichTextBlock5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getHorizontalTextAlignment();
    }
    pub fn putHorizontalTextAlignment(self: *@This(), value: TextAlignment) core.HResult!void {
        var this: ?*IRichTextBlock5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putHorizontalTextAlignment(value);
    }
    pub fn getTextHighlighters(self: *@This()) core.HResult!*IVector(TextHighlighter) {
        var this: ?*IRichTextBlock5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTextHighlighters();
    }
    pub fn addIsTextTrimmedChanged(self: *@This(), handler: *TypedEventHandler(RichTextBlock,IsTextTrimmedChangedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IRichTextBlock5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addIsTextTrimmedChanged(handler);
    }
    pub fn removeIsTextTrimmedChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IRichTextBlock5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeIsTextTrimmedChanged(token);
    }
    pub fn getSelectionFlyout(self: *@This()) core.HResult!*FlyoutBase {
        var this: ?*IRichTextBlock6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectionFlyout();
    }
    pub fn putSelectionFlyout(self: *@This(), value: *FlyoutBase) core.HResult!void {
        var this: ?*IRichTextBlock6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSelectionFlyout(value);
    }
    pub fn CopySelectionToClipboard(self: *@This()) core.HResult!void {
        var this: ?*IRichTextBlock6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlock6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.CopySelectionToClipboard();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IRichTextBlock.IID)));
    }
    pub fn getSelectionFlyoutProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStatics6Cache.get();
        return try _f.getSelectionFlyoutProperty();
    }
    pub fn getFontSizeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStaticsCache.get();
        return try _f.getFontSizeProperty();
    }
    pub fn getFontFamilyProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStaticsCache.get();
        return try _f.getFontFamilyProperty();
    }
    pub fn getFontWeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStaticsCache.get();
        return try _f.getFontWeightProperty();
    }
    pub fn getFontStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStaticsCache.get();
        return try _f.getFontStyleProperty();
    }
    pub fn getFontStretchProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStaticsCache.get();
        return try _f.getFontStretchProperty();
    }
    pub fn getForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStaticsCache.get();
        return try _f.getForegroundProperty();
    }
    pub fn getTextWrappingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStaticsCache.get();
        return try _f.getTextWrappingProperty();
    }
    pub fn getTextTrimmingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStaticsCache.get();
        return try _f.getTextTrimmingProperty();
    }
    pub fn getTextAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStaticsCache.get();
        return try _f.getTextAlignmentProperty();
    }
    pub fn getPaddingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStaticsCache.get();
        return try _f.getPaddingProperty();
    }
    pub fn getLineHeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStaticsCache.get();
        return try _f.getLineHeightProperty();
    }
    pub fn getLineStackingStrategyProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStaticsCache.get();
        return try _f.getLineStackingStrategyProperty();
    }
    pub fn getCharacterSpacingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStaticsCache.get();
        return try _f.getCharacterSpacingProperty();
    }
    pub fn getOverflowContentTargetProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStaticsCache.get();
        return try _f.getOverflowContentTargetProperty();
    }
    pub fn getIsTextSelectionEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStaticsCache.get();
        return try _f.getIsTextSelectionEnabledProperty();
    }
    pub fn getHasOverflowContentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStaticsCache.get();
        return try _f.getHasOverflowContentProperty();
    }
    pub fn getSelectedTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStaticsCache.get();
        return try _f.getSelectedTextProperty();
    }
    pub fn getTextIndentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStaticsCache.get();
        return try _f.getTextIndentProperty();
    }
    pub fn getIsTextTrimmedProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStatics5Cache.get();
        return try _f.getIsTextTrimmedProperty();
    }
    pub fn getHorizontalTextAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStatics5Cache.get();
        return try _f.getHorizontalTextAlignmentProperty();
    }
    pub fn getTextDecorationsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStatics4Cache.get();
        return try _f.getTextDecorationsProperty();
    }
    pub fn getIsTextScaleFactorEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStatics3Cache.get();
        return try _f.getIsTextScaleFactorEnabledProperty();
    }
    pub fn getMaxLinesProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStatics2Cache.get();
        return try _f.getMaxLinesProperty();
    }
    pub fn getTextLineBoundsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStatics2Cache.get();
        return try _f.getTextLineBoundsProperty();
    }
    pub fn getSelectionHighlightColorProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStatics2Cache.get();
        return try _f.getSelectionHighlightColorProperty();
    }
    pub fn getOpticalMarginAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStatics2Cache.get();
        return try _f.getOpticalMarginAlignmentProperty();
    }
    pub fn getIsColorFontEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStatics2Cache.get();
        return try _f.getIsColorFontEnabledProperty();
    }
    pub fn getTextReadingOrderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockStatics2Cache.get();
        return try _f.getTextReadingOrderProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.RichTextBlock";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IRichTextBlock.GUID;
    pub const IID: Guid = IRichTextBlock.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IRichTextBlock.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IRichTextBlockStatics6Cache: FactoryCache(IRichTextBlockStatics6, RUNTIME_NAME) = .{};
    var _IRichTextBlockStaticsCache: FactoryCache(IRichTextBlockStatics, RUNTIME_NAME) = .{};
    var _IRichTextBlockStatics5Cache: FactoryCache(IRichTextBlockStatics5, RUNTIME_NAME) = .{};
    var _IRichTextBlockStatics4Cache: FactoryCache(IRichTextBlockStatics4, RUNTIME_NAME) = .{};
    var _IRichTextBlockStatics3Cache: FactoryCache(IRichTextBlockStatics3, RUNTIME_NAME) = .{};
    var _IRichTextBlockStatics2Cache: FactoryCache(IRichTextBlockStatics2, RUNTIME_NAME) = .{};
};
pub const RichTextBlockOverflow = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getOverflowContentTarget(self: *@This()) core.HResult!*RichTextBlockOverflow {
        const this: *IRichTextBlockOverflow = @ptrCast(self);
        return try this.getOverflowContentTarget();
    }
    pub fn putOverflowContentTarget(self: *@This(), value: *RichTextBlockOverflow) core.HResult!void {
        const this: *IRichTextBlockOverflow = @ptrCast(self);
        return try this.putOverflowContentTarget(value);
    }
    pub fn getPadding(self: *@This()) core.HResult!Thickness {
        const this: *IRichTextBlockOverflow = @ptrCast(self);
        return try this.getPadding();
    }
    pub fn putPadding(self: *@This(), value: Thickness) core.HResult!void {
        const this: *IRichTextBlockOverflow = @ptrCast(self);
        return try this.putPadding(value);
    }
    pub fn getContentSource(self: *@This()) core.HResult!*RichTextBlock {
        const this: *IRichTextBlockOverflow = @ptrCast(self);
        return try this.getContentSource();
    }
    pub fn getHasOverflowContent(self: *@This()) core.HResult!bool {
        const this: *IRichTextBlockOverflow = @ptrCast(self);
        return try this.getHasOverflowContent();
    }
    pub fn getContentStart(self: *@This()) core.HResult!*TextPointer {
        const this: *IRichTextBlockOverflow = @ptrCast(self);
        return try this.getContentStart();
    }
    pub fn getContentEnd(self: *@This()) core.HResult!*TextPointer {
        const this: *IRichTextBlockOverflow = @ptrCast(self);
        return try this.getContentEnd();
    }
    pub fn getBaselineOffset(self: *@This()) core.HResult!f64 {
        const this: *IRichTextBlockOverflow = @ptrCast(self);
        return try this.getBaselineOffset();
    }
    pub fn GetPositionFromPoint(self: *@This(), point: Point) core.HResult!*TextPointer {
        const this: *IRichTextBlockOverflow = @ptrCast(self);
        return try this.GetPositionFromPoint(point);
    }
    pub fn Focus(self: *@This(), value: FocusState) core.HResult!bool {
        const this: *IRichTextBlockOverflow = @ptrCast(self);
        return try this.Focus(value);
    }
    pub fn getMaxLines(self: *@This()) core.HResult!i32 {
        var this: ?*IRichTextBlockOverflow2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlockOverflow2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getMaxLines();
    }
    pub fn putMaxLines(self: *@This(), value: i32) core.HResult!void {
        var this: ?*IRichTextBlockOverflow2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlockOverflow2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putMaxLines(value);
    }
    pub fn getIsTextTrimmed(self: *@This()) core.HResult!bool {
        var this: ?*IRichTextBlockOverflow3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlockOverflow3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsTextTrimmed();
    }
    pub fn addIsTextTrimmedChanged(self: *@This(), handler: *TypedEventHandler(RichTextBlockOverflow,IsTextTrimmedChangedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IRichTextBlockOverflow3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlockOverflow3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addIsTextTrimmedChanged(handler);
    }
    pub fn removeIsTextTrimmedChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IRichTextBlockOverflow3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IRichTextBlockOverflow3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeIsTextTrimmedChanged(token);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IRichTextBlockOverflow.IID)));
    }
    pub fn getIsTextTrimmedProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockOverflowStatics3Cache.get();
        return try _f.getIsTextTrimmedProperty();
    }
    pub fn getMaxLinesProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockOverflowStatics2Cache.get();
        return try _f.getMaxLinesProperty();
    }
    pub fn getOverflowContentTargetProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockOverflowStaticsCache.get();
        return try _f.getOverflowContentTargetProperty();
    }
    pub fn getPaddingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockOverflowStaticsCache.get();
        return try _f.getPaddingProperty();
    }
    pub fn getHasOverflowContentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRichTextBlockOverflowStaticsCache.get();
        return try _f.getHasOverflowContentProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.RichTextBlockOverflow";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IRichTextBlockOverflow.GUID;
    pub const IID: Guid = IRichTextBlockOverflow.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IRichTextBlockOverflow.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IRichTextBlockOverflowStatics3Cache: FactoryCache(IRichTextBlockOverflowStatics3, RUNTIME_NAME) = .{};
    var _IRichTextBlockOverflowStatics2Cache: FactoryCache(IRichTextBlockOverflowStatics2, RUNTIME_NAME) = .{};
    var _IRichTextBlockOverflowStaticsCache: FactoryCache(IRichTextBlockOverflowStatics, RUNTIME_NAME) = .{};
};
pub const RowDefinition = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getHeight(self: *@This()) core.HResult!GridLength {
        const this: *IRowDefinition = @ptrCast(self);
        return try this.getHeight();
    }
    pub fn putHeight(self: *@This(), value: GridLength) core.HResult!void {
        const this: *IRowDefinition = @ptrCast(self);
        return try this.putHeight(value);
    }
    pub fn getMaxHeight(self: *@This()) core.HResult!f64 {
        const this: *IRowDefinition = @ptrCast(self);
        return try this.getMaxHeight();
    }
    pub fn putMaxHeight(self: *@This(), value: f64) core.HResult!void {
        const this: *IRowDefinition = @ptrCast(self);
        return try this.putMaxHeight(value);
    }
    pub fn getMinHeight(self: *@This()) core.HResult!f64 {
        const this: *IRowDefinition = @ptrCast(self);
        return try this.getMinHeight();
    }
    pub fn putMinHeight(self: *@This(), value: f64) core.HResult!void {
        const this: *IRowDefinition = @ptrCast(self);
        return try this.putMinHeight(value);
    }
    pub fn getActualHeight(self: *@This()) core.HResult!f64 {
        const this: *IRowDefinition = @ptrCast(self);
        return try this.getActualHeight();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IRowDefinition.IID)));
    }
    pub fn getHeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRowDefinitionStaticsCache.get();
        return try _f.getHeightProperty();
    }
    pub fn getMaxHeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRowDefinitionStaticsCache.get();
        return try _f.getMaxHeightProperty();
    }
    pub fn getMinHeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().IRowDefinitionStaticsCache.get();
        return try _f.getMinHeightProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.RowDefinition";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IRowDefinition.GUID;
    pub const IID: Guid = IRowDefinition.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IRowDefinition.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IRowDefinitionStaticsCache: FactoryCache(IRowDefinitionStatics, RUNTIME_NAME) = .{};
};
pub const RowDefinitionCollection = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getSize(self: *@This()) core.HResult!u32 {
        const this: *IVector(RowDefinition) = @ptrCast(self);
        return try this.getSize();
    }
    pub fn GetView(self: *@This()) core.HResult!*IVectorView(RowDefinition) {
        const this: *IVector(RowDefinition) = @ptrCast(self);
        return try this.GetView();
    }
    pub fn RemoveAt(self: *@This(), index: u32) core.HResult!void {
        const this: *IVector(RowDefinition) = @ptrCast(self);
        return try this.RemoveAt(index);
    }
    pub fn RemoveAtEnd(self: *@This()) core.HResult!void {
        const this: *IVector(RowDefinition) = @ptrCast(self);
        return try this.RemoveAtEnd();
    }
    pub fn Clear(self: *@This()) core.HResult!void {
        const this: *IVector(RowDefinition) = @ptrCast(self);
        return try this.Clear();
    }
    pub fn First(self: *@This()) core.HResult!*IIterator(RowDefinition) {
        var this: ?*IIterable(RowDefinition) = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IIterable.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.First();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.RowDefinitionCollection";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IVector.GUID;
    pub const IID: Guid = IVector.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IVector.SIGNATURE);
};
pub const ScrollBarVisibility = enum(i32) {
    Disabled = 0,
    Auto = 1,
    Hidden = 2,
    Visible = 3,
};
pub const ScrollContentPresenter = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getCanVerticallyScroll(self: *@This()) core.HResult!bool {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.getCanVerticallyScroll();
    }
    pub fn putCanVerticallyScroll(self: *@This(), value: bool) core.HResult!void {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.putCanVerticallyScroll(value);
    }
    pub fn getCanHorizontallyScroll(self: *@This()) core.HResult!bool {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.getCanHorizontallyScroll();
    }
    pub fn putCanHorizontallyScroll(self: *@This(), value: bool) core.HResult!void {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.putCanHorizontallyScroll(value);
    }
    pub fn getExtentWidth(self: *@This()) core.HResult!f64 {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.getExtentWidth();
    }
    pub fn getExtentHeight(self: *@This()) core.HResult!f64 {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.getExtentHeight();
    }
    pub fn getViewportWidth(self: *@This()) core.HResult!f64 {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.getViewportWidth();
    }
    pub fn getViewportHeight(self: *@This()) core.HResult!f64 {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.getViewportHeight();
    }
    pub fn getHorizontalOffset(self: *@This()) core.HResult!f64 {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.getHorizontalOffset();
    }
    pub fn getVerticalOffset(self: *@This()) core.HResult!f64 {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.getVerticalOffset();
    }
    pub fn getScrollOwner(self: *@This()) core.HResult!*IInspectable {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.getScrollOwner();
    }
    pub fn putScrollOwner(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.putScrollOwner(value);
    }
    pub fn LineUp(self: *@This()) core.HResult!void {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.LineUp();
    }
    pub fn LineDown(self: *@This()) core.HResult!void {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.LineDown();
    }
    pub fn LineLeft(self: *@This()) core.HResult!void {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.LineLeft();
    }
    pub fn LineRight(self: *@This()) core.HResult!void {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.LineRight();
    }
    pub fn PageUp(self: *@This()) core.HResult!void {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.PageUp();
    }
    pub fn PageDown(self: *@This()) core.HResult!void {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.PageDown();
    }
    pub fn PageLeft(self: *@This()) core.HResult!void {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.PageLeft();
    }
    pub fn PageRight(self: *@This()) core.HResult!void {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.PageRight();
    }
    pub fn MouseWheelUp(self: *@This()) core.HResult!void {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.MouseWheelUp();
    }
    pub fn MouseWheelDown(self: *@This()) core.HResult!void {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.MouseWheelDown();
    }
    pub fn MouseWheelLeft(self: *@This()) core.HResult!void {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.MouseWheelLeft();
    }
    pub fn MouseWheelRight(self: *@This()) core.HResult!void {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.MouseWheelRight();
    }
    pub fn SetHorizontalOffset(self: *@This(), offset: f64) core.HResult!void {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.SetHorizontalOffset(offset);
    }
    pub fn SetVerticalOffset(self: *@This(), offset: f64) core.HResult!void {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.SetVerticalOffset(offset);
    }
    pub fn MakeVisible(self: *@This(), visual: *UIElement, rectangle: Rect) core.HResult!Rect {
        const this: *IScrollContentPresenter = @ptrCast(self);
        return try this.MakeVisible(visual, rectangle);
    }
    pub fn getCanContentRenderOutsideBounds(self: *@This()) core.HResult!bool {
        var this: ?*IScrollContentPresenter2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollContentPresenter2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCanContentRenderOutsideBounds();
    }
    pub fn putCanContentRenderOutsideBounds(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IScrollContentPresenter2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollContentPresenter2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putCanContentRenderOutsideBounds(value);
    }
    pub fn getSizesContentToTemplatedParent(self: *@This()) core.HResult!bool {
        var this: ?*IScrollContentPresenter2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollContentPresenter2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSizesContentToTemplatedParent();
    }
    pub fn putSizesContentToTemplatedParent(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IScrollContentPresenter2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollContentPresenter2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSizesContentToTemplatedParent(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IScrollContentPresenter.IID)));
    }
    pub fn getCanContentRenderOutsideBoundsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollContentPresenterStatics2Cache.get();
        return try _f.getCanContentRenderOutsideBoundsProperty();
    }
    pub fn getSizesContentToTemplatedParentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollContentPresenterStatics2Cache.get();
        return try _f.getSizesContentToTemplatedParentProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ScrollContentPresenter";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IScrollContentPresenter.GUID;
    pub const IID: Guid = IScrollContentPresenter.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IScrollContentPresenter.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IScrollContentPresenterStatics2Cache: FactoryCache(IScrollContentPresenterStatics2, RUNTIME_NAME) = .{};
};
pub const ScrollIntoViewAlignment = enum(i32) {
    Default = 0,
    Leading = 1,
};
pub const ScrollMode = enum(i32) {
    Disabled = 0,
    Enabled = 1,
    Auto = 2,
};
pub const ScrollViewer = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getHorizontalScrollBarVisibility(self: *@This()) core.HResult!ScrollBarVisibility {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getHorizontalScrollBarVisibility();
    }
    pub fn putHorizontalScrollBarVisibility(self: *@This(), value: ScrollBarVisibility) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.putHorizontalScrollBarVisibility(value);
    }
    pub fn getVerticalScrollBarVisibility(self: *@This()) core.HResult!ScrollBarVisibility {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getVerticalScrollBarVisibility();
    }
    pub fn putVerticalScrollBarVisibility(self: *@This(), value: ScrollBarVisibility) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.putVerticalScrollBarVisibility(value);
    }
    pub fn getIsHorizontalRailEnabled(self: *@This()) core.HResult!bool {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getIsHorizontalRailEnabled();
    }
    pub fn putIsHorizontalRailEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.putIsHorizontalRailEnabled(value);
    }
    pub fn getIsVerticalRailEnabled(self: *@This()) core.HResult!bool {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getIsVerticalRailEnabled();
    }
    pub fn putIsVerticalRailEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.putIsVerticalRailEnabled(value);
    }
    pub fn getIsHorizontalScrollChainingEnabled(self: *@This()) core.HResult!bool {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getIsHorizontalScrollChainingEnabled();
    }
    pub fn putIsHorizontalScrollChainingEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.putIsHorizontalScrollChainingEnabled(value);
    }
    pub fn getIsVerticalScrollChainingEnabled(self: *@This()) core.HResult!bool {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getIsVerticalScrollChainingEnabled();
    }
    pub fn putIsVerticalScrollChainingEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.putIsVerticalScrollChainingEnabled(value);
    }
    pub fn getIsZoomChainingEnabled(self: *@This()) core.HResult!bool {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getIsZoomChainingEnabled();
    }
    pub fn putIsZoomChainingEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.putIsZoomChainingEnabled(value);
    }
    pub fn getIsScrollInertiaEnabled(self: *@This()) core.HResult!bool {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getIsScrollInertiaEnabled();
    }
    pub fn putIsScrollInertiaEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.putIsScrollInertiaEnabled(value);
    }
    pub fn getIsZoomInertiaEnabled(self: *@This()) core.HResult!bool {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getIsZoomInertiaEnabled();
    }
    pub fn putIsZoomInertiaEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.putIsZoomInertiaEnabled(value);
    }
    pub fn getHorizontalScrollMode(self: *@This()) core.HResult!ScrollMode {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getHorizontalScrollMode();
    }
    pub fn putHorizontalScrollMode(self: *@This(), value: ScrollMode) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.putHorizontalScrollMode(value);
    }
    pub fn getVerticalScrollMode(self: *@This()) core.HResult!ScrollMode {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getVerticalScrollMode();
    }
    pub fn putVerticalScrollMode(self: *@This(), value: ScrollMode) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.putVerticalScrollMode(value);
    }
    pub fn getZoomMode(self: *@This()) core.HResult!ZoomMode {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getZoomMode();
    }
    pub fn putZoomMode(self: *@This(), value: ZoomMode) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.putZoomMode(value);
    }
    pub fn getHorizontalSnapPointsAlignment(self: *@This()) core.HResult!SnapPointsAlignment {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getHorizontalSnapPointsAlignment();
    }
    pub fn putHorizontalSnapPointsAlignment(self: *@This(), value: SnapPointsAlignment) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.putHorizontalSnapPointsAlignment(value);
    }
    pub fn getVerticalSnapPointsAlignment(self: *@This()) core.HResult!SnapPointsAlignment {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getVerticalSnapPointsAlignment();
    }
    pub fn putVerticalSnapPointsAlignment(self: *@This(), value: SnapPointsAlignment) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.putVerticalSnapPointsAlignment(value);
    }
    pub fn getHorizontalSnapPointsType(self: *@This()) core.HResult!SnapPointsType {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getHorizontalSnapPointsType();
    }
    pub fn putHorizontalSnapPointsType(self: *@This(), value: SnapPointsType) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.putHorizontalSnapPointsType(value);
    }
    pub fn getVerticalSnapPointsType(self: *@This()) core.HResult!SnapPointsType {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getVerticalSnapPointsType();
    }
    pub fn putVerticalSnapPointsType(self: *@This(), value: SnapPointsType) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.putVerticalSnapPointsType(value);
    }
    pub fn getZoomSnapPointsType(self: *@This()) core.HResult!SnapPointsType {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getZoomSnapPointsType();
    }
    pub fn putZoomSnapPointsType(self: *@This(), value: SnapPointsType) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.putZoomSnapPointsType(value);
    }
    pub fn getHorizontalOffset(self: *@This()) core.HResult!f64 {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getHorizontalOffset();
    }
    pub fn getViewportWidth(self: *@This()) core.HResult!f64 {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getViewportWidth();
    }
    pub fn getScrollableWidth(self: *@This()) core.HResult!f64 {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getScrollableWidth();
    }
    pub fn getComputedHorizontalScrollBarVisibility(self: *@This()) core.HResult!Visibility {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getComputedHorizontalScrollBarVisibility();
    }
    pub fn getExtentWidth(self: *@This()) core.HResult!f64 {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getExtentWidth();
    }
    pub fn getVerticalOffset(self: *@This()) core.HResult!f64 {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getVerticalOffset();
    }
    pub fn getViewportHeight(self: *@This()) core.HResult!f64 {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getViewportHeight();
    }
    pub fn getScrollableHeight(self: *@This()) core.HResult!f64 {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getScrollableHeight();
    }
    pub fn getComputedVerticalScrollBarVisibility(self: *@This()) core.HResult!Visibility {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getComputedVerticalScrollBarVisibility();
    }
    pub fn getExtentHeight(self: *@This()) core.HResult!f64 {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getExtentHeight();
    }
    pub fn getMinZoomFactor(self: *@This()) core.HResult!f32 {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getMinZoomFactor();
    }
    pub fn putMinZoomFactor(self: *@This(), value: f32) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.putMinZoomFactor(value);
    }
    pub fn getMaxZoomFactor(self: *@This()) core.HResult!f32 {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getMaxZoomFactor();
    }
    pub fn putMaxZoomFactor(self: *@This(), value: f32) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.putMaxZoomFactor(value);
    }
    pub fn getZoomFactor(self: *@This()) core.HResult!f32 {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getZoomFactor();
    }
    pub fn getZoomSnapPoints(self: *@This()) core.HResult!*IVector(f32) {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getZoomSnapPoints();
    }
    pub fn addViewChanged(self: *@This(), handler: *EventHandler(ScrollViewerViewChangedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.addViewChanged(handler);
    }
    pub fn removeViewChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.removeViewChanged(token);
    }
    pub fn ScrollToHorizontalOffset(self: *@This(), offset: f64) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.ScrollToHorizontalOffset(offset);
    }
    pub fn ScrollToVerticalOffset(self: *@This(), offset: f64) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.ScrollToVerticalOffset(offset);
    }
    pub fn ZoomToFactor(self: *@This(), factor: f32) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.ZoomToFactor(factor);
    }
    pub fn InvalidateScrollInfo(self: *@This()) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.InvalidateScrollInfo();
    }
    pub fn getIsDeferredScrollingEnabled(self: *@This()) core.HResult!bool {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getIsDeferredScrollingEnabled();
    }
    pub fn putIsDeferredScrollingEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.putIsDeferredScrollingEnabled(value);
    }
    pub fn getBringIntoViewOnFocusChange(self: *@This()) core.HResult!bool {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.getBringIntoViewOnFocusChange();
    }
    pub fn putBringIntoViewOnFocusChange(self: *@This(), value: bool) core.HResult!void {
        const this: *IScrollViewer = @ptrCast(self);
        return try this.putBringIntoViewOnFocusChange(value);
    }
    pub fn getTopLeftHeader(self: *@This()) core.HResult!*UIElement {
        var this: ?*IScrollViewer2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTopLeftHeader();
    }
    pub fn putTopLeftHeader(self: *@This(), value: *UIElement) core.HResult!void {
        var this: ?*IScrollViewer2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTopLeftHeader(value);
    }
    pub fn getLeftHeader(self: *@This()) core.HResult!*UIElement {
        var this: ?*IScrollViewer2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getLeftHeader();
    }
    pub fn putLeftHeader(self: *@This(), value: *UIElement) core.HResult!void {
        var this: ?*IScrollViewer2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putLeftHeader(value);
    }
    pub fn getTopHeader(self: *@This()) core.HResult!*UIElement {
        var this: ?*IScrollViewer2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTopHeader();
    }
    pub fn putTopHeader(self: *@This(), value: *UIElement) core.HResult!void {
        var this: ?*IScrollViewer2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTopHeader(value);
    }
    pub fn addViewChanging(self: *@This(), handler: *EventHandler(ScrollViewerViewChangingEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IScrollViewer2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addViewChanging(handler);
    }
    pub fn removeViewChanging(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IScrollViewer2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeViewChanging(token);
    }
    pub fn ChangeView(self: *@This(), horizontalOffset: *IReference(f64), verticalOffset: *IReference(f64), zoomFactor: *IReference(f32)) core.HResult!bool {
        var this: ?*IScrollViewer2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.ChangeView(horizontalOffset, verticalOffset, zoomFactor);
    }
    pub fn ChangeViewWithDisableAnimation(self: *@This(), horizontalOffset: *IReference(f64), verticalOffset: *IReference(f64), zoomFactor: *IReference(f32), disableAnimation: bool) core.HResult!bool {
        var this: ?*IScrollViewer2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.ChangeViewWithDisableAnimation(horizontalOffset, verticalOffset, zoomFactor, disableAnimation);
    }
    pub fn addDirectManipulationStarted(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        var this: ?*IScrollViewer3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addDirectManipulationStarted(handler);
    }
    pub fn removeDirectManipulationStarted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IScrollViewer3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeDirectManipulationStarted(token);
    }
    pub fn addDirectManipulationCompleted(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        var this: ?*IScrollViewer3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addDirectManipulationCompleted(handler);
    }
    pub fn removeDirectManipulationCompleted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IScrollViewer3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeDirectManipulationCompleted(token);
    }
    pub fn getReduceViewportForCoreInputViewOcclusions(self: *@This()) core.HResult!bool {
        var this: ?*IScrollViewer4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getReduceViewportForCoreInputViewOcclusions();
    }
    pub fn putReduceViewportForCoreInputViewOcclusions(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IScrollViewer4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putReduceViewportForCoreInputViewOcclusions(value);
    }
    pub fn getHorizontalAnchorRatio(self: *@This()) core.HResult!f64 {
        var this: ?*IScrollViewer4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getHorizontalAnchorRatio();
    }
    pub fn putHorizontalAnchorRatio(self: *@This(), value: f64) core.HResult!void {
        var this: ?*IScrollViewer4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putHorizontalAnchorRatio(value);
    }
    pub fn getVerticalAnchorRatio(self: *@This()) core.HResult!f64 {
        var this: ?*IScrollViewer4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getVerticalAnchorRatio();
    }
    pub fn putVerticalAnchorRatio(self: *@This(), value: f64) core.HResult!void {
        var this: ?*IScrollViewer4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putVerticalAnchorRatio(value);
    }
    pub fn getCanContentRenderOutsideBounds(self: *@This()) core.HResult!bool {
        var this: ?*IScrollViewer4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCanContentRenderOutsideBounds();
    }
    pub fn putCanContentRenderOutsideBounds(self: *@This(), value: bool) core.HResult!void {
        var this: ?*IScrollViewer4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putCanContentRenderOutsideBounds(value);
    }
    pub fn addAnchorRequested(self: *@This(), handler: *TypedEventHandler(ScrollViewer,AnchorRequestedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IScrollViewer4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addAnchorRequested(handler);
    }
    pub fn removeAnchorRequested(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IScrollViewer4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollViewer4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeAnchorRequested(token);
    }
    pub fn getCurrentAnchor(self: *@This()) core.HResult!*UIElement {
        var this: ?*IScrollAnchorProvider = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollAnchorProvider.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCurrentAnchor();
    }
    pub fn RegisterAnchorCandidate(self: *@This(), element: *UIElement) core.HResult!void {
        var this: ?*IScrollAnchorProvider = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollAnchorProvider.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.RegisterAnchorCandidate(element);
    }
    pub fn UnregisterAnchorCandidate(self: *@This(), element: *UIElement) core.HResult!void {
        var this: ?*IScrollAnchorProvider = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollAnchorProvider.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.UnregisterAnchorCandidate(element);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IScrollViewer.IID)));
    }
    pub fn getHorizontalSnapPointsAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getHorizontalSnapPointsAlignmentProperty();
    }
    pub fn getVerticalSnapPointsAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getVerticalSnapPointsAlignmentProperty();
    }
    pub fn getHorizontalSnapPointsTypeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getHorizontalSnapPointsTypeProperty();
    }
    pub fn getVerticalSnapPointsTypeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getVerticalSnapPointsTypeProperty();
    }
    pub fn getZoomSnapPointsTypeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getZoomSnapPointsTypeProperty();
    }
    pub fn getHorizontalOffsetProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getHorizontalOffsetProperty();
    }
    pub fn getViewportWidthProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getViewportWidthProperty();
    }
    pub fn getScrollableWidthProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getScrollableWidthProperty();
    }
    pub fn getComputedHorizontalScrollBarVisibilityProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getComputedHorizontalScrollBarVisibilityProperty();
    }
    pub fn getExtentWidthProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getExtentWidthProperty();
    }
    pub fn getVerticalOffsetProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getVerticalOffsetProperty();
    }
    pub fn getViewportHeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getViewportHeightProperty();
    }
    pub fn getScrollableHeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getScrollableHeightProperty();
    }
    pub fn getComputedVerticalScrollBarVisibilityProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getComputedVerticalScrollBarVisibilityProperty();
    }
    pub fn getExtentHeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getExtentHeightProperty();
    }
    pub fn getMinZoomFactorProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getMinZoomFactorProperty();
    }
    pub fn getMaxZoomFactorProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getMaxZoomFactorProperty();
    }
    pub fn getZoomFactorProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getZoomFactorProperty();
    }
    pub fn getZoomSnapPointsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getZoomSnapPointsProperty();
    }
    pub fn getHorizontalScrollBarVisibilityProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getHorizontalScrollBarVisibilityProperty();
    }
    pub fn GetHorizontalScrollBarVisibility(element: *DependencyObject) core.HResult!ScrollBarVisibility {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.GetHorizontalScrollBarVisibility(element);
    }
    pub fn SetHorizontalScrollBarVisibility(element: *DependencyObject, horizontalScrollBarVisibility: ScrollBarVisibility) core.HResult!void {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.SetHorizontalScrollBarVisibility(element, horizontalScrollBarVisibility);
    }
    pub fn getVerticalScrollBarVisibilityProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getVerticalScrollBarVisibilityProperty();
    }
    pub fn GetVerticalScrollBarVisibility(element: *DependencyObject) core.HResult!ScrollBarVisibility {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.GetVerticalScrollBarVisibility(element);
    }
    pub fn SetVerticalScrollBarVisibility(element: *DependencyObject, verticalScrollBarVisibility: ScrollBarVisibility) core.HResult!void {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.SetVerticalScrollBarVisibility(element, verticalScrollBarVisibility);
    }
    pub fn getIsHorizontalRailEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getIsHorizontalRailEnabledProperty();
    }
    pub fn GetIsHorizontalRailEnabled(element: *DependencyObject) core.HResult!bool {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.GetIsHorizontalRailEnabled(element);
    }
    pub fn SetIsHorizontalRailEnabled(element: *DependencyObject, isHorizontalRailEnabled: bool) core.HResult!void {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.SetIsHorizontalRailEnabled(element, isHorizontalRailEnabled);
    }
    pub fn getIsVerticalRailEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getIsVerticalRailEnabledProperty();
    }
    pub fn GetIsVerticalRailEnabled(element: *DependencyObject) core.HResult!bool {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.GetIsVerticalRailEnabled(element);
    }
    pub fn SetIsVerticalRailEnabled(element: *DependencyObject, isVerticalRailEnabled: bool) core.HResult!void {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.SetIsVerticalRailEnabled(element, isVerticalRailEnabled);
    }
    pub fn getIsHorizontalScrollChainingEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getIsHorizontalScrollChainingEnabledProperty();
    }
    pub fn GetIsHorizontalScrollChainingEnabled(element: *DependencyObject) core.HResult!bool {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.GetIsHorizontalScrollChainingEnabled(element);
    }
    pub fn SetIsHorizontalScrollChainingEnabled(element: *DependencyObject, isHorizontalScrollChainingEnabled: bool) core.HResult!void {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.SetIsHorizontalScrollChainingEnabled(element, isHorizontalScrollChainingEnabled);
    }
    pub fn getIsVerticalScrollChainingEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getIsVerticalScrollChainingEnabledProperty();
    }
    pub fn GetIsVerticalScrollChainingEnabled(element: *DependencyObject) core.HResult!bool {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.GetIsVerticalScrollChainingEnabled(element);
    }
    pub fn SetIsVerticalScrollChainingEnabled(element: *DependencyObject, isVerticalScrollChainingEnabled: bool) core.HResult!void {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.SetIsVerticalScrollChainingEnabled(element, isVerticalScrollChainingEnabled);
    }
    pub fn getIsZoomChainingEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getIsZoomChainingEnabledProperty();
    }
    pub fn GetIsZoomChainingEnabled(element: *DependencyObject) core.HResult!bool {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.GetIsZoomChainingEnabled(element);
    }
    pub fn SetIsZoomChainingEnabled(element: *DependencyObject, isZoomChainingEnabled: bool) core.HResult!void {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.SetIsZoomChainingEnabled(element, isZoomChainingEnabled);
    }
    pub fn getIsScrollInertiaEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getIsScrollInertiaEnabledProperty();
    }
    pub fn GetIsScrollInertiaEnabled(element: *DependencyObject) core.HResult!bool {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.GetIsScrollInertiaEnabled(element);
    }
    pub fn SetIsScrollInertiaEnabled(element: *DependencyObject, isScrollInertiaEnabled: bool) core.HResult!void {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.SetIsScrollInertiaEnabled(element, isScrollInertiaEnabled);
    }
    pub fn getIsZoomInertiaEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getIsZoomInertiaEnabledProperty();
    }
    pub fn GetIsZoomInertiaEnabled(element: *DependencyObject) core.HResult!bool {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.GetIsZoomInertiaEnabled(element);
    }
    pub fn SetIsZoomInertiaEnabled(element: *DependencyObject, isZoomInertiaEnabled: bool) core.HResult!void {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.SetIsZoomInertiaEnabled(element, isZoomInertiaEnabled);
    }
    pub fn getHorizontalScrollModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getHorizontalScrollModeProperty();
    }
    pub fn GetHorizontalScrollMode(element: *DependencyObject) core.HResult!ScrollMode {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.GetHorizontalScrollMode(element);
    }
    pub fn SetHorizontalScrollMode(element: *DependencyObject, horizontalScrollMode: ScrollMode) core.HResult!void {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.SetHorizontalScrollMode(element, horizontalScrollMode);
    }
    pub fn getVerticalScrollModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getVerticalScrollModeProperty();
    }
    pub fn GetVerticalScrollMode(element: *DependencyObject) core.HResult!ScrollMode {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.GetVerticalScrollMode(element);
    }
    pub fn SetVerticalScrollMode(element: *DependencyObject, verticalScrollMode: ScrollMode) core.HResult!void {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.SetVerticalScrollMode(element, verticalScrollMode);
    }
    pub fn getZoomModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getZoomModeProperty();
    }
    pub fn GetZoomMode(element: *DependencyObject) core.HResult!ZoomMode {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.GetZoomMode(element);
    }
    pub fn SetZoomMode(element: *DependencyObject, zoomMode: ZoomMode) core.HResult!void {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.SetZoomMode(element, zoomMode);
    }
    pub fn getIsDeferredScrollingEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getIsDeferredScrollingEnabledProperty();
    }
    pub fn GetIsDeferredScrollingEnabled(element: *DependencyObject) core.HResult!bool {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.GetIsDeferredScrollingEnabled(element);
    }
    pub fn SetIsDeferredScrollingEnabled(element: *DependencyObject, isDeferredScrollingEnabled: bool) core.HResult!void {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.SetIsDeferredScrollingEnabled(element, isDeferredScrollingEnabled);
    }
    pub fn getBringIntoViewOnFocusChangeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.getBringIntoViewOnFocusChangeProperty();
    }
    pub fn GetBringIntoViewOnFocusChange(element: *DependencyObject) core.HResult!bool {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.GetBringIntoViewOnFocusChange(element);
    }
    pub fn SetBringIntoViewOnFocusChange(element: *DependencyObject, bringIntoViewOnFocusChange: bool) core.HResult!void {
        const _f = @This().IScrollViewerStaticsCache.get();
        return try _f.SetBringIntoViewOnFocusChange(element, bringIntoViewOnFocusChange);
    }
    pub fn getTopLeftHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStatics2Cache.get();
        return try _f.getTopLeftHeaderProperty();
    }
    pub fn getLeftHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStatics2Cache.get();
        return try _f.getLeftHeaderProperty();
    }
    pub fn getTopHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStatics2Cache.get();
        return try _f.getTopHeaderProperty();
    }
    pub fn getReduceViewportForCoreInputViewOcclusionsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStatics4Cache.get();
        return try _f.getReduceViewportForCoreInputViewOcclusionsProperty();
    }
    pub fn getHorizontalAnchorRatioProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStatics4Cache.get();
        return try _f.getHorizontalAnchorRatioProperty();
    }
    pub fn getVerticalAnchorRatioProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStatics4Cache.get();
        return try _f.getVerticalAnchorRatioProperty();
    }
    pub fn getCanContentRenderOutsideBoundsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IScrollViewerStatics4Cache.get();
        return try _f.getCanContentRenderOutsideBoundsProperty();
    }
    pub fn GetCanContentRenderOutsideBounds(element: *DependencyObject) core.HResult!bool {
        const _f = @This().IScrollViewerStatics4Cache.get();
        return try _f.GetCanContentRenderOutsideBounds(element);
    }
    pub fn SetCanContentRenderOutsideBounds(element: *DependencyObject, canContentRenderOutsideBounds: bool) core.HResult!void {
        const _f = @This().IScrollViewerStatics4Cache.get();
        return try _f.SetCanContentRenderOutsideBounds(element, canContentRenderOutsideBounds);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ScrollViewer";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IScrollViewer.GUID;
    pub const IID: Guid = IScrollViewer.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IScrollViewer.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IScrollViewerStaticsCache: FactoryCache(IScrollViewerStatics, RUNTIME_NAME) = .{};
    var _IScrollViewerStatics2Cache: FactoryCache(IScrollViewerStatics2, RUNTIME_NAME) = .{};
    var _IScrollViewerStatics4Cache: FactoryCache(IScrollViewerStatics4, RUNTIME_NAME) = .{};
};
pub const ScrollViewerView = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getHorizontalOffset(self: *@This()) core.HResult!f64 {
        const this: *IScrollViewerView = @ptrCast(self);
        return try this.getHorizontalOffset();
    }
    pub fn getVerticalOffset(self: *@This()) core.HResult!f64 {
        const this: *IScrollViewerView = @ptrCast(self);
        return try this.getVerticalOffset();
    }
    pub fn getZoomFactor(self: *@This()) core.HResult!f32 {
        const this: *IScrollViewerView = @ptrCast(self);
        return try this.getZoomFactor();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ScrollViewerView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IScrollViewerView.GUID;
    pub const IID: Guid = IScrollViewerView.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IScrollViewerView.SIGNATURE);
};
pub const ScrollViewerViewChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsIntermediate(self: *@This()) core.HResult!bool {
        const this: *IScrollViewerViewChangedEventArgs = @ptrCast(self);
        return try this.getIsIntermediate();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IScrollViewerViewChangedEventArgs.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ScrollViewerViewChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IScrollViewerViewChangedEventArgs.GUID;
    pub const IID: Guid = IScrollViewerViewChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IScrollViewerViewChangedEventArgs.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const ScrollViewerViewChangingEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getNextView(self: *@This()) core.HResult!*ScrollViewerView {
        const this: *IScrollViewerViewChangingEventArgs = @ptrCast(self);
        return try this.getNextView();
    }
    pub fn getFinalView(self: *@This()) core.HResult!*ScrollViewerView {
        const this: *IScrollViewerViewChangingEventArgs = @ptrCast(self);
        return try this.getFinalView();
    }
    pub fn getIsInertial(self: *@This()) core.HResult!bool {
        const this: *IScrollViewerViewChangingEventArgs = @ptrCast(self);
        return try this.getIsInertial();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ScrollViewerViewChangingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IScrollViewerViewChangingEventArgs.GUID;
    pub const IID: Guid = IScrollViewerViewChangingEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IScrollViewerViewChangingEventArgs.SIGNATURE);
};
pub const SearchBox = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getSearchHistoryEnabled(self: *@This()) core.HResult!bool {
        const this: *ISearchBox = @ptrCast(self);
        return try this.getSearchHistoryEnabled();
    }
    pub fn putSearchHistoryEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *ISearchBox = @ptrCast(self);
        return try this.putSearchHistoryEnabled(value);
    }
    pub fn getSearchHistoryContext(self: *@This()) core.HResult!HSTRING {
        const this: *ISearchBox = @ptrCast(self);
        return try this.getSearchHistoryContext();
    }
    pub fn putSearchHistoryContext(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *ISearchBox = @ptrCast(self);
        return try this.putSearchHistoryContext(value);
    }
    pub fn getPlaceholderText(self: *@This()) core.HResult!HSTRING {
        const this: *ISearchBox = @ptrCast(self);
        return try this.getPlaceholderText();
    }
    pub fn putPlaceholderText(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *ISearchBox = @ptrCast(self);
        return try this.putPlaceholderText(value);
    }
    pub fn getQueryText(self: *@This()) core.HResult!HSTRING {
        const this: *ISearchBox = @ptrCast(self);
        return try this.getQueryText();
    }
    pub fn putQueryText(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *ISearchBox = @ptrCast(self);
        return try this.putQueryText(value);
    }
    pub fn getFocusOnKeyboardInput(self: *@This()) core.HResult!bool {
        const this: *ISearchBox = @ptrCast(self);
        return try this.getFocusOnKeyboardInput();
    }
    pub fn putFocusOnKeyboardInput(self: *@This(), value: bool) core.HResult!void {
        const this: *ISearchBox = @ptrCast(self);
        return try this.putFocusOnKeyboardInput(value);
    }
    pub fn getChooseSuggestionOnEnter(self: *@This()) core.HResult!bool {
        const this: *ISearchBox = @ptrCast(self);
        return try this.getChooseSuggestionOnEnter();
    }
    pub fn putChooseSuggestionOnEnter(self: *@This(), value: bool) core.HResult!void {
        const this: *ISearchBox = @ptrCast(self);
        return try this.putChooseSuggestionOnEnter(value);
    }
    pub fn addQueryChanged(self: *@This(), handler: *TypedEventHandler(SearchBox,SearchBoxQueryChangedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *ISearchBox = @ptrCast(self);
        return try this.addQueryChanged(handler);
    }
    pub fn removeQueryChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ISearchBox = @ptrCast(self);
        return try this.removeQueryChanged(token);
    }
    pub fn addSuggestionsRequested(self: *@This(), handler: *TypedEventHandler(SearchBox,SearchBoxSuggestionsRequestedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *ISearchBox = @ptrCast(self);
        return try this.addSuggestionsRequested(handler);
    }
    pub fn removeSuggestionsRequested(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ISearchBox = @ptrCast(self);
        return try this.removeSuggestionsRequested(token);
    }
    pub fn addQuerySubmitted(self: *@This(), handler: *TypedEventHandler(SearchBox,SearchBoxQuerySubmittedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *ISearchBox = @ptrCast(self);
        return try this.addQuerySubmitted(handler);
    }
    pub fn removeQuerySubmitted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ISearchBox = @ptrCast(self);
        return try this.removeQuerySubmitted(token);
    }
    pub fn addResultSuggestionChosen(self: *@This(), handler: *TypedEventHandler(SearchBox,SearchBoxResultSuggestionChosenEventArgs)) core.HResult!EventRegistrationToken {
        const this: *ISearchBox = @ptrCast(self);
        return try this.addResultSuggestionChosen(handler);
    }
    pub fn removeResultSuggestionChosen(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ISearchBox = @ptrCast(self);
        return try this.removeResultSuggestionChosen(token);
    }
    pub fn addPrepareForFocusOnKeyboardInput(self: *@This(), handler: *TypedEventHandler(SearchBox,RoutedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *ISearchBox = @ptrCast(self);
        return try this.addPrepareForFocusOnKeyboardInput(handler);
    }
    pub fn removePrepareForFocusOnKeyboardInput(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ISearchBox = @ptrCast(self);
        return try this.removePrepareForFocusOnKeyboardInput(token);
    }
    pub fn SetLocalContentSuggestionSettings(self: *@This(), settings: *LocalContentSuggestionSettings) core.HResult!void {
        const this: *ISearchBox = @ptrCast(self);
        return try this.SetLocalContentSuggestionSettings(settings);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getSearchHistoryEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISearchBoxStaticsCache.get();
        return try _f.getSearchHistoryEnabledProperty();
    }
    pub fn getSearchHistoryContextProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISearchBoxStaticsCache.get();
        return try _f.getSearchHistoryContextProperty();
    }
    pub fn getPlaceholderTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISearchBoxStaticsCache.get();
        return try _f.getPlaceholderTextProperty();
    }
    pub fn getQueryTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISearchBoxStaticsCache.get();
        return try _f.getQueryTextProperty();
    }
    pub fn getFocusOnKeyboardInputProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISearchBoxStaticsCache.get();
        return try _f.getFocusOnKeyboardInputProperty();
    }
    pub fn getChooseSuggestionOnEnterProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISearchBoxStaticsCache.get();
        return try _f.getChooseSuggestionOnEnterProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SearchBox {
        const _f = @This().ISearchBoxFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SearchBox";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISearchBox.GUID;
    pub const IID: Guid = ISearchBox.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISearchBox.SIGNATURE);
    var _ISearchBoxStaticsCache: FactoryCache(ISearchBoxStatics, RUNTIME_NAME) = .{};
    var _ISearchBoxFactoryCache: FactoryCache(ISearchBoxFactory, RUNTIME_NAME) = .{};
};
pub const SearchBoxQueryChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getQueryText(self: *@This()) core.HResult!HSTRING {
        const this: *ISearchBoxQueryChangedEventArgs = @ptrCast(self);
        return try this.getQueryText();
    }
    pub fn getLanguage(self: *@This()) core.HResult!HSTRING {
        const this: *ISearchBoxQueryChangedEventArgs = @ptrCast(self);
        return try this.getLanguage();
    }
    pub fn getLinguisticDetails(self: *@This()) core.HResult!*SearchQueryLinguisticDetails {
        const this: *ISearchBoxQueryChangedEventArgs = @ptrCast(self);
        return try this.getLinguisticDetails();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SearchBoxQueryChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISearchBoxQueryChangedEventArgs.GUID;
    pub const IID: Guid = ISearchBoxQueryChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISearchBoxQueryChangedEventArgs.SIGNATURE);
};
pub const SearchBoxQuerySubmittedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getQueryText(self: *@This()) core.HResult!HSTRING {
        const this: *ISearchBoxQuerySubmittedEventArgs = @ptrCast(self);
        return try this.getQueryText();
    }
    pub fn getLanguage(self: *@This()) core.HResult!HSTRING {
        const this: *ISearchBoxQuerySubmittedEventArgs = @ptrCast(self);
        return try this.getLanguage();
    }
    pub fn getLinguisticDetails(self: *@This()) core.HResult!*SearchQueryLinguisticDetails {
        const this: *ISearchBoxQuerySubmittedEventArgs = @ptrCast(self);
        return try this.getLinguisticDetails();
    }
    pub fn getKeyModifiers(self: *@This()) core.HResult!VirtualKeyModifiers {
        const this: *ISearchBoxQuerySubmittedEventArgs = @ptrCast(self);
        return try this.getKeyModifiers();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SearchBoxQuerySubmittedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISearchBoxQuerySubmittedEventArgs.GUID;
    pub const IID: Guid = ISearchBoxQuerySubmittedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISearchBoxQuerySubmittedEventArgs.SIGNATURE);
};
pub const SearchBoxResultSuggestionChosenEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getTag(self: *@This()) core.HResult!HSTRING {
        const this: *ISearchBoxResultSuggestionChosenEventArgs = @ptrCast(self);
        return try this.getTag();
    }
    pub fn getKeyModifiers(self: *@This()) core.HResult!VirtualKeyModifiers {
        const this: *ISearchBoxResultSuggestionChosenEventArgs = @ptrCast(self);
        return try this.getKeyModifiers();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&ISearchBoxResultSuggestionChosenEventArgs.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SearchBoxResultSuggestionChosenEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISearchBoxResultSuggestionChosenEventArgs.GUID;
    pub const IID: Guid = ISearchBoxResultSuggestionChosenEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISearchBoxResultSuggestionChosenEventArgs.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const SearchBoxSuggestionsRequestedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getQueryText(self: *@This()) core.HResult!HSTRING {
        const this: *ISearchBoxSuggestionsRequestedEventArgs = @ptrCast(self);
        return try this.getQueryText();
    }
    pub fn getLanguage(self: *@This()) core.HResult!HSTRING {
        const this: *ISearchBoxSuggestionsRequestedEventArgs = @ptrCast(self);
        return try this.getLanguage();
    }
    pub fn getLinguisticDetails(self: *@This()) core.HResult!*SearchQueryLinguisticDetails {
        const this: *ISearchBoxSuggestionsRequestedEventArgs = @ptrCast(self);
        return try this.getLinguisticDetails();
    }
    pub fn getRequest(self: *@This()) core.HResult!*SearchSuggestionsRequest {
        const this: *ISearchBoxSuggestionsRequestedEventArgs = @ptrCast(self);
        return try this.getRequest();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SearchBoxSuggestionsRequestedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISearchBoxSuggestionsRequestedEventArgs.GUID;
    pub const IID: Guid = ISearchBoxSuggestionsRequestedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISearchBoxSuggestionsRequestedEventArgs.SIGNATURE);
};
pub const SectionsInViewChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getAddedSections(self: *@This()) core.HResult!*IVector(HubSection) {
        const this: *ISectionsInViewChangedEventArgs = @ptrCast(self);
        return try this.getAddedSections();
    }
    pub fn getRemovedSections(self: *@This()) core.HResult!*IVector(HubSection) {
        const this: *ISectionsInViewChangedEventArgs = @ptrCast(self);
        return try this.getRemovedSections();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SectionsInViewChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISectionsInViewChangedEventArgs.GUID;
    pub const IID: Guid = ISectionsInViewChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISectionsInViewChangedEventArgs.SIGNATURE);
    var _ISectionsInViewChangedEventArgsFactoryCache: FactoryCache(ISectionsInViewChangedEventArgsFactory, RUNTIME_NAME) = .{};
};
pub const SectionsInViewChangedEventHandler = extern struct {
    vtable: *const VTable,
    _refs: @import("std").atomic.Value(u32),
    _cb: *const fn (context: ?*anyopaque) callconv(.winapi) void,
    _context: ?*anyopaque = null,
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn init(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *SectionsInViewChangedEventArgs) callconv(.winapi) void,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
        };
        return _r;
    }
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn initWithState(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *SectionsInViewChangedEventArgs) callconv(.winapi) void,
        context: anytype,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
            ._context = @ptrCast(context),
        };
        return _r;
    }
    /// This calls Release and voids the returned ref count. If ref count is 0 the memory is released,
    /// Otherwise the memory stays until all references are released, including all references Windows holds.
    ///
    /// The caller *MUST* always call deinit/Release at least once for every AddRef and init called.
    pub fn deinit(self: *@This()) void {
        _ = Release(@ptrCast(self));
    }
    fn QueryInterface(self: *anyopaque, riid: *const Guid, out: *?*anyopaque) callconv(.c) HRESULT {
        const me: *@This() = @ptrCast(@alignCast(self));
        // TODO: Handle IMarshal
        if (core.wiredGuidEql(riid, &IID) or
            core.wiredGuidEql(riid, &IUnknown.IID) or
            core.wiredGuidEql(riid, &IAgileObject.IID))
        {
            out.* = @as(?*anyopaque, @ptrCast(me));
            _ = AddRef(self);
            return 0;
        }
        out.* = null;
        return -2147467262; // E_NOINTERFACE
    }
    fn AddRef(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        return this._refs.fetchAdd(1, .monotonic) + 1;
    }
    fn Release(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        const left = this._refs.fetchSub(1, .acq_rel) - 1;
        if (left == 0) @import("std").heap.c_allocator.destroy(this);
        return left;
    }
    pub fn Invoke(self: *anyopaque, sender: *IInspectable, e: *SectionsInViewChangedEventArgs) callconv(.winapi) HRESULT {
        const this: *@This() = @ptrCast(@alignCast(self));
        this._cb(this._context, sender, e);
        return 0;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SectionsInViewChangedEventHandler";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "6becaa6a-63f8-47ff-b6ac-76e7da247d67";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.pinterface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        Invoke: *const fn(self: *anyopaque, sender: *IInspectable, e: *SectionsInViewChangedEventArgs) callconv(.winapi) HRESULT
    };
    pub const VTABLE = VTable {
        .QueryInterface = QueryInterface,
        .AddRef = AddRef,
        .Release = Release,
        .Invoke = Invoke,
    };
};
pub const SelectionChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getAddedItems(self: *@This()) core.HResult!*IVector(IInspectable) {
        const this: *ISelectionChangedEventArgs = @ptrCast(self);
        return try this.getAddedItems();
    }
    pub fn getRemovedItems(self: *@This()) core.HResult!*IVector(IInspectable) {
        const this: *ISelectionChangedEventArgs = @ptrCast(self);
        return try this.getRemovedItems();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstanceWithRemovedItemsAndAddedItems(removedItems: *IVector(IInspectable), addedItems: *IVector(IInspectable), baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SelectionChangedEventArgs {
        const _f = @This().ISelectionChangedEventArgsFactoryCache.get();
        return try _f.CreateInstanceWithRemovedItemsAndAddedItems(removedItems, addedItems, baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SelectionChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISelectionChangedEventArgs.GUID;
    pub const IID: Guid = ISelectionChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISelectionChangedEventArgs.SIGNATURE);
    var _ISelectionChangedEventArgsFactoryCache: FactoryCache(ISelectionChangedEventArgsFactory, RUNTIME_NAME) = .{};
};
pub const SelectionChangedEventHandler = extern struct {
    vtable: *const VTable,
    _refs: @import("std").atomic.Value(u32),
    _cb: *const fn (context: ?*anyopaque) callconv(.winapi) void,
    _context: ?*anyopaque = null,
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn init(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *SelectionChangedEventArgs) callconv(.winapi) void,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
        };
        return _r;
    }
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn initWithState(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *SelectionChangedEventArgs) callconv(.winapi) void,
        context: anytype,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
            ._context = @ptrCast(context),
        };
        return _r;
    }
    /// This calls Release and voids the returned ref count. If ref count is 0 the memory is released,
    /// Otherwise the memory stays until all references are released, including all references Windows holds.
    ///
    /// The caller *MUST* always call deinit/Release at least once for every AddRef and init called.
    pub fn deinit(self: *@This()) void {
        _ = Release(@ptrCast(self));
    }
    fn QueryInterface(self: *anyopaque, riid: *const Guid, out: *?*anyopaque) callconv(.c) HRESULT {
        const me: *@This() = @ptrCast(@alignCast(self));
        // TODO: Handle IMarshal
        if (core.wiredGuidEql(riid, &IID) or
            core.wiredGuidEql(riid, &IUnknown.IID) or
            core.wiredGuidEql(riid, &IAgileObject.IID))
        {
            out.* = @as(?*anyopaque, @ptrCast(me));
            _ = AddRef(self);
            return 0;
        }
        out.* = null;
        return -2147467262; // E_NOINTERFACE
    }
    fn AddRef(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        return this._refs.fetchAdd(1, .monotonic) + 1;
    }
    fn Release(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        const left = this._refs.fetchSub(1, .acq_rel) - 1;
        if (left == 0) @import("std").heap.c_allocator.destroy(this);
        return left;
    }
    pub fn Invoke(self: *anyopaque, sender: *IInspectable, e: *SelectionChangedEventArgs) callconv(.winapi) HRESULT {
        const this: *@This() = @ptrCast(@alignCast(self));
        this._cb(this._context, sender, e);
        return 0;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SelectionChangedEventHandler";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "e1a05352-5aa0-42ca-9cd9-068a14db6e68";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.pinterface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        Invoke: *const fn(self: *anyopaque, sender: *IInspectable, e: *SelectionChangedEventArgs) callconv(.winapi) HRESULT
    };
    pub const VTABLE = VTable {
        .QueryInterface = QueryInterface,
        .AddRef = AddRef,
        .Release = Release,
        .Invoke = Invoke,
    };
};
pub const SelectionMode = enum(i32) {
    Single = 0,
    Multiple = 1,
    Extended = 2,
};
pub const SemanticZoom = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getZoomedInView(self: *@This()) core.HResult!*ISemanticZoomInformation {
        const this: *ISemanticZoom = @ptrCast(self);
        return try this.getZoomedInView();
    }
    pub fn putZoomedInView(self: *@This(), value: *ISemanticZoomInformation) core.HResult!void {
        const this: *ISemanticZoom = @ptrCast(self);
        return try this.putZoomedInView(value);
    }
    pub fn getZoomedOutView(self: *@This()) core.HResult!*ISemanticZoomInformation {
        const this: *ISemanticZoom = @ptrCast(self);
        return try this.getZoomedOutView();
    }
    pub fn putZoomedOutView(self: *@This(), value: *ISemanticZoomInformation) core.HResult!void {
        const this: *ISemanticZoom = @ptrCast(self);
        return try this.putZoomedOutView(value);
    }
    pub fn getIsZoomedInViewActive(self: *@This()) core.HResult!bool {
        const this: *ISemanticZoom = @ptrCast(self);
        return try this.getIsZoomedInViewActive();
    }
    pub fn putIsZoomedInViewActive(self: *@This(), value: bool) core.HResult!void {
        const this: *ISemanticZoom = @ptrCast(self);
        return try this.putIsZoomedInViewActive(value);
    }
    pub fn getCanChangeViews(self: *@This()) core.HResult!bool {
        const this: *ISemanticZoom = @ptrCast(self);
        return try this.getCanChangeViews();
    }
    pub fn putCanChangeViews(self: *@This(), value: bool) core.HResult!void {
        const this: *ISemanticZoom = @ptrCast(self);
        return try this.putCanChangeViews(value);
    }
    pub fn addViewChangeStarted(self: *@This(), handler: *SemanticZoomViewChangedEventHandler) core.HResult!EventRegistrationToken {
        const this: *ISemanticZoom = @ptrCast(self);
        return try this.addViewChangeStarted(handler);
    }
    pub fn removeViewChangeStarted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ISemanticZoom = @ptrCast(self);
        return try this.removeViewChangeStarted(token);
    }
    pub fn addViewChangeCompleted(self: *@This(), handler: *SemanticZoomViewChangedEventHandler) core.HResult!EventRegistrationToken {
        const this: *ISemanticZoom = @ptrCast(self);
        return try this.addViewChangeCompleted(handler);
    }
    pub fn removeViewChangeCompleted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ISemanticZoom = @ptrCast(self);
        return try this.removeViewChangeCompleted(token);
    }
    pub fn ToggleActiveView(self: *@This()) core.HResult!void {
        const this: *ISemanticZoom = @ptrCast(self);
        return try this.ToggleActiveView();
    }
    pub fn getIsZoomOutButtonEnabled(self: *@This()) core.HResult!bool {
        const this: *ISemanticZoom = @ptrCast(self);
        return try this.getIsZoomOutButtonEnabled();
    }
    pub fn putIsZoomOutButtonEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *ISemanticZoom = @ptrCast(self);
        return try this.putIsZoomOutButtonEnabled(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&ISemanticZoom.IID)));
    }
    pub fn getZoomedInViewProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISemanticZoomStaticsCache.get();
        return try _f.getZoomedInViewProperty();
    }
    pub fn getZoomedOutViewProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISemanticZoomStaticsCache.get();
        return try _f.getZoomedOutViewProperty();
    }
    pub fn getIsZoomedInViewActiveProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISemanticZoomStaticsCache.get();
        return try _f.getIsZoomedInViewActiveProperty();
    }
    pub fn getCanChangeViewsProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISemanticZoomStaticsCache.get();
        return try _f.getCanChangeViewsProperty();
    }
    pub fn getIsZoomOutButtonEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISemanticZoomStaticsCache.get();
        return try _f.getIsZoomOutButtonEnabledProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SemanticZoom";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISemanticZoom.GUID;
    pub const IID: Guid = ISemanticZoom.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISemanticZoom.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _ISemanticZoomStaticsCache: FactoryCache(ISemanticZoomStatics, RUNTIME_NAME) = .{};
};
pub const SemanticZoomLocation = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getItem(self: *@This()) core.HResult!*IInspectable {
        const this: *ISemanticZoomLocation = @ptrCast(self);
        return try this.getItem();
    }
    pub fn putItem(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *ISemanticZoomLocation = @ptrCast(self);
        return try this.putItem(value);
    }
    pub fn getBounds(self: *@This()) core.HResult!Rect {
        const this: *ISemanticZoomLocation = @ptrCast(self);
        return try this.getBounds();
    }
    pub fn putBounds(self: *@This(), value: Rect) core.HResult!void {
        const this: *ISemanticZoomLocation = @ptrCast(self);
        return try this.putBounds(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&ISemanticZoomLocation.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SemanticZoomLocation";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISemanticZoomLocation.GUID;
    pub const IID: Guid = ISemanticZoomLocation.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISemanticZoomLocation.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const SemanticZoomViewChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsSourceZoomedInView(self: *@This()) core.HResult!bool {
        const this: *ISemanticZoomViewChangedEventArgs = @ptrCast(self);
        return try this.getIsSourceZoomedInView();
    }
    pub fn putIsSourceZoomedInView(self: *@This(), value: bool) core.HResult!void {
        const this: *ISemanticZoomViewChangedEventArgs = @ptrCast(self);
        return try this.putIsSourceZoomedInView(value);
    }
    pub fn getSourceItem(self: *@This()) core.HResult!*SemanticZoomLocation {
        const this: *ISemanticZoomViewChangedEventArgs = @ptrCast(self);
        return try this.getSourceItem();
    }
    pub fn putSourceItem(self: *@This(), value: *SemanticZoomLocation) core.HResult!void {
        const this: *ISemanticZoomViewChangedEventArgs = @ptrCast(self);
        return try this.putSourceItem(value);
    }
    pub fn getDestinationItem(self: *@This()) core.HResult!*SemanticZoomLocation {
        const this: *ISemanticZoomViewChangedEventArgs = @ptrCast(self);
        return try this.getDestinationItem();
    }
    pub fn putDestinationItem(self: *@This(), value: *SemanticZoomLocation) core.HResult!void {
        const this: *ISemanticZoomViewChangedEventArgs = @ptrCast(self);
        return try this.putDestinationItem(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&ISemanticZoomViewChangedEventArgs.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SemanticZoomViewChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISemanticZoomViewChangedEventArgs.GUID;
    pub const IID: Guid = ISemanticZoomViewChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISemanticZoomViewChangedEventArgs.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const SemanticZoomViewChangedEventHandler = extern struct {
    vtable: *const VTable,
    _refs: @import("std").atomic.Value(u32),
    _cb: *const fn (context: ?*anyopaque) callconv(.winapi) void,
    _context: ?*anyopaque = null,
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn init(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *SemanticZoomViewChangedEventArgs) callconv(.winapi) void,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
        };
        return _r;
    }
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn initWithState(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *SemanticZoomViewChangedEventArgs) callconv(.winapi) void,
        context: anytype,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
            ._context = @ptrCast(context),
        };
        return _r;
    }
    /// This calls Release and voids the returned ref count. If ref count is 0 the memory is released,
    /// Otherwise the memory stays until all references are released, including all references Windows holds.
    ///
    /// The caller *MUST* always call deinit/Release at least once for every AddRef and init called.
    pub fn deinit(self: *@This()) void {
        _ = Release(@ptrCast(self));
    }
    fn QueryInterface(self: *anyopaque, riid: *const Guid, out: *?*anyopaque) callconv(.c) HRESULT {
        const me: *@This() = @ptrCast(@alignCast(self));
        // TODO: Handle IMarshal
        if (core.wiredGuidEql(riid, &IID) or
            core.wiredGuidEql(riid, &IUnknown.IID) or
            core.wiredGuidEql(riid, &IAgileObject.IID))
        {
            out.* = @as(?*anyopaque, @ptrCast(me));
            _ = AddRef(self);
            return 0;
        }
        out.* = null;
        return -2147467262; // E_NOINTERFACE
    }
    fn AddRef(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        return this._refs.fetchAdd(1, .monotonic) + 1;
    }
    fn Release(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        const left = this._refs.fetchSub(1, .acq_rel) - 1;
        if (left == 0) @import("std").heap.c_allocator.destroy(this);
        return left;
    }
    pub fn Invoke(self: *anyopaque, sender: *IInspectable, e: *SemanticZoomViewChangedEventArgs) callconv(.winapi) HRESULT {
        const this: *@This() = @ptrCast(@alignCast(self));
        this._cb(this._context, sender, e);
        return 0;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SemanticZoomViewChangedEventHandler";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "1fa9161d-5d73-44fb-81ac-d1c9384919d4";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.pinterface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        Invoke: *const fn(self: *anyopaque, sender: *IInspectable, e: *SemanticZoomViewChangedEventArgs) callconv(.winapi) HRESULT
    };
    pub const VTABLE = VTable {
        .QueryInterface = QueryInterface,
        .AddRef = AddRef,
        .Release = Release,
        .Invoke = Invoke,
    };
};
pub const SettingsFlyout = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getTitle(self: *@This()) core.HResult!HSTRING {
        const this: *ISettingsFlyout = @ptrCast(self);
        return try this.getTitle();
    }
    pub fn putTitle(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *ISettingsFlyout = @ptrCast(self);
        return try this.putTitle(value);
    }
    pub fn getHeaderBackground(self: *@This()) core.HResult!*Brush {
        const this: *ISettingsFlyout = @ptrCast(self);
        return try this.getHeaderBackground();
    }
    pub fn putHeaderBackground(self: *@This(), value: *Brush) core.HResult!void {
        const this: *ISettingsFlyout = @ptrCast(self);
        return try this.putHeaderBackground(value);
    }
    pub fn getHeaderForeground(self: *@This()) core.HResult!*Brush {
        const this: *ISettingsFlyout = @ptrCast(self);
        return try this.getHeaderForeground();
    }
    pub fn putHeaderForeground(self: *@This(), value: *Brush) core.HResult!void {
        const this: *ISettingsFlyout = @ptrCast(self);
        return try this.putHeaderForeground(value);
    }
    pub fn getIconSource(self: *@This()) core.HResult!*ImageSource {
        const this: *ISettingsFlyout = @ptrCast(self);
        return try this.getIconSource();
    }
    pub fn putIconSource(self: *@This(), value: *ImageSource) core.HResult!void {
        const this: *ISettingsFlyout = @ptrCast(self);
        return try this.putIconSource(value);
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*SettingsFlyoutTemplateSettings {
        const this: *ISettingsFlyout = @ptrCast(self);
        return try this.getTemplateSettings();
    }
    pub fn addBackClick(self: *@This(), handler: *BackClickEventHandler) core.HResult!EventRegistrationToken {
        const this: *ISettingsFlyout = @ptrCast(self);
        return try this.addBackClick(handler);
    }
    pub fn removeBackClick(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ISettingsFlyout = @ptrCast(self);
        return try this.removeBackClick(token);
    }
    pub fn Show(self: *@This()) core.HResult!void {
        const this: *ISettingsFlyout = @ptrCast(self);
        return try this.Show();
    }
    pub fn ShowIndependent(self: *@This()) core.HResult!void {
        const this: *ISettingsFlyout = @ptrCast(self);
        return try this.ShowIndependent();
    }
    pub fn Hide(self: *@This()) core.HResult!void {
        const this: *ISettingsFlyout = @ptrCast(self);
        return try this.Hide();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getTitleProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISettingsFlyoutStaticsCache.get();
        return try _f.getTitleProperty();
    }
    pub fn getHeaderBackgroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISettingsFlyoutStaticsCache.get();
        return try _f.getHeaderBackgroundProperty();
    }
    pub fn getHeaderForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISettingsFlyoutStaticsCache.get();
        return try _f.getHeaderForegroundProperty();
    }
    pub fn getIconSourceProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISettingsFlyoutStaticsCache.get();
        return try _f.getIconSourceProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SettingsFlyout {
        const _f = @This().ISettingsFlyoutFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SettingsFlyout";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISettingsFlyout.GUID;
    pub const IID: Guid = ISettingsFlyout.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISettingsFlyout.SIGNATURE);
    var _ISettingsFlyoutStaticsCache: FactoryCache(ISettingsFlyoutStatics, RUNTIME_NAME) = .{};
    var _ISettingsFlyoutFactoryCache: FactoryCache(ISettingsFlyoutFactory, RUNTIME_NAME) = .{};
};
pub const SnapPointsType = enum(i32) {
    None = 0,
    Optional = 1,
    Mandatory = 2,
    OptionalSingle = 3,
    MandatorySingle = 4,
};
pub const SplitButton = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getFlyout(self: *@This()) core.HResult!*FlyoutBase {
        const this: *ISplitButton = @ptrCast(self);
        return try this.getFlyout();
    }
    pub fn putFlyout(self: *@This(), value: *FlyoutBase) core.HResult!void {
        const this: *ISplitButton = @ptrCast(self);
        return try this.putFlyout(value);
    }
    pub fn getCommand(self: *@This()) core.HResult!*ICommand {
        const this: *ISplitButton = @ptrCast(self);
        return try this.getCommand();
    }
    pub fn putCommand(self: *@This(), value: *ICommand) core.HResult!void {
        const this: *ISplitButton = @ptrCast(self);
        return try this.putCommand(value);
    }
    pub fn getCommandParameter(self: *@This()) core.HResult!*IInspectable {
        const this: *ISplitButton = @ptrCast(self);
        return try this.getCommandParameter();
    }
    pub fn putCommandParameter(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *ISplitButton = @ptrCast(self);
        return try this.putCommandParameter(value);
    }
    pub fn addClick(self: *@This(), handler: *TypedEventHandler(SplitButton,SplitButtonClickEventArgs)) core.HResult!EventRegistrationToken {
        const this: *ISplitButton = @ptrCast(self);
        return try this.addClick(handler);
    }
    pub fn removeClick(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ISplitButton = @ptrCast(self);
        return try this.removeClick(token);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getFlyoutProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISplitButtonStaticsCache.get();
        return try _f.getFlyoutProperty();
    }
    pub fn getCommandProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISplitButtonStaticsCache.get();
        return try _f.getCommandProperty();
    }
    pub fn getCommandParameterProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISplitButtonStaticsCache.get();
        return try _f.getCommandParameterProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SplitButton {
        const _f = @This().ISplitButtonFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SplitButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISplitButton.GUID;
    pub const IID: Guid = ISplitButton.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISplitButton.SIGNATURE);
    var _ISplitButtonStaticsCache: FactoryCache(ISplitButtonStatics, RUNTIME_NAME) = .{};
    var _ISplitButtonFactoryCache: FactoryCache(ISplitButtonFactory, RUNTIME_NAME) = .{};
};
pub const SplitButtonAutomationPeer = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getExpandCollapseState(self: *@This()) core.HResult!ExpandCollapseState {
        var this: ?*IExpandCollapseProvider = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IExpandCollapseProvider.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getExpandCollapseState();
    }
    pub fn Collapse(self: *@This()) core.HResult!void {
        var this: ?*IExpandCollapseProvider = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IExpandCollapseProvider.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.Collapse();
    }
    pub fn Expand(self: *@This()) core.HResult!void {
        var this: ?*IExpandCollapseProvider = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IExpandCollapseProvider.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.Expand();
    }
    pub fn Invoke(self: *@This()) core.HResult!void {
        var this: ?*IInvokeProvider = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IInvokeProvider.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.Invoke();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(owner: *SplitButton, baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SplitButtonAutomationPeer {
        const _f = @This().ISplitButtonAutomationPeerFactoryCache.get();
        return try _f.CreateInstance(owner, baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SplitButtonAutomationPeer";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISplitButtonAutomationPeer.GUID;
    pub const IID: Guid = ISplitButtonAutomationPeer.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISplitButtonAutomationPeer.SIGNATURE);
    var _ISplitButtonAutomationPeerFactoryCache: FactoryCache(ISplitButtonAutomationPeerFactory, RUNTIME_NAME) = .{};
};
pub const SplitButtonClickEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SplitButtonClickEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISplitButtonClickEventArgs.GUID;
    pub const IID: Guid = ISplitButtonClickEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISplitButtonClickEventArgs.SIGNATURE);
};
pub const SplitView = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getContent(self: *@This()) core.HResult!*UIElement {
        const this: *ISplitView = @ptrCast(self);
        return try this.getContent();
    }
    pub fn putContent(self: *@This(), value: *UIElement) core.HResult!void {
        const this: *ISplitView = @ptrCast(self);
        return try this.putContent(value);
    }
    pub fn getPane(self: *@This()) core.HResult!*UIElement {
        const this: *ISplitView = @ptrCast(self);
        return try this.getPane();
    }
    pub fn putPane(self: *@This(), value: *UIElement) core.HResult!void {
        const this: *ISplitView = @ptrCast(self);
        return try this.putPane(value);
    }
    pub fn getIsPaneOpen(self: *@This()) core.HResult!bool {
        const this: *ISplitView = @ptrCast(self);
        return try this.getIsPaneOpen();
    }
    pub fn putIsPaneOpen(self: *@This(), value: bool) core.HResult!void {
        const this: *ISplitView = @ptrCast(self);
        return try this.putIsPaneOpen(value);
    }
    pub fn getOpenPaneLength(self: *@This()) core.HResult!f64 {
        const this: *ISplitView = @ptrCast(self);
        return try this.getOpenPaneLength();
    }
    pub fn putOpenPaneLength(self: *@This(), value: f64) core.HResult!void {
        const this: *ISplitView = @ptrCast(self);
        return try this.putOpenPaneLength(value);
    }
    pub fn getCompactPaneLength(self: *@This()) core.HResult!f64 {
        const this: *ISplitView = @ptrCast(self);
        return try this.getCompactPaneLength();
    }
    pub fn putCompactPaneLength(self: *@This(), value: f64) core.HResult!void {
        const this: *ISplitView = @ptrCast(self);
        return try this.putCompactPaneLength(value);
    }
    pub fn getPanePlacement(self: *@This()) core.HResult!SplitViewPanePlacement {
        const this: *ISplitView = @ptrCast(self);
        return try this.getPanePlacement();
    }
    pub fn putPanePlacement(self: *@This(), value: SplitViewPanePlacement) core.HResult!void {
        const this: *ISplitView = @ptrCast(self);
        return try this.putPanePlacement(value);
    }
    pub fn getDisplayMode(self: *@This()) core.HResult!SplitViewDisplayMode {
        const this: *ISplitView = @ptrCast(self);
        return try this.getDisplayMode();
    }
    pub fn putDisplayMode(self: *@This(), value: SplitViewDisplayMode) core.HResult!void {
        const this: *ISplitView = @ptrCast(self);
        return try this.putDisplayMode(value);
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*SplitViewTemplateSettings {
        const this: *ISplitView = @ptrCast(self);
        return try this.getTemplateSettings();
    }
    pub fn getPaneBackground(self: *@This()) core.HResult!*Brush {
        const this: *ISplitView = @ptrCast(self);
        return try this.getPaneBackground();
    }
    pub fn putPaneBackground(self: *@This(), value: *Brush) core.HResult!void {
        const this: *ISplitView = @ptrCast(self);
        return try this.putPaneBackground(value);
    }
    pub fn addPaneClosing(self: *@This(), handler: *TypedEventHandler(SplitView,SplitViewPaneClosingEventArgs)) core.HResult!EventRegistrationToken {
        const this: *ISplitView = @ptrCast(self);
        return try this.addPaneClosing(handler);
    }
    pub fn removePaneClosing(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ISplitView = @ptrCast(self);
        return try this.removePaneClosing(token);
    }
    pub fn addPaneClosed(self: *@This(), handler: *TypedEventHandler(SplitView,IInspectable)) core.HResult!EventRegistrationToken {
        const this: *ISplitView = @ptrCast(self);
        return try this.addPaneClosed(handler);
    }
    pub fn removePaneClosed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ISplitView = @ptrCast(self);
        return try this.removePaneClosed(token);
    }
    pub fn getLightDismissOverlayMode(self: *@This()) core.HResult!LightDismissOverlayMode {
        var this: ?*ISplitView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISplitView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getLightDismissOverlayMode();
    }
    pub fn putLightDismissOverlayMode(self: *@This(), value: LightDismissOverlayMode) core.HResult!void {
        var this: ?*ISplitView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISplitView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putLightDismissOverlayMode(value);
    }
    pub fn addPaneOpening(self: *@This(), handler: *TypedEventHandler(SplitView,IInspectable)) core.HResult!EventRegistrationToken {
        var this: ?*ISplitView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISplitView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addPaneOpening(handler);
    }
    pub fn removePaneOpening(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*ISplitView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISplitView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removePaneOpening(token);
    }
    pub fn addPaneOpened(self: *@This(), handler: *TypedEventHandler(SplitView,IInspectable)) core.HResult!EventRegistrationToken {
        var this: ?*ISplitView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISplitView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addPaneOpened(handler);
    }
    pub fn removePaneOpened(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*ISplitView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISplitView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removePaneOpened(token);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getContentProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISplitViewStaticsCache.get();
        return try _f.getContentProperty();
    }
    pub fn getPaneProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISplitViewStaticsCache.get();
        return try _f.getPaneProperty();
    }
    pub fn getIsPaneOpenProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISplitViewStaticsCache.get();
        return try _f.getIsPaneOpenProperty();
    }
    pub fn getOpenPaneLengthProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISplitViewStaticsCache.get();
        return try _f.getOpenPaneLengthProperty();
    }
    pub fn getCompactPaneLengthProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISplitViewStaticsCache.get();
        return try _f.getCompactPaneLengthProperty();
    }
    pub fn getPanePlacementProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISplitViewStaticsCache.get();
        return try _f.getPanePlacementProperty();
    }
    pub fn getDisplayModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISplitViewStaticsCache.get();
        return try _f.getDisplayModeProperty();
    }
    pub fn getTemplateSettingsProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISplitViewStaticsCache.get();
        return try _f.getTemplateSettingsProperty();
    }
    pub fn getPaneBackgroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISplitViewStaticsCache.get();
        return try _f.getPaneBackgroundProperty();
    }
    pub fn getLightDismissOverlayModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISplitViewStatics2Cache.get();
        return try _f.getLightDismissOverlayModeProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SplitView {
        const _f = @This().ISplitViewFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SplitView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISplitView.GUID;
    pub const IID: Guid = ISplitView.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISplitView.SIGNATURE);
    var _ISplitViewStaticsCache: FactoryCache(ISplitViewStatics, RUNTIME_NAME) = .{};
    var _ISplitViewStatics2Cache: FactoryCache(ISplitViewStatics2, RUNTIME_NAME) = .{};
    var _ISplitViewFactoryCache: FactoryCache(ISplitViewFactory, RUNTIME_NAME) = .{};
};
pub const SplitViewDisplayMode = enum(i32) {
    Overlay = 0,
    Inline = 1,
    CompactOverlay = 2,
    CompactInline = 3,
};
pub const SplitViewPaneClosingEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getCancel(self: *@This()) core.HResult!bool {
        const this: *ISplitViewPaneClosingEventArgs = @ptrCast(self);
        return try this.getCancel();
    }
    pub fn putCancel(self: *@This(), value: bool) core.HResult!void {
        const this: *ISplitViewPaneClosingEventArgs = @ptrCast(self);
        return try this.putCancel(value);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SplitViewPaneClosingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISplitViewPaneClosingEventArgs.GUID;
    pub const IID: Guid = ISplitViewPaneClosingEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISplitViewPaneClosingEventArgs.SIGNATURE);
};
pub const SplitViewPanePlacement = enum(i32) {
    Left = 0,
    Right = 1,
};
pub const StackPanel = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getAreScrollSnapPointsRegular(self: *@This()) core.HResult!bool {
        const this: *IStackPanel = @ptrCast(self);
        return try this.getAreScrollSnapPointsRegular();
    }
    pub fn putAreScrollSnapPointsRegular(self: *@This(), value: bool) core.HResult!void {
        const this: *IStackPanel = @ptrCast(self);
        return try this.putAreScrollSnapPointsRegular(value);
    }
    pub fn getOrientation(self: *@This()) core.HResult!Orientation {
        const this: *IStackPanel = @ptrCast(self);
        return try this.getOrientation();
    }
    pub fn putOrientation(self: *@This(), value: Orientation) core.HResult!void {
        const this: *IStackPanel = @ptrCast(self);
        return try this.putOrientation(value);
    }
    pub fn getBorderBrush(self: *@This()) core.HResult!*Brush {
        var this: ?*IStackPanel2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IStackPanel2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getBorderBrush();
    }
    pub fn putBorderBrush(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*IStackPanel2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IStackPanel2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putBorderBrush(value);
    }
    pub fn getBorderThickness(self: *@This()) core.HResult!Thickness {
        var this: ?*IStackPanel2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IStackPanel2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getBorderThickness();
    }
    pub fn putBorderThickness(self: *@This(), value: Thickness) core.HResult!void {
        var this: ?*IStackPanel2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IStackPanel2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putBorderThickness(value);
    }
    pub fn getCornerRadius(self: *@This()) core.HResult!CornerRadius {
        var this: ?*IStackPanel2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IStackPanel2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCornerRadius();
    }
    pub fn putCornerRadius(self: *@This(), value: CornerRadius) core.HResult!void {
        var this: ?*IStackPanel2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IStackPanel2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putCornerRadius(value);
    }
    pub fn getPadding(self: *@This()) core.HResult!Thickness {
        var this: ?*IStackPanel2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IStackPanel2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getPadding();
    }
    pub fn putPadding(self: *@This(), value: Thickness) core.HResult!void {
        var this: ?*IStackPanel2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IStackPanel2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putPadding(value);
    }
    pub fn getSpacing(self: *@This()) core.HResult!f64 {
        var this: ?*IStackPanel4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IStackPanel4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSpacing();
    }
    pub fn putSpacing(self: *@This(), value: f64) core.HResult!void {
        var this: ?*IStackPanel4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IStackPanel4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSpacing(value);
    }
    pub fn getBackgroundSizing(self: *@This()) core.HResult!BackgroundSizing {
        var this: ?*IStackPanel5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IStackPanel5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getBackgroundSizing();
    }
    pub fn putBackgroundSizing(self: *@This(), value: BackgroundSizing) core.HResult!void {
        var this: ?*IStackPanel5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IStackPanel5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putBackgroundSizing(value);
    }
    pub fn getAreHorizontalSnapPointsRegular(self: *@This()) core.HResult!bool {
        var this: ?*IScrollSnapPointsInfo = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollSnapPointsInfo.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getAreHorizontalSnapPointsRegular();
    }
    pub fn getAreVerticalSnapPointsRegular(self: *@This()) core.HResult!bool {
        var this: ?*IScrollSnapPointsInfo = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollSnapPointsInfo.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getAreVerticalSnapPointsRegular();
    }
    pub fn addHorizontalSnapPointsChanged(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        var this: ?*IScrollSnapPointsInfo = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollSnapPointsInfo.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addHorizontalSnapPointsChanged(handler);
    }
    pub fn removeHorizontalSnapPointsChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IScrollSnapPointsInfo = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollSnapPointsInfo.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeHorizontalSnapPointsChanged(token);
    }
    pub fn addVerticalSnapPointsChanged(self: *@This(), handler: *EventHandler(IInspectable)) core.HResult!EventRegistrationToken {
        var this: ?*IScrollSnapPointsInfo = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollSnapPointsInfo.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addVerticalSnapPointsChanged(handler);
    }
    pub fn removeVerticalSnapPointsChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IScrollSnapPointsInfo = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollSnapPointsInfo.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeVerticalSnapPointsChanged(token);
    }
    pub fn GetIrregularSnapPoints(self: *@This(), orientation: Orientation, alignment: SnapPointsAlignment) core.HResult!*IVectorView(f32) {
        var this: ?*IScrollSnapPointsInfo = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollSnapPointsInfo.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GetIrregularSnapPoints(orientation, alignment);
    }
    pub fn GetRegularSnapPoints(self: *@This(), orientation: Orientation, alignment: SnapPointsAlignment, offset: f32) core.HResult!f32 {
        var this: ?*IScrollSnapPointsInfo = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IScrollSnapPointsInfo.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GetRegularSnapPoints(orientation, alignment, offset);
    }
    pub fn GetInsertionIndexes(self: *@This(), position: Point, first: i32, second: i32) core.HResult!void {
        var this: ?*IInsertionPanel = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IInsertionPanel.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GetInsertionIndexes(position, first, second);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getBorderBrushProperty() core.HResult!*DependencyProperty {
        const _f = @This().IStackPanelStatics2Cache.get();
        return try _f.getBorderBrushProperty();
    }
    pub fn getBorderThicknessProperty() core.HResult!*DependencyProperty {
        const _f = @This().IStackPanelStatics2Cache.get();
        return try _f.getBorderThicknessProperty();
    }
    pub fn getCornerRadiusProperty() core.HResult!*DependencyProperty {
        const _f = @This().IStackPanelStatics2Cache.get();
        return try _f.getCornerRadiusProperty();
    }
    pub fn getPaddingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IStackPanelStatics2Cache.get();
        return try _f.getPaddingProperty();
    }
    pub fn getAreScrollSnapPointsRegularProperty() core.HResult!*DependencyProperty {
        const _f = @This().IStackPanelStaticsCache.get();
        return try _f.getAreScrollSnapPointsRegularProperty();
    }
    pub fn getOrientationProperty() core.HResult!*DependencyProperty {
        const _f = @This().IStackPanelStaticsCache.get();
        return try _f.getOrientationProperty();
    }
    pub fn getBackgroundSizingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IStackPanelStatics5Cache.get();
        return try _f.getBackgroundSizingProperty();
    }
    pub fn getSpacingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IStackPanelStatics4Cache.get();
        return try _f.getSpacingProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*StackPanel {
        const _f = @This().IStackPanelFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.StackPanel";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IStackPanel.GUID;
    pub const IID: Guid = IStackPanel.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IStackPanel.SIGNATURE);
    var _IStackPanelStatics2Cache: FactoryCache(IStackPanelStatics2, RUNTIME_NAME) = .{};
    var _IStackPanelStaticsCache: FactoryCache(IStackPanelStatics, RUNTIME_NAME) = .{};
    var _IStackPanelStatics5Cache: FactoryCache(IStackPanelStatics5, RUNTIME_NAME) = .{};
    var _IStackPanelStatics4Cache: FactoryCache(IStackPanelStatics4, RUNTIME_NAME) = .{};
    var _IStackPanelFactoryCache: FactoryCache(IStackPanelFactory, RUNTIME_NAME) = .{};
};
pub const StretchDirection = enum(i32) {
    UpOnly = 0,
    DownOnly = 1,
    Both = 2,
};
pub const StyleSelector = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn SelectStyle(self: *@This(), item: *IInspectable, container: *DependencyObject) core.HResult!*Style {
        const this: *IStyleSelector = @ptrCast(self);
        return try this.SelectStyle(item, container);
    }
    pub fn SelectStyleCore(self: *@This(), item: *IInspectable, container: *DependencyObject) core.HResult!*Style {
        var this: ?*IStyleSelectorOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IStyleSelectorOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.SelectStyleCore(item, container);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*StyleSelector {
        const _f = @This().IStyleSelectorFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.StyleSelector";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IStyleSelector.GUID;
    pub const IID: Guid = IStyleSelector.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IStyleSelector.SIGNATURE);
    var _IStyleSelectorFactoryCache: FactoryCache(IStyleSelectorFactory, RUNTIME_NAME) = .{};
};
pub const SwapChainBackgroundPanel = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn CreateCoreIndependentInputSource(self: *@This(), deviceTypes: CoreInputDeviceTypes) core.HResult!*CoreIndependentInputSource {
        var this: ?*ISwapChainBackgroundPanel2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ISwapChainBackgroundPanel2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.CreateCoreIndependentInputSource(deviceTypes);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SwapChainBackgroundPanel {
        const _f = @This().ISwapChainBackgroundPanelFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SwapChainBackgroundPanel";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISwapChainBackgroundPanel.GUID;
    pub const IID: Guid = ISwapChainBackgroundPanel.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISwapChainBackgroundPanel.SIGNATURE);
    var _ISwapChainBackgroundPanelFactoryCache: FactoryCache(ISwapChainBackgroundPanelFactory, RUNTIME_NAME) = .{};
};
pub const SwapChainPanel = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getCompositionScaleX(self: *@This()) core.HResult!f32 {
        const this: *ISwapChainPanel = @ptrCast(self);
        return try this.getCompositionScaleX();
    }
    pub fn getCompositionScaleY(self: *@This()) core.HResult!f32 {
        const this: *ISwapChainPanel = @ptrCast(self);
        return try this.getCompositionScaleY();
    }
    pub fn addCompositionScaleChanged(self: *@This(), handler: *TypedEventHandler(SwapChainPanel,IInspectable)) core.HResult!EventRegistrationToken {
        const this: *ISwapChainPanel = @ptrCast(self);
        return try this.addCompositionScaleChanged(handler);
    }
    pub fn removeCompositionScaleChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ISwapChainPanel = @ptrCast(self);
        return try this.removeCompositionScaleChanged(token);
    }
    pub fn CreateCoreIndependentInputSource(self: *@This(), deviceTypes: CoreInputDeviceTypes) core.HResult!*CoreIndependentInputSource {
        const this: *ISwapChainPanel = @ptrCast(self);
        return try this.CreateCoreIndependentInputSource(deviceTypes);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getCompositionScaleXProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISwapChainPanelStaticsCache.get();
        return try _f.getCompositionScaleXProperty();
    }
    pub fn getCompositionScaleYProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISwapChainPanelStaticsCache.get();
        return try _f.getCompositionScaleYProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SwapChainPanel {
        const _f = @This().ISwapChainPanelFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SwapChainPanel";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISwapChainPanel.GUID;
    pub const IID: Guid = ISwapChainPanel.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISwapChainPanel.SIGNATURE);
    var _ISwapChainPanelStaticsCache: FactoryCache(ISwapChainPanelStatics, RUNTIME_NAME) = .{};
    var _ISwapChainPanelFactoryCache: FactoryCache(ISwapChainPanelFactory, RUNTIME_NAME) = .{};
};
pub const SwipeBehaviorOnInvoked = enum(i32) {
    Auto = 0,
    Close = 1,
    RemainOpen = 2,
};
pub const SwipeControl = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getLeftItems(self: *@This()) core.HResult!*SwipeItems {
        const this: *ISwipeControl = @ptrCast(self);
        return try this.getLeftItems();
    }
    pub fn putLeftItems(self: *@This(), value: *SwipeItems) core.HResult!void {
        const this: *ISwipeControl = @ptrCast(self);
        return try this.putLeftItems(value);
    }
    pub fn getRightItems(self: *@This()) core.HResult!*SwipeItems {
        const this: *ISwipeControl = @ptrCast(self);
        return try this.getRightItems();
    }
    pub fn putRightItems(self: *@This(), value: *SwipeItems) core.HResult!void {
        const this: *ISwipeControl = @ptrCast(self);
        return try this.putRightItems(value);
    }
    pub fn getTopItems(self: *@This()) core.HResult!*SwipeItems {
        const this: *ISwipeControl = @ptrCast(self);
        return try this.getTopItems();
    }
    pub fn putTopItems(self: *@This(), value: *SwipeItems) core.HResult!void {
        const this: *ISwipeControl = @ptrCast(self);
        return try this.putTopItems(value);
    }
    pub fn getBottomItems(self: *@This()) core.HResult!*SwipeItems {
        const this: *ISwipeControl = @ptrCast(self);
        return try this.getBottomItems();
    }
    pub fn putBottomItems(self: *@This(), value: *SwipeItems) core.HResult!void {
        const this: *ISwipeControl = @ptrCast(self);
        return try this.putBottomItems(value);
    }
    pub fn Close(self: *@This()) core.HResult!void {
        const this: *ISwipeControl = @ptrCast(self);
        return try this.Close();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getLeftItemsProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISwipeControlStaticsCache.get();
        return try _f.getLeftItemsProperty();
    }
    pub fn getRightItemsProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISwipeControlStaticsCache.get();
        return try _f.getRightItemsProperty();
    }
    pub fn getTopItemsProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISwipeControlStaticsCache.get();
        return try _f.getTopItemsProperty();
    }
    pub fn getBottomItemsProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISwipeControlStaticsCache.get();
        return try _f.getBottomItemsProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SwipeControl {
        const _f = @This().ISwipeControlFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SwipeControl";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISwipeControl.GUID;
    pub const IID: Guid = ISwipeControl.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISwipeControl.SIGNATURE);
    var _ISwipeControlStaticsCache: FactoryCache(ISwipeControlStatics, RUNTIME_NAME) = .{};
    var _ISwipeControlFactoryCache: FactoryCache(ISwipeControlFactory, RUNTIME_NAME) = .{};
};
pub const SwipeItem = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getText(self: *@This()) core.HResult!HSTRING {
        const this: *ISwipeItem = @ptrCast(self);
        return try this.getText();
    }
    pub fn putText(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *ISwipeItem = @ptrCast(self);
        return try this.putText(value);
    }
    pub fn getIconSource(self: *@This()) core.HResult!*IconSource {
        const this: *ISwipeItem = @ptrCast(self);
        return try this.getIconSource();
    }
    pub fn putIconSource(self: *@This(), value: *IconSource) core.HResult!void {
        const this: *ISwipeItem = @ptrCast(self);
        return try this.putIconSource(value);
    }
    pub fn getBackground(self: *@This()) core.HResult!*Brush {
        const this: *ISwipeItem = @ptrCast(self);
        return try this.getBackground();
    }
    pub fn putBackground(self: *@This(), value: *Brush) core.HResult!void {
        const this: *ISwipeItem = @ptrCast(self);
        return try this.putBackground(value);
    }
    pub fn getForeground(self: *@This()) core.HResult!*Brush {
        const this: *ISwipeItem = @ptrCast(self);
        return try this.getForeground();
    }
    pub fn putForeground(self: *@This(), value: *Brush) core.HResult!void {
        const this: *ISwipeItem = @ptrCast(self);
        return try this.putForeground(value);
    }
    pub fn getCommand(self: *@This()) core.HResult!*ICommand {
        const this: *ISwipeItem = @ptrCast(self);
        return try this.getCommand();
    }
    pub fn putCommand(self: *@This(), value: *ICommand) core.HResult!void {
        const this: *ISwipeItem = @ptrCast(self);
        return try this.putCommand(value);
    }
    pub fn getCommandParameter(self: *@This()) core.HResult!*IInspectable {
        const this: *ISwipeItem = @ptrCast(self);
        return try this.getCommandParameter();
    }
    pub fn putCommandParameter(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *ISwipeItem = @ptrCast(self);
        return try this.putCommandParameter(value);
    }
    pub fn getBehaviorOnInvoked(self: *@This()) core.HResult!SwipeBehaviorOnInvoked {
        const this: *ISwipeItem = @ptrCast(self);
        return try this.getBehaviorOnInvoked();
    }
    pub fn putBehaviorOnInvoked(self: *@This(), value: SwipeBehaviorOnInvoked) core.HResult!void {
        const this: *ISwipeItem = @ptrCast(self);
        return try this.putBehaviorOnInvoked(value);
    }
    pub fn addInvoked(self: *@This(), handler: *TypedEventHandler(SwipeItem,SwipeItemInvokedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *ISwipeItem = @ptrCast(self);
        return try this.addInvoked(handler);
    }
    pub fn removeInvoked(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ISwipeItem = @ptrCast(self);
        return try this.removeInvoked(token);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getIconSourceProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISwipeItemStaticsCache.get();
        return try _f.getIconSourceProperty();
    }
    pub fn getTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISwipeItemStaticsCache.get();
        return try _f.getTextProperty();
    }
    pub fn getBackgroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISwipeItemStaticsCache.get();
        return try _f.getBackgroundProperty();
    }
    pub fn getForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISwipeItemStaticsCache.get();
        return try _f.getForegroundProperty();
    }
    pub fn getCommandProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISwipeItemStaticsCache.get();
        return try _f.getCommandProperty();
    }
    pub fn getCommandParameterProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISwipeItemStaticsCache.get();
        return try _f.getCommandParameterProperty();
    }
    pub fn getBehaviorOnInvokedProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISwipeItemStaticsCache.get();
        return try _f.getBehaviorOnInvokedProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SwipeItem {
        const _f = @This().ISwipeItemFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SwipeItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISwipeItem.GUID;
    pub const IID: Guid = ISwipeItem.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISwipeItem.SIGNATURE);
    var _ISwipeItemStaticsCache: FactoryCache(ISwipeItemStatics, RUNTIME_NAME) = .{};
    var _ISwipeItemFactoryCache: FactoryCache(ISwipeItemFactory, RUNTIME_NAME) = .{};
};
pub const SwipeItemInvokedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getSwipeControl(self: *@This()) core.HResult!*SwipeControl {
        const this: *ISwipeItemInvokedEventArgs = @ptrCast(self);
        return try this.getSwipeControl();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SwipeItemInvokedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISwipeItemInvokedEventArgs.GUID;
    pub const IID: Guid = ISwipeItemInvokedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISwipeItemInvokedEventArgs.SIGNATURE);
};
pub const SwipeItems = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getMode(self: *@This()) core.HResult!SwipeMode {
        const this: *ISwipeItems = @ptrCast(self);
        return try this.getMode();
    }
    pub fn putMode(self: *@This(), value: SwipeMode) core.HResult!void {
        const this: *ISwipeItems = @ptrCast(self);
        return try this.putMode(value);
    }
    pub fn getSize(self: *@This()) core.HResult!u32 {
        var this: ?*IVector(SwipeItem) = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IVector.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSize();
    }
    pub fn GetView(self: *@This()) core.HResult!*IVectorView(SwipeItem) {
        var this: ?*IVector(SwipeItem) = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IVector.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GetView();
    }
    pub fn RemoveAt(self: *@This(), index: u32) core.HResult!void {
        var this: ?*IVector(SwipeItem) = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IVector.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.RemoveAt(index);
    }
    pub fn RemoveAtEnd(self: *@This()) core.HResult!void {
        var this: ?*IVector(SwipeItem) = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IVector.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.RemoveAtEnd();
    }
    pub fn Clear(self: *@This()) core.HResult!void {
        var this: ?*IVector(SwipeItem) = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IVector.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.Clear();
    }
    pub fn First(self: *@This()) core.HResult!*IIterator(SwipeItem) {
        var this: ?*IIterable(SwipeItem) = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IIterable.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.First();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISwipeItemsStaticsCache.get();
        return try _f.getModeProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SwipeItems {
        const _f = @This().ISwipeItemsFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SwipeItems";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISwipeItems.GUID;
    pub const IID: Guid = ISwipeItems.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISwipeItems.SIGNATURE);
    var _ISwipeItemsStaticsCache: FactoryCache(ISwipeItemsStatics, RUNTIME_NAME) = .{};
    var _ISwipeItemsFactoryCache: FactoryCache(ISwipeItemsFactory, RUNTIME_NAME) = .{};
};
pub const SwipeMode = enum(i32) {
    Reveal = 0,
    Execute = 1,
};
pub const Symbol = enum(i32) {
    Previous = 57600,
    Next = 57601,
    Play = 57602,
    Pause = 57603,
    Edit = 57604,
    Save = 57605,
    Clear = 57606,
    Delete = 57607,
    Remove = 57608,
    Add = 57609,
    Cancel = 57610,
    Accept = 57611,
    More = 57612,
    Redo = 57613,
    Undo = 57614,
    Home = 57615,
    Up = 57616,
    Forward = 57617,
    Back = 57618,
    Favorite = 57619,
    Camera = 57620,
    Setting = 57621,
    Video = 57622,
    Sync = 57623,
    Download = 57624,
    Mail = 57625,
    Find = 57626,
    Help = 57627,
    Upload = 57628,
    Emoji = 57629,
    TwoPage = 57630,
    LeaveChat = 57631,
    MailForward = 57632,
    Clock = 57633,
    Send = 57634,
    Crop = 57635,
    RotateCamera = 57636,
    People = 57637,
    OpenPane = 57638,
    ClosePane = 57639,
    World = 57640,
    Flag = 57641,
    PreviewLink = 57642,
    Globe = 57643,
    Trim = 57644,
    AttachCamera = 57645,
    ZoomIn = 57646,
    Bookmarks = 57647,
    Document = 57648,
    ProtectedDocument = 57649,
    Page = 57650,
    Bullets = 57651,
    Comment = 57652,
    MailFilled = 57653,
    ContactInfo = 57654,
    HangUp = 57655,
    ViewAll = 57656,
    MapPin = 57657,
    Phone = 57658,
    VideoChat = 57659,
    Switch = 57660,
    Contact = 57661,
    Rename = 57662,
    Pin = 57665,
    MusicInfo = 57666,
    Go = 57667,
    Keyboard = 57668,
    DockLeft = 57669,
    DockRight = 57670,
    DockBottom = 57671,
    Remote = 57672,
    Refresh = 57673,
    Rotate = 57674,
    Shuffle = 57675,
    List = 57676,
    Shop = 57677,
    SelectAll = 57678,
    Orientation = 57679,
    Import = 57680,
    ImportAll = 57681,
    BrowsePhotos = 57685,
    WebCam = 57686,
    Pictures = 57688,
    SaveLocal = 57689,
    Caption = 57690,
    Stop = 57691,
    ShowResults = 57692,
    Volume = 57693,
    Repair = 57694,
    Message = 57695,
    Page2 = 57696,
    CalendarDay = 57697,
    CalendarWeek = 57698,
    Calendar = 57699,
    Character = 57700,
    MailReplyAll = 57701,
    Read = 57702,
    Link = 57703,
    Account = 57704,
    ShowBcc = 57705,
    HideBcc = 57706,
    Cut = 57707,
    Attach = 57708,
    Paste = 57709,
    Filter = 57710,
    Copy = 57711,
    Emoji2 = 57712,
    Important = 57713,
    MailReply = 57714,
    SlideShow = 57715,
    Sort = 57716,
    Manage = 57720,
    AllApps = 57721,
    DisconnectDrive = 57722,
    MapDrive = 57723,
    NewWindow = 57724,
    OpenWith = 57725,
    ContactPresence = 57729,
    Priority = 57730,
    GoToToday = 57732,
    Font = 57733,
    FontColor = 57734,
    Contact2 = 57735,
    Folder = 57736,
    Audio = 57737,
    Placeholder = 57738,
    View = 57739,
    SetLockScreen = 57740,
    SetTile = 57741,
    ClosedCaption = 57744,
    StopSlideShow = 57745,
    Permissions = 57746,
    Highlight = 57747,
    DisableUpdates = 57748,
    UnFavorite = 57749,
    UnPin = 57750,
    OpenLocal = 57751,
    Mute = 57752,
    Italic = 57753,
    Underline = 57754,
    Bold = 57755,
    MoveToFolder = 57756,
    LikeDislike = 57757,
    Dislike = 57758,
    Like = 57759,
    AlignRight = 57760,
    AlignCenter = 57761,
    AlignLeft = 57762,
    Zoom = 57763,
    ZoomOut = 57764,
    OpenFile = 57765,
    OtherUser = 57766,
    Admin = 57767,
    Street = 57795,
    Map = 57796,
    ClearSelection = 57797,
    FontDecrease = 57798,
    FontIncrease = 57799,
    FontSize = 57800,
    CellPhone = 57801,
    ReShare = 57802,
    Tag = 57803,
    RepeatOne = 57804,
    RepeatAll = 57805,
    OutlineStar = 57806,
    SolidStar = 57807,
    Calculator = 57808,
    Directions = 57809,
    Target = 57810,
    Library = 57811,
    PhoneBook = 57812,
    Memo = 57813,
    Microphone = 57814,
    PostUpdate = 57815,
    BackToWindow = 57816,
    FullScreen = 57817,
    NewFolder = 57818,
    CalendarReply = 57819,
    UnSyncFolder = 57821,
    ReportHacked = 57822,
    SyncFolder = 57823,
    BlockContact = 57824,
    SwitchApps = 57825,
    AddFriend = 57826,
    TouchPointer = 57827,
    GoToStart = 57828,
    ZeroBars = 57829,
    OneBar = 57830,
    TwoBars = 57831,
    ThreeBars = 57832,
    FourBars = 57833,
    Scan = 58004,
    Preview = 58005,
    GlobalNavigationButton = 59136,
    Share = 59181,
    Print = 59209,
    XboxOneConsole = 59792,
};
pub const SymbolIcon = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getSymbol(self: *@This()) core.HResult!Symbol {
        const this: *ISymbolIcon = @ptrCast(self);
        return try this.getSymbol();
    }
    pub fn putSymbol(self: *@This(), value: Symbol) core.HResult!void {
        const this: *ISymbolIcon = @ptrCast(self);
        return try this.putSymbol(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&ISymbolIcon.IID)));
    }
    pub fn CreateInstanceWithSymbol(symbol: Symbol) core.HResult!*SymbolIcon {
        const _f = @This().ISymbolIconFactoryCache.get();
        return try _f.CreateInstanceWithSymbol(symbol);
    }
    pub fn getSymbolProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISymbolIconStaticsCache.get();
        return try _f.getSymbolProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SymbolIcon";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISymbolIcon.GUID;
    pub const IID: Guid = ISymbolIcon.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISymbolIcon.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _ISymbolIconFactoryCache: FactoryCache(ISymbolIconFactory, RUNTIME_NAME) = .{};
    var _ISymbolIconStaticsCache: FactoryCache(ISymbolIconStatics, RUNTIME_NAME) = .{};
};
pub const SymbolIconSource = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getSymbol(self: *@This()) core.HResult!Symbol {
        const this: *ISymbolIconSource = @ptrCast(self);
        return try this.getSymbol();
    }
    pub fn putSymbol(self: *@This(), value: Symbol) core.HResult!void {
        const this: *ISymbolIconSource = @ptrCast(self);
        return try this.putSymbol(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getSymbolProperty() core.HResult!*DependencyProperty {
        const _f = @This().ISymbolIconSourceStaticsCache.get();
        return try _f.getSymbolProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*SymbolIconSource {
        const _f = @This().ISymbolIconSourceFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.SymbolIconSource";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ISymbolIconSource.GUID;
    pub const IID: Guid = ISymbolIconSource.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ISymbolIconSource.SIGNATURE);
    var _ISymbolIconSourceStaticsCache: FactoryCache(ISymbolIconSourceStatics, RUNTIME_NAME) = .{};
    var _ISymbolIconSourceFactoryCache: FactoryCache(ISymbolIconSourceFactory, RUNTIME_NAME) = .{};
};
pub const TextBlock = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getFontSize(self: *@This()) core.HResult!f64 {
        const this: *ITextBlock = @ptrCast(self);
        return try this.getFontSize();
    }
    pub fn putFontSize(self: *@This(), value: f64) core.HResult!void {
        const this: *ITextBlock = @ptrCast(self);
        return try this.putFontSize(value);
    }
    pub fn getFontFamily(self: *@This()) core.HResult!*FontFamily {
        const this: *ITextBlock = @ptrCast(self);
        return try this.getFontFamily();
    }
    pub fn putFontFamily(self: *@This(), value: *FontFamily) core.HResult!void {
        const this: *ITextBlock = @ptrCast(self);
        return try this.putFontFamily(value);
    }
    pub fn getFontWeight(self: *@This()) core.HResult!FontWeight {
        const this: *ITextBlock = @ptrCast(self);
        return try this.getFontWeight();
    }
    pub fn putFontWeight(self: *@This(), value: FontWeight) core.HResult!void {
        const this: *ITextBlock = @ptrCast(self);
        return try this.putFontWeight(value);
    }
    pub fn getFontStyle(self: *@This()) core.HResult!FontStyle {
        const this: *ITextBlock = @ptrCast(self);
        return try this.getFontStyle();
    }
    pub fn putFontStyle(self: *@This(), value: FontStyle) core.HResult!void {
        const this: *ITextBlock = @ptrCast(self);
        return try this.putFontStyle(value);
    }
    pub fn getFontStretch(self: *@This()) core.HResult!FontStretch {
        const this: *ITextBlock = @ptrCast(self);
        return try this.getFontStretch();
    }
    pub fn putFontStretch(self: *@This(), value: FontStretch) core.HResult!void {
        const this: *ITextBlock = @ptrCast(self);
        return try this.putFontStretch(value);
    }
    pub fn getCharacterSpacing(self: *@This()) core.HResult!i32 {
        const this: *ITextBlock = @ptrCast(self);
        return try this.getCharacterSpacing();
    }
    pub fn putCharacterSpacing(self: *@This(), value: i32) core.HResult!void {
        const this: *ITextBlock = @ptrCast(self);
        return try this.putCharacterSpacing(value);
    }
    pub fn getForeground(self: *@This()) core.HResult!*Brush {
        const this: *ITextBlock = @ptrCast(self);
        return try this.getForeground();
    }
    pub fn putForeground(self: *@This(), value: *Brush) core.HResult!void {
        const this: *ITextBlock = @ptrCast(self);
        return try this.putForeground(value);
    }
    pub fn getTextWrapping(self: *@This()) core.HResult!TextWrapping {
        const this: *ITextBlock = @ptrCast(self);
        return try this.getTextWrapping();
    }
    pub fn putTextWrapping(self: *@This(), value: TextWrapping) core.HResult!void {
        const this: *ITextBlock = @ptrCast(self);
        return try this.putTextWrapping(value);
    }
    pub fn getTextTrimming(self: *@This()) core.HResult!TextTrimming {
        const this: *ITextBlock = @ptrCast(self);
        return try this.getTextTrimming();
    }
    pub fn putTextTrimming(self: *@This(), value: TextTrimming) core.HResult!void {
        const this: *ITextBlock = @ptrCast(self);
        return try this.putTextTrimming(value);
    }
    pub fn getTextAlignment(self: *@This()) core.HResult!TextAlignment {
        const this: *ITextBlock = @ptrCast(self);
        return try this.getTextAlignment();
    }
    pub fn putTextAlignment(self: *@This(), value: TextAlignment) core.HResult!void {
        const this: *ITextBlock = @ptrCast(self);
        return try this.putTextAlignment(value);
    }
    pub fn getText(self: *@This()) core.HResult!HSTRING {
        const this: *ITextBlock = @ptrCast(self);
        return try this.getText();
    }
    pub fn putText(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *ITextBlock = @ptrCast(self);
        return try this.putText(value);
    }
    pub fn getInlines(self: *@This()) core.HResult!*InlineCollection {
        const this: *ITextBlock = @ptrCast(self);
        return try this.getInlines();
    }
    pub fn getPadding(self: *@This()) core.HResult!Thickness {
        const this: *ITextBlock = @ptrCast(self);
        return try this.getPadding();
    }
    pub fn putPadding(self: *@This(), value: Thickness) core.HResult!void {
        const this: *ITextBlock = @ptrCast(self);
        return try this.putPadding(value);
    }
    pub fn getLineHeight(self: *@This()) core.HResult!f64 {
        const this: *ITextBlock = @ptrCast(self);
        return try this.getLineHeight();
    }
    pub fn putLineHeight(self: *@This(), value: f64) core.HResult!void {
        const this: *ITextBlock = @ptrCast(self);
        return try this.putLineHeight(value);
    }
    pub fn getLineStackingStrategy(self: *@This()) core.HResult!LineStackingStrategy {
        const this: *ITextBlock = @ptrCast(self);
        return try this.getLineStackingStrategy();
    }
    pub fn putLineStackingStrategy(self: *@This(), value: LineStackingStrategy) core.HResult!void {
        const this: *ITextBlock = @ptrCast(self);
        return try this.putLineStackingStrategy(value);
    }
    pub fn getIsTextSelectionEnabled(self: *@This()) core.HResult!bool {
        const this: *ITextBlock = @ptrCast(self);
        return try this.getIsTextSelectionEnabled();
    }
    pub fn putIsTextSelectionEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *ITextBlock = @ptrCast(self);
        return try this.putIsTextSelectionEnabled(value);
    }
    pub fn getSelectedText(self: *@This()) core.HResult!HSTRING {
        const this: *ITextBlock = @ptrCast(self);
        return try this.getSelectedText();
    }
    pub fn getContentStart(self: *@This()) core.HResult!*TextPointer {
        const this: *ITextBlock = @ptrCast(self);
        return try this.getContentStart();
    }
    pub fn getContentEnd(self: *@This()) core.HResult!*TextPointer {
        const this: *ITextBlock = @ptrCast(self);
        return try this.getContentEnd();
    }
    pub fn getSelectionStart(self: *@This()) core.HResult!*TextPointer {
        const this: *ITextBlock = @ptrCast(self);
        return try this.getSelectionStart();
    }
    pub fn getSelectionEnd(self: *@This()) core.HResult!*TextPointer {
        const this: *ITextBlock = @ptrCast(self);
        return try this.getSelectionEnd();
    }
    pub fn getBaselineOffset(self: *@This()) core.HResult!f64 {
        const this: *ITextBlock = @ptrCast(self);
        return try this.getBaselineOffset();
    }
    pub fn addSelectionChanged(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        const this: *ITextBlock = @ptrCast(self);
        return try this.addSelectionChanged(handler);
    }
    pub fn removeSelectionChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ITextBlock = @ptrCast(self);
        return try this.removeSelectionChanged(token);
    }
    pub fn addContextMenuOpening(self: *@This(), handler: *ContextMenuOpeningEventHandler) core.HResult!EventRegistrationToken {
        const this: *ITextBlock = @ptrCast(self);
        return try this.addContextMenuOpening(handler);
    }
    pub fn removeContextMenuOpening(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ITextBlock = @ptrCast(self);
        return try this.removeContextMenuOpening(token);
    }
    pub fn SelectAll(self: *@This()) core.HResult!void {
        const this: *ITextBlock = @ptrCast(self);
        return try this.SelectAll();
    }
    pub fn Select(self: *@This(), start: *TextPointer, end: *TextPointer) core.HResult!void {
        const this: *ITextBlock = @ptrCast(self);
        return try this.Select(start, end);
    }
    pub fn Focus(self: *@This(), value: FocusState) core.HResult!bool {
        const this: *ITextBlock = @ptrCast(self);
        return try this.Focus(value);
    }
    pub fn getSelectionHighlightColor(self: *@This()) core.HResult!*SolidColorBrush {
        var this: ?*ITextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectionHighlightColor();
    }
    pub fn putSelectionHighlightColor(self: *@This(), value: *SolidColorBrush) core.HResult!void {
        var this: ?*ITextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSelectionHighlightColor(value);
    }
    pub fn getMaxLines(self: *@This()) core.HResult!i32 {
        var this: ?*ITextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getMaxLines();
    }
    pub fn putMaxLines(self: *@This(), value: i32) core.HResult!void {
        var this: ?*ITextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putMaxLines(value);
    }
    pub fn getTextLineBounds(self: *@This()) core.HResult!TextLineBounds {
        var this: ?*ITextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTextLineBounds();
    }
    pub fn putTextLineBounds(self: *@This(), value: TextLineBounds) core.HResult!void {
        var this: ?*ITextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTextLineBounds(value);
    }
    pub fn getOpticalMarginAlignment(self: *@This()) core.HResult!OpticalMarginAlignment {
        var this: ?*ITextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getOpticalMarginAlignment();
    }
    pub fn putOpticalMarginAlignment(self: *@This(), value: OpticalMarginAlignment) core.HResult!void {
        var this: ?*ITextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putOpticalMarginAlignment(value);
    }
    pub fn getIsColorFontEnabled(self: *@This()) core.HResult!bool {
        var this: ?*ITextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsColorFontEnabled();
    }
    pub fn putIsColorFontEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*ITextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsColorFontEnabled(value);
    }
    pub fn getTextReadingOrder(self: *@This()) core.HResult!TextReadingOrder {
        var this: ?*ITextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTextReadingOrder();
    }
    pub fn putTextReadingOrder(self: *@This(), value: TextReadingOrder) core.HResult!void {
        var this: ?*ITextBlock2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTextReadingOrder(value);
    }
    pub fn getIsTextScaleFactorEnabled(self: *@This()) core.HResult!bool {
        var this: ?*ITextBlock3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsTextScaleFactorEnabled();
    }
    pub fn putIsTextScaleFactorEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*ITextBlock3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsTextScaleFactorEnabled(value);
    }
    pub fn GetAlphaMask(self: *@This()) core.HResult!*CompositionBrush {
        var this: ?*ITextBlock4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GetAlphaMask();
    }
    pub fn getTextDecorations(self: *@This()) core.HResult!TextDecorations {
        var this: ?*ITextBlock5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTextDecorations();
    }
    pub fn putTextDecorations(self: *@This(), value: TextDecorations) core.HResult!void {
        var this: ?*ITextBlock5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTextDecorations(value);
    }
    pub fn getIsTextTrimmed(self: *@This()) core.HResult!bool {
        var this: ?*ITextBlock6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsTextTrimmed();
    }
    pub fn getHorizontalTextAlignment(self: *@This()) core.HResult!TextAlignment {
        var this: ?*ITextBlock6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getHorizontalTextAlignment();
    }
    pub fn putHorizontalTextAlignment(self: *@This(), value: TextAlignment) core.HResult!void {
        var this: ?*ITextBlock6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putHorizontalTextAlignment(value);
    }
    pub fn getTextHighlighters(self: *@This()) core.HResult!*IVector(TextHighlighter) {
        var this: ?*ITextBlock6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTextHighlighters();
    }
    pub fn addIsTextTrimmedChanged(self: *@This(), handler: *TypedEventHandler(TextBlock,IsTextTrimmedChangedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*ITextBlock6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addIsTextTrimmedChanged(handler);
    }
    pub fn removeIsTextTrimmedChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*ITextBlock6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeIsTextTrimmedChanged(token);
    }
    pub fn getSelectionFlyout(self: *@This()) core.HResult!*FlyoutBase {
        var this: ?*ITextBlock7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectionFlyout();
    }
    pub fn putSelectionFlyout(self: *@This(), value: *FlyoutBase) core.HResult!void {
        var this: ?*ITextBlock7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSelectionFlyout(value);
    }
    pub fn CopySelectionToClipboard(self: *@This()) core.HResult!void {
        var this: ?*ITextBlock7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBlock7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.CopySelectionToClipboard();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&ITextBlock.IID)));
    }
    pub fn getTextDecorationsProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStatics5Cache.get();
        return try _f.getTextDecorationsProperty();
    }
    pub fn getIsTextScaleFactorEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStatics3Cache.get();
        return try _f.getIsTextScaleFactorEnabledProperty();
    }
    pub fn getSelectionFlyoutProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStatics7Cache.get();
        return try _f.getSelectionFlyoutProperty();
    }
    pub fn getSelectionHighlightColorProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStatics2Cache.get();
        return try _f.getSelectionHighlightColorProperty();
    }
    pub fn getMaxLinesProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStatics2Cache.get();
        return try _f.getMaxLinesProperty();
    }
    pub fn getTextLineBoundsProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStatics2Cache.get();
        return try _f.getTextLineBoundsProperty();
    }
    pub fn getOpticalMarginAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStatics2Cache.get();
        return try _f.getOpticalMarginAlignmentProperty();
    }
    pub fn getIsColorFontEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStatics2Cache.get();
        return try _f.getIsColorFontEnabledProperty();
    }
    pub fn getTextReadingOrderProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStatics2Cache.get();
        return try _f.getTextReadingOrderProperty();
    }
    pub fn getIsTextTrimmedProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStatics6Cache.get();
        return try _f.getIsTextTrimmedProperty();
    }
    pub fn getHorizontalTextAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStatics6Cache.get();
        return try _f.getHorizontalTextAlignmentProperty();
    }
    pub fn getFontSizeProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStaticsCache.get();
        return try _f.getFontSizeProperty();
    }
    pub fn getFontFamilyProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStaticsCache.get();
        return try _f.getFontFamilyProperty();
    }
    pub fn getFontWeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStaticsCache.get();
        return try _f.getFontWeightProperty();
    }
    pub fn getFontStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStaticsCache.get();
        return try _f.getFontStyleProperty();
    }
    pub fn getFontStretchProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStaticsCache.get();
        return try _f.getFontStretchProperty();
    }
    pub fn getCharacterSpacingProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStaticsCache.get();
        return try _f.getCharacterSpacingProperty();
    }
    pub fn getForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStaticsCache.get();
        return try _f.getForegroundProperty();
    }
    pub fn getTextWrappingProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStaticsCache.get();
        return try _f.getTextWrappingProperty();
    }
    pub fn getTextTrimmingProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStaticsCache.get();
        return try _f.getTextTrimmingProperty();
    }
    pub fn getTextAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStaticsCache.get();
        return try _f.getTextAlignmentProperty();
    }
    pub fn getTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStaticsCache.get();
        return try _f.getTextProperty();
    }
    pub fn getPaddingProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStaticsCache.get();
        return try _f.getPaddingProperty();
    }
    pub fn getLineHeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStaticsCache.get();
        return try _f.getLineHeightProperty();
    }
    pub fn getLineStackingStrategyProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStaticsCache.get();
        return try _f.getLineStackingStrategyProperty();
    }
    pub fn getIsTextSelectionEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStaticsCache.get();
        return try _f.getIsTextSelectionEnabledProperty();
    }
    pub fn getSelectedTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBlockStaticsCache.get();
        return try _f.getSelectedTextProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TextBlock";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITextBlock.GUID;
    pub const IID: Guid = ITextBlock.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITextBlock.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _ITextBlockStatics5Cache: FactoryCache(ITextBlockStatics5, RUNTIME_NAME) = .{};
    var _ITextBlockStatics3Cache: FactoryCache(ITextBlockStatics3, RUNTIME_NAME) = .{};
    var _ITextBlockStatics7Cache: FactoryCache(ITextBlockStatics7, RUNTIME_NAME) = .{};
    var _ITextBlockStatics2Cache: FactoryCache(ITextBlockStatics2, RUNTIME_NAME) = .{};
    var _ITextBlockStatics6Cache: FactoryCache(ITextBlockStatics6, RUNTIME_NAME) = .{};
    var _ITextBlockStaticsCache: FactoryCache(ITextBlockStatics, RUNTIME_NAME) = .{};
};
pub const TextBox = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getText(self: *@This()) core.HResult!HSTRING {
        const this: *ITextBox = @ptrCast(self);
        return try this.getText();
    }
    pub fn putText(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *ITextBox = @ptrCast(self);
        return try this.putText(value);
    }
    pub fn getSelectedText(self: *@This()) core.HResult!HSTRING {
        const this: *ITextBox = @ptrCast(self);
        return try this.getSelectedText();
    }
    pub fn putSelectedText(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *ITextBox = @ptrCast(self);
        return try this.putSelectedText(value);
    }
    pub fn getSelectionLength(self: *@This()) core.HResult!i32 {
        const this: *ITextBox = @ptrCast(self);
        return try this.getSelectionLength();
    }
    pub fn putSelectionLength(self: *@This(), value: i32) core.HResult!void {
        const this: *ITextBox = @ptrCast(self);
        return try this.putSelectionLength(value);
    }
    pub fn getSelectionStart(self: *@This()) core.HResult!i32 {
        const this: *ITextBox = @ptrCast(self);
        return try this.getSelectionStart();
    }
    pub fn putSelectionStart(self: *@This(), value: i32) core.HResult!void {
        const this: *ITextBox = @ptrCast(self);
        return try this.putSelectionStart(value);
    }
    pub fn getMaxLength(self: *@This()) core.HResult!i32 {
        const this: *ITextBox = @ptrCast(self);
        return try this.getMaxLength();
    }
    pub fn putMaxLength(self: *@This(), value: i32) core.HResult!void {
        const this: *ITextBox = @ptrCast(self);
        return try this.putMaxLength(value);
    }
    pub fn getIsReadOnly(self: *@This()) core.HResult!bool {
        const this: *ITextBox = @ptrCast(self);
        return try this.getIsReadOnly();
    }
    pub fn putIsReadOnly(self: *@This(), value: bool) core.HResult!void {
        const this: *ITextBox = @ptrCast(self);
        return try this.putIsReadOnly(value);
    }
    pub fn getAcceptsReturn(self: *@This()) core.HResult!bool {
        const this: *ITextBox = @ptrCast(self);
        return try this.getAcceptsReturn();
    }
    pub fn putAcceptsReturn(self: *@This(), value: bool) core.HResult!void {
        const this: *ITextBox = @ptrCast(self);
        return try this.putAcceptsReturn(value);
    }
    pub fn getTextAlignment(self: *@This()) core.HResult!TextAlignment {
        const this: *ITextBox = @ptrCast(self);
        return try this.getTextAlignment();
    }
    pub fn putTextAlignment(self: *@This(), value: TextAlignment) core.HResult!void {
        const this: *ITextBox = @ptrCast(self);
        return try this.putTextAlignment(value);
    }
    pub fn getTextWrapping(self: *@This()) core.HResult!TextWrapping {
        const this: *ITextBox = @ptrCast(self);
        return try this.getTextWrapping();
    }
    pub fn putTextWrapping(self: *@This(), value: TextWrapping) core.HResult!void {
        const this: *ITextBox = @ptrCast(self);
        return try this.putTextWrapping(value);
    }
    pub fn getIsSpellCheckEnabled(self: *@This()) core.HResult!bool {
        const this: *ITextBox = @ptrCast(self);
        return try this.getIsSpellCheckEnabled();
    }
    pub fn putIsSpellCheckEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *ITextBox = @ptrCast(self);
        return try this.putIsSpellCheckEnabled(value);
    }
    pub fn getIsTextPredictionEnabled(self: *@This()) core.HResult!bool {
        const this: *ITextBox = @ptrCast(self);
        return try this.getIsTextPredictionEnabled();
    }
    pub fn putIsTextPredictionEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *ITextBox = @ptrCast(self);
        return try this.putIsTextPredictionEnabled(value);
    }
    pub fn getInputScope(self: *@This()) core.HResult!*InputScope {
        const this: *ITextBox = @ptrCast(self);
        return try this.getInputScope();
    }
    pub fn putInputScope(self: *@This(), value: *InputScope) core.HResult!void {
        const this: *ITextBox = @ptrCast(self);
        return try this.putInputScope(value);
    }
    pub fn addTextChanged(self: *@This(), handler: *TextChangedEventHandler) core.HResult!EventRegistrationToken {
        const this: *ITextBox = @ptrCast(self);
        return try this.addTextChanged(handler);
    }
    pub fn removeTextChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ITextBox = @ptrCast(self);
        return try this.removeTextChanged(token);
    }
    pub fn addSelectionChanged(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        const this: *ITextBox = @ptrCast(self);
        return try this.addSelectionChanged(handler);
    }
    pub fn removeSelectionChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ITextBox = @ptrCast(self);
        return try this.removeSelectionChanged(token);
    }
    pub fn addContextMenuOpening(self: *@This(), handler: *ContextMenuOpeningEventHandler) core.HResult!EventRegistrationToken {
        const this: *ITextBox = @ptrCast(self);
        return try this.addContextMenuOpening(handler);
    }
    pub fn removeContextMenuOpening(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ITextBox = @ptrCast(self);
        return try this.removeContextMenuOpening(token);
    }
    pub fn Select(self: *@This(), start: i32, length: i32) core.HResult!void {
        const this: *ITextBox = @ptrCast(self);
        return try this.Select(start, length);
    }
    pub fn SelectAll(self: *@This()) core.HResult!void {
        const this: *ITextBox = @ptrCast(self);
        return try this.SelectAll();
    }
    pub fn GetRectFromCharacterIndex(self: *@This(), charIndex: i32, trailingEdge: bool) core.HResult!Rect {
        const this: *ITextBox = @ptrCast(self);
        return try this.GetRectFromCharacterIndex(charIndex, trailingEdge);
    }
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        var this: ?*ITextBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getHeader();
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        var this: ?*ITextBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putHeader(value);
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        var this: ?*ITextBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getHeaderTemplate();
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        var this: ?*ITextBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putHeaderTemplate(value);
    }
    pub fn getPlaceholderText(self: *@This()) core.HResult!HSTRING {
        var this: ?*ITextBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getPlaceholderText();
    }
    pub fn putPlaceholderText(self: *@This(), value: HSTRING) core.HResult!void {
        var this: ?*ITextBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putPlaceholderText(value);
    }
    pub fn getSelectionHighlightColor(self: *@This()) core.HResult!*SolidColorBrush {
        var this: ?*ITextBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectionHighlightColor();
    }
    pub fn putSelectionHighlightColor(self: *@This(), value: *SolidColorBrush) core.HResult!void {
        var this: ?*ITextBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSelectionHighlightColor(value);
    }
    pub fn getPreventKeyboardDisplayOnProgrammaticFocus(self: *@This()) core.HResult!bool {
        var this: ?*ITextBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getPreventKeyboardDisplayOnProgrammaticFocus();
    }
    pub fn putPreventKeyboardDisplayOnProgrammaticFocus(self: *@This(), value: bool) core.HResult!void {
        var this: ?*ITextBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putPreventKeyboardDisplayOnProgrammaticFocus(value);
    }
    pub fn getIsColorFontEnabled(self: *@This()) core.HResult!bool {
        var this: ?*ITextBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsColorFontEnabled();
    }
    pub fn putIsColorFontEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*ITextBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsColorFontEnabled(value);
    }
    pub fn addPaste(self: *@This(), handler: *TextControlPasteEventHandler) core.HResult!EventRegistrationToken {
        var this: ?*ITextBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addPaste(handler);
    }
    pub fn removePaste(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*ITextBox2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removePaste(token);
    }
    pub fn addTextCompositionStarted(self: *@This(), handler: *TypedEventHandler(TextBox,TextCompositionStartedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*ITextBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addTextCompositionStarted(handler);
    }
    pub fn removeTextCompositionStarted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*ITextBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeTextCompositionStarted(token);
    }
    pub fn addTextCompositionChanged(self: *@This(), handler: *TypedEventHandler(TextBox,TextCompositionChangedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*ITextBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addTextCompositionChanged(handler);
    }
    pub fn removeTextCompositionChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*ITextBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeTextCompositionChanged(token);
    }
    pub fn addTextCompositionEnded(self: *@This(), handler: *TypedEventHandler(TextBox,TextCompositionEndedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*ITextBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addTextCompositionEnded(handler);
    }
    pub fn removeTextCompositionEnded(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*ITextBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeTextCompositionEnded(token);
    }
    pub fn getTextReadingOrder(self: *@This()) core.HResult!TextReadingOrder {
        var this: ?*ITextBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getTextReadingOrder();
    }
    pub fn putTextReadingOrder(self: *@This(), value: TextReadingOrder) core.HResult!void {
        var this: ?*ITextBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putTextReadingOrder(value);
    }
    pub fn getDesiredCandidateWindowAlignment(self: *@This()) core.HResult!CandidateWindowAlignment {
        var this: ?*ITextBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDesiredCandidateWindowAlignment();
    }
    pub fn putDesiredCandidateWindowAlignment(self: *@This(), value: CandidateWindowAlignment) core.HResult!void {
        var this: ?*ITextBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putDesiredCandidateWindowAlignment(value);
    }
    pub fn addCandidateWindowBoundsChanged(self: *@This(), handler: *TypedEventHandler(TextBox,CandidateWindowBoundsChangedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*ITextBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addCandidateWindowBoundsChanged(handler);
    }
    pub fn removeCandidateWindowBoundsChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*ITextBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeCandidateWindowBoundsChanged(token);
    }
    pub fn addTextChanging(self: *@This(), handler: *TypedEventHandler(TextBox,TextBoxTextChangingEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*ITextBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addTextChanging(handler);
    }
    pub fn removeTextChanging(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*ITextBox3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeTextChanging(token);
    }
    pub fn GetLinguisticAlternativesAsync(self: *@This()) core.HResult!*IAsyncOperation(IVectorView(HSTRING)) {
        var this: ?*ITextBox4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GetLinguisticAlternativesAsync();
    }
    pub fn getSelectionHighlightColorWhenNotFocused(self: *@This()) core.HResult!*SolidColorBrush {
        var this: ?*ITextBox5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectionHighlightColorWhenNotFocused();
    }
    pub fn putSelectionHighlightColorWhenNotFocused(self: *@This(), value: *SolidColorBrush) core.HResult!void {
        var this: ?*ITextBox5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSelectionHighlightColorWhenNotFocused(value);
    }
    pub fn getHorizontalTextAlignment(self: *@This()) core.HResult!TextAlignment {
        var this: ?*ITextBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getHorizontalTextAlignment();
    }
    pub fn putHorizontalTextAlignment(self: *@This(), value: TextAlignment) core.HResult!void {
        var this: ?*ITextBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putHorizontalTextAlignment(value);
    }
    pub fn getCharacterCasing(self: *@This()) core.HResult!CharacterCasing {
        var this: ?*ITextBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCharacterCasing();
    }
    pub fn putCharacterCasing(self: *@This(), value: CharacterCasing) core.HResult!void {
        var this: ?*ITextBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putCharacterCasing(value);
    }
    pub fn getPlaceholderForeground(self: *@This()) core.HResult!*Brush {
        var this: ?*ITextBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getPlaceholderForeground();
    }
    pub fn putPlaceholderForeground(self: *@This(), value: *Brush) core.HResult!void {
        var this: ?*ITextBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putPlaceholderForeground(value);
    }
    pub fn addCopyingToClipboard(self: *@This(), handler: *TypedEventHandler(TextBox,TextControlCopyingToClipboardEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*ITextBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addCopyingToClipboard(handler);
    }
    pub fn removeCopyingToClipboard(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*ITextBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeCopyingToClipboard(token);
    }
    pub fn addCuttingToClipboard(self: *@This(), handler: *TypedEventHandler(TextBox,TextControlCuttingToClipboardEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*ITextBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addCuttingToClipboard(handler);
    }
    pub fn removeCuttingToClipboard(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*ITextBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeCuttingToClipboard(token);
    }
    pub fn addBeforeTextChanging(self: *@This(), handler: *TypedEventHandler(TextBox,TextBoxBeforeTextChangingEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*ITextBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addBeforeTextChanging(handler);
    }
    pub fn removeBeforeTextChanging(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*ITextBox6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeBeforeTextChanging(token);
    }
    pub fn getHandwritingView(self: *@This()) core.HResult!*HandwritingView {
        var this: ?*ITextBox7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getHandwritingView();
    }
    pub fn putHandwritingView(self: *@This(), value: *HandwritingView) core.HResult!void {
        var this: ?*ITextBox7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putHandwritingView(value);
    }
    pub fn getIsHandwritingViewEnabled(self: *@This()) core.HResult!bool {
        var this: ?*ITextBox7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsHandwritingViewEnabled();
    }
    pub fn putIsHandwritingViewEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*ITextBox7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsHandwritingViewEnabled(value);
    }
    pub fn getCanPasteClipboardContent(self: *@This()) core.HResult!bool {
        var this: ?*ITextBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCanPasteClipboardContent();
    }
    pub fn getCanUndo(self: *@This()) core.HResult!bool {
        var this: ?*ITextBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCanUndo();
    }
    pub fn getCanRedo(self: *@This()) core.HResult!bool {
        var this: ?*ITextBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCanRedo();
    }
    pub fn getSelectionFlyout(self: *@This()) core.HResult!*FlyoutBase {
        var this: ?*ITextBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectionFlyout();
    }
    pub fn putSelectionFlyout(self: *@This(), value: *FlyoutBase) core.HResult!void {
        var this: ?*ITextBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSelectionFlyout(value);
    }
    pub fn getProofingMenuFlyout(self: *@This()) core.HResult!*FlyoutBase {
        var this: ?*ITextBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getProofingMenuFlyout();
    }
    pub fn getDescription(self: *@This()) core.HResult!*IInspectable {
        var this: ?*ITextBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDescription();
    }
    pub fn putDescription(self: *@This(), value: *IInspectable) core.HResult!void {
        var this: ?*ITextBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putDescription(value);
    }
    pub fn addSelectionChanging(self: *@This(), handler: *TypedEventHandler(TextBox,TextBoxSelectionChangingEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*ITextBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addSelectionChanging(handler);
    }
    pub fn removeSelectionChanging(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*ITextBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeSelectionChanging(token);
    }
    pub fn Undo(self: *@This()) core.HResult!void {
        var this: ?*ITextBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.Undo();
    }
    pub fn Redo(self: *@This()) core.HResult!void {
        var this: ?*ITextBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.Redo();
    }
    pub fn PasteFromClipboard(self: *@This()) core.HResult!void {
        var this: ?*ITextBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.PasteFromClipboard();
    }
    pub fn CopySelectionToClipboard(self: *@This()) core.HResult!void {
        var this: ?*ITextBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.CopySelectionToClipboard();
    }
    pub fn CutSelectionToClipboard(self: *@This()) core.HResult!void {
        var this: ?*ITextBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.CutSelectionToClipboard();
    }
    pub fn ClearUndoRedoHistory(self: *@This()) core.HResult!void {
        var this: ?*ITextBox8 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBox8.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.ClearUndoRedoHistory();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStatics2Cache.get();
        return try _f.getHeaderProperty();
    }
    pub fn getHeaderTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStatics2Cache.get();
        return try _f.getHeaderTemplateProperty();
    }
    pub fn getPlaceholderTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStatics2Cache.get();
        return try _f.getPlaceholderTextProperty();
    }
    pub fn getSelectionHighlightColorProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStatics2Cache.get();
        return try _f.getSelectionHighlightColorProperty();
    }
    pub fn getPreventKeyboardDisplayOnProgrammaticFocusProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStatics2Cache.get();
        return try _f.getPreventKeyboardDisplayOnProgrammaticFocusProperty();
    }
    pub fn getIsColorFontEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStatics2Cache.get();
        return try _f.getIsColorFontEnabledProperty();
    }
    pub fn getTextProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStaticsCache.get();
        return try _f.getTextProperty();
    }
    pub fn getMaxLengthProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStaticsCache.get();
        return try _f.getMaxLengthProperty();
    }
    pub fn getIsReadOnlyProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStaticsCache.get();
        return try _f.getIsReadOnlyProperty();
    }
    pub fn getAcceptsReturnProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStaticsCache.get();
        return try _f.getAcceptsReturnProperty();
    }
    pub fn getTextAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStaticsCache.get();
        return try _f.getTextAlignmentProperty();
    }
    pub fn getTextWrappingProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStaticsCache.get();
        return try _f.getTextWrappingProperty();
    }
    pub fn getIsSpellCheckEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStaticsCache.get();
        return try _f.getIsSpellCheckEnabledProperty();
    }
    pub fn getIsTextPredictionEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStaticsCache.get();
        return try _f.getIsTextPredictionEnabledProperty();
    }
    pub fn getInputScopeProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStaticsCache.get();
        return try _f.getInputScopeProperty();
    }
    pub fn getCanPasteClipboardContentProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStatics8Cache.get();
        return try _f.getCanPasteClipboardContentProperty();
    }
    pub fn getCanUndoProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStatics8Cache.get();
        return try _f.getCanUndoProperty();
    }
    pub fn getCanRedoProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStatics8Cache.get();
        return try _f.getCanRedoProperty();
    }
    pub fn getSelectionFlyoutProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStatics8Cache.get();
        return try _f.getSelectionFlyoutProperty();
    }
    pub fn getProofingMenuFlyoutProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStatics8Cache.get();
        return try _f.getProofingMenuFlyoutProperty();
    }
    pub fn getDescriptionProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStatics8Cache.get();
        return try _f.getDescriptionProperty();
    }
    pub fn getHandwritingViewProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStatics7Cache.get();
        return try _f.getHandwritingViewProperty();
    }
    pub fn getIsHandwritingViewEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStatics7Cache.get();
        return try _f.getIsHandwritingViewEnabledProperty();
    }
    pub fn getHorizontalTextAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStatics6Cache.get();
        return try _f.getHorizontalTextAlignmentProperty();
    }
    pub fn getCharacterCasingProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStatics6Cache.get();
        return try _f.getCharacterCasingProperty();
    }
    pub fn getPlaceholderForegroundProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStatics6Cache.get();
        return try _f.getPlaceholderForegroundProperty();
    }
    pub fn getSelectionHighlightColorWhenNotFocusedProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStatics5Cache.get();
        return try _f.getSelectionHighlightColorWhenNotFocusedProperty();
    }
    pub fn getDesiredCandidateWindowAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStatics3Cache.get();
        return try _f.getDesiredCandidateWindowAlignmentProperty();
    }
    pub fn getTextReadingOrderProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITextBoxStatics3Cache.get();
        return try _f.getTextReadingOrderProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*TextBox {
        const _f = @This().ITextBoxFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TextBox";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITextBox.GUID;
    pub const IID: Guid = ITextBox.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITextBox.SIGNATURE);
    var _ITextBoxStatics2Cache: FactoryCache(ITextBoxStatics2, RUNTIME_NAME) = .{};
    var _ITextBoxStaticsCache: FactoryCache(ITextBoxStatics, RUNTIME_NAME) = .{};
    var _ITextBoxStatics8Cache: FactoryCache(ITextBoxStatics8, RUNTIME_NAME) = .{};
    var _ITextBoxStatics7Cache: FactoryCache(ITextBoxStatics7, RUNTIME_NAME) = .{};
    var _ITextBoxStatics6Cache: FactoryCache(ITextBoxStatics6, RUNTIME_NAME) = .{};
    var _ITextBoxStatics5Cache: FactoryCache(ITextBoxStatics5, RUNTIME_NAME) = .{};
    var _ITextBoxStatics3Cache: FactoryCache(ITextBoxStatics3, RUNTIME_NAME) = .{};
    var _ITextBoxFactoryCache: FactoryCache(ITextBoxFactory, RUNTIME_NAME) = .{};
};
pub const TextBoxBeforeTextChangingEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getNewText(self: *@This()) core.HResult!HSTRING {
        const this: *ITextBoxBeforeTextChangingEventArgs = @ptrCast(self);
        return try this.getNewText();
    }
    pub fn getCancel(self: *@This()) core.HResult!bool {
        const this: *ITextBoxBeforeTextChangingEventArgs = @ptrCast(self);
        return try this.getCancel();
    }
    pub fn putCancel(self: *@This(), value: bool) core.HResult!void {
        const this: *ITextBoxBeforeTextChangingEventArgs = @ptrCast(self);
        return try this.putCancel(value);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TextBoxBeforeTextChangingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITextBoxBeforeTextChangingEventArgs.GUID;
    pub const IID: Guid = ITextBoxBeforeTextChangingEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITextBoxBeforeTextChangingEventArgs.SIGNATURE);
};
pub const TextBoxSelectionChangingEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getSelectionStart(self: *@This()) core.HResult!i32 {
        const this: *ITextBoxSelectionChangingEventArgs = @ptrCast(self);
        return try this.getSelectionStart();
    }
    pub fn getSelectionLength(self: *@This()) core.HResult!i32 {
        const this: *ITextBoxSelectionChangingEventArgs = @ptrCast(self);
        return try this.getSelectionLength();
    }
    pub fn getCancel(self: *@This()) core.HResult!bool {
        const this: *ITextBoxSelectionChangingEventArgs = @ptrCast(self);
        return try this.getCancel();
    }
    pub fn putCancel(self: *@This(), value: bool) core.HResult!void {
        const this: *ITextBoxSelectionChangingEventArgs = @ptrCast(self);
        return try this.putCancel(value);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TextBoxSelectionChangingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITextBoxSelectionChangingEventArgs.GUID;
    pub const IID: Guid = ITextBoxSelectionChangingEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITextBoxSelectionChangingEventArgs.SIGNATURE);
};
pub const TextBoxTextChangingEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsContentChanging(self: *@This()) core.HResult!bool {
        var this: ?*ITextBoxTextChangingEventArgs2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITextBoxTextChangingEventArgs2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsContentChanging();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TextBoxTextChangingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITextBoxTextChangingEventArgs.GUID;
    pub const IID: Guid = ITextBoxTextChangingEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITextBoxTextChangingEventArgs.SIGNATURE);
};
pub const TextChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TextChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITextChangedEventArgs.GUID;
    pub const IID: Guid = ITextChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITextChangedEventArgs.SIGNATURE);
};
pub const TextChangedEventHandler = extern struct {
    vtable: *const VTable,
    _refs: @import("std").atomic.Value(u32),
    _cb: *const fn (context: ?*anyopaque) callconv(.winapi) void,
    _context: ?*anyopaque = null,
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn init(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *TextChangedEventArgs) callconv(.winapi) void,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
        };
        return _r;
    }
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn initWithState(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *TextChangedEventArgs) callconv(.winapi) void,
        context: anytype,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
            ._context = @ptrCast(context),
        };
        return _r;
    }
    /// This calls Release and voids the returned ref count. If ref count is 0 the memory is released,
    /// Otherwise the memory stays until all references are released, including all references Windows holds.
    ///
    /// The caller *MUST* always call deinit/Release at least once for every AddRef and init called.
    pub fn deinit(self: *@This()) void {
        _ = Release(@ptrCast(self));
    }
    fn QueryInterface(self: *anyopaque, riid: *const Guid, out: *?*anyopaque) callconv(.c) HRESULT {
        const me: *@This() = @ptrCast(@alignCast(self));
        // TODO: Handle IMarshal
        if (core.wiredGuidEql(riid, &IID) or
            core.wiredGuidEql(riid, &IUnknown.IID) or
            core.wiredGuidEql(riid, &IAgileObject.IID))
        {
            out.* = @as(?*anyopaque, @ptrCast(me));
            _ = AddRef(self);
            return 0;
        }
        out.* = null;
        return -2147467262; // E_NOINTERFACE
    }
    fn AddRef(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        return this._refs.fetchAdd(1, .monotonic) + 1;
    }
    fn Release(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        const left = this._refs.fetchSub(1, .acq_rel) - 1;
        if (left == 0) @import("std").heap.c_allocator.destroy(this);
        return left;
    }
    pub fn Invoke(self: *anyopaque, sender: *IInspectable, e: *TextChangedEventArgs) callconv(.winapi) HRESULT {
        const this: *@This() = @ptrCast(@alignCast(self));
        this._cb(this._context, sender, e);
        return 0;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TextChangedEventHandler";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "8eb35b97-ad87-40e8-818b-77db24759566";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.pinterface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        Invoke: *const fn(self: *anyopaque, sender: *IInspectable, e: *TextChangedEventArgs) callconv(.winapi) HRESULT
    };
    pub const VTABLE = VTable {
        .QueryInterface = QueryInterface,
        .AddRef = AddRef,
        .Release = Release,
        .Invoke = Invoke,
    };
};
pub const TextCommandBarFlyout = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*TextCommandBarFlyout {
        const _f = @This().ITextCommandBarFlyoutFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TextCommandBarFlyout";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITextCommandBarFlyout.GUID;
    pub const IID: Guid = ITextCommandBarFlyout.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITextCommandBarFlyout.SIGNATURE);
    var _ITextCommandBarFlyoutFactoryCache: FactoryCache(ITextCommandBarFlyoutFactory, RUNTIME_NAME) = .{};
};
pub const TextCompositionChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getStartIndex(self: *@This()) core.HResult!i32 {
        const this: *ITextCompositionChangedEventArgs = @ptrCast(self);
        return try this.getStartIndex();
    }
    pub fn getLength(self: *@This()) core.HResult!i32 {
        const this: *ITextCompositionChangedEventArgs = @ptrCast(self);
        return try this.getLength();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TextCompositionChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITextCompositionChangedEventArgs.GUID;
    pub const IID: Guid = ITextCompositionChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITextCompositionChangedEventArgs.SIGNATURE);
};
pub const TextCompositionEndedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getStartIndex(self: *@This()) core.HResult!i32 {
        const this: *ITextCompositionEndedEventArgs = @ptrCast(self);
        return try this.getStartIndex();
    }
    pub fn getLength(self: *@This()) core.HResult!i32 {
        const this: *ITextCompositionEndedEventArgs = @ptrCast(self);
        return try this.getLength();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TextCompositionEndedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITextCompositionEndedEventArgs.GUID;
    pub const IID: Guid = ITextCompositionEndedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITextCompositionEndedEventArgs.SIGNATURE);
};
pub const TextCompositionStartedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getStartIndex(self: *@This()) core.HResult!i32 {
        const this: *ITextCompositionStartedEventArgs = @ptrCast(self);
        return try this.getStartIndex();
    }
    pub fn getLength(self: *@This()) core.HResult!i32 {
        const this: *ITextCompositionStartedEventArgs = @ptrCast(self);
        return try this.getLength();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TextCompositionStartedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITextCompositionStartedEventArgs.GUID;
    pub const IID: Guid = ITextCompositionStartedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITextCompositionStartedEventArgs.SIGNATURE);
};
pub const TextControlCopyingToClipboardEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getHandled(self: *@This()) core.HResult!bool {
        const this: *ITextControlCopyingToClipboardEventArgs = @ptrCast(self);
        return try this.getHandled();
    }
    pub fn putHandled(self: *@This(), value: bool) core.HResult!void {
        const this: *ITextControlCopyingToClipboardEventArgs = @ptrCast(self);
        return try this.putHandled(value);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TextControlCopyingToClipboardEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITextControlCopyingToClipboardEventArgs.GUID;
    pub const IID: Guid = ITextControlCopyingToClipboardEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITextControlCopyingToClipboardEventArgs.SIGNATURE);
};
pub const TextControlCuttingToClipboardEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getHandled(self: *@This()) core.HResult!bool {
        const this: *ITextControlCuttingToClipboardEventArgs = @ptrCast(self);
        return try this.getHandled();
    }
    pub fn putHandled(self: *@This(), value: bool) core.HResult!void {
        const this: *ITextControlCuttingToClipboardEventArgs = @ptrCast(self);
        return try this.putHandled(value);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TextControlCuttingToClipboardEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITextControlCuttingToClipboardEventArgs.GUID;
    pub const IID: Guid = ITextControlCuttingToClipboardEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITextControlCuttingToClipboardEventArgs.SIGNATURE);
};
pub const TextControlPasteEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getHandled(self: *@This()) core.HResult!bool {
        const this: *ITextControlPasteEventArgs = @ptrCast(self);
        return try this.getHandled();
    }
    pub fn putHandled(self: *@This(), value: bool) core.HResult!void {
        const this: *ITextControlPasteEventArgs = @ptrCast(self);
        return try this.putHandled(value);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TextControlPasteEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITextControlPasteEventArgs.GUID;
    pub const IID: Guid = ITextControlPasteEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITextControlPasteEventArgs.SIGNATURE);
};
pub const TextControlPasteEventHandler = extern struct {
    vtable: *const VTable,
    _refs: @import("std").atomic.Value(u32),
    _cb: *const fn (context: ?*anyopaque) callconv(.winapi) void,
    _context: ?*anyopaque = null,
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn init(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *TextControlPasteEventArgs) callconv(.winapi) void,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
        };
        return _r;
    }
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn initWithState(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *TextControlPasteEventArgs) callconv(.winapi) void,
        context: anytype,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
            ._context = @ptrCast(context),
        };
        return _r;
    }
    /// This calls Release and voids the returned ref count. If ref count is 0 the memory is released,
    /// Otherwise the memory stays until all references are released, including all references Windows holds.
    ///
    /// The caller *MUST* always call deinit/Release at least once for every AddRef and init called.
    pub fn deinit(self: *@This()) void {
        _ = Release(@ptrCast(self));
    }
    fn QueryInterface(self: *anyopaque, riid: *const Guid, out: *?*anyopaque) callconv(.c) HRESULT {
        const me: *@This() = @ptrCast(@alignCast(self));
        // TODO: Handle IMarshal
        if (core.wiredGuidEql(riid, &IID) or
            core.wiredGuidEql(riid, &IUnknown.IID) or
            core.wiredGuidEql(riid, &IAgileObject.IID))
        {
            out.* = @as(?*anyopaque, @ptrCast(me));
            _ = AddRef(self);
            return 0;
        }
        out.* = null;
        return -2147467262; // E_NOINTERFACE
    }
    fn AddRef(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        return this._refs.fetchAdd(1, .monotonic) + 1;
    }
    fn Release(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        const left = this._refs.fetchSub(1, .acq_rel) - 1;
        if (left == 0) @import("std").heap.c_allocator.destroy(this);
        return left;
    }
    pub fn Invoke(self: *anyopaque, sender: *IInspectable, e: *TextControlPasteEventArgs) callconv(.winapi) HRESULT {
        const this: *@This() = @ptrCast(@alignCast(self));
        this._cb(this._context, sender, e);
        return 0;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TextControlPasteEventHandler";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "d56db359-6f77-4296-ab9c-794939444365";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.pinterface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        Invoke: *const fn(self: *anyopaque, sender: *IInspectable, e: *TextControlPasteEventArgs) callconv(.winapi) HRESULT
    };
    pub const VTABLE = VTable {
        .QueryInterface = QueryInterface,
        .AddRef = AddRef,
        .Release = Release,
        .Invoke = Invoke,
    };
};
pub const TimePickedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getOldTime(self: *@This()) core.HResult!TimeSpan {
        const this: *ITimePickedEventArgs = @ptrCast(self);
        return try this.getOldTime();
    }
    pub fn getNewTime(self: *@This()) core.HResult!TimeSpan {
        const this: *ITimePickedEventArgs = @ptrCast(self);
        return try this.getNewTime();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&ITimePickedEventArgs.IID)));
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TimePickedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITimePickedEventArgs.GUID;
    pub const IID: Guid = ITimePickedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITimePickedEventArgs.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
};
pub const TimePicker = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        const this: *ITimePicker = @ptrCast(self);
        return try this.getHeader();
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *ITimePicker = @ptrCast(self);
        return try this.putHeader(value);
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        const this: *ITimePicker = @ptrCast(self);
        return try this.getHeaderTemplate();
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const this: *ITimePicker = @ptrCast(self);
        return try this.putHeaderTemplate(value);
    }
    pub fn getClockIdentifier(self: *@This()) core.HResult!HSTRING {
        const this: *ITimePicker = @ptrCast(self);
        return try this.getClockIdentifier();
    }
    pub fn putClockIdentifier(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *ITimePicker = @ptrCast(self);
        return try this.putClockIdentifier(value);
    }
    pub fn getMinuteIncrement(self: *@This()) core.HResult!i32 {
        const this: *ITimePicker = @ptrCast(self);
        return try this.getMinuteIncrement();
    }
    pub fn putMinuteIncrement(self: *@This(), value: i32) core.HResult!void {
        const this: *ITimePicker = @ptrCast(self);
        return try this.putMinuteIncrement(value);
    }
    pub fn getTime(self: *@This()) core.HResult!TimeSpan {
        const this: *ITimePicker = @ptrCast(self);
        return try this.getTime();
    }
    pub fn putTime(self: *@This(), value: TimeSpan) core.HResult!void {
        const this: *ITimePicker = @ptrCast(self);
        return try this.putTime(value);
    }
    pub fn addTimeChanged(self: *@This(), handler: *EventHandler(TimePickerValueChangedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *ITimePicker = @ptrCast(self);
        return try this.addTimeChanged(handler);
    }
    pub fn removeTimeChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ITimePicker = @ptrCast(self);
        return try this.removeTimeChanged(token);
    }
    pub fn getLightDismissOverlayMode(self: *@This()) core.HResult!LightDismissOverlayMode {
        var this: ?*ITimePicker2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITimePicker2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getLightDismissOverlayMode();
    }
    pub fn putLightDismissOverlayMode(self: *@This(), value: LightDismissOverlayMode) core.HResult!void {
        var this: ?*ITimePicker2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITimePicker2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putLightDismissOverlayMode(value);
    }
    pub fn getSelectedTime(self: *@This()) core.HResult!*IReference(TimeSpan) {
        var this: ?*ITimePicker3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITimePicker3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSelectedTime();
    }
    pub fn putSelectedTime(self: *@This(), value: *IReference(TimeSpan)) core.HResult!void {
        var this: ?*ITimePicker3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITimePicker3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putSelectedTime(value);
    }
    pub fn addSelectedTimeChanged(self: *@This(), handler: *TypedEventHandler(TimePicker,TimePickerSelectedValueChangedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*ITimePicker3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITimePicker3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addSelectedTimeChanged(handler);
    }
    pub fn removeSelectedTimeChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*ITimePicker3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITimePicker3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeSelectedTimeChanged(token);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getLightDismissOverlayModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITimePickerStatics2Cache.get();
        return try _f.getLightDismissOverlayModeProperty();
    }
    pub fn getSelectedTimeProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITimePickerStatics3Cache.get();
        return try _f.getSelectedTimeProperty();
    }
    pub fn getHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITimePickerStaticsCache.get();
        return try _f.getHeaderProperty();
    }
    pub fn getHeaderTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITimePickerStaticsCache.get();
        return try _f.getHeaderTemplateProperty();
    }
    pub fn getClockIdentifierProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITimePickerStaticsCache.get();
        return try _f.getClockIdentifierProperty();
    }
    pub fn getMinuteIncrementProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITimePickerStaticsCache.get();
        return try _f.getMinuteIncrementProperty();
    }
    pub fn getTimeProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITimePickerStaticsCache.get();
        return try _f.getTimeProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*TimePicker {
        const _f = @This().ITimePickerFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TimePicker";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITimePicker.GUID;
    pub const IID: Guid = ITimePicker.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITimePicker.SIGNATURE);
    var _ITimePickerStatics2Cache: FactoryCache(ITimePickerStatics2, RUNTIME_NAME) = .{};
    var _ITimePickerStatics3Cache: FactoryCache(ITimePickerStatics3, RUNTIME_NAME) = .{};
    var _ITimePickerStaticsCache: FactoryCache(ITimePickerStatics, RUNTIME_NAME) = .{};
    var _ITimePickerFactoryCache: FactoryCache(ITimePickerFactory, RUNTIME_NAME) = .{};
};
pub const TimePickerFlyout = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getClockIdentifier(self: *@This()) core.HResult!HSTRING {
        const this: *ITimePickerFlyout = @ptrCast(self);
        return try this.getClockIdentifier();
    }
    pub fn putClockIdentifier(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *ITimePickerFlyout = @ptrCast(self);
        return try this.putClockIdentifier(value);
    }
    pub fn getTime(self: *@This()) core.HResult!TimeSpan {
        const this: *ITimePickerFlyout = @ptrCast(self);
        return try this.getTime();
    }
    pub fn putTime(self: *@This(), value: TimeSpan) core.HResult!void {
        const this: *ITimePickerFlyout = @ptrCast(self);
        return try this.putTime(value);
    }
    pub fn getMinuteIncrement(self: *@This()) core.HResult!i32 {
        const this: *ITimePickerFlyout = @ptrCast(self);
        return try this.getMinuteIncrement();
    }
    pub fn putMinuteIncrement(self: *@This(), value: i32) core.HResult!void {
        const this: *ITimePickerFlyout = @ptrCast(self);
        return try this.putMinuteIncrement(value);
    }
    pub fn addTimePicked(self: *@This(), handler: *TypedEventHandler(TimePickerFlyout,TimePickedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *ITimePickerFlyout = @ptrCast(self);
        return try this.addTimePicked(handler);
    }
    pub fn removeTimePicked(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ITimePickerFlyout = @ptrCast(self);
        return try this.removeTimePicked(token);
    }
    pub fn ShowAtAsync(self: *@This(), target: *FrameworkElement) core.HResult!*IAsyncOperation(IReference(TimeSpan)) {
        const this: *ITimePickerFlyout = @ptrCast(self);
        return try this.ShowAtAsync(target);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&ITimePickerFlyout.IID)));
    }
    pub fn getClockIdentifierProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITimePickerFlyoutStaticsCache.get();
        return try _f.getClockIdentifierProperty();
    }
    pub fn getTimeProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITimePickerFlyoutStaticsCache.get();
        return try _f.getTimeProperty();
    }
    pub fn getMinuteIncrementProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITimePickerFlyoutStaticsCache.get();
        return try _f.getMinuteIncrementProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TimePickerFlyout";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITimePickerFlyout.GUID;
    pub const IID: Guid = ITimePickerFlyout.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITimePickerFlyout.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _ITimePickerFlyoutStaticsCache: FactoryCache(ITimePickerFlyoutStatics, RUNTIME_NAME) = .{};
};
pub const TimePickerFlyoutPresenter = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsDefaultShadowEnabled(self: *@This()) core.HResult!bool {
        var this: ?*ITimePickerFlyoutPresenter2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITimePickerFlyoutPresenter2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getIsDefaultShadowEnabled();
    }
    pub fn putIsDefaultShadowEnabled(self: *@This(), value: bool) core.HResult!void {
        var this: ?*ITimePickerFlyoutPresenter2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITimePickerFlyoutPresenter2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putIsDefaultShadowEnabled(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getIsDefaultShadowEnabledProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITimePickerFlyoutPresenterStatics2Cache.get();
        return try _f.getIsDefaultShadowEnabledProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TimePickerFlyoutPresenter";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITimePickerFlyoutPresenter.GUID;
    pub const IID: Guid = ITimePickerFlyoutPresenter.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITimePickerFlyoutPresenter.SIGNATURE);
    var _ITimePickerFlyoutPresenterStatics2Cache: FactoryCache(ITimePickerFlyoutPresenterStatics2, RUNTIME_NAME) = .{};
};
pub const TimePickerSelectedValueChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getOldTime(self: *@This()) core.HResult!*IReference(TimeSpan) {
        const this: *ITimePickerSelectedValueChangedEventArgs = @ptrCast(self);
        return try this.getOldTime();
    }
    pub fn getNewTime(self: *@This()) core.HResult!*IReference(TimeSpan) {
        const this: *ITimePickerSelectedValueChangedEventArgs = @ptrCast(self);
        return try this.getNewTime();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TimePickerSelectedValueChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITimePickerSelectedValueChangedEventArgs.GUID;
    pub const IID: Guid = ITimePickerSelectedValueChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITimePickerSelectedValueChangedEventArgs.SIGNATURE);
};
pub const TimePickerValueChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getOldTime(self: *@This()) core.HResult!TimeSpan {
        const this: *ITimePickerValueChangedEventArgs = @ptrCast(self);
        return try this.getOldTime();
    }
    pub fn getNewTime(self: *@This()) core.HResult!TimeSpan {
        const this: *ITimePickerValueChangedEventArgs = @ptrCast(self);
        return try this.getNewTime();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TimePickerValueChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITimePickerValueChangedEventArgs.GUID;
    pub const IID: Guid = ITimePickerValueChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITimePickerValueChangedEventArgs.SIGNATURE);
};
pub const ToggleMenuFlyoutItem = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsChecked(self: *@This()) core.HResult!bool {
        const this: *IToggleMenuFlyoutItem = @ptrCast(self);
        return try this.getIsChecked();
    }
    pub fn putIsChecked(self: *@This(), value: bool) core.HResult!void {
        const this: *IToggleMenuFlyoutItem = @ptrCast(self);
        return try this.putIsChecked(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getIsCheckedProperty() core.HResult!*DependencyProperty {
        const _f = @This().IToggleMenuFlyoutItemStaticsCache.get();
        return try _f.getIsCheckedProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ToggleMenuFlyoutItem {
        const _f = @This().IToggleMenuFlyoutItemFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ToggleMenuFlyoutItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IToggleMenuFlyoutItem.GUID;
    pub const IID: Guid = IToggleMenuFlyoutItem.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IToggleMenuFlyoutItem.SIGNATURE);
    var _IToggleMenuFlyoutItemStaticsCache: FactoryCache(IToggleMenuFlyoutItemStatics, RUNTIME_NAME) = .{};
    var _IToggleMenuFlyoutItemFactoryCache: FactoryCache(IToggleMenuFlyoutItemFactory, RUNTIME_NAME) = .{};
};
pub const ToggleSplitButton = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsChecked(self: *@This()) core.HResult!bool {
        const this: *IToggleSplitButton = @ptrCast(self);
        return try this.getIsChecked();
    }
    pub fn putIsChecked(self: *@This(), value: bool) core.HResult!void {
        const this: *IToggleSplitButton = @ptrCast(self);
        return try this.putIsChecked(value);
    }
    pub fn addIsCheckedChanged(self: *@This(), handler: *TypedEventHandler(ToggleSplitButton,ToggleSplitButtonIsCheckedChangedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *IToggleSplitButton = @ptrCast(self);
        return try this.addIsCheckedChanged(handler);
    }
    pub fn removeIsCheckedChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IToggleSplitButton = @ptrCast(self);
        return try this.removeIsCheckedChanged(token);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ToggleSplitButton {
        const _f = @This().IToggleSplitButtonFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ToggleSplitButton";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IToggleSplitButton.GUID;
    pub const IID: Guid = IToggleSplitButton.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IToggleSplitButton.SIGNATURE);
    var _IToggleSplitButtonFactoryCache: FactoryCache(IToggleSplitButtonFactory, RUNTIME_NAME) = .{};
};
pub const ToggleSplitButtonAutomationPeer = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getExpandCollapseState(self: *@This()) core.HResult!ExpandCollapseState {
        var this: ?*IExpandCollapseProvider = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IExpandCollapseProvider.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getExpandCollapseState();
    }
    pub fn Collapse(self: *@This()) core.HResult!void {
        var this: ?*IExpandCollapseProvider = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IExpandCollapseProvider.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.Collapse();
    }
    pub fn Expand(self: *@This()) core.HResult!void {
        var this: ?*IExpandCollapseProvider = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IExpandCollapseProvider.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.Expand();
    }
    pub fn getToggleState(self: *@This()) core.HResult!ToggleState {
        var this: ?*IToggleProvider = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IToggleProvider.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getToggleState();
    }
    pub fn Toggle(self: *@This()) core.HResult!void {
        var this: ?*IToggleProvider = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IToggleProvider.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.Toggle();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(owner: *ToggleSplitButton, baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ToggleSplitButtonAutomationPeer {
        const _f = @This().IToggleSplitButtonAutomationPeerFactoryCache.get();
        return try _f.CreateInstance(owner, baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ToggleSplitButtonAutomationPeer";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IToggleSplitButtonAutomationPeer.GUID;
    pub const IID: Guid = IToggleSplitButtonAutomationPeer.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IToggleSplitButtonAutomationPeer.SIGNATURE);
    var _IToggleSplitButtonAutomationPeerFactoryCache: FactoryCache(IToggleSplitButtonAutomationPeerFactory, RUNTIME_NAME) = .{};
};
pub const ToggleSplitButtonIsCheckedChangedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ToggleSplitButtonIsCheckedChangedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IToggleSplitButtonIsCheckedChangedEventArgs.GUID;
    pub const IID: Guid = IToggleSplitButtonIsCheckedChangedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IToggleSplitButtonIsCheckedChangedEventArgs.SIGNATURE);
};
pub const ToggleSwitch = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsOn(self: *@This()) core.HResult!bool {
        const this: *IToggleSwitch = @ptrCast(self);
        return try this.getIsOn();
    }
    pub fn putIsOn(self: *@This(), value: bool) core.HResult!void {
        const this: *IToggleSwitch = @ptrCast(self);
        return try this.putIsOn(value);
    }
    pub fn getHeader(self: *@This()) core.HResult!*IInspectable {
        const this: *IToggleSwitch = @ptrCast(self);
        return try this.getHeader();
    }
    pub fn putHeader(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IToggleSwitch = @ptrCast(self);
        return try this.putHeader(value);
    }
    pub fn getHeaderTemplate(self: *@This()) core.HResult!*DataTemplate {
        const this: *IToggleSwitch = @ptrCast(self);
        return try this.getHeaderTemplate();
    }
    pub fn putHeaderTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const this: *IToggleSwitch = @ptrCast(self);
        return try this.putHeaderTemplate(value);
    }
    pub fn getOnContent(self: *@This()) core.HResult!*IInspectable {
        const this: *IToggleSwitch = @ptrCast(self);
        return try this.getOnContent();
    }
    pub fn putOnContent(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IToggleSwitch = @ptrCast(self);
        return try this.putOnContent(value);
    }
    pub fn getOnContentTemplate(self: *@This()) core.HResult!*DataTemplate {
        const this: *IToggleSwitch = @ptrCast(self);
        return try this.getOnContentTemplate();
    }
    pub fn putOnContentTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const this: *IToggleSwitch = @ptrCast(self);
        return try this.putOnContentTemplate(value);
    }
    pub fn getOffContent(self: *@This()) core.HResult!*IInspectable {
        const this: *IToggleSwitch = @ptrCast(self);
        return try this.getOffContent();
    }
    pub fn putOffContent(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *IToggleSwitch = @ptrCast(self);
        return try this.putOffContent(value);
    }
    pub fn getOffContentTemplate(self: *@This()) core.HResult!*DataTemplate {
        const this: *IToggleSwitch = @ptrCast(self);
        return try this.getOffContentTemplate();
    }
    pub fn putOffContentTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        const this: *IToggleSwitch = @ptrCast(self);
        return try this.putOffContentTemplate(value);
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*ToggleSwitchTemplateSettings {
        const this: *IToggleSwitch = @ptrCast(self);
        return try this.getTemplateSettings();
    }
    pub fn addToggled(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IToggleSwitch = @ptrCast(self);
        return try this.addToggled(handler);
    }
    pub fn removeToggled(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IToggleSwitch = @ptrCast(self);
        return try this.removeToggled(token);
    }
    pub fn OnToggled(self: *@This()) core.HResult!void {
        var this: ?*IToggleSwitchOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IToggleSwitchOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnToggled();
    }
    pub fn OnOnContentChanged(self: *@This(), oldContent: *IInspectable, newContent: *IInspectable) core.HResult!void {
        var this: ?*IToggleSwitchOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IToggleSwitchOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnOnContentChanged(oldContent, newContent);
    }
    pub fn OnOffContentChanged(self: *@This(), oldContent: *IInspectable, newContent: *IInspectable) core.HResult!void {
        var this: ?*IToggleSwitchOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IToggleSwitchOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnOffContentChanged(oldContent, newContent);
    }
    pub fn OnHeaderChanged(self: *@This(), oldContent: *IInspectable, newContent: *IInspectable) core.HResult!void {
        var this: ?*IToggleSwitchOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IToggleSwitchOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnHeaderChanged(oldContent, newContent);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IToggleSwitch.IID)));
    }
    pub fn getIsOnProperty() core.HResult!*DependencyProperty {
        const _f = @This().IToggleSwitchStaticsCache.get();
        return try _f.getIsOnProperty();
    }
    pub fn getHeaderProperty() core.HResult!*DependencyProperty {
        const _f = @This().IToggleSwitchStaticsCache.get();
        return try _f.getHeaderProperty();
    }
    pub fn getHeaderTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IToggleSwitchStaticsCache.get();
        return try _f.getHeaderTemplateProperty();
    }
    pub fn getOnContentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IToggleSwitchStaticsCache.get();
        return try _f.getOnContentProperty();
    }
    pub fn getOnContentTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IToggleSwitchStaticsCache.get();
        return try _f.getOnContentTemplateProperty();
    }
    pub fn getOffContentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IToggleSwitchStaticsCache.get();
        return try _f.getOffContentProperty();
    }
    pub fn getOffContentTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().IToggleSwitchStaticsCache.get();
        return try _f.getOffContentTemplateProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ToggleSwitch";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IToggleSwitch.GUID;
    pub const IID: Guid = IToggleSwitch.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IToggleSwitch.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IToggleSwitchStaticsCache: FactoryCache(IToggleSwitchStatics, RUNTIME_NAME) = .{};
};
pub const ToolTip = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getHorizontalOffset(self: *@This()) core.HResult!f64 {
        const this: *IToolTip = @ptrCast(self);
        return try this.getHorizontalOffset();
    }
    pub fn putHorizontalOffset(self: *@This(), value: f64) core.HResult!void {
        const this: *IToolTip = @ptrCast(self);
        return try this.putHorizontalOffset(value);
    }
    pub fn getIsOpen(self: *@This()) core.HResult!bool {
        const this: *IToolTip = @ptrCast(self);
        return try this.getIsOpen();
    }
    pub fn putIsOpen(self: *@This(), value: bool) core.HResult!void {
        const this: *IToolTip = @ptrCast(self);
        return try this.putIsOpen(value);
    }
    pub fn getPlacement(self: *@This()) core.HResult!PlacementMode {
        const this: *IToolTip = @ptrCast(self);
        return try this.getPlacement();
    }
    pub fn putPlacement(self: *@This(), value: PlacementMode) core.HResult!void {
        const this: *IToolTip = @ptrCast(self);
        return try this.putPlacement(value);
    }
    pub fn getPlacementTarget(self: *@This()) core.HResult!*UIElement {
        const this: *IToolTip = @ptrCast(self);
        return try this.getPlacementTarget();
    }
    pub fn putPlacementTarget(self: *@This(), value: *UIElement) core.HResult!void {
        const this: *IToolTip = @ptrCast(self);
        return try this.putPlacementTarget(value);
    }
    pub fn getVerticalOffset(self: *@This()) core.HResult!f64 {
        const this: *IToolTip = @ptrCast(self);
        return try this.getVerticalOffset();
    }
    pub fn putVerticalOffset(self: *@This(), value: f64) core.HResult!void {
        const this: *IToolTip = @ptrCast(self);
        return try this.putVerticalOffset(value);
    }
    pub fn getTemplateSettings(self: *@This()) core.HResult!*ToolTipTemplateSettings {
        const this: *IToolTip = @ptrCast(self);
        return try this.getTemplateSettings();
    }
    pub fn addClosed(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IToolTip = @ptrCast(self);
        return try this.addClosed(handler);
    }
    pub fn removeClosed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IToolTip = @ptrCast(self);
        return try this.removeClosed(token);
    }
    pub fn addOpened(self: *@This(), handler: *RoutedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IToolTip = @ptrCast(self);
        return try this.addOpened(handler);
    }
    pub fn removeOpened(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IToolTip = @ptrCast(self);
        return try this.removeOpened(token);
    }
    pub fn getPlacementRect(self: *@This()) core.HResult!*IReference(Rect) {
        var this: ?*IToolTip2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IToolTip2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getPlacementRect();
    }
    pub fn putPlacementRect(self: *@This(), value: *IReference(Rect)) core.HResult!void {
        var this: ?*IToolTip2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IToolTip2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putPlacementRect(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getPlacementRectProperty() core.HResult!*DependencyProperty {
        const _f = @This().IToolTipStatics2Cache.get();
        return try _f.getPlacementRectProperty();
    }
    pub fn getHorizontalOffsetProperty() core.HResult!*DependencyProperty {
        const _f = @This().IToolTipStaticsCache.get();
        return try _f.getHorizontalOffsetProperty();
    }
    pub fn getIsOpenProperty() core.HResult!*DependencyProperty {
        const _f = @This().IToolTipStaticsCache.get();
        return try _f.getIsOpenProperty();
    }
    pub fn getPlacementProperty() core.HResult!*DependencyProperty {
        const _f = @This().IToolTipStaticsCache.get();
        return try _f.getPlacementProperty();
    }
    pub fn getPlacementTargetProperty() core.HResult!*DependencyProperty {
        const _f = @This().IToolTipStaticsCache.get();
        return try _f.getPlacementTargetProperty();
    }
    pub fn getVerticalOffsetProperty() core.HResult!*DependencyProperty {
        const _f = @This().IToolTipStaticsCache.get();
        return try _f.getVerticalOffsetProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*ToolTip {
        const _f = @This().IToolTipFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ToolTip";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IToolTip.GUID;
    pub const IID: Guid = IToolTip.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IToolTip.SIGNATURE);
    var _IToolTipStatics2Cache: FactoryCache(IToolTipStatics2, RUNTIME_NAME) = .{};
    var _IToolTipStaticsCache: FactoryCache(IToolTipStatics, RUNTIME_NAME) = .{};
    var _IToolTipFactoryCache: FactoryCache(IToolTipFactory, RUNTIME_NAME) = .{};
};
pub const ToolTipService = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getPlacementProperty() core.HResult!*DependencyProperty {
        const _f = @This().IToolTipServiceStaticsCache.get();
        return try _f.getPlacementProperty();
    }
    pub fn GetPlacement(element: *DependencyObject) core.HResult!PlacementMode {
        const _f = @This().IToolTipServiceStaticsCache.get();
        return try _f.GetPlacement(element);
    }
    pub fn SetPlacement(element: *DependencyObject, value: PlacementMode) core.HResult!void {
        const _f = @This().IToolTipServiceStaticsCache.get();
        return try _f.SetPlacement(element, value);
    }
    pub fn getPlacementTargetProperty() core.HResult!*DependencyProperty {
        const _f = @This().IToolTipServiceStaticsCache.get();
        return try _f.getPlacementTargetProperty();
    }
    pub fn GetPlacementTarget(element: *DependencyObject) core.HResult!*UIElement {
        const _f = @This().IToolTipServiceStaticsCache.get();
        return try _f.GetPlacementTarget(element);
    }
    pub fn SetPlacementTarget(element: *DependencyObject, value: *UIElement) core.HResult!void {
        const _f = @This().IToolTipServiceStaticsCache.get();
        return try _f.SetPlacementTarget(element, value);
    }
    pub fn getToolTipProperty() core.HResult!*DependencyProperty {
        const _f = @This().IToolTipServiceStaticsCache.get();
        return try _f.getToolTipProperty();
    }
    pub fn GetToolTip(element: *DependencyObject) core.HResult!*IInspectable {
        const _f = @This().IToolTipServiceStaticsCache.get();
        return try _f.GetToolTip(element);
    }
    pub fn SetToolTip(element: *DependencyObject, value: *IInspectable) core.HResult!void {
        const _f = @This().IToolTipServiceStaticsCache.get();
        return try _f.SetToolTip(element, value);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.ToolTipService";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IToolTipService.GUID;
    pub const IID: Guid = IToolTipService.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IToolTipService.SIGNATURE);
    var _IToolTipServiceStaticsCache: FactoryCache(IToolTipServiceStatics, RUNTIME_NAME) = .{};
};
pub const TreeView = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getRootNodes(self: *@This()) core.HResult!*IVector(TreeViewNode) {
        const this: *ITreeView = @ptrCast(self);
        return try this.getRootNodes();
    }
    pub fn getSelectionMode(self: *@This()) core.HResult!TreeViewSelectionMode {
        const this: *ITreeView = @ptrCast(self);
        return try this.getSelectionMode();
    }
    pub fn putSelectionMode(self: *@This(), value: TreeViewSelectionMode) core.HResult!void {
        const this: *ITreeView = @ptrCast(self);
        return try this.putSelectionMode(value);
    }
    pub fn getSelectedNodes(self: *@This()) core.HResult!*IVector(TreeViewNode) {
        const this: *ITreeView = @ptrCast(self);
        return try this.getSelectedNodes();
    }
    pub fn Expand(self: *@This(), value: *TreeViewNode) core.HResult!void {
        const this: *ITreeView = @ptrCast(self);
        return try this.Expand(value);
    }
    pub fn Collapse(self: *@This(), value: *TreeViewNode) core.HResult!void {
        const this: *ITreeView = @ptrCast(self);
        return try this.Collapse(value);
    }
    pub fn SelectAll(self: *@This()) core.HResult!void {
        const this: *ITreeView = @ptrCast(self);
        return try this.SelectAll();
    }
    pub fn addItemInvoked(self: *@This(), handler: *TypedEventHandler(TreeView,TreeViewItemInvokedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *ITreeView = @ptrCast(self);
        return try this.addItemInvoked(handler);
    }
    pub fn removeItemInvoked(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ITreeView = @ptrCast(self);
        return try this.removeItemInvoked(token);
    }
    pub fn addExpanding(self: *@This(), handler: *TypedEventHandler(TreeView,TreeViewExpandingEventArgs)) core.HResult!EventRegistrationToken {
        const this: *ITreeView = @ptrCast(self);
        return try this.addExpanding(handler);
    }
    pub fn removeExpanding(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ITreeView = @ptrCast(self);
        return try this.removeExpanding(token);
    }
    pub fn addCollapsed(self: *@This(), handler: *TypedEventHandler(TreeView,TreeViewCollapsedEventArgs)) core.HResult!EventRegistrationToken {
        const this: *ITreeView = @ptrCast(self);
        return try this.addCollapsed(handler);
    }
    pub fn removeCollapsed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ITreeView = @ptrCast(self);
        return try this.removeCollapsed(token);
    }
    pub fn NodeFromContainer(self: *@This(), container: *DependencyObject) core.HResult!*TreeViewNode {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.NodeFromContainer(container);
    }
    pub fn ContainerFromNode(self: *@This(), node: *TreeViewNode) core.HResult!*DependencyObject {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.ContainerFromNode(node);
    }
    pub fn ItemFromContainer(self: *@This(), container: *DependencyObject) core.HResult!*IInspectable {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.ItemFromContainer(container);
    }
    pub fn ContainerFromItem(self: *@This(), item: *IInspectable) core.HResult!*DependencyObject {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.ContainerFromItem(item);
    }
    pub fn getCanDragItems(self: *@This()) core.HResult!bool {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCanDragItems();
    }
    pub fn putCanDragItems(self: *@This(), value: bool) core.HResult!void {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putCanDragItems(value);
    }
    pub fn getCanReorderItems(self: *@This()) core.HResult!bool {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCanReorderItems();
    }
    pub fn putCanReorderItems(self: *@This(), value: bool) core.HResult!void {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putCanReorderItems(value);
    }
    pub fn getItemTemplate(self: *@This()) core.HResult!*DataTemplate {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getItemTemplate();
    }
    pub fn putItemTemplate(self: *@This(), value: *DataTemplate) core.HResult!void {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putItemTemplate(value);
    }
    pub fn getItemTemplateSelector(self: *@This()) core.HResult!*DataTemplateSelector {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getItemTemplateSelector();
    }
    pub fn putItemTemplateSelector(self: *@This(), value: *DataTemplateSelector) core.HResult!void {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putItemTemplateSelector(value);
    }
    pub fn getItemContainerStyle(self: *@This()) core.HResult!*Style {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getItemContainerStyle();
    }
    pub fn putItemContainerStyle(self: *@This(), value: *Style) core.HResult!void {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putItemContainerStyle(value);
    }
    pub fn getItemContainerStyleSelector(self: *@This()) core.HResult!*StyleSelector {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getItemContainerStyleSelector();
    }
    pub fn putItemContainerStyleSelector(self: *@This(), value: *StyleSelector) core.HResult!void {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putItemContainerStyleSelector(value);
    }
    pub fn getItemContainerTransitions(self: *@This()) core.HResult!*TransitionCollection {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getItemContainerTransitions();
    }
    pub fn putItemContainerTransitions(self: *@This(), value: *TransitionCollection) core.HResult!void {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putItemContainerTransitions(value);
    }
    pub fn getItemsSource(self: *@This()) core.HResult!*IInspectable {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getItemsSource();
    }
    pub fn putItemsSource(self: *@This(), value: *IInspectable) core.HResult!void {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putItemsSource(value);
    }
    pub fn addDragItemsStarting(self: *@This(), handler: *TypedEventHandler(TreeView,TreeViewDragItemsStartingEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addDragItemsStarting(handler);
    }
    pub fn removeDragItemsStarting(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeDragItemsStarting(token);
    }
    pub fn addDragItemsCompleted(self: *@This(), handler: *TypedEventHandler(TreeView,TreeViewDragItemsCompletedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addDragItemsCompleted(handler);
    }
    pub fn removeDragItemsCompleted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*ITreeView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeDragItemsCompleted(token);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getSelectionModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewStaticsCache.get();
        return try _f.getSelectionModeProperty();
    }
    pub fn getCanDragItemsProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewStatics2Cache.get();
        return try _f.getCanDragItemsProperty();
    }
    pub fn getCanReorderItemsProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewStatics2Cache.get();
        return try _f.getCanReorderItemsProperty();
    }
    pub fn getItemTemplateProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewStatics2Cache.get();
        return try _f.getItemTemplateProperty();
    }
    pub fn getItemTemplateSelectorProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewStatics2Cache.get();
        return try _f.getItemTemplateSelectorProperty();
    }
    pub fn getItemContainerStyleProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewStatics2Cache.get();
        return try _f.getItemContainerStyleProperty();
    }
    pub fn getItemContainerStyleSelectorProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewStatics2Cache.get();
        return try _f.getItemContainerStyleSelectorProperty();
    }
    pub fn getItemContainerTransitionsProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewStatics2Cache.get();
        return try _f.getItemContainerTransitionsProperty();
    }
    pub fn getItemsSourceProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewStatics2Cache.get();
        return try _f.getItemsSourceProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*TreeView {
        const _f = @This().ITreeViewFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TreeView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITreeView.GUID;
    pub const IID: Guid = ITreeView.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITreeView.SIGNATURE);
    var _ITreeViewStaticsCache: FactoryCache(ITreeViewStatics, RUNTIME_NAME) = .{};
    var _ITreeViewStatics2Cache: FactoryCache(ITreeViewStatics2, RUNTIME_NAME) = .{};
    var _ITreeViewFactoryCache: FactoryCache(ITreeViewFactory, RUNTIME_NAME) = .{};
};
pub const TreeViewCollapsedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getNode(self: *@This()) core.HResult!*TreeViewNode {
        const this: *ITreeViewCollapsedEventArgs = @ptrCast(self);
        return try this.getNode();
    }
    pub fn getItem(self: *@This()) core.HResult!*IInspectable {
        var this: ?*ITreeViewCollapsedEventArgs2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeViewCollapsedEventArgs2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getItem();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TreeViewCollapsedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITreeViewCollapsedEventArgs.GUID;
    pub const IID: Guid = ITreeViewCollapsedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITreeViewCollapsedEventArgs.SIGNATURE);
};
pub const TreeViewDragItemsCompletedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getDropResult(self: *@This()) core.HResult!DataPackageOperation {
        const this: *ITreeViewDragItemsCompletedEventArgs = @ptrCast(self);
        return try this.getDropResult();
    }
    pub fn getItems(self: *@This()) core.HResult!*IVectorView(IInspectable) {
        const this: *ITreeViewDragItemsCompletedEventArgs = @ptrCast(self);
        return try this.getItems();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TreeViewDragItemsCompletedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITreeViewDragItemsCompletedEventArgs.GUID;
    pub const IID: Guid = ITreeViewDragItemsCompletedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITreeViewDragItemsCompletedEventArgs.SIGNATURE);
};
pub const TreeViewDragItemsStartingEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getCancel(self: *@This()) core.HResult!bool {
        const this: *ITreeViewDragItemsStartingEventArgs = @ptrCast(self);
        return try this.getCancel();
    }
    pub fn putCancel(self: *@This(), value: bool) core.HResult!void {
        const this: *ITreeViewDragItemsStartingEventArgs = @ptrCast(self);
        return try this.putCancel(value);
    }
    pub fn getData(self: *@This()) core.HResult!*DataPackage {
        const this: *ITreeViewDragItemsStartingEventArgs = @ptrCast(self);
        return try this.getData();
    }
    pub fn getItems(self: *@This()) core.HResult!*IVector(IInspectable) {
        const this: *ITreeViewDragItemsStartingEventArgs = @ptrCast(self);
        return try this.getItems();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TreeViewDragItemsStartingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITreeViewDragItemsStartingEventArgs.GUID;
    pub const IID: Guid = ITreeViewDragItemsStartingEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITreeViewDragItemsStartingEventArgs.SIGNATURE);
};
pub const TreeViewExpandingEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getNode(self: *@This()) core.HResult!*TreeViewNode {
        const this: *ITreeViewExpandingEventArgs = @ptrCast(self);
        return try this.getNode();
    }
    pub fn getItem(self: *@This()) core.HResult!*IInspectable {
        var this: ?*ITreeViewExpandingEventArgs2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeViewExpandingEventArgs2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getItem();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TreeViewExpandingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITreeViewExpandingEventArgs.GUID;
    pub const IID: Guid = ITreeViewExpandingEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITreeViewExpandingEventArgs.SIGNATURE);
};
pub const TreeViewItem = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getGlyphOpacity(self: *@This()) core.HResult!f64 {
        const this: *ITreeViewItem = @ptrCast(self);
        return try this.getGlyphOpacity();
    }
    pub fn putGlyphOpacity(self: *@This(), value: f64) core.HResult!void {
        const this: *ITreeViewItem = @ptrCast(self);
        return try this.putGlyphOpacity(value);
    }
    pub fn getGlyphBrush(self: *@This()) core.HResult!*Brush {
        const this: *ITreeViewItem = @ptrCast(self);
        return try this.getGlyphBrush();
    }
    pub fn putGlyphBrush(self: *@This(), value: *Brush) core.HResult!void {
        const this: *ITreeViewItem = @ptrCast(self);
        return try this.putGlyphBrush(value);
    }
    pub fn getExpandedGlyph(self: *@This()) core.HResult!HSTRING {
        const this: *ITreeViewItem = @ptrCast(self);
        return try this.getExpandedGlyph();
    }
    pub fn putExpandedGlyph(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *ITreeViewItem = @ptrCast(self);
        return try this.putExpandedGlyph(value);
    }
    pub fn getCollapsedGlyph(self: *@This()) core.HResult!HSTRING {
        const this: *ITreeViewItem = @ptrCast(self);
        return try this.getCollapsedGlyph();
    }
    pub fn putCollapsedGlyph(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *ITreeViewItem = @ptrCast(self);
        return try this.putCollapsedGlyph(value);
    }
    pub fn getGlyphSize(self: *@This()) core.HResult!f64 {
        const this: *ITreeViewItem = @ptrCast(self);
        return try this.getGlyphSize();
    }
    pub fn putGlyphSize(self: *@This(), value: f64) core.HResult!void {
        const this: *ITreeViewItem = @ptrCast(self);
        return try this.putGlyphSize(value);
    }
    pub fn getIsExpanded(self: *@This()) core.HResult!bool {
        const this: *ITreeViewItem = @ptrCast(self);
        return try this.getIsExpanded();
    }
    pub fn putIsExpanded(self: *@This(), value: bool) core.HResult!void {
        const this: *ITreeViewItem = @ptrCast(self);
        return try this.putIsExpanded(value);
    }
    pub fn getTreeViewItemTemplateSettings(self: *@This()) core.HResult!*TreeViewItemTemplateSettings {
        const this: *ITreeViewItem = @ptrCast(self);
        return try this.getTreeViewItemTemplateSettings();
    }
    pub fn getHasUnrealizedChildren(self: *@This()) core.HResult!bool {
        var this: ?*ITreeViewItem2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeViewItem2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getHasUnrealizedChildren();
    }
    pub fn putHasUnrealizedChildren(self: *@This(), value: bool) core.HResult!void {
        var this: ?*ITreeViewItem2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeViewItem2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putHasUnrealizedChildren(value);
    }
    pub fn getItemsSource(self: *@This()) core.HResult!*IInspectable {
        var this: ?*ITreeViewItem2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeViewItem2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getItemsSource();
    }
    pub fn putItemsSource(self: *@This(), value: *IInspectable) core.HResult!void {
        var this: ?*ITreeViewItem2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &ITreeViewItem2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putItemsSource(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getGlyphOpacityProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewItemStaticsCache.get();
        return try _f.getGlyphOpacityProperty();
    }
    pub fn getGlyphBrushProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewItemStaticsCache.get();
        return try _f.getGlyphBrushProperty();
    }
    pub fn getExpandedGlyphProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewItemStaticsCache.get();
        return try _f.getExpandedGlyphProperty();
    }
    pub fn getCollapsedGlyphProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewItemStaticsCache.get();
        return try _f.getCollapsedGlyphProperty();
    }
    pub fn getGlyphSizeProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewItemStaticsCache.get();
        return try _f.getGlyphSizeProperty();
    }
    pub fn getIsExpandedProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewItemStaticsCache.get();
        return try _f.getIsExpandedProperty();
    }
    pub fn getTreeViewItemTemplateSettingsProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewItemStaticsCache.get();
        return try _f.getTreeViewItemTemplateSettingsProperty();
    }
    pub fn getHasUnrealizedChildrenProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewItemStatics2Cache.get();
        return try _f.getHasUnrealizedChildrenProperty();
    }
    pub fn getItemsSourceProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewItemStatics2Cache.get();
        return try _f.getItemsSourceProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*TreeViewItem {
        const _f = @This().ITreeViewItemFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TreeViewItem";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITreeViewItem.GUID;
    pub const IID: Guid = ITreeViewItem.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITreeViewItem.SIGNATURE);
    var _ITreeViewItemStaticsCache: FactoryCache(ITreeViewItemStatics, RUNTIME_NAME) = .{};
    var _ITreeViewItemStatics2Cache: FactoryCache(ITreeViewItemStatics2, RUNTIME_NAME) = .{};
    var _ITreeViewItemFactoryCache: FactoryCache(ITreeViewItemFactory, RUNTIME_NAME) = .{};
};
pub const TreeViewItemInvokedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getInvokedItem(self: *@This()) core.HResult!*IInspectable {
        const this: *ITreeViewItemInvokedEventArgs = @ptrCast(self);
        return try this.getInvokedItem();
    }
    pub fn putHandled(self: *@This(), value: bool) core.HResult!void {
        const this: *ITreeViewItemInvokedEventArgs = @ptrCast(self);
        return try this.putHandled(value);
    }
    pub fn getHandled(self: *@This()) core.HResult!bool {
        const this: *ITreeViewItemInvokedEventArgs = @ptrCast(self);
        return try this.getHandled();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TreeViewItemInvokedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITreeViewItemInvokedEventArgs.GUID;
    pub const IID: Guid = ITreeViewItemInvokedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITreeViewItemInvokedEventArgs.SIGNATURE);
};
pub const TreeViewItemTemplateSettings = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getExpandedGlyphVisibility(self: *@This()) core.HResult!Visibility {
        const this: *ITreeViewItemTemplateSettings = @ptrCast(self);
        return try this.getExpandedGlyphVisibility();
    }
    pub fn getCollapsedGlyphVisibility(self: *@This()) core.HResult!Visibility {
        const this: *ITreeViewItemTemplateSettings = @ptrCast(self);
        return try this.getCollapsedGlyphVisibility();
    }
    pub fn getIndentation(self: *@This()) core.HResult!Thickness {
        const this: *ITreeViewItemTemplateSettings = @ptrCast(self);
        return try this.getIndentation();
    }
    pub fn getDragItemsCount(self: *@This()) core.HResult!i32 {
        const this: *ITreeViewItemTemplateSettings = @ptrCast(self);
        return try this.getDragItemsCount();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getExpandedGlyphVisibilityProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewItemTemplateSettingsStaticsCache.get();
        return try _f.getExpandedGlyphVisibilityProperty();
    }
    pub fn getCollapsedGlyphVisibilityProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewItemTemplateSettingsStaticsCache.get();
        return try _f.getCollapsedGlyphVisibilityProperty();
    }
    pub fn getIndentationProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewItemTemplateSettingsStaticsCache.get();
        return try _f.getIndentationProperty();
    }
    pub fn getDragItemsCountProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewItemTemplateSettingsStaticsCache.get();
        return try _f.getDragItemsCountProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*TreeViewItemTemplateSettings {
        const _f = @This().ITreeViewItemTemplateSettingsFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TreeViewItemTemplateSettings";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITreeViewItemTemplateSettings.GUID;
    pub const IID: Guid = ITreeViewItemTemplateSettings.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITreeViewItemTemplateSettings.SIGNATURE);
    var _ITreeViewItemTemplateSettingsStaticsCache: FactoryCache(ITreeViewItemTemplateSettingsStatics, RUNTIME_NAME) = .{};
    var _ITreeViewItemTemplateSettingsFactoryCache: FactoryCache(ITreeViewItemTemplateSettingsFactory, RUNTIME_NAME) = .{};
};
pub const TreeViewList = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*TreeViewList {
        const _f = @This().ITreeViewListFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TreeViewList";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITreeViewList.GUID;
    pub const IID: Guid = ITreeViewList.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITreeViewList.SIGNATURE);
    var _ITreeViewListFactoryCache: FactoryCache(ITreeViewListFactory, RUNTIME_NAME) = .{};
};
pub const TreeViewNode = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getContent(self: *@This()) core.HResult!*IInspectable {
        const this: *ITreeViewNode = @ptrCast(self);
        return try this.getContent();
    }
    pub fn putContent(self: *@This(), value: *IInspectable) core.HResult!void {
        const this: *ITreeViewNode = @ptrCast(self);
        return try this.putContent(value);
    }
    pub fn getParent(self: *@This()) core.HResult!*TreeViewNode {
        const this: *ITreeViewNode = @ptrCast(self);
        return try this.getParent();
    }
    pub fn getIsExpanded(self: *@This()) core.HResult!bool {
        const this: *ITreeViewNode = @ptrCast(self);
        return try this.getIsExpanded();
    }
    pub fn putIsExpanded(self: *@This(), value: bool) core.HResult!void {
        const this: *ITreeViewNode = @ptrCast(self);
        return try this.putIsExpanded(value);
    }
    pub fn getHasChildren(self: *@This()) core.HResult!bool {
        const this: *ITreeViewNode = @ptrCast(self);
        return try this.getHasChildren();
    }
    pub fn getDepth(self: *@This()) core.HResult!i32 {
        const this: *ITreeViewNode = @ptrCast(self);
        return try this.getDepth();
    }
    pub fn getHasUnrealizedChildren(self: *@This()) core.HResult!bool {
        const this: *ITreeViewNode = @ptrCast(self);
        return try this.getHasUnrealizedChildren();
    }
    pub fn putHasUnrealizedChildren(self: *@This(), value: bool) core.HResult!void {
        const this: *ITreeViewNode = @ptrCast(self);
        return try this.putHasUnrealizedChildren(value);
    }
    pub fn getChildren(self: *@This()) core.HResult!*IVector(TreeViewNode) {
        const this: *ITreeViewNode = @ptrCast(self);
        return try this.getChildren();
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getContentProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewNodeStaticsCache.get();
        return try _f.getContentProperty();
    }
    pub fn getDepthProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewNodeStaticsCache.get();
        return try _f.getDepthProperty();
    }
    pub fn getIsExpandedProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewNodeStaticsCache.get();
        return try _f.getIsExpandedProperty();
    }
    pub fn getHasChildrenProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITreeViewNodeStaticsCache.get();
        return try _f.getHasChildrenProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*TreeViewNode {
        const _f = @This().ITreeViewNodeFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TreeViewNode";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITreeViewNode.GUID;
    pub const IID: Guid = ITreeViewNode.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITreeViewNode.SIGNATURE);
    var _ITreeViewNodeStaticsCache: FactoryCache(ITreeViewNodeStatics, RUNTIME_NAME) = .{};
    var _ITreeViewNodeFactoryCache: FactoryCache(ITreeViewNodeFactory, RUNTIME_NAME) = .{};
};
pub const TreeViewSelectionMode = enum(i32) {
    None = 0,
    Single = 1,
    Multiple = 2,
};
pub const TwoPaneView = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getPane1(self: *@This()) core.HResult!*UIElement {
        const this: *ITwoPaneView = @ptrCast(self);
        return try this.getPane1();
    }
    pub fn putPane1(self: *@This(), value: *UIElement) core.HResult!void {
        const this: *ITwoPaneView = @ptrCast(self);
        return try this.putPane1(value);
    }
    pub fn getPane2(self: *@This()) core.HResult!*UIElement {
        const this: *ITwoPaneView = @ptrCast(self);
        return try this.getPane2();
    }
    pub fn putPane2(self: *@This(), value: *UIElement) core.HResult!void {
        const this: *ITwoPaneView = @ptrCast(self);
        return try this.putPane2(value);
    }
    pub fn getPane1Length(self: *@This()) core.HResult!GridLength {
        const this: *ITwoPaneView = @ptrCast(self);
        return try this.getPane1Length();
    }
    pub fn putPane1Length(self: *@This(), value: GridLength) core.HResult!void {
        const this: *ITwoPaneView = @ptrCast(self);
        return try this.putPane1Length(value);
    }
    pub fn getPane2Length(self: *@This()) core.HResult!GridLength {
        const this: *ITwoPaneView = @ptrCast(self);
        return try this.getPane2Length();
    }
    pub fn putPane2Length(self: *@This(), value: GridLength) core.HResult!void {
        const this: *ITwoPaneView = @ptrCast(self);
        return try this.putPane2Length(value);
    }
    pub fn getPanePriority(self: *@This()) core.HResult!TwoPaneViewPriority {
        const this: *ITwoPaneView = @ptrCast(self);
        return try this.getPanePriority();
    }
    pub fn putPanePriority(self: *@This(), value: TwoPaneViewPriority) core.HResult!void {
        const this: *ITwoPaneView = @ptrCast(self);
        return try this.putPanePriority(value);
    }
    pub fn getMode(self: *@This()) core.HResult!TwoPaneViewMode {
        const this: *ITwoPaneView = @ptrCast(self);
        return try this.getMode();
    }
    pub fn getWideModeConfiguration(self: *@This()) core.HResult!TwoPaneViewWideModeConfiguration {
        const this: *ITwoPaneView = @ptrCast(self);
        return try this.getWideModeConfiguration();
    }
    pub fn putWideModeConfiguration(self: *@This(), value: TwoPaneViewWideModeConfiguration) core.HResult!void {
        const this: *ITwoPaneView = @ptrCast(self);
        return try this.putWideModeConfiguration(value);
    }
    pub fn getTallModeConfiguration(self: *@This()) core.HResult!TwoPaneViewTallModeConfiguration {
        const this: *ITwoPaneView = @ptrCast(self);
        return try this.getTallModeConfiguration();
    }
    pub fn putTallModeConfiguration(self: *@This(), value: TwoPaneViewTallModeConfiguration) core.HResult!void {
        const this: *ITwoPaneView = @ptrCast(self);
        return try this.putTallModeConfiguration(value);
    }
    pub fn getMinWideModeWidth(self: *@This()) core.HResult!f64 {
        const this: *ITwoPaneView = @ptrCast(self);
        return try this.getMinWideModeWidth();
    }
    pub fn putMinWideModeWidth(self: *@This(), value: f64) core.HResult!void {
        const this: *ITwoPaneView = @ptrCast(self);
        return try this.putMinWideModeWidth(value);
    }
    pub fn getMinTallModeHeight(self: *@This()) core.HResult!f64 {
        const this: *ITwoPaneView = @ptrCast(self);
        return try this.getMinTallModeHeight();
    }
    pub fn putMinTallModeHeight(self: *@This(), value: f64) core.HResult!void {
        const this: *ITwoPaneView = @ptrCast(self);
        return try this.putMinTallModeHeight(value);
    }
    pub fn addModeChanged(self: *@This(), handler: *TypedEventHandler(TwoPaneView,IInspectable)) core.HResult!EventRegistrationToken {
        const this: *ITwoPaneView = @ptrCast(self);
        return try this.addModeChanged(handler);
    }
    pub fn removeModeChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *ITwoPaneView = @ptrCast(self);
        return try this.removeModeChanged(token);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn getPane1Property() core.HResult!*DependencyProperty {
        const _f = @This().ITwoPaneViewStaticsCache.get();
        return try _f.getPane1Property();
    }
    pub fn getPane2Property() core.HResult!*DependencyProperty {
        const _f = @This().ITwoPaneViewStaticsCache.get();
        return try _f.getPane2Property();
    }
    pub fn getPane1LengthProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITwoPaneViewStaticsCache.get();
        return try _f.getPane1LengthProperty();
    }
    pub fn getPane2LengthProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITwoPaneViewStaticsCache.get();
        return try _f.getPane2LengthProperty();
    }
    pub fn getPanePriorityProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITwoPaneViewStaticsCache.get();
        return try _f.getPanePriorityProperty();
    }
    pub fn getModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITwoPaneViewStaticsCache.get();
        return try _f.getModeProperty();
    }
    pub fn getWideModeConfigurationProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITwoPaneViewStaticsCache.get();
        return try _f.getWideModeConfigurationProperty();
    }
    pub fn getTallModeConfigurationProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITwoPaneViewStaticsCache.get();
        return try _f.getTallModeConfigurationProperty();
    }
    pub fn getMinWideModeWidthProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITwoPaneViewStaticsCache.get();
        return try _f.getMinWideModeWidthProperty();
    }
    pub fn getMinTallModeHeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().ITwoPaneViewStaticsCache.get();
        return try _f.getMinTallModeHeightProperty();
    }
    pub fn CreateInstance(baseInterface: *IInspectable, innerInterface: *IInspectable) core.HResult!*TwoPaneView {
        const _f = @This().ITwoPaneViewFactoryCache.get();
        return try _f.CreateInstance(baseInterface, innerInterface);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.TwoPaneView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = ITwoPaneView.GUID;
    pub const IID: Guid = ITwoPaneView.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, ITwoPaneView.SIGNATURE);
    var _ITwoPaneViewStaticsCache: FactoryCache(ITwoPaneViewStatics, RUNTIME_NAME) = .{};
    var _ITwoPaneViewFactoryCache: FactoryCache(ITwoPaneViewFactory, RUNTIME_NAME) = .{};
};
pub const TwoPaneViewMode = enum(i32) {
    SinglePane = 0,
    Wide = 1,
    Tall = 2,
};
pub const TwoPaneViewPriority = enum(i32) {
    Pane1 = 0,
    Pane2 = 1,
};
pub const TwoPaneViewTallModeConfiguration = enum(i32) {
    SinglePane = 0,
    TopBottom = 1,
    BottomTop = 2,
};
pub const TwoPaneViewWideModeConfiguration = enum(i32) {
    SinglePane = 0,
    LeftRight = 1,
    RightLeft = 2,
};
pub const UIElementCollection = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn Move(self: *@This(), oldIndex: u32, newIndex: u32) core.HResult!void {
        var this: ?*IUIElementCollection = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IUIElementCollection.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.Move(oldIndex, newIndex);
    }
    pub fn getSize(self: *@This()) core.HResult!u32 {
        const this: *IVector(UIElement) = @ptrCast(self);
        return try this.getSize();
    }
    pub fn GetView(self: *@This()) core.HResult!*IVectorView(UIElement) {
        const this: *IVector(UIElement) = @ptrCast(self);
        return try this.GetView();
    }
    pub fn RemoveAt(self: *@This(), index: u32) core.HResult!void {
        const this: *IVector(UIElement) = @ptrCast(self);
        return try this.RemoveAt(index);
    }
    pub fn RemoveAtEnd(self: *@This()) core.HResult!void {
        const this: *IVector(UIElement) = @ptrCast(self);
        return try this.RemoveAtEnd();
    }
    pub fn Clear(self: *@This()) core.HResult!void {
        const this: *IVector(UIElement) = @ptrCast(self);
        return try this.Clear();
    }
    pub fn First(self: *@This()) core.HResult!*IIterator(UIElement) {
        var this: ?*IIterable(UIElement) = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IIterable.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.First();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.UIElementCollection";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IVector.GUID;
    pub const IID: Guid = IVector.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IVector.SIGNATURE);
};
pub const VariableSizedWrapGrid = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getItemHeight(self: *@This()) core.HResult!f64 {
        const this: *IVariableSizedWrapGrid = @ptrCast(self);
        return try this.getItemHeight();
    }
    pub fn putItemHeight(self: *@This(), value: f64) core.HResult!void {
        const this: *IVariableSizedWrapGrid = @ptrCast(self);
        return try this.putItemHeight(value);
    }
    pub fn getItemWidth(self: *@This()) core.HResult!f64 {
        const this: *IVariableSizedWrapGrid = @ptrCast(self);
        return try this.getItemWidth();
    }
    pub fn putItemWidth(self: *@This(), value: f64) core.HResult!void {
        const this: *IVariableSizedWrapGrid = @ptrCast(self);
        return try this.putItemWidth(value);
    }
    pub fn getOrientation(self: *@This()) core.HResult!Orientation {
        const this: *IVariableSizedWrapGrid = @ptrCast(self);
        return try this.getOrientation();
    }
    pub fn putOrientation(self: *@This(), value: Orientation) core.HResult!void {
        const this: *IVariableSizedWrapGrid = @ptrCast(self);
        return try this.putOrientation(value);
    }
    pub fn getHorizontalChildrenAlignment(self: *@This()) core.HResult!HorizontalAlignment {
        const this: *IVariableSizedWrapGrid = @ptrCast(self);
        return try this.getHorizontalChildrenAlignment();
    }
    pub fn putHorizontalChildrenAlignment(self: *@This(), value: HorizontalAlignment) core.HResult!void {
        const this: *IVariableSizedWrapGrid = @ptrCast(self);
        return try this.putHorizontalChildrenAlignment(value);
    }
    pub fn getVerticalChildrenAlignment(self: *@This()) core.HResult!VerticalAlignment {
        const this: *IVariableSizedWrapGrid = @ptrCast(self);
        return try this.getVerticalChildrenAlignment();
    }
    pub fn putVerticalChildrenAlignment(self: *@This(), value: VerticalAlignment) core.HResult!void {
        const this: *IVariableSizedWrapGrid = @ptrCast(self);
        return try this.putVerticalChildrenAlignment(value);
    }
    pub fn getMaximumRowsOrColumns(self: *@This()) core.HResult!i32 {
        const this: *IVariableSizedWrapGrid = @ptrCast(self);
        return try this.getMaximumRowsOrColumns();
    }
    pub fn putMaximumRowsOrColumns(self: *@This(), value: i32) core.HResult!void {
        const this: *IVariableSizedWrapGrid = @ptrCast(self);
        return try this.putMaximumRowsOrColumns(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IVariableSizedWrapGrid.IID)));
    }
    pub fn getItemHeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().IVariableSizedWrapGridStaticsCache.get();
        return try _f.getItemHeightProperty();
    }
    pub fn getItemWidthProperty() core.HResult!*DependencyProperty {
        const _f = @This().IVariableSizedWrapGridStaticsCache.get();
        return try _f.getItemWidthProperty();
    }
    pub fn getOrientationProperty() core.HResult!*DependencyProperty {
        const _f = @This().IVariableSizedWrapGridStaticsCache.get();
        return try _f.getOrientationProperty();
    }
    pub fn getHorizontalChildrenAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IVariableSizedWrapGridStaticsCache.get();
        return try _f.getHorizontalChildrenAlignmentProperty();
    }
    pub fn getVerticalChildrenAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IVariableSizedWrapGridStaticsCache.get();
        return try _f.getVerticalChildrenAlignmentProperty();
    }
    pub fn getMaximumRowsOrColumnsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IVariableSizedWrapGridStaticsCache.get();
        return try _f.getMaximumRowsOrColumnsProperty();
    }
    pub fn getRowSpanProperty() core.HResult!*DependencyProperty {
        const _f = @This().IVariableSizedWrapGridStaticsCache.get();
        return try _f.getRowSpanProperty();
    }
    pub fn GetRowSpan(element: *UIElement) core.HResult!i32 {
        const _f = @This().IVariableSizedWrapGridStaticsCache.get();
        return try _f.GetRowSpan(element);
    }
    pub fn SetRowSpan(element: *UIElement, value: i32) core.HResult!void {
        const _f = @This().IVariableSizedWrapGridStaticsCache.get();
        return try _f.SetRowSpan(element, value);
    }
    pub fn getColumnSpanProperty() core.HResult!*DependencyProperty {
        const _f = @This().IVariableSizedWrapGridStaticsCache.get();
        return try _f.getColumnSpanProperty();
    }
    pub fn GetColumnSpan(element: *UIElement) core.HResult!i32 {
        const _f = @This().IVariableSizedWrapGridStaticsCache.get();
        return try _f.GetColumnSpan(element);
    }
    pub fn SetColumnSpan(element: *UIElement, value: i32) core.HResult!void {
        const _f = @This().IVariableSizedWrapGridStaticsCache.get();
        return try _f.SetColumnSpan(element, value);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.VariableSizedWrapGrid";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IVariableSizedWrapGrid.GUID;
    pub const IID: Guid = IVariableSizedWrapGrid.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IVariableSizedWrapGrid.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IVariableSizedWrapGridStaticsCache: FactoryCache(IVariableSizedWrapGridStatics, RUNTIME_NAME) = .{};
};
pub const Viewbox = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getChild(self: *@This()) core.HResult!*UIElement {
        const this: *IViewbox = @ptrCast(self);
        return try this.getChild();
    }
    pub fn putChild(self: *@This(), value: *UIElement) core.HResult!void {
        const this: *IViewbox = @ptrCast(self);
        return try this.putChild(value);
    }
    pub fn getStretch(self: *@This()) core.HResult!Stretch {
        const this: *IViewbox = @ptrCast(self);
        return try this.getStretch();
    }
    pub fn putStretch(self: *@This(), value: Stretch) core.HResult!void {
        const this: *IViewbox = @ptrCast(self);
        return try this.putStretch(value);
    }
    pub fn getStretchDirection(self: *@This()) core.HResult!StretchDirection {
        const this: *IViewbox = @ptrCast(self);
        return try this.getStretchDirection();
    }
    pub fn putStretchDirection(self: *@This(), value: StretchDirection) core.HResult!void {
        const this: *IViewbox = @ptrCast(self);
        return try this.putStretchDirection(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IViewbox.IID)));
    }
    pub fn getStretchProperty() core.HResult!*DependencyProperty {
        const _f = @This().IViewboxStaticsCache.get();
        return try _f.getStretchProperty();
    }
    pub fn getStretchDirectionProperty() core.HResult!*DependencyProperty {
        const _f = @This().IViewboxStaticsCache.get();
        return try _f.getStretchDirectionProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.Viewbox";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IViewbox.GUID;
    pub const IID: Guid = IViewbox.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IViewbox.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IViewboxStaticsCache: FactoryCache(IViewboxStatics, RUNTIME_NAME) = .{};
};
pub const VirtualizationMode = enum(i32) {
    Standard = 0,
    Recycling = 1,
};
pub const VirtualizingStackPanel = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getAreScrollSnapPointsRegular(self: *@This()) core.HResult!bool {
        const this: *IVirtualizingStackPanel = @ptrCast(self);
        return try this.getAreScrollSnapPointsRegular();
    }
    pub fn putAreScrollSnapPointsRegular(self: *@This(), value: bool) core.HResult!void {
        const this: *IVirtualizingStackPanel = @ptrCast(self);
        return try this.putAreScrollSnapPointsRegular(value);
    }
    pub fn getOrientation(self: *@This()) core.HResult!Orientation {
        const this: *IVirtualizingStackPanel = @ptrCast(self);
        return try this.getOrientation();
    }
    pub fn putOrientation(self: *@This(), value: Orientation) core.HResult!void {
        const this: *IVirtualizingStackPanel = @ptrCast(self);
        return try this.putOrientation(value);
    }
    pub fn addCleanUpVirtualizedItemEvent(self: *@This(), handler: *CleanUpVirtualizedItemEventHandler) core.HResult!EventRegistrationToken {
        const this: *IVirtualizingStackPanel = @ptrCast(self);
        return try this.addCleanUpVirtualizedItemEvent(handler);
    }
    pub fn removeCleanUpVirtualizedItemEvent(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IVirtualizingStackPanel = @ptrCast(self);
        return try this.removeCleanUpVirtualizedItemEvent(token);
    }
    pub fn OnCleanUpVirtualizedItem(self: *@This(), e: *CleanUpVirtualizedItemEventArgs) core.HResult!void {
        var this: ?*IVirtualizingStackPanelOverrides = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IVirtualizingStackPanelOverrides.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.OnCleanUpVirtualizedItem(e);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IVirtualizingStackPanel.IID)));
    }
    pub fn getAreScrollSnapPointsRegularProperty() core.HResult!*DependencyProperty {
        const _f = @This().IVirtualizingStackPanelStaticsCache.get();
        return try _f.getAreScrollSnapPointsRegularProperty();
    }
    pub fn getOrientationProperty() core.HResult!*DependencyProperty {
        const _f = @This().IVirtualizingStackPanelStaticsCache.get();
        return try _f.getOrientationProperty();
    }
    pub fn getVirtualizationModeProperty() core.HResult!*DependencyProperty {
        const _f = @This().IVirtualizingStackPanelStaticsCache.get();
        return try _f.getVirtualizationModeProperty();
    }
    pub fn GetVirtualizationMode(element: *DependencyObject) core.HResult!VirtualizationMode {
        const _f = @This().IVirtualizingStackPanelStaticsCache.get();
        return try _f.GetVirtualizationMode(element);
    }
    pub fn SetVirtualizationMode(element: *DependencyObject, value: VirtualizationMode) core.HResult!void {
        const _f = @This().IVirtualizingStackPanelStaticsCache.get();
        return try _f.SetVirtualizationMode(element, value);
    }
    pub fn getIsVirtualizingProperty() core.HResult!*DependencyProperty {
        const _f = @This().IVirtualizingStackPanelStaticsCache.get();
        return try _f.getIsVirtualizingProperty();
    }
    pub fn GetIsVirtualizing(o: *DependencyObject) core.HResult!bool {
        const _f = @This().IVirtualizingStackPanelStaticsCache.get();
        return try _f.GetIsVirtualizing(o);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.VirtualizingStackPanel";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IVirtualizingStackPanel.GUID;
    pub const IID: Guid = IVirtualizingStackPanel.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IVirtualizingStackPanel.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IVirtualizingStackPanelStaticsCache: FactoryCache(IVirtualizingStackPanelStatics, RUNTIME_NAME) = .{};
};
pub const WebView = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getSource(self: *@This()) core.HResult!*Uri {
        const this: *IWebView = @ptrCast(self);
        return try this.getSource();
    }
    pub fn putSource(self: *@This(), value: *Uri) core.HResult!void {
        const this: *IWebView = @ptrCast(self);
        return try this.putSource(value);
    }
    pub fn getAllowedScriptNotifyUris(self: *@This()) core.HResult!*IVector(Uri) {
        const this: *IWebView = @ptrCast(self);
        return try this.getAllowedScriptNotifyUris();
    }
    pub fn putAllowedScriptNotifyUris(self: *@This(), value: *IVector(Uri)) core.HResult!void {
        const this: *IWebView = @ptrCast(self);
        return try this.putAllowedScriptNotifyUris(value);
    }
    pub fn getDataTransferPackage(self: *@This()) core.HResult!*DataPackage {
        const this: *IWebView = @ptrCast(self);
        return try this.getDataTransferPackage();
    }
    pub fn addLoadCompleted(self: *@This(), handler: *LoadCompletedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IWebView = @ptrCast(self);
        return try this.addLoadCompleted(handler);
    }
    pub fn removeLoadCompleted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IWebView = @ptrCast(self);
        return try this.removeLoadCompleted(token);
    }
    pub fn addScriptNotify(self: *@This(), handler: *NotifyEventHandler) core.HResult!EventRegistrationToken {
        const this: *IWebView = @ptrCast(self);
        return try this.addScriptNotify(handler);
    }
    pub fn removeScriptNotify(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IWebView = @ptrCast(self);
        return try this.removeScriptNotify(token);
    }
    pub fn addNavigationFailed(self: *@This(), handler: *WebViewNavigationFailedEventHandler) core.HResult!EventRegistrationToken {
        const this: *IWebView = @ptrCast(self);
        return try this.addNavigationFailed(handler);
    }
    pub fn removeNavigationFailed(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        const this: *IWebView = @ptrCast(self);
        return try this.removeNavigationFailed(token);
    }
    pub fn InvokeScript(self: *@This(), scriptName: HSTRING, arguments: [*]HSTRING) core.HResult!HSTRING {
        const this: *IWebView = @ptrCast(self);
        return try this.InvokeScript(scriptName, arguments);
    }
    pub fn Navigate(self: *@This(), source: *Uri) core.HResult!void {
        const this: *IWebView = @ptrCast(self);
        return try this.Navigate(source);
    }
    pub fn NavigateToString(self: *@This(), text: HSTRING) core.HResult!void {
        const this: *IWebView = @ptrCast(self);
        return try this.NavigateToString(text);
    }
    pub fn getCanGoBack(self: *@This()) core.HResult!bool {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCanGoBack();
    }
    pub fn getCanGoForward(self: *@This()) core.HResult!bool {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getCanGoForward();
    }
    pub fn getDocumentTitle(self: *@This()) core.HResult!HSTRING {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDocumentTitle();
    }
    pub fn addNavigationStarting(self: *@This(), handler: *TypedEventHandler(WebView,WebViewNavigationStartingEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addNavigationStarting(handler);
    }
    pub fn removeNavigationStarting(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeNavigationStarting(token);
    }
    pub fn addContentLoading(self: *@This(), handler: *TypedEventHandler(WebView,WebViewContentLoadingEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addContentLoading(handler);
    }
    pub fn removeContentLoading(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeContentLoading(token);
    }
    pub fn addDOMContentLoaded(self: *@This(), handler: *TypedEventHandler(WebView,WebViewDOMContentLoadedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addDOMContentLoaded(handler);
    }
    pub fn removeDOMContentLoaded(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeDOMContentLoaded(token);
    }
    pub fn GoForward(self: *@This()) core.HResult!void {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GoForward();
    }
    pub fn GoBack(self: *@This()) core.HResult!void {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.GoBack();
    }
    pub fn Refresh(self: *@This()) core.HResult!void {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.Refresh();
    }
    pub fn Stop(self: *@This()) core.HResult!void {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.Stop();
    }
    pub fn CapturePreviewToStreamAsync(self: *@This(), stream: *IRandomAccessStream) core.HResult!*IAsyncAction {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.CapturePreviewToStreamAsync(stream);
    }
    pub fn InvokeScriptAsync(self: *@This(), scriptName: HSTRING, arguments: *IIterable(HSTRING)) core.HResult!*IAsyncOperation(HSTRING) {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.InvokeScriptAsync(scriptName, arguments);
    }
    pub fn CaptureSelectedContentToDataPackageAsync(self: *@This()) core.HResult!*IAsyncOperation(DataPackage) {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.CaptureSelectedContentToDataPackageAsync();
    }
    pub fn NavigateToLocalStreamUri(self: *@This(), source: *Uri, streamResolver: *IUriToStreamResolver) core.HResult!void {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.NavigateToLocalStreamUri(source, streamResolver);
    }
    pub fn BuildLocalStreamUri(self: *@This(), contentIdentifier: HSTRING, relativePath: HSTRING) core.HResult!*Uri {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.BuildLocalStreamUri(contentIdentifier, relativePath);
    }
    pub fn getDefaultBackgroundColor(self: *@This()) core.HResult!Color {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDefaultBackgroundColor();
    }
    pub fn putDefaultBackgroundColor(self: *@This(), value: Color) core.HResult!void {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putDefaultBackgroundColor(value);
    }
    pub fn addNavigationCompleted(self: *@This(), handler: *TypedEventHandler(WebView,WebViewNavigationCompletedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addNavigationCompleted(handler);
    }
    pub fn removeNavigationCompleted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeNavigationCompleted(token);
    }
    pub fn addFrameNavigationStarting(self: *@This(), handler: *TypedEventHandler(WebView,WebViewNavigationStartingEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addFrameNavigationStarting(handler);
    }
    pub fn removeFrameNavigationStarting(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeFrameNavigationStarting(token);
    }
    pub fn addFrameContentLoading(self: *@This(), handler: *TypedEventHandler(WebView,WebViewContentLoadingEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addFrameContentLoading(handler);
    }
    pub fn removeFrameContentLoading(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeFrameContentLoading(token);
    }
    pub fn addFrameDOMContentLoaded(self: *@This(), handler: *TypedEventHandler(WebView,WebViewDOMContentLoadedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addFrameDOMContentLoaded(handler);
    }
    pub fn removeFrameDOMContentLoaded(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeFrameDOMContentLoaded(token);
    }
    pub fn addFrameNavigationCompleted(self: *@This(), handler: *TypedEventHandler(WebView,WebViewNavigationCompletedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addFrameNavigationCompleted(handler);
    }
    pub fn removeFrameNavigationCompleted(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeFrameNavigationCompleted(token);
    }
    pub fn addLongRunningScriptDetected(self: *@This(), handler: *TypedEventHandler(WebView,WebViewLongRunningScriptDetectedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addLongRunningScriptDetected(handler);
    }
    pub fn removeLongRunningScriptDetected(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeLongRunningScriptDetected(token);
    }
    pub fn addUnsafeContentWarningDisplaying(self: *@This(), handler: *TypedEventHandler(WebView,IInspectable)) core.HResult!EventRegistrationToken {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addUnsafeContentWarningDisplaying(handler);
    }
    pub fn removeUnsafeContentWarningDisplaying(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeUnsafeContentWarningDisplaying(token);
    }
    pub fn addUnviewableContentIdentified(self: *@This(), handler: *TypedEventHandler(WebView,WebViewUnviewableContentIdentifiedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addUnviewableContentIdentified(handler);
    }
    pub fn removeUnviewableContentIdentified(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeUnviewableContentIdentified(token);
    }
    pub fn NavigateWithHttpRequestMessage(self: *@This(), requestMessage: *HttpRequestMessage) core.HResult!void {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.NavigateWithHttpRequestMessage(requestMessage);
    }
    pub fn Focus(self: *@This(), value: FocusState) core.HResult!bool {
        var this: ?*IWebView2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.Focus(value);
    }
    pub fn getContainsFullScreenElement(self: *@This()) core.HResult!bool {
        var this: ?*IWebView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getContainsFullScreenElement();
    }
    pub fn addContainsFullScreenElementChanged(self: *@This(), handler: *TypedEventHandler(WebView,IInspectable)) core.HResult!EventRegistrationToken {
        var this: ?*IWebView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addContainsFullScreenElementChanged(handler);
    }
    pub fn removeContainsFullScreenElementChanged(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IWebView3 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView3.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeContainsFullScreenElementChanged(token);
    }
    pub fn getExecutionMode(self: *@This()) core.HResult!WebViewExecutionMode {
        var this: ?*IWebView4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getExecutionMode();
    }
    pub fn getDeferredPermissionRequests(self: *@This()) core.HResult!*IVector(WebViewDeferredPermissionRequest) {
        var this: ?*IWebView4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getDeferredPermissionRequests();
    }
    pub fn getSettings(self: *@This()) core.HResult!*WebViewSettings {
        var this: ?*IWebView4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getSettings();
    }
    pub fn addUnsupportedUriSchemeIdentified(self: *@This(), handler: *TypedEventHandler(WebView,WebViewUnsupportedUriSchemeIdentifiedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IWebView4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addUnsupportedUriSchemeIdentified(handler);
    }
    pub fn removeUnsupportedUriSchemeIdentified(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IWebView4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeUnsupportedUriSchemeIdentified(token);
    }
    pub fn addNewWindowRequested(self: *@This(), handler: *TypedEventHandler(WebView,WebViewNewWindowRequestedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IWebView4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addNewWindowRequested(handler);
    }
    pub fn removeNewWindowRequested(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IWebView4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeNewWindowRequested(token);
    }
    pub fn addPermissionRequested(self: *@This(), handler: *TypedEventHandler(WebView,WebViewPermissionRequestedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IWebView4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addPermissionRequested(handler);
    }
    pub fn removePermissionRequested(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IWebView4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removePermissionRequested(token);
    }
    pub fn AddWebAllowedObject(self: *@This(), name: HSTRING, pObject: *IInspectable) core.HResult!void {
        var this: ?*IWebView4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.AddWebAllowedObject(name, pObject);
    }
    pub fn DeferredPermissionRequestById(self: *@This(), id: u32) core.HResult!*WebViewDeferredPermissionRequest {
        var this: ?*IWebView4 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView4.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.DeferredPermissionRequestById(id);
    }
    pub fn getXYFocusLeft(self: *@This()) core.HResult!*DependencyObject {
        var this: ?*IWebView5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getXYFocusLeft();
    }
    pub fn putXYFocusLeft(self: *@This(), value: *DependencyObject) core.HResult!void {
        var this: ?*IWebView5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putXYFocusLeft(value);
    }
    pub fn getXYFocusRight(self: *@This()) core.HResult!*DependencyObject {
        var this: ?*IWebView5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getXYFocusRight();
    }
    pub fn putXYFocusRight(self: *@This(), value: *DependencyObject) core.HResult!void {
        var this: ?*IWebView5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putXYFocusRight(value);
    }
    pub fn getXYFocusUp(self: *@This()) core.HResult!*DependencyObject {
        var this: ?*IWebView5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getXYFocusUp();
    }
    pub fn putXYFocusUp(self: *@This(), value: *DependencyObject) core.HResult!void {
        var this: ?*IWebView5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putXYFocusUp(value);
    }
    pub fn getXYFocusDown(self: *@This()) core.HResult!*DependencyObject {
        var this: ?*IWebView5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getXYFocusDown();
    }
    pub fn putXYFocusDown(self: *@This(), value: *DependencyObject) core.HResult!void {
        var this: ?*IWebView5 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView5.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.putXYFocusDown(value);
    }
    pub fn addSeparateProcessLost(self: *@This(), handler: *TypedEventHandler(WebView,WebViewSeparateProcessLostEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IWebView6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addSeparateProcessLost(handler);
    }
    pub fn removeSeparateProcessLost(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IWebView6 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView6.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeSeparateProcessLost(token);
    }
    pub fn addWebResourceRequested(self: *@This(), handler: *TypedEventHandler(WebView,WebViewWebResourceRequestedEventArgs)) core.HResult!EventRegistrationToken {
        var this: ?*IWebView7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.addWebResourceRequested(handler);
    }
    pub fn removeWebResourceRequested(self: *@This(), token: EventRegistrationToken) core.HResult!void {
        var this: ?*IWebView7 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebView7.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.removeWebResourceRequested(token);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IWebView.IID)));
    }
    pub fn CreateInstanceWithExecutionMode(executionMode: WebViewExecutionMode) core.HResult!*WebView {
        const _f = @This().IWebViewFactory4Cache.get();
        return try _f.CreateInstanceWithExecutionMode(executionMode);
    }
    pub fn getDefaultExecutionMode() core.HResult!WebViewExecutionMode {
        const _f = @This().IWebViewStatics4Cache.get();
        return try _f.getDefaultExecutionMode();
    }
    pub fn ClearTemporaryWebDataAsync() core.HResult!*IAsyncAction {
        const _f = @This().IWebViewStatics4Cache.get();
        return try _f.ClearTemporaryWebDataAsync();
    }
    pub fn getCanGoBackProperty() core.HResult!*DependencyProperty {
        const _f = @This().IWebViewStatics2Cache.get();
        return try _f.getCanGoBackProperty();
    }
    pub fn getCanGoForwardProperty() core.HResult!*DependencyProperty {
        const _f = @This().IWebViewStatics2Cache.get();
        return try _f.getCanGoForwardProperty();
    }
    pub fn getDocumentTitleProperty() core.HResult!*DependencyProperty {
        const _f = @This().IWebViewStatics2Cache.get();
        return try _f.getDocumentTitleProperty();
    }
    pub fn getDefaultBackgroundColorProperty() core.HResult!*DependencyProperty {
        const _f = @This().IWebViewStatics2Cache.get();
        return try _f.getDefaultBackgroundColorProperty();
    }
    pub fn getContainsFullScreenElementProperty() core.HResult!*DependencyProperty {
        const _f = @This().IWebViewStatics3Cache.get();
        return try _f.getContainsFullScreenElementProperty();
    }
    pub fn getXYFocusLeftProperty() core.HResult!*DependencyProperty {
        const _f = @This().IWebViewStatics5Cache.get();
        return try _f.getXYFocusLeftProperty();
    }
    pub fn getXYFocusRightProperty() core.HResult!*DependencyProperty {
        const _f = @This().IWebViewStatics5Cache.get();
        return try _f.getXYFocusRightProperty();
    }
    pub fn getXYFocusUpProperty() core.HResult!*DependencyProperty {
        const _f = @This().IWebViewStatics5Cache.get();
        return try _f.getXYFocusUpProperty();
    }
    pub fn getXYFocusDownProperty() core.HResult!*DependencyProperty {
        const _f = @This().IWebViewStatics5Cache.get();
        return try _f.getXYFocusDownProperty();
    }
    pub fn getAnyScriptNotifyUri() core.HResult!*IVector(Uri) {
        const _f = @This().IWebViewStaticsCache.get();
        return try _f.getAnyScriptNotifyUri();
    }
    pub fn getSourceProperty() core.HResult!*DependencyProperty {
        const _f = @This().IWebViewStaticsCache.get();
        return try _f.getSourceProperty();
    }
    pub fn getAllowedScriptNotifyUrisProperty() core.HResult!*DependencyProperty {
        const _f = @This().IWebViewStaticsCache.get();
        return try _f.getAllowedScriptNotifyUrisProperty();
    }
    pub fn getDataTransferPackageProperty() core.HResult!*DependencyProperty {
        const _f = @This().IWebViewStaticsCache.get();
        return try _f.getDataTransferPackageProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.WebView";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IWebView.GUID;
    pub const IID: Guid = IWebView.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IWebView.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IWebViewFactory4Cache: FactoryCache(IWebViewFactory4, RUNTIME_NAME) = .{};
    var _IWebViewStatics4Cache: FactoryCache(IWebViewStatics4, RUNTIME_NAME) = .{};
    var _IWebViewStatics2Cache: FactoryCache(IWebViewStatics2, RUNTIME_NAME) = .{};
    var _IWebViewStatics3Cache: FactoryCache(IWebViewStatics3, RUNTIME_NAME) = .{};
    var _IWebViewStatics5Cache: FactoryCache(IWebViewStatics5, RUNTIME_NAME) = .{};
    var _IWebViewStaticsCache: FactoryCache(IWebViewStatics, RUNTIME_NAME) = .{};
};
pub const WebViewBrush = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getSourceName(self: *@This()) core.HResult!HSTRING {
        const this: *IWebViewBrush = @ptrCast(self);
        return try this.getSourceName();
    }
    pub fn putSourceName(self: *@This(), value: HSTRING) core.HResult!void {
        const this: *IWebViewBrush = @ptrCast(self);
        return try this.putSourceName(value);
    }
    pub fn Redraw(self: *@This()) core.HResult!void {
        const this: *IWebViewBrush = @ptrCast(self);
        return try this.Redraw();
    }
    pub fn SetSource(self: *@This(), source: *WebView) core.HResult!void {
        const this: *IWebViewBrush = @ptrCast(self);
        return try this.SetSource(source);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IWebViewBrush.IID)));
    }
    pub fn getSourceNameProperty() core.HResult!*DependencyProperty {
        const _f = @This().IWebViewBrushStaticsCache.get();
        return try _f.getSourceNameProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.WebViewBrush";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IWebViewBrush.GUID;
    pub const IID: Guid = IWebViewBrush.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IWebViewBrush.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IWebViewBrushStaticsCache: FactoryCache(IWebViewBrushStatics, RUNTIME_NAME) = .{};
};
pub const WebViewContentLoadingEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getUri(self: *@This()) core.HResult!*Uri {
        const this: *IWebViewContentLoadingEventArgs = @ptrCast(self);
        return try this.getUri();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.WebViewContentLoadingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IWebViewContentLoadingEventArgs.GUID;
    pub const IID: Guid = IWebViewContentLoadingEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IWebViewContentLoadingEventArgs.SIGNATURE);
};
pub const WebViewDOMContentLoadedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getUri(self: *@This()) core.HResult!*Uri {
        const this: *IWebViewDOMContentLoadedEventArgs = @ptrCast(self);
        return try this.getUri();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.WebViewDOMContentLoadedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IWebViewDOMContentLoadedEventArgs.GUID;
    pub const IID: Guid = IWebViewDOMContentLoadedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IWebViewDOMContentLoadedEventArgs.SIGNATURE);
};
pub const WebViewDeferredPermissionRequest = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getUri(self: *@This()) core.HResult!*Uri {
        const this: *IWebViewDeferredPermissionRequest = @ptrCast(self);
        return try this.getUri();
    }
    pub fn getPermissionType(self: *@This()) core.HResult!WebViewPermissionType {
        const this: *IWebViewDeferredPermissionRequest = @ptrCast(self);
        return try this.getPermissionType();
    }
    pub fn getId(self: *@This()) core.HResult!u32 {
        const this: *IWebViewDeferredPermissionRequest = @ptrCast(self);
        return try this.getId();
    }
    pub fn Allow(self: *@This()) core.HResult!void {
        const this: *IWebViewDeferredPermissionRequest = @ptrCast(self);
        return try this.Allow();
    }
    pub fn Deny(self: *@This()) core.HResult!void {
        const this: *IWebViewDeferredPermissionRequest = @ptrCast(self);
        return try this.Deny();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.WebViewDeferredPermissionRequest";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IWebViewDeferredPermissionRequest.GUID;
    pub const IID: Guid = IWebViewDeferredPermissionRequest.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IWebViewDeferredPermissionRequest.SIGNATURE);
};
pub const WebViewExecutionMode = enum(i32) {
    SameThread = 0,
    SeparateThread = 1,
    SeparateProcess = 2,
};
pub const WebViewLongRunningScriptDetectedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getExecutionTime(self: *@This()) core.HResult!TimeSpan {
        const this: *IWebViewLongRunningScriptDetectedEventArgs = @ptrCast(self);
        return try this.getExecutionTime();
    }
    pub fn getStopPageScriptExecution(self: *@This()) core.HResult!bool {
        const this: *IWebViewLongRunningScriptDetectedEventArgs = @ptrCast(self);
        return try this.getStopPageScriptExecution();
    }
    pub fn putStopPageScriptExecution(self: *@This(), value: bool) core.HResult!void {
        const this: *IWebViewLongRunningScriptDetectedEventArgs = @ptrCast(self);
        return try this.putStopPageScriptExecution(value);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.WebViewLongRunningScriptDetectedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IWebViewLongRunningScriptDetectedEventArgs.GUID;
    pub const IID: Guid = IWebViewLongRunningScriptDetectedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IWebViewLongRunningScriptDetectedEventArgs.SIGNATURE);
};
pub const WebViewNavigationCompletedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getUri(self: *@This()) core.HResult!*Uri {
        const this: *IWebViewNavigationCompletedEventArgs = @ptrCast(self);
        return try this.getUri();
    }
    pub fn getIsSuccess(self: *@This()) core.HResult!bool {
        const this: *IWebViewNavigationCompletedEventArgs = @ptrCast(self);
        return try this.getIsSuccess();
    }
    pub fn getWebErrorStatus(self: *@This()) core.HResult!WebErrorStatus {
        const this: *IWebViewNavigationCompletedEventArgs = @ptrCast(self);
        return try this.getWebErrorStatus();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.WebViewNavigationCompletedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IWebViewNavigationCompletedEventArgs.GUID;
    pub const IID: Guid = IWebViewNavigationCompletedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IWebViewNavigationCompletedEventArgs.SIGNATURE);
};
pub const WebViewNavigationFailedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getUri(self: *@This()) core.HResult!*Uri {
        const this: *IWebViewNavigationFailedEventArgs = @ptrCast(self);
        return try this.getUri();
    }
    pub fn getWebErrorStatus(self: *@This()) core.HResult!WebErrorStatus {
        const this: *IWebViewNavigationFailedEventArgs = @ptrCast(self);
        return try this.getWebErrorStatus();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.WebViewNavigationFailedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IWebViewNavigationFailedEventArgs.GUID;
    pub const IID: Guid = IWebViewNavigationFailedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IWebViewNavigationFailedEventArgs.SIGNATURE);
};
pub const WebViewNavigationFailedEventHandler = extern struct {
    vtable: *const VTable,
    _refs: @import("std").atomic.Value(u32),
    _cb: *const fn (context: ?*anyopaque) callconv(.winapi) void,
    _context: ?*anyopaque = null,
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn init(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *WebViewNavigationFailedEventArgs) callconv(.winapi) void,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
        };
        return _r;
    }
    /// This creates a heap allocated instance that only frees/destroys when all
    /// references are released including any references Windows makes.
    pub fn initWithState(
        cb: *const fn(?*anyopaque, sender: *IInspectable, e: *WebViewNavigationFailedEventArgs) callconv(.winapi) void,
        context: anytype,
    ) !*@This() {
        const _r = try @import("std").heap.c_allocator.create(@This());
        _r.* = .{
            .vtable = &VTABLE,
            ._cb = cb,
            ._refs = .init(1),
            ._context = @ptrCast(context),
        };
        return _r;
    }
    /// This calls Release and voids the returned ref count. If ref count is 0 the memory is released,
    /// Otherwise the memory stays until all references are released, including all references Windows holds.
    ///
    /// The caller *MUST* always call deinit/Release at least once for every AddRef and init called.
    pub fn deinit(self: *@This()) void {
        _ = Release(@ptrCast(self));
    }
    fn QueryInterface(self: *anyopaque, riid: *const Guid, out: *?*anyopaque) callconv(.c) HRESULT {
        const me: *@This() = @ptrCast(@alignCast(self));
        // TODO: Handle IMarshal
        if (core.wiredGuidEql(riid, &IID) or
            core.wiredGuidEql(riid, &IUnknown.IID) or
            core.wiredGuidEql(riid, &IAgileObject.IID))
        {
            out.* = @as(?*anyopaque, @ptrCast(me));
            _ = AddRef(self);
            return 0;
        }
        out.* = null;
        return -2147467262; // E_NOINTERFACE
    }
    fn AddRef(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        return this._refs.fetchAdd(1, .monotonic) + 1;
    }
    fn Release(self: *anyopaque) callconv(.c) u32 {
        const this: *@This() = @ptrCast(@alignCast(self));
        const left = this._refs.fetchSub(1, .acq_rel) - 1;
        if (left == 0) @import("std").heap.c_allocator.destroy(this);
        return left;
    }
    pub fn Invoke(self: *anyopaque, sender: *IInspectable, e: *WebViewNavigationFailedEventArgs) callconv(.winapi) HRESULT {
        const this: *@This() = @ptrCast(@alignCast(self));
        this._cb(this._context, sender, e);
        return 0;
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.WebViewNavigationFailedEventHandler";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = "a31eafe1-41dc-47f8-ae22-9706c8f143d4";
    pub const IID: Guid = Guid.initString(GUID);
    pub const SIGNATURE: []const u8 = core.Signature.pinterface(GUID);
    pub const VTable = extern struct {
        QueryInterface: *const fn(self: *anyopaque, riid: *const Guid, ppvObject: *?*anyopaque) callconv(.winapi) HRESULT,
        AddRef: *const fn(self: *anyopaque) callconv(.winapi) u32,
        Release: *const fn(self: *anyopaque,) callconv(.winapi) u32,
        Invoke: *const fn(self: *anyopaque, sender: *IInspectable, e: *WebViewNavigationFailedEventArgs) callconv(.winapi) HRESULT
    };
    pub const VTABLE = VTable {
        .QueryInterface = QueryInterface,
        .AddRef = AddRef,
        .Release = Release,
        .Invoke = Invoke,
    };
};
pub const WebViewNavigationStartingEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getUri(self: *@This()) core.HResult!*Uri {
        const this: *IWebViewNavigationStartingEventArgs = @ptrCast(self);
        return try this.getUri();
    }
    pub fn getCancel(self: *@This()) core.HResult!bool {
        const this: *IWebViewNavigationStartingEventArgs = @ptrCast(self);
        return try this.getCancel();
    }
    pub fn putCancel(self: *@This(), value: bool) core.HResult!void {
        const this: *IWebViewNavigationStartingEventArgs = @ptrCast(self);
        return try this.putCancel(value);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.WebViewNavigationStartingEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IWebViewNavigationStartingEventArgs.GUID;
    pub const IID: Guid = IWebViewNavigationStartingEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IWebViewNavigationStartingEventArgs.SIGNATURE);
};
pub const WebViewNewWindowRequestedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getUri(self: *@This()) core.HResult!*Uri {
        const this: *IWebViewNewWindowRequestedEventArgs = @ptrCast(self);
        return try this.getUri();
    }
    pub fn getReferrer(self: *@This()) core.HResult!*Uri {
        const this: *IWebViewNewWindowRequestedEventArgs = @ptrCast(self);
        return try this.getReferrer();
    }
    pub fn getHandled(self: *@This()) core.HResult!bool {
        const this: *IWebViewNewWindowRequestedEventArgs = @ptrCast(self);
        return try this.getHandled();
    }
    pub fn putHandled(self: *@This(), value: bool) core.HResult!void {
        const this: *IWebViewNewWindowRequestedEventArgs = @ptrCast(self);
        return try this.putHandled(value);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.WebViewNewWindowRequestedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IWebViewNewWindowRequestedEventArgs.GUID;
    pub const IID: Guid = IWebViewNewWindowRequestedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IWebViewNewWindowRequestedEventArgs.SIGNATURE);
};
pub const WebViewPermissionRequest = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getUri(self: *@This()) core.HResult!*Uri {
        const this: *IWebViewPermissionRequest = @ptrCast(self);
        return try this.getUri();
    }
    pub fn getPermissionType(self: *@This()) core.HResult!WebViewPermissionType {
        const this: *IWebViewPermissionRequest = @ptrCast(self);
        return try this.getPermissionType();
    }
    pub fn getId(self: *@This()) core.HResult!u32 {
        const this: *IWebViewPermissionRequest = @ptrCast(self);
        return try this.getId();
    }
    pub fn getState(self: *@This()) core.HResult!WebViewPermissionState {
        const this: *IWebViewPermissionRequest = @ptrCast(self);
        return try this.getState();
    }
    pub fn Defer(self: *@This()) core.HResult!void {
        const this: *IWebViewPermissionRequest = @ptrCast(self);
        return try this.Defer();
    }
    pub fn Allow(self: *@This()) core.HResult!void {
        const this: *IWebViewPermissionRequest = @ptrCast(self);
        return try this.Allow();
    }
    pub fn Deny(self: *@This()) core.HResult!void {
        const this: *IWebViewPermissionRequest = @ptrCast(self);
        return try this.Deny();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.WebViewPermissionRequest";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IWebViewPermissionRequest.GUID;
    pub const IID: Guid = IWebViewPermissionRequest.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IWebViewPermissionRequest.SIGNATURE);
};
pub const WebViewPermissionRequestedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getPermissionRequest(self: *@This()) core.HResult!*WebViewPermissionRequest {
        const this: *IWebViewPermissionRequestedEventArgs = @ptrCast(self);
        return try this.getPermissionRequest();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.WebViewPermissionRequestedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IWebViewPermissionRequestedEventArgs.GUID;
    pub const IID: Guid = IWebViewPermissionRequestedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IWebViewPermissionRequestedEventArgs.SIGNATURE);
};
pub const WebViewPermissionState = enum(i32) {
    Unknown = 0,
    Defer = 1,
    Allow = 2,
    Deny = 3,
};
pub const WebViewPermissionType = enum(i32) {
    Geolocation = 0,
    UnlimitedIndexedDBQuota = 1,
    Media = 2,
    PointerLock = 3,
    WebNotifications = 4,
    Screen = 5,
    ImmersiveView = 6,
};
pub const WebViewSeparateProcessLostEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.WebViewSeparateProcessLostEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IWebViewSeparateProcessLostEventArgs.GUID;
    pub const IID: Guid = IWebViewSeparateProcessLostEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IWebViewSeparateProcessLostEventArgs.SIGNATURE);
};
pub const WebViewSettings = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getIsJavaScriptEnabled(self: *@This()) core.HResult!bool {
        const this: *IWebViewSettings = @ptrCast(self);
        return try this.getIsJavaScriptEnabled();
    }
    pub fn putIsJavaScriptEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IWebViewSettings = @ptrCast(self);
        return try this.putIsJavaScriptEnabled(value);
    }
    pub fn getIsIndexedDBEnabled(self: *@This()) core.HResult!bool {
        const this: *IWebViewSettings = @ptrCast(self);
        return try this.getIsIndexedDBEnabled();
    }
    pub fn putIsIndexedDBEnabled(self: *@This(), value: bool) core.HResult!void {
        const this: *IWebViewSettings = @ptrCast(self);
        return try this.putIsIndexedDBEnabled(value);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.WebViewSettings";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IWebViewSettings.GUID;
    pub const IID: Guid = IWebViewSettings.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IWebViewSettings.SIGNATURE);
};
pub const WebViewUnsupportedUriSchemeIdentifiedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getUri(self: *@This()) core.HResult!*Uri {
        const this: *IWebViewUnsupportedUriSchemeIdentifiedEventArgs = @ptrCast(self);
        return try this.getUri();
    }
    pub fn getHandled(self: *@This()) core.HResult!bool {
        const this: *IWebViewUnsupportedUriSchemeIdentifiedEventArgs = @ptrCast(self);
        return try this.getHandled();
    }
    pub fn putHandled(self: *@This(), value: bool) core.HResult!void {
        const this: *IWebViewUnsupportedUriSchemeIdentifiedEventArgs = @ptrCast(self);
        return try this.putHandled(value);
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.WebViewUnsupportedUriSchemeIdentifiedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IWebViewUnsupportedUriSchemeIdentifiedEventArgs.GUID;
    pub const IID: Guid = IWebViewUnsupportedUriSchemeIdentifiedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IWebViewUnsupportedUriSchemeIdentifiedEventArgs.SIGNATURE);
};
pub const WebViewUnviewableContentIdentifiedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getUri(self: *@This()) core.HResult!*Uri {
        const this: *IWebViewUnviewableContentIdentifiedEventArgs = @ptrCast(self);
        return try this.getUri();
    }
    pub fn getReferrer(self: *@This()) core.HResult!*Uri {
        const this: *IWebViewUnviewableContentIdentifiedEventArgs = @ptrCast(self);
        return try this.getReferrer();
    }
    pub fn getMediaType(self: *@This()) core.HResult!HSTRING {
        var this: ?*IWebViewUnviewableContentIdentifiedEventArgs2 = undefined;
        const _c = IUnknown.QueryInterface(@ptrCast(self), &IWebViewUnviewableContentIdentifiedEventArgs2.IID, @ptrCast(&this));
        if (this == null or _c != 0) return core.hresultToError(_c).err;
        return try this.?.getMediaType();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.WebViewUnviewableContentIdentifiedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IWebViewUnviewableContentIdentifiedEventArgs.GUID;
    pub const IID: Guid = IWebViewUnviewableContentIdentifiedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IWebViewUnviewableContentIdentifiedEventArgs.SIGNATURE);
};
pub const WebViewWebResourceRequestedEventArgs = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getRequest(self: *@This()) core.HResult!*HttpRequestMessage {
        const this: *IWebViewWebResourceRequestedEventArgs = @ptrCast(self);
        return try this.getRequest();
    }
    pub fn getResponse(self: *@This()) core.HResult!*HttpResponseMessage {
        const this: *IWebViewWebResourceRequestedEventArgs = @ptrCast(self);
        return try this.getResponse();
    }
    pub fn putResponse(self: *@This(), value: *HttpResponseMessage) core.HResult!void {
        const this: *IWebViewWebResourceRequestedEventArgs = @ptrCast(self);
        return try this.putResponse(value);
    }
    pub fn GetDeferral(self: *@This()) core.HResult!*Deferral {
        const this: *IWebViewWebResourceRequestedEventArgs = @ptrCast(self);
        return try this.GetDeferral();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.WebViewWebResourceRequestedEventArgs";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IWebViewWebResourceRequestedEventArgs.GUID;
    pub const IID: Guid = IWebViewWebResourceRequestedEventArgs.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IWebViewWebResourceRequestedEventArgs.SIGNATURE);
};
pub const WrapGrid = extern struct {
    vtable: *const IInspectable.VTable,
    pub fn getItemWidth(self: *@This()) core.HResult!f64 {
        const this: *IWrapGrid = @ptrCast(self);
        return try this.getItemWidth();
    }
    pub fn putItemWidth(self: *@This(), value: f64) core.HResult!void {
        const this: *IWrapGrid = @ptrCast(self);
        return try this.putItemWidth(value);
    }
    pub fn getItemHeight(self: *@This()) core.HResult!f64 {
        const this: *IWrapGrid = @ptrCast(self);
        return try this.getItemHeight();
    }
    pub fn putItemHeight(self: *@This(), value: f64) core.HResult!void {
        const this: *IWrapGrid = @ptrCast(self);
        return try this.putItemHeight(value);
    }
    pub fn getOrientation(self: *@This()) core.HResult!Orientation {
        const this: *IWrapGrid = @ptrCast(self);
        return try this.getOrientation();
    }
    pub fn putOrientation(self: *@This(), value: Orientation) core.HResult!void {
        const this: *IWrapGrid = @ptrCast(self);
        return try this.putOrientation(value);
    }
    pub fn getHorizontalChildrenAlignment(self: *@This()) core.HResult!HorizontalAlignment {
        const this: *IWrapGrid = @ptrCast(self);
        return try this.getHorizontalChildrenAlignment();
    }
    pub fn putHorizontalChildrenAlignment(self: *@This(), value: HorizontalAlignment) core.HResult!void {
        const this: *IWrapGrid = @ptrCast(self);
        return try this.putHorizontalChildrenAlignment(value);
    }
    pub fn getVerticalChildrenAlignment(self: *@This()) core.HResult!VerticalAlignment {
        const this: *IWrapGrid = @ptrCast(self);
        return try this.getVerticalChildrenAlignment();
    }
    pub fn putVerticalChildrenAlignment(self: *@This(), value: VerticalAlignment) core.HResult!void {
        const this: *IWrapGrid = @ptrCast(self);
        return try this.putVerticalChildrenAlignment(value);
    }
    pub fn getMaximumRowsOrColumns(self: *@This()) core.HResult!i32 {
        const this: *IWrapGrid = @ptrCast(self);
        return try this.getMaximumRowsOrColumns();
    }
    pub fn putMaximumRowsOrColumns(self: *@This(), value: i32) core.HResult!void {
        const this: *IWrapGrid = @ptrCast(self);
        return try this.putMaximumRowsOrColumns(value);
    }
    pub fn deinit(self: *@This()) void {
        _ = IUnknown.Release(@ptrCast(self));
    }
    pub fn init() core.HResult!*@This() {
        const _f = try @This()._IActivationFactoryCache.get();
        return @ptrCast(@alignCast(try _f.ActivateInstance(&IWrapGrid.IID)));
    }
    pub fn getItemWidthProperty() core.HResult!*DependencyProperty {
        const _f = @This().IWrapGridStaticsCache.get();
        return try _f.getItemWidthProperty();
    }
    pub fn getItemHeightProperty() core.HResult!*DependencyProperty {
        const _f = @This().IWrapGridStaticsCache.get();
        return try _f.getItemHeightProperty();
    }
    pub fn getOrientationProperty() core.HResult!*DependencyProperty {
        const _f = @This().IWrapGridStaticsCache.get();
        return try _f.getOrientationProperty();
    }
    pub fn getHorizontalChildrenAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IWrapGridStaticsCache.get();
        return try _f.getHorizontalChildrenAlignmentProperty();
    }
    pub fn getVerticalChildrenAlignmentProperty() core.HResult!*DependencyProperty {
        const _f = @This().IWrapGridStaticsCache.get();
        return try _f.getVerticalChildrenAlignmentProperty();
    }
    pub fn getMaximumRowsOrColumnsProperty() core.HResult!*DependencyProperty {
        const _f = @This().IWrapGridStaticsCache.get();
        return try _f.getMaximumRowsOrColumnsProperty();
    }
    pub const NAME: []const u8 = "Windows.UI.Xaml.Controls.WrapGrid";
    pub const RUNTIME_NAME: [:0]const u16 = @import("std").unicode.utf8ToUtf16LeStringLiteral(NAME);
    pub const GUID: []const u8 = IWrapGrid.GUID;
    pub const IID: Guid = IWrapGrid.IID;
    pub const SIGNATURE: []const u8 = core.Signature.class(NAME, IWrapGrid.SIGNATURE);
    var _IActivationFactoryCache: FactoryCache(IActivationFactory, RUNTIME_NAME) = .{};
    var _IWrapGridStaticsCache: FactoryCache(IWrapGridStatics, RUNTIME_NAME) = .{};
};
pub const ZoomMode = enum(i32) {
    Disabled = 0,
    Enabled = 1,
};
const AudioCategory = @import("./Media.zig").AudioCategory;
const AppBarButtonTemplateSettings = @import("./Controls/Primitives.zig").AppBarButtonTemplateSettings;
const CalendarViewTemplateSettings = @import("./Controls/Primitives.zig").CalendarViewTemplateSettings;
const TextTrimming = @import("../Xaml.zig").TextTrimming;
const IIterable = @import("../../Foundation/Collections.zig").IIterable;
const ItemsChangedEventHandler = @import("./Controls/Primitives.zig").ItemsChangedEventHandler;
const CornerRadius = @import("../Xaml.zig").CornerRadius;
const IReference = @import("../../Foundation.zig").IReference;
const Stereo3DVideoRenderMode = @import("./Media.zig").Stereo3DVideoRenderMode;
const TextAlignment = @import("../Xaml.zig").TextAlignment;
const InputScope = @import("./Input.zig").InputScope;
const BrushTransition = @import("../Xaml.zig").BrushTransition;
const SplitViewTemplateSettings = @import("./Controls/Primitives.zig").SplitViewTemplateSettings;
const TrustLevel = @import("../../root.zig").TrustLevel;
const MenuFlyoutPresenterTemplateSettings = @import("./Controls/Primitives.zig").MenuFlyoutPresenterTemplateSettings;
const FastPlayFallbackBehaviour = @import("./Media.zig").FastPlayFallbackBehaviour;
const GroupHeaderPlacement = @import("./Controls/Primitives.zig").GroupHeaderPlacement;
const IPropertySet = @import("../../Foundation/Collections.zig").IPropertySet;
const NavigationStoppedEventHandler = @import("./Navigation.zig").NavigationStoppedEventHandler;
const LineStackingStrategy = @import("../Xaml.zig").LineStackingStrategy;
const Style = @import("../Xaml.zig").Style;
const DependencyProperty = @import("../Xaml.zig").DependencyProperty;
const PageStackEntry = @import("./Navigation.zig").PageStackEntry;
const MenuFlyoutItemTemplateSettings = @import("./Controls/Primitives.zig").MenuFlyoutItemTemplateSettings;
const ToggleState = @import("./Automation.zig").ToggleState;
const InlineCollection = @import("./Documents.zig").InlineCollection;
const MediaPlayer = @import("../../Media/Playback.zig").MediaPlayer;
const Stereo3DVideoPackingMode = @import("./Media.zig").Stereo3DVideoPackingMode;
const Brush = @import("./Media.zig").Brush;
const ElementFactoryGetArgs = @import("../Xaml.zig").ElementFactoryGetArgs;
const LoadCompletedEventHandler = @import("./Navigation.zig").LoadCompletedEventHandler;
const GeneratorPosition = @import("./Controls/Primitives.zig").GeneratorPosition;
const ManipulationStartedRoutedEventArgs = @import("./Input.zig").ManipulationStartedRoutedEventArgs;
const IIterator = @import("../../Foundation/Collections.zig").IIterator;
const WebErrorStatus = @import("../../Web.zig").WebErrorStatus;
const AudioDeviceType = @import("./Media.zig").AudioDeviceType;
const VectorChangedEventHandler = @import("../../Foundation/Collections.zig").VectorChangedEventHandler;
const FontWeight = @import("../Text.zig").FontWeight;
const GridLength = @import("../Xaml.zig").GridLength;
const INotifyPropertyChanged = @import("./Data.zig").INotifyPropertyChanged;
const CastingSource = @import("../../Media/Casting.zig").CastingSource;
const FontFamily = @import("./Media.zig").FontFamily;
const FlyoutBase = @import("./Controls/Primitives.zig").FlyoutBase;
const RateChangedRoutedEventHandler = @import("./Media.zig").RateChangedRoutedEventHandler;
const PropertyChangedEventHandler = @import("./Data.zig").PropertyChangedEventHandler;
const TextDecorations = @import("../Text.zig").TextDecorations;
const Duration = @import("../Xaml.zig").Duration;
const IMediaPlaybackSource = @import("../../Media/Playback.zig").IMediaPlaybackSource;
const IUriToStreamResolver = @import("../../Web.zig").IUriToStreamResolver;
const LoadMoreItemsResult = @import("./Data.zig").LoadMoreItemsResult;
const DependencyObjectCollection = @import("../Xaml.zig").DependencyObjectCollection;
const EventRegistrationToken = @import("../../Foundation.zig").EventRegistrationToken;
const Stretch = @import("./Media.zig").Stretch;
const TickPlacement = @import("./Controls/Primitives.zig").TickPlacement;
const LocalContentSuggestionSettings = @import("../../ApplicationModel/Search.zig").LocalContentSuggestionSettings;
const ItemsChangedEventArgs = @import("./Controls/Primitives.zig").ItemsChangedEventArgs;
const ProgressRingTemplateSettings = @import("./Controls/Primitives.zig").ProgressRingTemplateSettings;
const Rect = @import("../../Foundation.zig").Rect;
const InkPresenter = @import("../Input/Inking.zig").InkPresenter;
const ConnectedAnimation = @import("./Media/Animation.zig").ConnectedAnimation;
const TimelineMarkerCollection = @import("./Media.zig").TimelineMarkerCollection;
const FocusState = @import("../Xaml.zig").FocusState;
const Contact = @import("../../ApplicationModel/Contacts.zig").Contact;
const ContentLinkInvokedEventArgs = @import("./Documents.zig").ContentLinkInvokedEventArgs;
const RoutedEventHandler = @import("../Xaml.zig").RoutedEventHandler;
const HttpRequestMessage = @import("../../Web/Http.zig").HttpRequestMessage;
const Guid = @import("../../root.zig").Guid;
const CompositionBrush = @import("../Composition.zig").CompositionBrush;
const IVector = @import("../../Foundation/Collections.zig").IVector;
const ManipulationCompletedRoutedEventArgs = @import("./Input.zig").ManipulationCompletedRoutedEventArgs;
const CharacterReceivedRoutedEventArgs = @import("./Input.zig").CharacterReceivedRoutedEventArgs;
const ComboBoxTemplateSettings = @import("./Controls/Primitives.zig").ComboBoxTemplateSettings;
const DependencyObject = @import("../Xaml.zig").DependencyObject;
const HttpResponseMessage = @import("../../Web/Http.zig").HttpResponseMessage;
const FrameNavigationOptions = @import("./Navigation.zig").FrameNavigationOptions;
const TypeName = @import("./Interop.zig").TypeName;
const RoutedEventArgs = @import("../Xaml.zig").RoutedEventArgs;
const HRESULT = @import("../../root.zig").HRESULT;
const TextHighlighter = @import("./Documents.zig").TextHighlighter;
const AppBarTemplateSettings = @import("./Controls/Primitives.zig").AppBarTemplateSettings;
const TextPointer = @import("./Documents.zig").TextPointer;
const DateTime = @import("../../Foundation.zig").DateTime;
const DoubleTappedRoutedEventArgs = @import("./Input.zig").DoubleTappedRoutedEventArgs;
const GridViewItemTemplateSettings = @import("./Controls/Primitives.zig").GridViewItemTemplateSettings;
const ElementFactoryRecycleArgs = @import("../Xaml.zig").ElementFactoryRecycleArgs;
const NavigatingCancelEventHandler = @import("./Navigation.zig").NavigatingCancelEventHandler;
const SearchSuggestionsRequest = @import("../../ApplicationModel/Search.zig").SearchSuggestionsRequest;
const FrameworkElement = @import("../Xaml.zig").FrameworkElement;
const PlayToSource = @import("../../Media/PlayTo.zig").PlayToSource;
const EventHandler = @import("../../Foundation.zig").EventHandler;
const VirtualKeyModifiers = @import("../../System.zig").VirtualKeyModifiers;
const SliderSnapsTo = @import("./Controls/Primitives.zig").SliderSnapsTo;
const SelectorItem = @import("./Controls/Primitives.zig").SelectorItem;
const MediaTransportControlsThumbnailRequestedEventArgs = @import("./Media.zig").MediaTransportControlsThumbnailRequestedEventArgs;
const TextWrapping = @import("../Xaml.zig").TextWrapping;
const IUnknown = @import("../../root.zig").IUnknown;
const IActivationFactory = @import("../../Foundation.zig").IActivationFactory;
const ItemIndexRange = @import("./Data.zig").ItemIndexRange;
const HorizontalAlignment = @import("../Xaml.zig").HorizontalAlignment;
const TimelineMarkerRoutedEventHandler = @import("./Media.zig").TimelineMarkerRoutedEventHandler;
const IInspectable = @import("../../Foundation.zig").IInspectable;
const IExpandCollapseProvider = @import("./Automation/Provider.zig").IExpandCollapseProvider;
const ContentLinkProviderCollection = @import("./Documents.zig").ContentLinkProviderCollection;
const ManipulationStartingRoutedEventArgs = @import("./Input.zig").ManipulationStartingRoutedEventArgs;
const UIElement = @import("../Xaml.zig").UIElement;
const ICustomPropertyProvider = @import("./Data.zig").ICustomPropertyProvider;
const ToolTipTemplateSettings = @import("./Controls/Primitives.zig").ToolTipTemplateSettings;
const KeyRoutedEventArgs = @import("./Input.zig").KeyRoutedEventArgs;
const NavigatingCancelEventArgs = @import("./Navigation.zig").NavigatingCancelEventArgs;
const FontStyle = @import("../Text.zig").FontStyle;
const ContentLinkInfo = @import("../Text.zig").ContentLinkInfo;
const ManipulationDeltaRoutedEventArgs = @import("./Input.zig").ManipulationDeltaRoutedEventArgs;
const IElementFactory = @import("../Xaml.zig").IElementFactory;
const TextRange = @import("./Documents.zig").TextRange;
const SnapPointsAlignment = @import("./Controls/Primitives.zig").SnapPointsAlignment;
const ImageSource = @import("./Media.zig").ImageSource;
const NavigationFailedEventHandler = @import("./Navigation.zig").NavigationFailedEventHandler;
const SettingsFlyoutTemplateSettings = @import("./Controls/Primitives.zig").SettingsFlyoutTemplateSettings;
const IAgileObject = @import("../../root.zig").IAgileObject;
const KeyboardNavigationMode = @import("./Input.zig").KeyboardNavigationMode;
const ICommand = @import("./Input.zig").ICommand;
const IMediaSource = @import("../../Media/Core.zig").IMediaSource;
const DataTemplate = @import("../Xaml.zig").DataTemplate;
const HoldingRoutedEventArgs = @import("./Input.zig").HoldingRoutedEventArgs;
const Deferral = @import("../../Foundation.zig").Deferral;
const TextLineBounds = @import("../Xaml.zig").TextLineBounds;
const VerticalAlignment = @import("../Xaml.zig").VerticalAlignment;
const BlockCollection = @import("./Documents.zig").BlockCollection;
const ICustomProperty = @import("./Data.zig").ICustomProperty;
const ToggleSwitchTemplateSettings = @import("./Controls/Primitives.zig").ToggleSwitchTemplateSettings;
const ElementSoundMode = @import("../Xaml.zig").ElementSoundMode;
const ExceptionRoutedEventHandler = @import("../Xaml.zig").ExceptionRoutedEventHandler;
const AppBarToggleButtonTemplateSettings = @import("./Controls/Primitives.zig").AppBarToggleButtonTemplateSettings;
const ITextDocument = @import("../Text.zig").ITextDocument;
const Geometry = @import("./Media.zig").Geometry;
const GeneratorDirection = @import("./Controls/Primitives.zig").GeneratorDirection;
const SearchQueryLinguisticDetails = @import("../../ApplicationModel/Search.zig").SearchQueryLinguisticDetails;
const PlacementMode = @import("./Controls/Primitives.zig").PlacementMode;
const IRandomAccessStream = @import("../../Storage/Streams.zig").IRandomAccessStream;
const CoreInputDeviceTypes = @import("../Core.zig").CoreInputDeviceTypes;
const RichEditTextDocument = @import("../Text.zig").RichEditTextDocument;
const TappedRoutedEventArgs = @import("./Input.zig").TappedRoutedEventArgs;
const Color = @import("../../UI.zig").Color;
const MediaElementState = @import("./Media.zig").MediaElementState;
const DataPackageOperation = @import("../../ApplicationModel/DataTransfer.zig").DataPackageOperation;
const CommandBarTemplateSettings = @import("./Controls/Primitives.zig").CommandBarTemplateSettings;
const InkPresenterProtractor = @import("../Input/Inking.zig").InkPresenterProtractor;
const IAsyncOperation = @import("../../Foundation.zig").IAsyncOperation;
const MediaCanPlayResponse = @import("./Media.zig").MediaCanPlayResponse;
const InkPresenterRuler = @import("../Input/Inking.zig").InkPresenterRuler;
const DependencyPropertyChangedEventHandler = @import("../Xaml.zig").DependencyPropertyChangedEventHandler;
const IInvokeProvider = @import("./Automation/Provider.zig").IInvokeProvider;
const DragEventArgs = @import("../Xaml.zig").DragEventArgs;
const ManipulationInertiaStartingRoutedEventArgs = @import("./Input.zig").ManipulationInertiaStartingRoutedEventArgs;
const NavigationCacheMode = @import("./Navigation.zig").NavigationCacheMode;
const Uri = @import("../../Foundation.zig").Uri;
const NavigationTransitionInfo = @import("./Media/Animation.zig").NavigationTransitionInfo;
const IAsyncAction = @import("../../Foundation.zig").IAsyncAction;
const IVectorView = @import("../../Foundation/Collections.zig").IVectorView;
const Point = @import("../../Foundation.zig").Point;
const NavigationEventArgs = @import("./Navigation.zig").NavigationEventArgs;
const FactoryCache = @import("../../core.zig").FactoryCache;
const ListViewItemTemplateSettings = @import("./Controls/Primitives.zig").ListViewItemTemplateSettings;
const CoreIndependentInputSource = @import("../Core.zig").CoreIndependentInputSource;
const PartialMediaFailureDetectedEventArgs = @import("./Media.zig").PartialMediaFailureDetectedEventArgs;
const TimeSpan = @import("../../Foundation.zig").TimeSpan;
const MediaProtectionManager = @import("../../Media/Protection.zig").MediaProtectionManager;
const ProgressBarTemplateSettings = @import("./Controls/Primitives.zig").ProgressBarTemplateSettings;
const OpticalMarginAlignment = @import("../Xaml.zig").OpticalMarginAlignment;
const IToggleProvider = @import("./Automation/Provider.zig").IToggleProvider;
const Thickness = @import("../Xaml.zig").Thickness;
const IObservableVector = @import("../../Foundation/Collections.zig").IObservableVector;
const RightTappedRoutedEventArgs = @import("./Input.zig").RightTappedRoutedEventArgs;
const SolidColorBrush = @import("./Media.zig").SolidColorBrush;
const TransitionCollection = @import("./Media/Animation.zig").TransitionCollection;
const NavigatedEventHandler = @import("./Navigation.zig").NavigatedEventHandler;
const TextReadingOrder = @import("../Xaml.zig").TextReadingOrder;
const PointerRoutedEventArgs = @import("./Input.zig").PointerRoutedEventArgs;
const ExpandCollapseState = @import("./Automation.zig").ExpandCollapseState;
const IValueConverter = @import("./Data.zig").IValueConverter;
const DataPackage = @import("../../ApplicationModel/DataTransfer.zig").DataPackage;
const DayOfWeek = @import("../../Globalization.zig").DayOfWeek;
const Visibility = @import("../Xaml.zig").Visibility;
const InkDrawingAttributes = @import("../Input/Inking.zig").InkDrawingAttributes;
const TypedEventHandler = @import("../../Foundation.zig").TypedEventHandler;
const HSTRING = @import("../../root.zig").HSTRING;
const FontStretch = @import("../Text.zig").FontStretch;
const MediaCapture = @import("../../Media/Capture.zig").MediaCapture;
const IScrollSnapPointsInfo = @import("./Controls/Primitives.zig").IScrollSnapPointsInfo;
const core = @import("../../root.zig").core;
pub const Maps = @import("./Controls/Maps.zig");
pub const Primitives = @import("./Controls/Primitives.zig");
